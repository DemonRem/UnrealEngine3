/*=============================================================================
	Pixel Shader code used by MwyUI / Scaleform GFX
	These shaders are converted to HLSL/cg from the example DX9 assembly
	renderer in ScaleForm's SDK
=============================================================================*/

sampler2D TextureImage;
sampler2D TextureImage2;
sampler2D TextureImage3;
sampler2D TextureImage4;

float4 ConstantColor;
float4 ColorScale;
float4 ColorBias;
half   InverseGamma;

float4 CorrectGamma(float4 color)
{
    return float4(saturate(pow(color.rgb, InverseGamma)), color.a);
}

float4 Main_SolidColor(
	) : COLOR0
{
	return ConstantColor;
}

float4 Main_CxformTexture(
	in float2 TextureCoordinate : TEXCOORD0	
	) : COLOR0
{
	float4 Sample = tex2D(TextureImage,TextureCoordinate);	
	return CorrectGamma(Sample * ColorScale + ColorBias);
}

float4 Main_CxformTextureMultiply(
	in float2 TextureCoordinate : TEXCOORD0	
	) : COLOR0
{
	float4 Sample = tex2D(TextureImage,TextureCoordinate);	
	float4 BiasedSample = Sample * ColorScale + ColorBias;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedSample, BiasedSample.a ));
}

float4 Main_Glyph(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
	float4 Sample = tex2D(TextureImage,TextureCoordinate);
	Color0.a = Color0.a * Sample.r;
	return CorrectGamma(Color0 * ColorScale + ColorBias);	
}

float4 Main_GlyphColor(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
	float4 Sample = tex2D(TextureImage,TextureCoordinate) * ColorScale + ColorBias;
	return CorrectGamma(Sample);	
}

float4 Main_GlyphColorMultiply(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
	float4 Sample = tex2D(TextureImage,TextureCoordinate) * ColorScale + ColorBias;
	return CorrectGamma(lerp( float4(1,1,1,1), Sample, Sample.a) );	
}

// The below Shaders are used when Gouraud shading / Edge AA is enabled

float4 Main_CxformGouraud(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1
	) : COLOR0
{
	float4 BiasedColor = Color0 * ColorScale + ColorBias;
	return CorrectGamma(float4( BiasedColor.rgb, BiasedColor.a * Color1.a ));
}

float4 Main_CxformGouraudMultiply(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1
	) : COLOR0
{
	float4 BiasedColor = Color0 * ColorScale + ColorBias;
	BiasedColor.a *= Color1.a;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}

float4 Main_CxformGouraud_NoAddAlpha(
	in float4 Color0 : COLOR0
	) : COLOR0
{
	return CorrectGamma(Color0 * ColorScale + ColorBias);
}

float4 Main_CxformGouraudMultiply_NoAddAlpha(
	in float4 Color0 : COLOR0
	) : COLOR0
{
	float4 BiasedColor = Color0 * ColorScale + ColorBias;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}

float4 Main_CxformGouraudTexture(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1,
	in float2 TextureCoordinate : TEXCOORD0
	) : COLOR0
{
	float4 Sample = tex2D(TextureImage,TextureCoordinate);
	float4 InterpolatedColor = lerp( Color0, Sample, Color1.b );
	float4 BiasedColor = InterpolatedColor * ColorScale + ColorBias;
	return CorrectGamma(float4( BiasedColor.rgb, BiasedColor.a * Color1.a ));
}

float4 Main_CxformGouraudMultiplyTexture(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1,
	in float2 TextureCoordinate : TEXCOORD0
	) : COLOR0
{
	float4 Sample = tex2D(TextureImage,TextureCoordinate);
	float4 InterpolatedColor = lerp( Color0, Sample, Color1.b );
	float4 BiasedColor = InterpolatedColor * ColorScale + ColorBias;
	BiasedColor.a *= Color1.a;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}

float4 Main_Cxform2Texture(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1,
	in float2 TextureCoordinate0 : TEXCOORD0,
	in float2 TextureCoordinate1 : TEXCOORD1
	) : COLOR0
{
	float4 Sample0 = tex2D(TextureImage,  TextureCoordinate0);
	float4 Sample1 = tex2D(TextureImage2, TextureCoordinate1);
	
	float4 InterpolatedColor = lerp(Sample1, Sample0, Color1.b);
	return CorrectGamma(InterpolatedColor * ColorScale + ColorBias);
}

float4 Main_CxformMultiply2Texture(
	in float4 Color0 : COLOR0,
	in float4 Color1 : COLOR1,
	in float2 TextureCoordinate0 : TEXCOORD0,
	in float2 TextureCoordinate1 : TEXCOORD1
	) : COLOR0
{
	float4 Sample0 = tex2D(TextureImage,  TextureCoordinate0);
	float4 Sample1 = tex2D(TextureImage2, TextureCoordinate1);
	
	float4 InterpolatedColor = lerp(Sample1, Sample0, Color1.b);
	float4 BiasedColor = InterpolatedColor * ColorScale + ColorBias;
	
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}

float4 Main_GlyphYUV(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
    float  Y = (float)tex2D(TextureImage, TextureCoordinate).r;
    float  U = (float)tex2D(TextureImage2,TextureCoordinate).r - 128.f/255.f;
    float  V = (float)tex2D(TextureImage3,TextureCoordinate).r - 128.f/255.f;
    float3 color = (float3(Y, Y, Y) - float3(16.f/255.f, 16.f/255.f, 16.f/255.f)) * 1.164;
    color.r +=  V * 1.596f;
    color.g += -U * 0.392f - V * 0.813f;
    color.b +=  U * 2.017f;
	return CorrectGamma(ColorScale * float4(color,1) + ColorBias);
}

float4 Main_GlyphYUVMultiply(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
    float  Y = (float)tex2D(TextureImage, TextureCoordinate).r;
    float  U = (float)tex2D(TextureImage2,TextureCoordinate).r - 128.f/255.f;
    float  V = (float)tex2D(TextureImage3,TextureCoordinate).r - 128.f/255.f;
    float3 color = (float3(Y, Y, Y) - float3(16.f/255.f, 16.f/255.f, 16.f/255.f)) * 1.164;
    color.r +=  V * 1.596f;
    color.g += -U * 0.392f - V * 0.813f;
    color.b +=  U * 2.017f;
    float4 BiasedColor = ColorScale * float4(color,1) + ColorBias;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}

float4 Main_GlyphYUVA(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
    float  Y = (float)tex2D(TextureImage, TextureCoordinate).r;
    float  U = (float)tex2D(TextureImage2,TextureCoordinate).r - 128.f/255.f;
    float  V = (float)tex2D(TextureImage3,TextureCoordinate).r - 128.f/255.f;
    float3 color = (float3(Y, Y, Y) - float3(16.f/255.f, 16.f/255.f, 16.f/255.f)) * 1.164;
    color.r +=  V * 1.596f;
    color.g += -U * 0.392f - V * 0.813f;
    color.b +=  U * 2.017f;
	return CorrectGamma(ColorScale * float4(color,tex2D(TextureImage4, TextureCoordinate).r) + ColorBias);
}

float4 Main_GlyphYUVAMultiply(
	in float2 TextureCoordinate : TEXCOORD0,
	in float4 Color0 : COLOR0
	) : COLOR0
{	
    float  Y = (float)tex2D(TextureImage, TextureCoordinate).r;
    float  U = (float)tex2D(TextureImage2,TextureCoordinate).r - 128.f/255.f;
    float  V = (float)tex2D(TextureImage3,TextureCoordinate).r - 128.f/255.f;
    float3 color = (float3(Y, Y, Y) - float3(16.f/255.f, 16.f/255.f, 16.f/255.f)) * 1.164;
    color.r +=  V * 1.596f;
    color.g += -U * 0.392f - V * 0.813f;
    color.b +=  U * 2.017f;
    float4 BiasedColor = ColorScale * float4(color,tex2D(TextureImage4, TextureCoordinate).r) + ColorBias;
	return CorrectGamma(lerp( float4(1,1,1,1), BiasedColor, BiasedColor.a ));
}
