/*=============================================================================
	MotionBlurCommon.usf: Common helper functionality for motion blur.
	Copyright 1998-2009 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#ifndef NUM_SAMPLES
#define NUM_SAMPLES 5
#endif

float4 RenderTargetClampParameter;

float2 ClampUV(float2 UV)
{
// SM2 currently doesn't support correctly clamped motion blur (not enough instructions)
#if !SM2_PROFILE
	// Clamp the sampling UVs to avoid sampling from outside viewport region
	// (hence render target size can be bigger than viewport region)
	UV.x = clamp(UV.x, RenderTargetClampParameter.x, RenderTargetClampParameter.z);
	UV.y = clamp(UV.y, RenderTargetClampParameter.y, RenderTargetClampParameter.w);
#endif
	return UV;
}


#if XBOX
// XY used for ScaleAndBias: { 3*SCENE_COLOR_BIAS_FACTOR, -2, 0, 0 }
//
float4 MotionBlurMaskScaleAndBias;

// AlphaValue can have four different values (0/3, 1/3, 2/3, 3/3).
// The MotionBlurMask bit is set when AlphaValue is 1/3 or 3/3, and this function
// returns 1.0 if the bit is set, otherwise 0.0.
half GetMotionBlurMask( half AlphaValue )
{
//	half MotionBlurMask = abs( AlphaValue*3.0f - 2.0f );
	half MotionBlurMask = abs( AlphaValue*MotionBlurMaskScaleAndBias.x + MotionBlurMaskScaleAndBias.y );
	return (AlphaValue < 0.001f) ? 0.0f : MotionBlurMask;
}
half4 GetMotionBlurMask4( half Alpha1, half Alpha2, half Alpha3, half Alpha4 )
{
//  half MotionBlurMask = abs( AlphaValue*3.0f - 2.0f );
    half4 AlphaValues = half4( Alpha1, Alpha2, Alpha3, Alpha4 );
    half4 MotionBlurMask = abs( AlphaValues*MotionBlurMaskScaleAndBias.x + MotionBlurMaskScaleAndBias.y );
    MotionBlurMask = (AlphaValues < 0.001f) ? 0.0f : MotionBlurMask;
    return MotionBlurMask;
}
#endif

sampler2D	VelocityBuffer;
float4x4	ScreenToWorld;
float4x4	PrevViewProjMatrix;

//{ 0.5f, -0.5f, MAX_PIXELVELOCITY, MAX_PIXELVELOCITY }
float4 StaticVelocityParameters = { 0.5f, -0.5f, 16.0f/1280.0f, 16.0f/720.0f };
// { 2.0f*MAX_PIXELVELOCITY, -2.0f*MAX_PIXELVELOCITY, 2.0f*MAX_TRANSLUCENT_PIXELVELOCITY, -2.0f*MAX_TRANSLUCENT_PIXELVELOCITY }
float4 DynamicVelocityParameters = { 2.0f*16.0f/1280.0f, -2.0f*16.0f/720.0f, -64.0f/1280.0f, 64.0f/720.0f };

// offsets/weights when sampling using opaque motion based velocity
float StepOffsetsOpaque[NUM_SAMPLES] = {0, 1, 2, -1, -2};
float StepWeightsOpaque[NUM_SAMPLES] = {3.0/10.0, 1.5/10.0, 2.0/10.0, 2.0/10.0, 1.5/10.0};
// offsets/weights when sampling using translucent non-motion based velocity
float StepOffsetsTranslucent[NUM_SAMPLES] = {0, 1, 2, 3, 4};
float StepWeightsTranslucent[NUM_SAMPLES] = {1.0/5.0, 1.0/5.0, 1.0/5.0, 1.0/5.0, 1.5/10.0};

half3 MotionBlur( half4 SceneColor, float4 ScreenPosition )
{
	half2 PixelVelocity = 0;	
	half MaxMotionBlurMask = 0;
    half MaxNeighborMask = 0;

	float2 UV = ScreenPosition.zw;

	// scaling of step offset size for each sample
	float StepOffsets[NUM_SAMPLES] = StepOffsetsOpaque;
	// weight for contribution from each sample
	float StepWeights[NUM_SAMPLES] = StepWeightsOpaque;
	// texture samples
	half4 StepSamples[NUM_SAMPLES];

	// NOTE: Maximum value for an fp16 depth-value is 65504.
	half4	DynamicVelocity	= tex2D( VelocityBuffer, UV );	

	// 0.0f (-1.0f after scale-and-bias) in the velocity buffer has special meaning. It means "use static background velocity".
	// Velocity rendering clamps to 1/255, so every pixel it touches will fail this check.

	half SelectorOpaque = DynamicVelocity.x;
	half SelectorTranslucent = DynamicVelocity.z;
	if ( SelectorTranslucent > 0 )
	{
		// Scale dynamic velocity from [-1,+1] to [-MAX_TRANSLUCENT_PIXELVELOCITY,+MAX_TRANSLUCENT_PIXELVELOCITY] pixels
		half2 NominalVelocity	= DynamicVelocity.zw * 2.0f - 1.0f;
		PixelVelocity			= NominalVelocity * DynamicVelocityParameters.zw;
#if !SM2_PROFILE
		// override offsets/weights to use translucent version
		StepOffsets = StepOffsetsTranslucent;
		StepWeights = StepWeightsTranslucent;
#endif
#if XBOX
		// disable masking of characters 
		MaxMotionBlurMask = 100;
		MaxNeighborMask = 100;
#endif
	}
	if ( SelectorOpaque > 0 )
	{
		// Scale dynamic velocity from [-1,+1] to [-MAX_VELOCITY,+MAX_VELOCITY] pixels
		half2 NominalVelocity	= DynamicVelocity.xy * 2.0f - 1.0f;
		half2 MotionPixelVelocity	= NominalVelocity * DynamicVelocityParameters.xy;
		// Make it nicely curved.
 		half Scale		= dot(NominalVelocity, NominalVelocity);
 		MotionPixelVelocity	*= Scale;

		// Accumulate total pixel velocity
		PixelVelocity += MotionPixelVelocity;
	}
	else
	{
		half	CurrDepth			= min( CalcSceneDepth( UV ), 65504);
		if ( CurrDepth < 14.0f )
			CurrDepth = 65504.0f;
		float4	ProjectedPosition	= float4( ScreenPosition.xy * CurrDepth, CurrDepth, 1 );
		float4	PrevScreenPosition	= MulMatrix( PrevViewProjMatrix, ProjectedPosition );
		PrevScreenPosition.xy		/= PrevScreenPosition.w;

		// Scale static velocity from projection space to texel space and clamp to +/- MAX_VELOCITY pixels.
		half2	StaticVelocity	= ScreenPosition.xy - PrevScreenPosition.xy;
		half2 MotionPixelVelocity	= clamp( StaticVelocity*StaticVelocityParameters.xy, -StaticVelocityParameters.zw, StaticVelocityParameters.zw );
		half2 NominalVelocity	= MotionPixelVelocity/StaticVelocityParameters.zw;
		// Make it nicely curved.
		half Scale		= dot(NominalVelocity, NominalVelocity);
		MotionPixelVelocity	*= Scale;

		// Accumulate total pixel velocity
		PixelVelocity += MotionPixelVelocity;
	}

	// Average NUM_SAMPLES screen colors along the velocity vector.
	half2 Step = PixelVelocity / NUM_SAMPLES;
	StepSamples[0] = SceneColor;
	UNROLL 
	for(int i=1; i<NUM_SAMPLES; i++)
	{
		StepSamples[i] = tex2D( SceneColorTexture, ClampUV(UV + Step*StepOffsets[i]) );
	}

	half3 Color = 0;	
#if XBOX
	half4 MotionBlurMask = GetMotionBlurMask( SceneColor.a );
	MotionBlurMask = max(MotionBlurMask,MaxMotionBlurMask);
    half4 NeighborMask = GetMotionBlurMask4( StepSamples[0].a, StepSamples[1].a, StepSamples[2].a, StepSamples[3].a );
	NeighborMask = max(NeighborMask,MaxNeighborMask);
    half4 SelectionMask = (MotionBlurMask == NeighborMask);
	Color = StepSamples[0].rgb * StepWeights[0];
	Color += SelectionMask.x * StepSamples[1].rgb * StepWeights[1];
    Color += SelectionMask.y * StepSamples[2].rgb * StepWeights[2];
    Color += SelectionMask.z * StepSamples[3].rgb * StepWeights[3];
    Color += SelectionMask.w * StepSamples[4].rgb * StepWeights[4];
	float TotalWeight = StepWeights[0] + dot(SelectionMask,half4(StepWeights[1],StepWeights[2],StepWeights[3],StepWeights[4]));
	Color /= TotalWeight;
#else
	UNROLL 
	for(int j=0; j<NUM_SAMPLES; j++)
	{
		Color += StepSamples[j].rgb*StepWeights[j];
	}
#endif
	return Color;
}
