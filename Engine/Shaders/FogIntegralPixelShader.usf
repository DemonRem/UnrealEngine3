/*=============================================================================
	FogIntegralPixelShader.usf: Computes the line integral for fog volumes
	Copyright © 1998-2007 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#include "Common.usf"
#include "Material.usf"
#include "VertexFactory.usf"

/* transform from post projective space to world space */
float4x4 ScreenToWorld;

/* world space camera position */
float4	CameraPosition;

/* set to 1.0f for backfaces, and -1.0f for frontfaces */
float	FaceScale;

/* parameters specific to the density function */
float4	FirstDensityFunctionParameters;
float4	SecondDensityFunctionParameters;

/* offsets for filtering scene depth */
float4  DepthFilterSampleOffsets[2];

/* 1 / MaxIntegral estimate for the density function */
float	InvMaxIntegral;

/*
* Filters scene depth by taking 4 samples and averaging the results
* which helps to antialias it when rendering to a downsampled integral buffer.
*/
half PreviousFilteredDepth(float4 ScreenPosition)
{
	float2 PersCorrectScreenPos = ScreenPosition.xy / ScreenPosition.w * ScreenPositionScaleBias.xy + ScreenPositionScaleBias.wz;
	half4 Depths;
	float4 FirstOffsetPos = DepthFilterSampleOffsets[0] + PersCorrectScreenPos.xyxy; 
	float4 SecondOffsetPos = DepthFilterSampleOffsets[1] + PersCorrectScreenPos.xyxy; 

#if SUPPORTS_DEPTH_TEXTURES

	Depths.x = texDepth2D(SceneDepthTexture, FirstOffsetPos.xy).r; 
	Depths.y = texDepth2D(SceneDepthTexture, FirstOffsetPos.zw).r;
	Depths.z = texDepth2D(SceneDepthTexture, SecondOffsetPos.xy).r;
	Depths.w = texDepth2D(SceneDepthTexture, SecondOffsetPos.zw).r;
	Depths = 1.f / (Depths * MinZ_MaxZRatio.zzzz - MinZ_MaxZRatio.wwww);

#else

	Depths.x = tex2D(SceneColorTexture, FirstOffsetPos.xy).a; 
	Depths.y = tex2D(SceneColorTexture, FirstOffsetPos.zw).a;
	Depths.z = tex2D(SceneColorTexture, SecondOffsetPos.xy).a;
	Depths.w = tex2D(SceneColorTexture, SecondOffsetPos.zw).a;

#endif

	half SampleWeight = 1.0f / 4.0f;
	float AverageDepth = dot(Depths, SampleWeight.xxxx);

	//sample the current position if desired, doesn't make a big visual difference
	//AverageDepth = AverageDepth + 1.0f / 3.0f * tex2D(SceneColorTexture, PersCorrectScreenPos.xy).w;
	return AverageDepth;
}

/*
* Encodes the floating point integral based on what the current platform needs.  
* Platforms that can do high precision fp blending negate the integral for frontfaces,
* Platforms without fp blending pack the integral into a fixed point buffer.
*/
float4 EncodeIntegral(float Integral)
{
#if XBOX || MANUAL_FP_BLEND

/*
	//pack the integral into G16R16
	float NormalizedIntegral = Integral * InvMaxIntegral;
	float2 Shift = float2(65536.0f, 1.0f);
	float2 Mask = float2(0.0f, 1.0f / 65536.0f);
	float2 ClampedIntegral = frac(NormalizedIntegral.xx * Shift);
	float2 EncodedIntegral = ClampedIntegral - ClampedIntegral.xx * Mask;
	return float4(EncodedIntegral.x, EncodedIntegral.y, 0.0f, 0.0f);
*/

	//24bits, from the lowest 6 bits of RGBA8.  2 are left over for overflow in each channel, for a max of 4 additive blends
	//normalize the integral
	float NormalizedIntegral = Integral * InvMaxIntegral;
	//shift up 18, 12, 6, 0 bits
	//x will store the lowest value 6 bits of the integral, w will store the highest 6 bits
	float4 Shift = float4(262144.0f, 4096.0f, 64.0f, 1.0f);
	//shift the values and clamp off anything greater than 1
	float4 ClampedIntegral = frac(NormalizedIntegral.xxxx * Shift);
	//6 bit shift down, converts between channels
	float ChannelShift = 1.0f / 64.0f;
	//clamp off anything lower than what can be stored in the channel's 6 bits to avoid rounding by the hardware
	//this is done by subtracting the lower channels after shifting them into the same space 
	ClampedIntegral.yzw = ClampedIntegral.yzw - ClampedIntegral.xyz * ChannelShift.xxx;
	//shift every channel down 2 bits, so additive blends will overflow into these bits
	return ClampedIntegral / 4.0f;

#else

	//add backface integral results, subtract frontface results
	return float4(Integral * FaceScale, 0.0f, 0.0f, 0.0f);

#endif
	
}

/*
* Constant density - constant density factor stored in FirstDensityFunctionParameters.x
*
* Computes the line integral from the camera to the current face of the fog volume being rendered
* or an intersecting opaque object.
*/
void ConstantDensityMain(
	FVertexFactoryInterpolants Interpolants,
	float4	ScreenPosition	: TEXCOORD5,
	float3	CameraVector	: TEXCOORD6,
	out float4 OutColor		: COLOR0
	)
{
	half SceneW = PreviousFilteredDepth(ScreenPosition);

	//use whichever is closest, this pixel or the nearest opaque object
	half ClosestDistance = min(SceneW, ScreenPosition.z);
	
	//constant density
	float LineIntegral = ClosestDistance * FirstDensityFunctionParameters.x;

	OutColor = EncodeIntegral(LineIntegral);
}

/*
* Constant density capped to a height - constant density factor stored in FirstDensityFunctionParameters.x, height in .y
*
* Computes the line integral from the camera to the current face of the fog volume being rendered
* or an intersecting opaque object.
*/
void ConstantHeightDensityMain(
	FVertexFactoryInterpolants Interpolants,
	float4	ScreenPosition	: TEXCOORD5,
	float3	CameraVector	: TEXCOORD6,
	out float4 OutColor		: COLOR0
	)
{
	float LineIntegral;
	half SceneW = PreviousFilteredDepth(ScreenPosition);

	//use whichever is closest, this pixel or the nearest opaque object
	half ClosestDistance = min(SceneW, ScreenPosition.z);
	
	//transform into worldspace
	float3 WorldReceiverPos = MulMatrix(ScreenToWorld, float4(ScreenPosition.xy / ScreenPosition.w * ClosestDistance, ClosestDistance, 1)).xyz;

	//used to avoid a divide by zero
	float Epsilon = .0001;

	float3 V = CameraPosition.xyz - WorldReceiverPos;

	//constant height
	float k = 0;
	if (CameraPosition.z - FirstDensityFunctionParameters.y <= 0)
	{
		k = 1;
	}

	float DistanceInHalfspace = saturate(k - (WorldReceiverPos.z - FirstDensityFunctionParameters.y) / (abs(V.z) + Epsilon)) * length(V);
	LineIntegral = DistanceInHalfspace * FirstDensityFunctionParameters.x;

	OutColor = EncodeIntegral(LineIntegral);
}

/*
* A halfspace of fog with density increasing linearly away from the plane, 
* linear density factor stored in FirstDensityFunctionParameters.x, plane stored in SecondDensityFunctionParameters
*
* Computes the line integral from the camera to the current face of the fog volume being rendered
* or an intersecting opaque object.
*/
void LinearHalfspaceDensityMain(
	FVertexFactoryInterpolants Interpolants,
	float4	ScreenPosition	: TEXCOORD5,
	float3	CameraVector	: TEXCOORD6,
	out float4 OutColor		: COLOR0
	)
{
	float LineIntegral;
	half SceneW = PreviousFilteredDepth(ScreenPosition);

	//use whichever is closest, this pixel or the nearest opaque object
	half ClosestDistance = min(SceneW, ScreenPosition.z);
	
	//transform into worldspace
	float3 WorldReceiverPos = MulMatrix(ScreenToWorld, float4(ScreenPosition.xy / ScreenPosition.w * ClosestDistance, ClosestDistance, 1)).xyz;

	//used to avoid a divide by zero
	float Epsilon = .0001;

	float3 V = CameraPosition.xyz - WorldReceiverPos;

	//linear halfspace density
	float FDotC = dot(SecondDensityFunctionParameters, float4(CameraPosition.xyz, 1));
	float FDotP = dot(SecondDensityFunctionParameters, float4(WorldReceiverPos, 1));
	float FDotV = dot(SecondDensityFunctionParameters, float4(V, 0));
	float CameraOutsideMask = 0;
	if (FDotC <= 0)
	{
		CameraOutsideMask = 1;
	}
	float IntersectionMask = min((1 - 2 * CameraOutsideMask) * FDotP, 0);
	float IntersectionPortion = IntersectionMask * IntersectionMask / (abs(FDotV) + Epsilon);
	float InsideVolumePortion = CameraOutsideMask * (FDotP + FDotC);
	LineIntegral = -.5 * FirstDensityFunctionParameters.x * .0001f * length(V) * (InsideVolumePortion - IntersectionPortion);

	OutColor = EncodeIntegral(LineIntegral);
}

#define PI_2 1.57079632

float ArcTan(float value)
{
	//close enough
	float ValueSign = sign(value);
	return ValueSign * (-PI_2 * exp2(-ValueSign * value) + PI_2);

	//funky
	//return sin(value * 5.0f);

	//slow
	//return atan2(value, 1.0f);
}

/*
* A sphere shaped density function with G1 continuity at the center and smooth quadratic falloff at the edges.
* Spherical Density = MaximumDensity * (1 - distanceToCenter^2 / SphereRadius^2), where MaximumDensity is the maximum density at the center of the sphere.
* This density function has its zeroes at SphereRadius and -SphereRadius, so the edges of the sphere fade out smoothly.
* MaxDensity stored in FirstDensityFunctionParameters.x, sphere center in SecondDensityFunctionParameters.xyz, sphere radius in SecondDensityFunctionParameters.w
*
* Computes the line integral from the camera to the current face of the fog volume being rendered
* or an intersecting opaque object.
*/
void SphericalDensityMain(
	FVertexFactoryInterpolants Interpolants,
	float4	ScreenPosition	: TEXCOORD5,
	float3	CameraVector	: TEXCOORD6,
	out float4 OutColor		: COLOR0
	)
{
	float LineIntegral = 0;
	half SceneW = PreviousDepth(ScreenPosition);

	//use whichever is closest, this pixel or the nearest opaque object
	half ClosestDistance = min(SceneW, ScreenPosition.z);
	
	//transform into worldspace
	float3 WorldReceiverPos = MulMatrix(ScreenToWorld, float4(ScreenPosition.xy / ScreenPosition.w * ClosestDistance, ClosestDistance, 1)).xyz;

	//used to avoid a divide by zero
	float Epsilon = .0001;

	float3 V = CameraPosition.xyz - WorldReceiverPos;

	float SphereRadiusSquared = SecondDensityFunctionParameters.w * SecondDensityFunctionParameters.w;

	float3 ReceiverToSphereCenter = WorldReceiverPos - SecondDensityFunctionParameters.xyz;
	float ReceiverToSphereCenterSq = dot(ReceiverToSphereCenter, ReceiverToSphereCenter);

	//find the intersection between the ray from the receiver to the camera and the sphere
	//x, y and z correspond to a, b and c in a * x^2 + b * x + c = 0
	//except c has the -SphereRadiusSquared term left out for reuse in the integral
	float3 QuadraticCoef;
	QuadraticCoef.x = dot(V, V);
	QuadraticCoef.y = 2 * dot(V, ReceiverToSphereCenter);
	QuadraticCoef.z = ReceiverToSphereCenterSq;

	//b^2 - 4 * a * c
	float Determinant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * (QuadraticCoef.z - SphereRadiusSquared);

	//only continue if the ray intersects the sphere
	//@todo - try to optimize this using dynamic branching
	if (Determinant >= 0)
	{
		float InvTwoA = .5 / (QuadraticCoef.x + Epsilon);
		float SqrtDeterminant = sqrt(Determinant);

		//clamp intersections to [0, 1].  0 on the ray is the receiver position, 1 is the camera position.
		//closest stored in x, furthest in y
		float2 Intersections = saturate(-(float2(SqrtDeterminant, -SqrtDeterminant) + QuadraticCoef.yy) * InvTwoA);

		//spherical density = MaximumDensity * (1 - distanceToCenter^2 / SphereRadius^2), where MaximumDensity is the maximum density at the center of the sphere
		//distanceToCenter is squared which cancels out the sqrt in the distance calculation and greatly simplifies the line integral

		float3 IntegralCoefficients = QuadraticCoef * float3(1.0f / 3.0f, 1.0f / 2.0f, 1.0f);
		float2 IntersectionsSquared = Intersections * Intersections;
		float2 IntersectionsCubed = IntersectionsSquared * Intersections;
		float3 ClosestVector = float3(IntersectionsCubed.x, IntersectionsSquared.x, Intersections.x);
		float3 FurthestVector = float3(IntersectionsCubed.y, IntersectionsSquared.y, Intersections.y);
		float2 IntegralPolynomials = float2(dot(IntegralCoefficients, ClosestVector), dot(IntegralCoefficients, FurthestVector));

		//evaluation at the closest intersection in x, furthest in y
		float2 Evaluations = FirstDensityFunctionParameters.xx * (Intersections - IntegralPolynomials / SphereRadiusSquared.xx);
		LineIntegral = (Evaluations.y - Evaluations.x) * length(V);
		
		/*
		//spherical density = 1 / r^2
		//looks like the inscattering from a bright lamp on a foggy night
		float QuadraticFalloffCoef = .02;
		float3 SphereCenterToReceiver = -ReceiverToSphereCenter;
		float A2 = QuadraticCoef.x * QuadraticFalloffCoef;
		float B2 = -2 * dot(V, SphereCenterToReceiver) * QuadraticFalloffCoef;
		float C2 = dot(SphereCenterToReceiver, SphereCenterToReceiver) * QuadraticFalloffCoef;
		
		float IntegralDeterminant = 4 * A2 * C2 - B2 * B2;
		float SqrtIntegralDeterminant = sqrt(abs(IntegralDeterminant));
		float InvSqrtIntegralDeterminant = 1 / (SqrtIntegralDeterminant + Epsilon);
		float FurthestValue = (2 * A2 * Intersections.y + B2) * InvSqrtIntegralDeterminant;
		float ClosestValue = (2 * A2 * Intersections.x + B2) * InvSqrtIntegralDeterminant;
		
		if (IntegralDeterminant > 0)
		{
			LineIntegral = 2 * InvSqrtIntegralDeterminant * (ArcTan(FurthestValue) - ArcTan(ClosestValue)) * length(V);
		}
		*/
	}

	OutColor = EncodeIntegral(LineIntegral);
}

/*
* Not fully implemented
*
* Computes the line integral from the camera to the current face of the fog volume being rendered
* or an intersecting opaque object.
*/
void ConeDensityMain(
	FVertexFactoryInterpolants Interpolants,
	float4	ScreenPosition	: TEXCOORD5,
	float3	CameraVector	: TEXCOORD6,
	out float4 OutColor		: COLOR0
	)
{
	float LineIntegral = 0;
	half SceneW = PreviousFilteredDepth(ScreenPosition);

	//use whichever is closest, this pixel or the nearest opaque object
	half ClosestDistance = min(SceneW, ScreenPosition.z);
	
	//transform into worldspace
	float3 WorldReceiverPos = MulMatrix(ScreenToWorld, float4(ScreenPosition.xy / ScreenPosition.w * ClosestDistance, ClosestDistance, 1)).xyz;

	//used to avoid a divide by zero
	float Epsilon = .0001;

	float3 ConeVertex = FirstDensityFunctionParameters.xyz;
	float MaxDensity = FirstDensityFunctionParameters.w;
	float3 ConeAxis = SecondDensityFunctionParameters.xyz;
	float ConeRadius = SecondDensityFunctionParameters.w;
/*
	float3 ConeVertex = FirstDensityFunctionParameters.xyz;
	float MaxDensity = .01;
	float3 ConeAxis = float3(0,0,1);
	float ConeRadius = 600.0f;
*/
	float CosSqTheta = cos(3.1415926535f / 4.0f) * cos(3.1415926535f / 4.0f);

	float3 V = CameraPosition.xyz - WorldReceiverPos;

	float3 ReceiverToConeVertex = WorldReceiverPos - ConeVertex;

	float ReceiverAngle = dot(ConeAxis, ReceiverToConeVertex);

	//eliminate the reflection
	if (ReceiverAngle >= 0)
	{
		float3 QuadraticCoef;
		float ConeAxisDotView = dot(ConeAxis, V);
		QuadraticCoef.x = ConeAxisDotView * ConeAxisDotView - CosSqTheta * dot(V, V);
		QuadraticCoef.y = 2.0f * (ConeAxisDotView * ReceiverAngle - CosSqTheta * dot(V, ReceiverToConeVertex));
		QuadraticCoef.z = ReceiverAngle * ReceiverAngle - CosSqTheta * dot(ReceiverToConeVertex, ReceiverToConeVertex);

		//b^2 - 4 * a * c
		float Determinant = QuadraticCoef.y * QuadraticCoef.y - 4.0f * QuadraticCoef.x * QuadraticCoef.z;

		if (Determinant >= 0)
		{
			float InvTwoA = .5 / (QuadraticCoef.x + Epsilon);
			float SqrtDeterminant = sqrt(Determinant);

			//clamp intersections to [0, 1].  0 on the ray is the receiver position, 1 is the camera position.
			//closest stored in x, furthest in y
			float2 Intersections = saturate(-(float2(SqrtDeterminant, -SqrtDeterminant) + QuadraticCoef.yy) * InvTwoA);

			LineIntegral = MaxDensity * (Intersections.y - Intersections.x) * length(V);
		}

	}

	OutColor = EncodeIntegral(LineIntegral);
}