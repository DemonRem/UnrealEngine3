<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00181.html">tbb</a>::<a class="el" href="a00103.html">concurrent_hash_map</a></div>
<h1>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00184.html">Containers</a>]</small>
</h1><!-- doxytag: class="tbb::concurrent_hash_map" -->Unordered map from Key to T.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00205.html">concurrent_hash_map.h</a>&gt;</code>
<p>
<a href="a00013.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d038ec60c1c2ceed0c72b17cbe0bea9"></a><!-- doxytag: member="tbb::concurrent_hash_map::key_type" ref="1d038ec60c1c2ceed0c72b17cbe0bea9" args="" -->
typedef Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6fbae1d8b51f862e56dc56091256eed"></a><!-- doxytag: member="tbb::concurrent_hash_map::mapped_type" ref="a6fbae1d8b51f862e56dc56091256eed" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b252d006d9ece4104b3c95b633471881"></a><!-- doxytag: member="tbb::concurrent_hash_map::value_type" ref="b252d006d9ece4104b3c95b633471881" args="" -->
typedef std::pair&lt; const Key,<br>
 T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f598b6335e5bab3e48a30216476f62d0"></a><!-- doxytag: member="tbb::concurrent_hash_map::size_type" ref="f598b6335e5bab3e48a30216476f62d0" args="" -->
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df1e3c8848b8d59152f083bc5b00e567"></a><!-- doxytag: member="tbb::concurrent_hash_map::difference_type" ref="df1e3c8848b8d59152f083bc5b00e567" args="" -->
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c05a3e247f0cee405d4b805a1e6a882"></a><!-- doxytag: member="tbb::concurrent_hash_map::pointer" ref="9c05a3e247f0cee405d4b805a1e6a882" args="" -->
typedef value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c9f52df29f1d27ade53567eb77b1677"></a><!-- doxytag: member="tbb::concurrent_hash_map::const_pointer" ref="4c9f52df29f1d27ade53567eb77b1677" args="" -->
typedef const value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab5233c4b1dc7b7002f1316002a85c7c"></a><!-- doxytag: member="tbb::concurrent_hash_map::reference" ref="ab5233c4b1dc7b7002f1316002a85c7c" args="" -->
typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8bfa9d924148cba008d6a18cebee391e"></a><!-- doxytag: member="tbb::concurrent_hash_map::const_reference" ref="8bfa9d924148cba008d6a18cebee391e" args="" -->
typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3dcd58d51c60c9c63a652aa0ce6230bb"></a><!-- doxytag: member="tbb::concurrent_hash_map::iterator" ref="3dcd58d51c60c9c63a652aa0ce6230bb" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00103.html">concurrent_hash_map</a>, value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="48abcd52da831debc5ece5c4cbd48acd"></a><!-- doxytag: member="tbb::concurrent_hash_map::const_iterator" ref="48abcd52da831debc5ece5c4cbd48acd" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00103.html">concurrent_hash_map</a>, const <br>
value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="31e78c64b24e4d917f4ac7097a2f6f15"></a><!-- doxytag: member="tbb::concurrent_hash_map::range_type" ref="31e78c64b24e4d917f4ac7097a2f6f15" args="" -->
typedef internal::hash_map_range&lt;<br>
 iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d16b749ebee9da332aa40122de0378ba"></a><!-- doxytag: member="tbb::concurrent_hash_map::const_range_type" ref="d16b749ebee9da332aa40122de0378ba" args="" -->
typedef internal::hash_map_range&lt;<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="110fe1ce2586d68bf7366ee525f9306b"></a><!-- doxytag: member="tbb::concurrent_hash_map::allocator_type" ref="110fe1ce2586d68bf7366ee525f9306b" args="" -->
typedef A&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a65733441a84e3581491eb49e305cf8"></a><!-- doxytag: member="tbb::concurrent_hash_map::concurrent_hash_map" ref="6a65733441a84e3581491eb49e305cf8" args="(const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#6a65733441a84e3581491eb49e305cf8">concurrent_hash_map</a> (const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6af4e2b7d2434bc72a645b7e5eb3959f"></a><!-- doxytag: member="tbb::concurrent_hash_map::concurrent_hash_map" ref="6af4e2b7d2434bc72a645b7e5eb3959f" args="(const concurrent_hash_map &amp;table, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#6af4e2b7d2434bc72a645b7e5eb3959f">concurrent_hash_map</a> (const <a class="el" href="a00103.html">concurrent_hash_map</a> &amp;table, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="51cccc7b42e83884462dcadede034822"></a><!-- doxytag: member="tbb::concurrent_hash_map::concurrent_hash_map" ref="51cccc7b42e83884462dcadede034822" args="(I first, I last, const allocator_type &amp;a=allocator_type())" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#51cccc7b42e83884462dcadede034822">concurrent_hash_map</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d70ad33f97ce38d004620580bb1b09ba"></a><!-- doxytag: member="tbb::concurrent_hash_map::operator=" ref="d70ad33f97ce38d004620580bb1b09ba" args="(const concurrent_hash_map &amp;table)" -->
<a class="el" href="a00103.html">concurrent_hash_map</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#d70ad33f97ce38d004620580bb1b09ba">operator=</a> (const <a class="el" href="a00103.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36bcd50fd5383f3682032323b2d74333"></a><!-- doxytag: member="tbb::concurrent_hash_map::clear" ref="36bcd50fd5383f3682032323b2d74333" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#36bcd50fd5383f3682032323b2d74333">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a683e8db50438b9976e46e7d4f60e65"></a><!-- doxytag: member="tbb::concurrent_hash_map::~concurrent_hash_map" ref="5a683e8db50438b9976e46e7d4f60e65" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#5a683e8db50438b9976e46e7d4f60e65">~concurrent_hash_map</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table and destroy it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1fe150921b1fca793626f9d3c1e7ae6"></a><!-- doxytag: member="tbb::concurrent_hash_map::range" ref="b1fe150921b1fca793626f9d3c1e7ae6" args="(size_type grainsize=1)" -->
range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4020e7960c644259dd48d0348b83333f"></a><!-- doxytag: member="tbb::concurrent_hash_map::range" ref="4020e7960c644259dd48d0348b83333f" args="(size_type grainsize=1) const " -->
const_range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb5754d1e138dfe66c6aaf9bce744c9d"></a><!-- doxytag: member="tbb::concurrent_hash_map::begin" ref="fb5754d1e138dfe66c6aaf9bce744c9d" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf655ff36a5aab4c4d2f26f89394ef0d"></a><!-- doxytag: member="tbb::concurrent_hash_map::end" ref="cf655ff36a5aab4c4d2f26f89394ef0d" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8e1ea009f96b7034598caca4fe09103"></a><!-- doxytag: member="tbb::concurrent_hash_map::begin" ref="a8e1ea009f96b7034598caca4fe09103" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1128d0cc01e85ea56ca7ef99ef4a28db"></a><!-- doxytag: member="tbb::concurrent_hash_map::end" ref="1128d0cc01e85ea56ca7ef99ef4a28db" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ee2e81844e9afc18f91f11609fe9a2b"></a><!-- doxytag: member="tbb::concurrent_hash_map::equal_range" ref="0ee2e81844e9afc18f91f11609fe9a2b" args="(const Key &amp;key)" -->
std::pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a017126fdc03ad42e37f80f1c68c5a7"></a><!-- doxytag: member="tbb::concurrent_hash_map::equal_range" ref="2a017126fdc03ad42e37f80f1c68c5a7" args="(const Key &amp;key) const " -->
std::pair&lt; const_iterator,<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#75bb57a153952ffadfcf2e4c73deabb1">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of items in table.  <a href="#75bb57a153952ffadfcf2e4c73deabb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9599dd587892366ed31dea23e5c5837"></a><!-- doxytag: member="tbb::concurrent_hash_map::empty" ref="b9599dd587892366ed31dea23e5c5837" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#b9599dd587892366ed31dea23e5c5837">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="a00103.html#75bb57a153952ffadfcf2e4c73deabb1">size()</a>==0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="62d1fdc2c4d37d84b0dca1cd45f1cf1f"></a><!-- doxytag: member="tbb::concurrent_hash_map::max_size" ref="62d1fdc2c4d37d84b0dca1cd45f1cf1f" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#62d1fdc2c4d37d84b0dca1cd45f1cf1f">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14255f38f7b10bb892b233fce283fbce"></a><!-- doxytag: member="tbb::concurrent_hash_map::get_allocator" ref="14255f38f7b10bb892b233fce283fbce" args="() const " -->
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#14255f38f7b10bb892b233fce283fbce">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74990f452286f35ad6aa08cab6c5a8cd"></a><!-- doxytag: member="tbb::concurrent_hash_map::swap" ref="74990f452286f35ad6aa08cab6c5a8cd" args="(concurrent_hash_map &amp;table)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#74990f452286f35ad6aa08cab6c5a8cd">swap</a> (<a class="el" href="a00103.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="345daf26f2f7e2b4d93382fea80b3a7f"></a><!-- doxytag: member="tbb::concurrent_hash_map::count" ref="345daf26f2f7e2b4d93382fea80b3a7f" args="(const Key &amp;key) const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#345daf26f2f7e2b4d93382fea80b3a7f">count</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return count of items (0 or 1). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ae4b9cb9aa025de8251f90f5f21e9e95">find</a> (<a class="el" href="a00105.html">const_accessor</a> &amp;result, const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="#ae4b9cb9aa025de8251f90f5f21e9e95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#68a6bd5b8a0bc2d5066e5eb175fd5ba9">find</a> (<a class="el" href="a00104.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="#68a6bd5b8a0bc2d5066e5eb175fd5ba9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#2c10a645a8b40c6438c2bb119a61e93b">insert</a> (<a class="el" href="a00105.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="#2c10a645a8b40c6438c2bb119a61e93b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#da381dd244a7dbad494e1e60743b5afa">insert</a> (<a class="el" href="a00104.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="#da381dd244a7dbad494e1e60743b5afa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#7fa987ae247a894ce9f1ca097a919fd4">insert</a> (<a class="el" href="a00105.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#7fa987ae247a894ce9f1ca097a919fd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#2182c693d5898106675b76b443812b47">insert</a> (<a class="el" href="a00104.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#2182c693d5898106675b76b443812b47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#70017dbe0ebbe8c83b9740cd54a6b7e0">insert</a> (const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#70017dbe0ebbe8c83b9740cd54a6b7e0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="06a95a56a40fcbdf3897051d22aaab19"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="06a95a56a40fcbdf3897051d22aaab19" args="(I first, I last)" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#06a95a56a40fcbdf3897051d22aaab19">insert</a> (I first, I last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert range [first, last). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#58df7a1e4373c55eb4c2fa9dc69516b1">erase</a> (const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item.  <a href="#58df7a1e4373c55eb4c2fa9dc69516b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#cc090be8a6c0a3765360ec363cf2474e">erase</a> (<a class="el" href="a00105.html">const_accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by <a class="el" href="a00105.html">const_accessor</a>.  <a href="#cc090be8a6c0a3765360ec363cf2474e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#b5bd8c8f49f8d0e72afedca53caa6b15">erase</a> (<a class="el" href="a00104.html">accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by accessor.  <a href="#b5bd8c8f49f8d0e72afedca53caa6b15"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e24acd2f6849db3377a3942807639758"></a><!-- doxytag: member="tbb::concurrent_hash_map::internal::hash_map_iterator" ref="e24acd2f6849db3377a3942807639758" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c94f21746c8902f7e0b5115a8d4da1d2"></a><!-- doxytag: member="tbb::concurrent_hash_map::internal::hash_map_range" ref="c94f21746c8902f7e0b5115a8d4da1d2" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dc77e04783fa7a1f011a855aaef4b4d"></a><!-- doxytag: member="tbb::concurrent_hash_map::node" ref="9dc77e04783fa7a1f011a855aaef4b4d" args="" -->
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c0028dfa75a6baa14007355ab1ef7fc"></a><!-- doxytag: member="tbb::concurrent_hash_map::const_accessor" ref="2c0028dfa75a6baa14007355ab1ef7fc" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5c8768cb80985347e4880fd00e50995"></a><!-- doxytag: member="tbb::concurrent_hash_map::chain" ref="b5c8768cb80985347e4880fd00e50995" args="" -->
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>chain</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf6a83ad8a91ce6aafcdf46300746c09"></a><!-- doxytag: member="tbb::concurrent_hash_map::segment" ref="cf6a83ad8a91ce6aafcdf46300746c09" args="" -->
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>segment</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00104.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>chain</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linked-list of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">const_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00105.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic unit of storage used in chain. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>segment</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segment of the table. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Key, typename T, typename HashCompare, typename A&gt;<br>
 class tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</h3>

Unordered map from Key to T. 
<p>
<a class="el" href="a00103.html">concurrent_hash_map</a> is associative container with concurrent access.<p>
<dl compact><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1).</dd></dl>
<dl compact><dt><b>Exception Safety</b></dt><dd><ul>
<li>Hash function is not permitted to throw an exception. User-defined types Key and T are forbidden from throwing an exception in destructors.</li><li>If exception happens during <a class="el" href="a00103.html#2c10a645a8b40c6438c2bb119a61e93b">insert()</a> operations, it has no effect (unless exception raised by HashCompare::hash() function during grow_segment).</li><li>If exception happens during <a class="el" href="a00103.html#d70ad33f97ce38d004620580bb1b09ba">operator=()</a> operation, the container can have a part of source items, and methods <a class="el" href="a00103.html#75bb57a153952ffadfcf2e4c73deabb1">size()</a> and <a class="el" href="a00103.html#b9599dd587892366ed31dea23e5c5837">empty()</a> can return wrong results.</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Fixed exception-safety</li><li>Added template argument for allocator</li><li>Added allocator argument in constructors</li><li>Added constructor from a range of iterators</li><li>Added several new overloaded <a class="el" href="a00103.html#2c10a645a8b40c6438c2bb119a61e93b">insert()</a> methods</li><li>Added <a class="el" href="a00103.html#14255f38f7b10bb892b233fce283fbce">get_allocator()</a></li><li>Added <a class="el" href="a00103.html#74990f452286f35ad6aa08cab6c5a8cd">swap()</a></li><li>Added <a class="el" href="a00103.html#345daf26f2f7e2b4d93382fea80b3a7f">count()</a></li><li>Added overloaded <a class="el" href="a00103.html#b5bd8c8f49f8d0e72afedca53caa6b15">erase(accessor &amp;)</a> and <a class="el" href="a00103.html#cc090be8a6c0a3765360ec363cf2474e">erase(const_accessor&amp;)</a></li><li>Added equal_range() [const]</li><li>Added [const_]pointer, [const_]reference, and allocator_type types</li><li>Added global functions: operator==(), operator!=(), and <a class="el" href="a00103.html#74990f452286f35ad6aa08cab6c5a8cd">swap()</a> </li></ul>
</dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b5bd8c8f49f8d0e72afedca53caa6b15"></a><!-- doxytag: member="tbb::concurrent_hash_map::erase" ref="b5bd8c8f49f8d0e72afedca53caa6b15" args="(accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by accessor. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="cc090be8a6c0a3765360ec363cf2474e"></a><!-- doxytag: member="tbb::concurrent_hash_map::erase" ref="cc090be8a6c0a3765360ec363cf2474e" args="(const_accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by <a class="el" href="a00105.html">const_accessor</a>. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="58df7a1e4373c55eb4c2fa9dc69516b1"></a><!-- doxytag: member="tbb::concurrent_hash_map::erase" ref="58df7a1e4373c55eb4c2fa9dc69516b1" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="68a6bd5b8a0bc2d5066e5eb175fd5ba9"></a><!-- doxytag: member="tbb::concurrent_hash_map::find" ref="68a6bd5b8a0bc2d5066e5eb175fd5ba9" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a write lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="ae4b9cb9aa025de8251f90f5f21e9e95"></a><!-- doxytag: member="tbb::concurrent_hash_map::find" ref="ae4b9cb9aa025de8251f90f5f21e9e95" args="(const_accessor &amp;result, const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a read lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="70017dbe0ebbe8c83b9740cd54a6b7e0"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="70017dbe0ebbe8c83b9740cd54a6b7e0" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already. 
<p>
Returns true if item is inserted. 
</div>
</div><p>
<a class="anchor" name="2182c693d5898106675b76b443812b47"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="2182c693d5898106675b76b443812b47" args="(accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="7fa987ae247a894ce9f1ca097a919fd4"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="7fa987ae247a894ce9f1ca097a919fd4" args="(const_accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="da381dd244a7dbad494e1e60743b5afa"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="da381dd244a7dbad494e1e60743b5afa" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="2c10a645a8b40c6438c2bb119a61e93b"></a><!-- doxytag: member="tbb::concurrent_hash_map::insert" ref="2c10a645a8b40c6438c2bb119a61e93b" args="(const_accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="75bb57a153952ffadfcf2e4c73deabb1"></a><!-- doxytag: member="tbb::concurrent_hash_map::size" ref="75bb57a153952ffadfcf2e4c73deabb1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00103.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::size_type <a class="el" href="a00103.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of items in table. 
<p>
Be aware that this method is relatively slow compared to the typical <a class="el" href="a00103.html#75bb57a153952ffadfcf2e4c73deabb1">size()</a> method for an STL container. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00205.html">concurrent_hash_map.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2009 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
