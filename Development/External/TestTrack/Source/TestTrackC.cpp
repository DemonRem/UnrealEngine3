/* TestTrackC.cpp
   Generated by gSOAP 2.7.10 from ttsoapcgi.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "TestTrackH.h"

SOAP_SOURCE_STAMP("@(#) TestTrackC.cpp ver 2.7.10 2008-06-03 19:40:27 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_TT1ArrayOfCFolderItem:
		return soap_in_TT1ArrayOfCFolderItem(soap, NULL, NULL, "TT1:CFolderItem");
	case SOAP_TYPE_TT1ArrayOfCFolder:
		return soap_in_TT1ArrayOfCFolder(soap, NULL, NULL, "TT1:CFolder");
	case SOAP_TYPE_TT1__CFolderItem:
		return soap_in_TT1__CFolderItem(soap, NULL, NULL, "TT1:CFolderItem");
	case SOAP_TYPE_TT1__CFolder:
		return soap_in_TT1__CFolder(soap, NULL, NULL, "TT1:CFolder");
	case SOAP_TYPE_TT1ArrayOfCItemToTrack:
		return soap_in_TT1ArrayOfCItemToTrack(soap, NULL, NULL, "TT1:CItemToTrack");
	case SOAP_TYPE_TT1__CTestRun:
		return soap_in_TT1__CTestRun(soap, NULL, NULL, "TT1:CTestRun");
	case SOAP_TYPE_TT1__CTestCase:
		return soap_in_TT1__CTestCase(soap, NULL, NULL, "TT1:CTestCase");
	case SOAP_TYPE_TT1ArrayOfCLink:
		return soap_in_TT1ArrayOfCLink(soap, NULL, NULL, "TT1:CLink");
	case SOAP_TYPE_TT1__CLink:
		return soap_in_TT1__CLink(soap, NULL, NULL, "TT1:CLink");
	case SOAP_TYPE_TT1ArrayOfCLinkHistoryItem:
		return soap_in_TT1ArrayOfCLinkHistoryItem(soap, NULL, NULL, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_TT1__CLinkHistoryItem:
		return soap_in_TT1__CLinkHistoryItem(soap, NULL, NULL, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_TT1ArrayOfCLinkedItem:
		return soap_in_TT1ArrayOfCLinkedItem(soap, NULL, NULL, "TT1:CLinkedItem");
	case SOAP_TYPE_TT1__CLinkedItem:
		return soap_in_TT1__CLinkedItem(soap, NULL, NULL, "TT1:CLinkedItem");
	case SOAP_TYPE_TT1ArrayOfCUserLicense:
		return soap_in_TT1ArrayOfCUserLicense(soap, NULL, NULL, "TT1:CUserLicense");
	case SOAP_TYPE_TT1__CUserLicense:
		return soap_in_TT1__CUserLicense(soap, NULL, NULL, "TT1:CUserLicense");
	case SOAP_TYPE_TT1ArrayOfCGlobalUser:
		return soap_in_TT1ArrayOfCGlobalUser(soap, NULL, NULL, "TT1:CGlobalUser");
	case SOAP_TYPE_TT1__CGlobalUser:
		return soap_in_TT1__CGlobalUser(soap, NULL, NULL, "TT1:CGlobalUser");
	case SOAP_TYPE_TT1__CUser:
		return soap_in_TT1__CUser(soap, NULL, NULL, "TT1:CUser");
	case SOAP_TYPE_TT1__PhoneNumber:
		return soap_in_TT1__PhoneNumber(soap, NULL, NULL, "TT1:PhoneNumber");
	case SOAP_TYPE_TT1__CTask:
		return soap_in_TT1__CTask(soap, NULL, NULL, "TT1:CTask");
	case SOAP_TYPE_TT1__CDefect:
		return soap_in_TT1__CDefect(soap, NULL, NULL, "TT1:CDefect");
	case SOAP_TYPE_TT1ArrayOfCDefectEventDefinition:
		return soap_in_TT1ArrayOfCDefectEventDefinition(soap, NULL, NULL, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_TT1__CDefectEventDefinition:
		return soap_in_TT1__CDefectEventDefinition(soap, NULL, NULL, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_TT1ArrayOfCEventDefinition:
		return soap_in_TT1ArrayOfCEventDefinition(soap, NULL, NULL, "TT1:CEventDefinition");
	case SOAP_TYPE_TT1__CEventDefinition:
		return soap_in_TT1__CEventDefinition(soap, NULL, NULL, "TT1:CEventDefinition");
	case SOAP_TYPE_TT1ArrayOfCDefectEvent:
		return soap_in_TT1ArrayOfCDefectEvent(soap, NULL, NULL, "TT1:CDefectEvent");
	case SOAP_TYPE_TT1__CDefectEvent:
		return soap_in_TT1__CDefectEvent(soap, NULL, NULL, "TT1:CDefectEvent");
	case SOAP_TYPE_TT1ArrayOfCEvent:
		return soap_in_TT1ArrayOfCEvent(soap, NULL, NULL, "TT1:CEvent");
	case SOAP_TYPE_TT1__CEvent:
		return soap_in_TT1__CEvent(soap, NULL, NULL, "TT1:CEvent");
	case SOAP_TYPE_TT1ArrayOfCTestCaseVariantField:
		return soap_in_TT1ArrayOfCTestCaseVariantField(soap, NULL, NULL, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_TT1ArrayOfCTestRunVariantField:
		return soap_in_TT1ArrayOfCTestRunVariantField(soap, NULL, NULL, "TT1:CTestRunVariantField");
	case SOAP_TYPE_TT1ArrayOfCField:
		return soap_in_TT1ArrayOfCField(soap, NULL, NULL, "TT1:CField");
	case SOAP_TYPE_TT1__CVersionField:
		return soap_in_TT1__CVersionField(soap, NULL, NULL, "TT1:CVersionField");
	case SOAP_TYPE_TT1__CTestCaseVariantField:
		return soap_in_TT1__CTestCaseVariantField(soap, NULL, NULL, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_TT1__CTestRunVariantField:
		return soap_in_TT1__CTestRunVariantField(soap, NULL, NULL, "TT1:CTestRunVariantField");
	case SOAP_TYPE_TT1__CMultiSelectDropdownField:
		return soap_in_TT1__CMultiSelectDropdownField(soap, NULL, NULL, "TT1:CMultiSelectDropdownField");
	case SOAP_TYPE_TT1__CDropdownField:
		return soap_in_TT1__CDropdownField(soap, NULL, NULL, "TT1:CDropdownField");
	case SOAP_TYPE_TT1__CDateTimeField:
		return soap_in_TT1__CDateTimeField(soap, NULL, NULL, "TT1:CDateTimeField");
	case SOAP_TYPE_TT1__CDateField:
		return soap_in_TT1__CDateField(soap, NULL, NULL, "TT1:CDateField");
	case SOAP_TYPE_TT1__CBooleanField:
		return soap_in_TT1__CBooleanField(soap, NULL, NULL, "TT1:CBooleanField");
	case SOAP_TYPE_TT1__CDecimalField:
		return soap_in_TT1__CDecimalField(soap, NULL, NULL, "TT1:CDecimalField");
	case SOAP_TYPE_TT1__CIntegerField:
		return soap_in_TT1__CIntegerField(soap, NULL, NULL, "TT1:CIntegerField");
	case SOAP_TYPE_TT1__CStringField:
		return soap_in_TT1__CStringField(soap, NULL, NULL, "TT1:CStringField");
	case SOAP_TYPE_TT1__CField:
		return soap_in_TT1__CField(soap, NULL, NULL, "TT1:CField");
	case SOAP_TYPE_TT1ArrayOfCReportedByRecord:
		return soap_in_TT1ArrayOfCReportedByRecord(soap, NULL, NULL, "TT1:CReportedByRecord");
	case SOAP_TYPE_TT1__CReportedByRecord:
		return soap_in_TT1__CReportedByRecord(soap, NULL, NULL, "TT1:CReportedByRecord");
	case SOAP_TYPE_TT1ArrayOfCFileAttachment:
		return soap_in_TT1ArrayOfCFileAttachment(soap, NULL, NULL, "TT1:CFileAttachment");
	case SOAP_TYPE_TT1__CFileAttachment:
		return soap_in_TT1__CFileAttachment(soap, NULL, NULL, "TT1:CFileAttachment");
	case SOAP_TYPE_TT1ArrayOfCSCCFileRecord:
		return soap_in_TT1ArrayOfCSCCFileRecord(soap, NULL, NULL, "TT1:CSCCFileRecord");
	case SOAP_TYPE_TT1__CSCCFileRecord:
		return soap_in_TT1__CSCCFileRecord(soap, NULL, NULL, "TT1:CSCCFileRecord");
	case SOAP_TYPE_TT1__CSystem:
		return soap_in_TT1__CSystem(soap, NULL, NULL, "TT1:CSystem");
	case SOAP_TYPE_TT1__CSystemBase:
		return soap_in_TT1__CSystemBase(soap, NULL, NULL, "TT1:CSystemBase");
	case SOAP_TYPE_TT1__COrderedItemWithDBRecordId:
		return soap_in_TT1__COrderedItemWithDBRecordId(soap, NULL, NULL, "TT1:COrderedItemWithDBRecordId");
	case SOAP_TYPE_TT1__CItemToTrack:
		return soap_in_TT1__CItemToTrack(soap, NULL, NULL, "TT1:CItemToTrack");
	case SOAP_TYPE_TT1__CItemWithDBRecordId:
		return soap_in_TT1__CItemWithDBRecordId(soap, NULL, NULL, "TT1:CItemWithDBRecordId");
	case SOAP_TYPE_TT1__CRecordListSoap:
		return soap_in_TT1__CRecordListSoap(soap, NULL, NULL, "TT1:CRecordListSoap");
	case SOAP_TYPE_TT1ArrayOfCRecordRowSoap:
		return soap_in_TT1ArrayOfCRecordRowSoap(soap, NULL, NULL, "TT1:CRecordRowSoap");
	case SOAP_TYPE_TT1__CRecordRowSoap:
		return soap_in_TT1__CRecordRowSoap(soap, NULL, NULL, "TT1:CRecordRowSoap");
	case SOAP_TYPE_TT1ArrayOfCRecordData:
		return soap_in_TT1ArrayOfCRecordData(soap, NULL, NULL, "TT1:CRecordData");
	case SOAP_TYPE_TT1__CRecordData:
		return soap_in_TT1__CRecordData(soap, NULL, NULL, "TT1:CRecordData");
	case SOAP_TYPE_TT1ArrayOfCFilter:
		return soap_in_TT1ArrayOfCFilter(soap, NULL, NULL, "TT1:CFilter");
	case SOAP_TYPE_TT1__CFilter:
		return soap_in_TT1__CFilter(soap, NULL, NULL, "TT1:CFilter");
	case SOAP_TYPE_TT1ArrayOfCTableColumn:
		return soap_in_TT1ArrayOfCTableColumn(soap, NULL, NULL, "TT1:CTableColumn");
	case SOAP_TYPE_TT1__CTableColumn:
		return soap_in_TT1__CTableColumn(soap, NULL, NULL, "TT1:CTableColumn");
	case SOAP_TYPE_TT1ArrayOfCFieldValue:
		return soap_in_TT1ArrayOfCFieldValue(soap, NULL, NULL, "TT1:CFieldValue");
	case SOAP_TYPE_TT1__CFieldValue:
		return soap_in_TT1__CFieldValue(soap, NULL, NULL, "TT1:CFieldValue");
	case SOAP_TYPE_TT1ArrayOfCTableField:
		return soap_in_TT1ArrayOfCTableField(soap, NULL, NULL, "TT1:CTableField");
	case SOAP_TYPE_TT1__CTableField:
		return soap_in_TT1__CTableField(soap, NULL, NULL, "TT1:CTableField");
	case SOAP_TYPE_TT1ArrayOfCDatabaseTable:
		return soap_in_TT1ArrayOfCDatabaseTable(soap, NULL, NULL, "TT1:CDatabaseTable");
	case SOAP_TYPE_TT1__CDatabaseTable:
		return soap_in_TT1__CDatabaseTable(soap, NULL, NULL, "TT1:CDatabaseTable");
	case SOAP_TYPE_TT1ArrayOfCProject:
		return soap_in_TT1ArrayOfCProject(soap, NULL, NULL, "TT1:CProject");
	case SOAP_TYPE_TT1__CProject:
		return soap_in_TT1__CProject(soap, NULL, NULL, "TT1:CProject");
	case SOAP_TYPE_TT1ArrayOfCProjectDataOption:
		return soap_in_TT1ArrayOfCProjectDataOption(soap, NULL, NULL, "TT1:CProjectDataOption");
	case SOAP_TYPE_TT1__CProjectDataOption:
		return soap_in_TT1__CProjectDataOption(soap, NULL, NULL, "TT1:CProjectDataOption");
	case SOAP_TYPE_TT1ArrayOfCDatabase:
		return soap_in_TT1ArrayOfCDatabase(soap, NULL, NULL, "TT1:CDatabase");
	case SOAP_TYPE_TT1__CDatabase:
		return soap_in_TT1__CDatabase(soap, NULL, NULL, "TT1:CDatabase");
	case SOAP_TYPE_TT1ArrayOfstring:
		return soap_in_TT1ArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_TT1__getRootPrivateFolderPath:
		return soap_in_TT1__getRootPrivateFolderPath(soap, NULL, NULL, "TT1:getRootPrivateFolderPath");
	case SOAP_TYPE_TT1__getRootPrivateFolderPathResponse:
		return soap_in_TT1__getRootPrivateFolderPathResponse(soap, NULL, NULL, "TT1:getRootPrivateFolderPathResponse");
	case SOAP_TYPE_TT1__getRootPublicFolderPath:
		return soap_in_TT1__getRootPublicFolderPath(soap, NULL, NULL, "TT1:getRootPublicFolderPath");
	case SOAP_TYPE_TT1__getRootPublicFolderPathResponse:
		return soap_in_TT1__getRootPublicFolderPathResponse(soap, NULL, NULL, "TT1:getRootPublicFolderPathResponse");
	case SOAP_TYPE_TT1__getFolderPathSeparator:
		return soap_in_TT1__getFolderPathSeparator(soap, NULL, NULL, "TT1:getFolderPathSeparator");
	case SOAP_TYPE_TT1__getFolderPathSeparatorResponse:
		return soap_in_TT1__getFolderPathSeparatorResponse(soap, NULL, NULL, "TT1:getFolderPathSeparatorResponse");
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordID:
		return soap_in_TT1__getEntityListForFolderByRecordID(soap, NULL, NULL, "TT1:getEntityListForFolderByRecordID");
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse:
		return soap_in_TT1__getEntityListForFolderByRecordIDResponse(soap, NULL, NULL, "TT1:getEntityListForFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordID:
		return soap_in_TT1__removeEntityFromFolderByRecordID(soap, NULL, NULL, "TT1:removeEntityFromFolderByRecordID");
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse:
		return soap_in_TT1__removeEntityFromFolderByRecordIDResponse(soap, NULL, NULL, "TT1:removeEntityFromFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__addEntityToFolderByRecordID:
		return soap_in_TT1__addEntityToFolderByRecordID(soap, NULL, NULL, "TT1:addEntityToFolderByRecordID");
	case SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse:
		return soap_in_TT1__addEntityToFolderByRecordIDResponse(soap, NULL, NULL, "TT1:addEntityToFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteFolderByRecordID:
		return soap_in_TT1__deleteFolderByRecordID(soap, NULL, NULL, "TT1:deleteFolderByRecordID");
	case SOAP_TYPE_TT1__deleteFolderByRecordIDResponse:
		return soap_in_TT1__deleteFolderByRecordIDResponse(soap, NULL, NULL, "TT1:deleteFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteFolder:
		return soap_in_TT1__deleteFolder(soap, NULL, NULL, "TT1:deleteFolder");
	case SOAP_TYPE_TT1__deleteFolderResponse:
		return soap_in_TT1__deleteFolderResponse(soap, NULL, NULL, "TT1:deleteFolderResponse");
	case SOAP_TYPE_TT1__getFolderByRecordID:
		return soap_in_TT1__getFolderByRecordID(soap, NULL, NULL, "TT1:getFolderByRecordID");
	case SOAP_TYPE_TT1__getFolderByRecordIDResponse:
		return soap_in_TT1__getFolderByRecordIDResponse(soap, NULL, NULL, "TT1:getFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__getFolder:
		return soap_in_TT1__getFolder(soap, NULL, NULL, "TT1:getFolder");
	case SOAP_TYPE_TT1__getFolderResponse:
		return soap_in_TT1__getFolderResponse(soap, NULL, NULL, "TT1:getFolderResponse");
	case SOAP_TYPE_TT1__cancelSaveFolder:
		return soap_in_TT1__cancelSaveFolder(soap, NULL, NULL, "TT1:cancelSaveFolder");
	case SOAP_TYPE_TT1__cancelSaveFolderResponse:
		return soap_in_TT1__cancelSaveFolderResponse(soap, NULL, NULL, "TT1:cancelSaveFolderResponse");
	case SOAP_TYPE_TT1__saveFolder:
		return soap_in_TT1__saveFolder(soap, NULL, NULL, "TT1:saveFolder");
	case SOAP_TYPE_TT1__saveFolderResponse:
		return soap_in_TT1__saveFolderResponse(soap, NULL, NULL, "TT1:saveFolderResponse");
	case SOAP_TYPE_TT1__editFolderByRecordID:
		return soap_in_TT1__editFolderByRecordID(soap, NULL, NULL, "TT1:editFolderByRecordID");
	case SOAP_TYPE_TT1__editFolderByRecordIDResponse:
		return soap_in_TT1__editFolderByRecordIDResponse(soap, NULL, NULL, "TT1:editFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__editFolder:
		return soap_in_TT1__editFolder(soap, NULL, NULL, "TT1:editFolder");
	case SOAP_TYPE_TT1__editFolderResponse:
		return soap_in_TT1__editFolderResponse(soap, NULL, NULL, "TT1:editFolderResponse");
	case SOAP_TYPE_TT1__addFolder:
		return soap_in_TT1__addFolder(soap, NULL, NULL, "TT1:addFolder");
	case SOAP_TYPE_TT1__addFolderResponse:
		return soap_in_TT1__addFolderResponse(soap, NULL, NULL, "TT1:addFolderResponse");
	case SOAP_TYPE_TT1__generateTestRuns:
		return soap_in_TT1__generateTestRuns(soap, NULL, NULL, "TT1:generateTestRuns");
	case SOAP_TYPE_TT1__generateTestRunsResponse:
		return soap_in_TT1__generateTestRunsResponse(soap, NULL, NULL, "TT1:generateTestRunsResponse");
	case SOAP_TYPE_TT1__createDefectForTestRun:
		return soap_in_TT1__createDefectForTestRun(soap, NULL, NULL, "TT1:createDefectForTestRun");
	case SOAP_TYPE_TT1__createDefectForTestRunResponse:
		return soap_in_TT1__createDefectForTestRunResponse(soap, NULL, NULL, "TT1:createDefectForTestRunResponse");
	case SOAP_TYPE_TT1__cancelSaveTestRun:
		return soap_in_TT1__cancelSaveTestRun(soap, NULL, NULL, "TT1:cancelSaveTestRun");
	case SOAP_TYPE_TT1__cancelSaveTestRunResponse:
		return soap_in_TT1__cancelSaveTestRunResponse(soap, NULL, NULL, "TT1:cancelSaveTestRunResponse");
	case SOAP_TYPE_TT1__saveTestRun:
		return soap_in_TT1__saveTestRun(soap, NULL, NULL, "TT1:saveTestRun");
	case SOAP_TYPE_TT1__saveTestRunResponse:
		return soap_in_TT1__saveTestRunResponse(soap, NULL, NULL, "TT1:saveTestRunResponse");
	case SOAP_TYPE_TT1__editTestRunByRecordID:
		return soap_in_TT1__editTestRunByRecordID(soap, NULL, NULL, "TT1:editTestRunByRecordID");
	case SOAP_TYPE_TT1__editTestRunByRecordIDResponse:
		return soap_in_TT1__editTestRunByRecordIDResponse(soap, NULL, NULL, "TT1:editTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestRun:
		return soap_in_TT1__editTestRun(soap, NULL, NULL, "TT1:editTestRun");
	case SOAP_TYPE_TT1__editTestRunResponse:
		return soap_in_TT1__editTestRunResponse(soap, NULL, NULL, "TT1:editTestRunResponse");
	case SOAP_TYPE_TT1__deleteTestRunByRecordID:
		return soap_in_TT1__deleteTestRunByRecordID(soap, NULL, NULL, "TT1:deleteTestRunByRecordID");
	case SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse:
		return soap_in_TT1__deleteTestRunByRecordIDResponse(soap, NULL, NULL, "TT1:deleteTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestRun:
		return soap_in_TT1__deleteTestRun(soap, NULL, NULL, "TT1:deleteTestRun");
	case SOAP_TYPE_TT1__deleteTestRunResponse:
		return soap_in_TT1__deleteTestRunResponse(soap, NULL, NULL, "TT1:deleteTestRunResponse");
	case SOAP_TYPE_TT1__getTestRunByRecordID:
		return soap_in_TT1__getTestRunByRecordID(soap, NULL, NULL, "TT1:getTestRunByRecordID");
	case SOAP_TYPE_TT1__getTestRunByRecordIDResponse:
		return soap_in_TT1__getTestRunByRecordIDResponse(soap, NULL, NULL, "TT1:getTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestRun:
		return soap_in_TT1__getTestRun(soap, NULL, NULL, "TT1:getTestRun");
	case SOAP_TYPE_TT1__getTestRunResponse:
		return soap_in_TT1__getTestRunResponse(soap, NULL, NULL, "TT1:getTestRunResponse");
	case SOAP_TYPE_TT1__cancelSaveTestCase:
		return soap_in_TT1__cancelSaveTestCase(soap, NULL, NULL, "TT1:cancelSaveTestCase");
	case SOAP_TYPE_TT1__cancelSaveTestCaseResponse:
		return soap_in_TT1__cancelSaveTestCaseResponse(soap, NULL, NULL, "TT1:cancelSaveTestCaseResponse");
	case SOAP_TYPE_TT1__saveTestCase:
		return soap_in_TT1__saveTestCase(soap, NULL, NULL, "TT1:saveTestCase");
	case SOAP_TYPE_TT1__saveTestCaseResponse:
		return soap_in_TT1__saveTestCaseResponse(soap, NULL, NULL, "TT1:saveTestCaseResponse");
	case SOAP_TYPE_TT1__editTestCaseByRecordID:
		return soap_in_TT1__editTestCaseByRecordID(soap, NULL, NULL, "TT1:editTestCaseByRecordID");
	case SOAP_TYPE_TT1__editTestCaseByRecordIDResponse:
		return soap_in_TT1__editTestCaseByRecordIDResponse(soap, NULL, NULL, "TT1:editTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestCase:
		return soap_in_TT1__editTestCase(soap, NULL, NULL, "TT1:editTestCase");
	case SOAP_TYPE_TT1__editTestCaseResponse:
		return soap_in_TT1__editTestCaseResponse(soap, NULL, NULL, "TT1:editTestCaseResponse");
	case SOAP_TYPE_TT1__deleteTestCaseByRecordID:
		return soap_in_TT1__deleteTestCaseByRecordID(soap, NULL, NULL, "TT1:deleteTestCaseByRecordID");
	case SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse:
		return soap_in_TT1__deleteTestCaseByRecordIDResponse(soap, NULL, NULL, "TT1:deleteTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestCase:
		return soap_in_TT1__deleteTestCase(soap, NULL, NULL, "TT1:deleteTestCase");
	case SOAP_TYPE_TT1__deleteTestCaseResponse:
		return soap_in_TT1__deleteTestCaseResponse(soap, NULL, NULL, "TT1:deleteTestCaseResponse");
	case SOAP_TYPE_TT1__addTestCase:
		return soap_in_TT1__addTestCase(soap, NULL, NULL, "TT1:addTestCase");
	case SOAP_TYPE_TT1__addTestCaseResponse:
		return soap_in_TT1__addTestCaseResponse(soap, NULL, NULL, "TT1:addTestCaseResponse");
	case SOAP_TYPE_TT1__getTestCaseByRecordID:
		return soap_in_TT1__getTestCaseByRecordID(soap, NULL, NULL, "TT1:getTestCaseByRecordID");
	case SOAP_TYPE_TT1__getTestCaseByRecordIDResponse:
		return soap_in_TT1__getTestCaseByRecordIDResponse(soap, NULL, NULL, "TT1:getTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestCase:
		return soap_in_TT1__getTestCase(soap, NULL, NULL, "TT1:getTestCase");
	case SOAP_TYPE_TT1__getTestCaseResponse:
		return soap_in_TT1__getTestCaseResponse(soap, NULL, NULL, "TT1:getTestCaseResponse");
	case SOAP_TYPE_TT1__getTestRunStepsModes:
		return soap_in_TT1__getTestRunStepsModes(soap, NULL, NULL, "TT1:getTestRunStepsModes");
	case SOAP_TYPE_TT1__getTestRunStepsModesResponse:
		return soap_in_TT1__getTestRunStepsModesResponse(soap, NULL, NULL, "TT1:getTestRunStepsModesResponse");
	case SOAP_TYPE_TT1__getTestVariantTypes:
		return soap_in_TT1__getTestVariantTypes(soap, NULL, NULL, "TT1:getTestVariantTypes");
	case SOAP_TYPE_TT1__getTestVariantTypesResponse:
		return soap_in_TT1__getTestVariantTypesResponse(soap, NULL, NULL, "TT1:getTestVariantTypesResponse");
	case SOAP_TYPE_TT1__cancelSaveLink:
		return soap_in_TT1__cancelSaveLink(soap, NULL, NULL, "TT1:cancelSaveLink");
	case SOAP_TYPE_TT1__cancelSaveLinkResponse:
		return soap_in_TT1__cancelSaveLinkResponse(soap, NULL, NULL, "TT1:cancelSaveLinkResponse");
	case SOAP_TYPE_TT1__saveLink:
		return soap_in_TT1__saveLink(soap, NULL, NULL, "TT1:saveLink");
	case SOAP_TYPE_TT1__saveLinkResponse:
		return soap_in_TT1__saveLinkResponse(soap, NULL, NULL, "TT1:saveLinkResponse");
	case SOAP_TYPE_TT1__editLink:
		return soap_in_TT1__editLink(soap, NULL, NULL, "TT1:editLink");
	case SOAP_TYPE_TT1__editLinkResponse:
		return soap_in_TT1__editLinkResponse(soap, NULL, NULL, "TT1:editLinkResponse");
	case SOAP_TYPE_TT1__deleteLink:
		return soap_in_TT1__deleteLink(soap, NULL, NULL, "TT1:deleteLink");
	case SOAP_TYPE_TT1__deleteLinkResponse:
		return soap_in_TT1__deleteLinkResponse(soap, NULL, NULL, "TT1:deleteLinkResponse");
	case SOAP_TYPE_TT1__addLink:
		return soap_in_TT1__addLink(soap, NULL, NULL, "TT1:addLink");
	case SOAP_TYPE_TT1__addLinkResponse:
		return soap_in_TT1__addLinkResponse(soap, NULL, NULL, "TT1:addLinkResponse");
	case SOAP_TYPE_TT1__getLink:
		return soap_in_TT1__getLink(soap, NULL, NULL, "TT1:getLink");
	case SOAP_TYPE_TT1__getLinkResponse:
		return soap_in_TT1__getLinkResponse(soap, NULL, NULL, "TT1:getLinkResponse");
	case SOAP_TYPE_TT1__getLinksForDefect:
		return soap_in_TT1__getLinksForDefect(soap, NULL, NULL, "TT1:getLinksForDefect");
	case SOAP_TYPE_TT1__getLinksForDefectResponse:
		return soap_in_TT1__getLinksForDefectResponse(soap, NULL, NULL, "TT1:getLinksForDefectResponse");
	case SOAP_TYPE_TT1__getLinksForItem:
		return soap_in_TT1__getLinksForItem(soap, NULL, NULL, "TT1:getLinksForItem");
	case SOAP_TYPE_TT1__getLinksForItemResponse:
		return soap_in_TT1__getLinksForItemResponse(soap, NULL, NULL, "TT1:getLinksForItemResponse");
	case SOAP_TYPE_TT1__addGlobalCustomer:
		return soap_in_TT1__addGlobalCustomer(soap, NULL, NULL, "TT1:addGlobalCustomer");
	case SOAP_TYPE_TT1__addGlobalCustomerResponse:
		return soap_in_TT1__addGlobalCustomerResponse(soap, NULL, NULL, "TT1:addGlobalCustomerResponse");
	case SOAP_TYPE_TT1__promoteCustomer:
		return soap_in_TT1__promoteCustomer(soap, NULL, NULL, "TT1:promoteCustomer");
	case SOAP_TYPE_TT1__promoteCustomerResponse:
		return soap_in_TT1__promoteCustomerResponse(soap, NULL, NULL, "TT1:promoteCustomerResponse");
	case SOAP_TYPE_TT1__cancelSaveCustomer:
		return soap_in_TT1__cancelSaveCustomer(soap, NULL, NULL, "TT1:cancelSaveCustomer");
	case SOAP_TYPE_TT1__cancelSaveCustomerResponse:
		return soap_in_TT1__cancelSaveCustomerResponse(soap, NULL, NULL, "TT1:cancelSaveCustomerResponse");
	case SOAP_TYPE_TT1__deleteCustomerByRecordID:
		return soap_in_TT1__deleteCustomerByRecordID(soap, NULL, NULL, "TT1:deleteCustomerByRecordID");
	case SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse:
		return soap_in_TT1__deleteCustomerByRecordIDResponse(soap, NULL, NULL, "TT1:deleteCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteCustomer:
		return soap_in_TT1__deleteCustomer(soap, NULL, NULL, "TT1:deleteCustomer");
	case SOAP_TYPE_TT1__deleteCustomerResponse:
		return soap_in_TT1__deleteCustomerResponse(soap, NULL, NULL, "TT1:deleteCustomerResponse");
	case SOAP_TYPE_TT1__saveCustomer:
		return soap_in_TT1__saveCustomer(soap, NULL, NULL, "TT1:saveCustomer");
	case SOAP_TYPE_TT1__saveCustomerResponse:
		return soap_in_TT1__saveCustomerResponse(soap, NULL, NULL, "TT1:saveCustomerResponse");
	case SOAP_TYPE_TT1__editCustomerByRecordID:
		return soap_in_TT1__editCustomerByRecordID(soap, NULL, NULL, "TT1:editCustomerByRecordID");
	case SOAP_TYPE_TT1__editCustomerByRecordIDResponse:
		return soap_in_TT1__editCustomerByRecordIDResponse(soap, NULL, NULL, "TT1:editCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__editCustomer:
		return soap_in_TT1__editCustomer(soap, NULL, NULL, "TT1:editCustomer");
	case SOAP_TYPE_TT1__editCustomerResponse:
		return soap_in_TT1__editCustomerResponse(soap, NULL, NULL, "TT1:editCustomerResponse");
	case SOAP_TYPE_TT1__addCustomer:
		return soap_in_TT1__addCustomer(soap, NULL, NULL, "TT1:addCustomer");
	case SOAP_TYPE_TT1__addCustomerResponse:
		return soap_in_TT1__addCustomerResponse(soap, NULL, NULL, "TT1:addCustomerResponse");
	case SOAP_TYPE_TT1__getCustomerByRecordID:
		return soap_in_TT1__getCustomerByRecordID(soap, NULL, NULL, "TT1:getCustomerByRecordID");
	case SOAP_TYPE_TT1__getCustomerByRecordIDResponse:
		return soap_in_TT1__getCustomerByRecordIDResponse(soap, NULL, NULL, "TT1:getCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__getCustomer:
		return soap_in_TT1__getCustomer(soap, NULL, NULL, "TT1:getCustomer");
	case SOAP_TYPE_TT1__getCustomerResponse:
		return soap_in_TT1__getCustomerResponse(soap, NULL, NULL, "TT1:getCustomerResponse");
	case SOAP_TYPE_TT1__addGlobalUser:
		return soap_in_TT1__addGlobalUser(soap, NULL, NULL, "TT1:addGlobalUser");
	case SOAP_TYPE_TT1__addGlobalUserResponse:
		return soap_in_TT1__addGlobalUserResponse(soap, NULL, NULL, "TT1:addGlobalUserResponse");
	case SOAP_TYPE_TT1__promoteUser:
		return soap_in_TT1__promoteUser(soap, NULL, NULL, "TT1:promoteUser");
	case SOAP_TYPE_TT1__promoteUserResponse:
		return soap_in_TT1__promoteUserResponse(soap, NULL, NULL, "TT1:promoteUserResponse");
	case SOAP_TYPE_TT1__cancelSaveUser:
		return soap_in_TT1__cancelSaveUser(soap, NULL, NULL, "TT1:cancelSaveUser");
	case SOAP_TYPE_TT1__cancelSaveUserResponse:
		return soap_in_TT1__cancelSaveUserResponse(soap, NULL, NULL, "TT1:cancelSaveUserResponse");
	case SOAP_TYPE_TT1__deleteUserByRecordID:
		return soap_in_TT1__deleteUserByRecordID(soap, NULL, NULL, "TT1:deleteUserByRecordID");
	case SOAP_TYPE_TT1__deleteUserByRecordIDResponse:
		return soap_in_TT1__deleteUserByRecordIDResponse(soap, NULL, NULL, "TT1:deleteUserByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteUser:
		return soap_in_TT1__deleteUser(soap, NULL, NULL, "TT1:deleteUser");
	case SOAP_TYPE_TT1__deleteUserResponse:
		return soap_in_TT1__deleteUserResponse(soap, NULL, NULL, "TT1:deleteUserResponse");
	case SOAP_TYPE_TT1__saveUser:
		return soap_in_TT1__saveUser(soap, NULL, NULL, "TT1:saveUser");
	case SOAP_TYPE_TT1__saveUserResponse:
		return soap_in_TT1__saveUserResponse(soap, NULL, NULL, "TT1:saveUserResponse");
	case SOAP_TYPE_TT1__editUserByRecordID:
		return soap_in_TT1__editUserByRecordID(soap, NULL, NULL, "TT1:editUserByRecordID");
	case SOAP_TYPE_TT1__editUserByRecordIDResponse:
		return soap_in_TT1__editUserByRecordIDResponse(soap, NULL, NULL, "TT1:editUserByRecordIDResponse");
	case SOAP_TYPE_TT1__editUser:
		return soap_in_TT1__editUser(soap, NULL, NULL, "TT1:editUser");
	case SOAP_TYPE_TT1__editUserResponse:
		return soap_in_TT1__editUserResponse(soap, NULL, NULL, "TT1:editUserResponse");
	case SOAP_TYPE_TT1__addUser:
		return soap_in_TT1__addUser(soap, NULL, NULL, "TT1:addUser");
	case SOAP_TYPE_TT1__addUserResponse:
		return soap_in_TT1__addUserResponse(soap, NULL, NULL, "TT1:addUserResponse");
	case SOAP_TYPE_TT1__getUserByRecordID:
		return soap_in_TT1__getUserByRecordID(soap, NULL, NULL, "TT1:getUserByRecordID");
	case SOAP_TYPE_TT1__getUserByRecordIDResponse:
		return soap_in_TT1__getUserByRecordIDResponse(soap, NULL, NULL, "TT1:getUserByRecordIDResponse");
	case SOAP_TYPE_TT1__getUser:
		return soap_in_TT1__getUser(soap, NULL, NULL, "TT1:getUser");
	case SOAP_TYPE_TT1__getUserResponse:
		return soap_in_TT1__getUserResponse(soap, NULL, NULL, "TT1:getUserResponse");
	case SOAP_TYPE_TT1__getUserLicenseList:
		return soap_in_TT1__getUserLicenseList(soap, NULL, NULL, "TT1:getUserLicenseList");
	case SOAP_TYPE_TT1__getUserLicenseListResponse:
		return soap_in_TT1__getUserLicenseListResponse(soap, NULL, NULL, "TT1:getUserLicenseListResponse");
	case SOAP_TYPE_TT1__getGlobalCustomerList:
		return soap_in_TT1__getGlobalCustomerList(soap, NULL, NULL, "TT1:getGlobalCustomerList");
	case SOAP_TYPE_TT1__getGlobalCustomerListResponse:
		return soap_in_TT1__getGlobalCustomerListResponse(soap, NULL, NULL, "TT1:getGlobalCustomerListResponse");
	case SOAP_TYPE_TT1__getGlobalUserList:
		return soap_in_TT1__getGlobalUserList(soap, NULL, NULL, "TT1:getGlobalUserList");
	case SOAP_TYPE_TT1__getGlobalUserListResponse:
		return soap_in_TT1__getGlobalUserListResponse(soap, NULL, NULL, "TT1:getGlobalUserListResponse");
	case SOAP_TYPE_TT1__cancelSaveTask:
		return soap_in_TT1__cancelSaveTask(soap, NULL, NULL, "TT1:cancelSaveTask");
	case SOAP_TYPE_TT1__cancelSaveTaskResponse:
		return soap_in_TT1__cancelSaveTaskResponse(soap, NULL, NULL, "TT1:cancelSaveTaskResponse");
	case SOAP_TYPE_TT1__saveTask:
		return soap_in_TT1__saveTask(soap, NULL, NULL, "TT1:saveTask");
	case SOAP_TYPE_TT1__saveTaskResponse:
		return soap_in_TT1__saveTaskResponse(soap, NULL, NULL, "TT1:saveTaskResponse");
	case SOAP_TYPE_TT1__editTaskByRecordID:
		return soap_in_TT1__editTaskByRecordID(soap, NULL, NULL, "TT1:editTaskByRecordID");
	case SOAP_TYPE_TT1__editTaskByRecordIDResponse:
		return soap_in_TT1__editTaskByRecordIDResponse(soap, NULL, NULL, "TT1:editTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__editTask:
		return soap_in_TT1__editTask(soap, NULL, NULL, "TT1:editTask");
	case SOAP_TYPE_TT1__editTaskResponse:
		return soap_in_TT1__editTaskResponse(soap, NULL, NULL, "TT1:editTaskResponse");
	case SOAP_TYPE_TT1__deleteTaskByRecordID:
		return soap_in_TT1__deleteTaskByRecordID(soap, NULL, NULL, "TT1:deleteTaskByRecordID");
	case SOAP_TYPE_TT1__deleteTaskByRecordIDResponse:
		return soap_in_TT1__deleteTaskByRecordIDResponse(soap, NULL, NULL, "TT1:deleteTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTask:
		return soap_in_TT1__deleteTask(soap, NULL, NULL, "TT1:deleteTask");
	case SOAP_TYPE_TT1__deleteTaskResponse:
		return soap_in_TT1__deleteTaskResponse(soap, NULL, NULL, "TT1:deleteTaskResponse");
	case SOAP_TYPE_TT1__addTask:
		return soap_in_TT1__addTask(soap, NULL, NULL, "TT1:addTask");
	case SOAP_TYPE_TT1__addTaskResponse:
		return soap_in_TT1__addTaskResponse(soap, NULL, NULL, "TT1:addTaskResponse");
	case SOAP_TYPE_TT1__getTaskByRecordID:
		return soap_in_TT1__getTaskByRecordID(soap, NULL, NULL, "TT1:getTaskByRecordID");
	case SOAP_TYPE_TT1__getTaskByRecordIDResponse:
		return soap_in_TT1__getTaskByRecordIDResponse(soap, NULL, NULL, "TT1:getTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__getTask:
		return soap_in_TT1__getTask(soap, NULL, NULL, "TT1:getTask");
	case SOAP_TYPE_TT1__getTaskResponse:
		return soap_in_TT1__getTaskResponse(soap, NULL, NULL, "TT1:getTaskResponse");
	case SOAP_TYPE_TT1__getDefectAttachment:
		return soap_in_TT1__getDefectAttachment(soap, NULL, NULL, "TT1:getDefectAttachment");
	case SOAP_TYPE_TT1__getDefectAttachmentResponse:
		return soap_in_TT1__getDefectAttachmentResponse(soap, NULL, NULL, "TT1:getDefectAttachmentResponse");
	case SOAP_TYPE_TT1__getAttachment:
		return soap_in_TT1__getAttachment(soap, NULL, NULL, "TT1:getAttachment");
	case SOAP_TYPE_TT1__getAttachmentResponse:
		return soap_in_TT1__getAttachmentResponse(soap, NULL, NULL, "TT1:getAttachmentResponse");
	case SOAP_TYPE_TT1__cancelSaveDefect:
		return soap_in_TT1__cancelSaveDefect(soap, NULL, NULL, "TT1:cancelSaveDefect");
	case SOAP_TYPE_TT1__cancelSaveDefectResponse:
		return soap_in_TT1__cancelSaveDefectResponse(soap, NULL, NULL, "TT1:cancelSaveDefectResponse");
	case SOAP_TYPE_TT1__saveDefect:
		return soap_in_TT1__saveDefect(soap, NULL, NULL, "TT1:saveDefect");
	case SOAP_TYPE_TT1__saveDefectResponse:
		return soap_in_TT1__saveDefectResponse(soap, NULL, NULL, "TT1:saveDefectResponse");
	case SOAP_TYPE_TT1__editDefectByRecordID:
		return soap_in_TT1__editDefectByRecordID(soap, NULL, NULL, "TT1:editDefectByRecordID");
	case SOAP_TYPE_TT1__editDefectByRecordIDResponse:
		return soap_in_TT1__editDefectByRecordIDResponse(soap, NULL, NULL, "TT1:editDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__editDefect:
		return soap_in_TT1__editDefect(soap, NULL, NULL, "TT1:editDefect");
	case SOAP_TYPE_TT1__editDefectResponse:
		return soap_in_TT1__editDefectResponse(soap, NULL, NULL, "TT1:editDefectResponse");
	case SOAP_TYPE_TT1__deleteDefectByRecordID:
		return soap_in_TT1__deleteDefectByRecordID(soap, NULL, NULL, "TT1:deleteDefectByRecordID");
	case SOAP_TYPE_TT1__deleteDefectByRecordIDResponse:
		return soap_in_TT1__deleteDefectByRecordIDResponse(soap, NULL, NULL, "TT1:deleteDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteDefect:
		return soap_in_TT1__deleteDefect(soap, NULL, NULL, "TT1:deleteDefect");
	case SOAP_TYPE_TT1__deleteDefectResponse:
		return soap_in_TT1__deleteDefectResponse(soap, NULL, NULL, "TT1:deleteDefectResponse");
	case SOAP_TYPE_TT1__addDefectWithLink:
		return soap_in_TT1__addDefectWithLink(soap, NULL, NULL, "TT1:addDefectWithLink");
	case SOAP_TYPE_TT1__addDefectWithLinkResponse:
		return soap_in_TT1__addDefectWithLinkResponse(soap, NULL, NULL, "TT1:addDefectWithLinkResponse");
	case SOAP_TYPE_TT1__addDefect:
		return soap_in_TT1__addDefect(soap, NULL, NULL, "TT1:addDefect");
	case SOAP_TYPE_TT1__addDefectResponse:
		return soap_in_TT1__addDefectResponse(soap, NULL, NULL, "TT1:addDefectResponse");
	case SOAP_TYPE_TT1__getDefectByRecordID:
		return soap_in_TT1__getDefectByRecordID(soap, NULL, NULL, "TT1:getDefectByRecordID");
	case SOAP_TYPE_TT1__getDefectByRecordIDResponse:
		return soap_in_TT1__getDefectByRecordIDResponse(soap, NULL, NULL, "TT1:getDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__getDefect:
		return soap_in_TT1__getDefect(soap, NULL, NULL, "TT1:getDefect");
	case SOAP_TYPE_TT1__getDefectResponse:
		return soap_in_TT1__getDefectResponse(soap, NULL, NULL, "TT1:getDefectResponse");
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList:
		return soap_in_TT1__getDefectCustomFieldsDefinitionList(soap, NULL, NULL, "TT1:getDefectCustomFieldsDefinitionList");
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse:
		return soap_in_TT1__getDefectCustomFieldsDefinitionListResponse(soap, NULL, NULL, "TT1:getDefectCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionList:
		return soap_in_TT1__getCustomFieldsDefinitionList(soap, NULL, NULL, "TT1:getCustomFieldsDefinitionList");
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse:
		return soap_in_TT1__getCustomFieldsDefinitionListResponse(soap, NULL, NULL, "TT1:getCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_TT1__getDefectEventDefinitionList:
		return soap_in_TT1__getDefectEventDefinitionList(soap, NULL, NULL, "TT1:getDefectEventDefinitionList");
	case SOAP_TYPE_TT1__getDefectEventDefinitionListResponse:
		return soap_in_TT1__getDefectEventDefinitionListResponse(soap, NULL, NULL, "TT1:getDefectEventDefinitionListResponse");
	case SOAP_TYPE_TT1__getEventDefinitionList:
		return soap_in_TT1__getEventDefinitionList(soap, NULL, NULL, "TT1:getEventDefinitionList");
	case SOAP_TYPE_TT1__getEventDefinitionListResponse:
		return soap_in_TT1__getEventDefinitionListResponse(soap, NULL, NULL, "TT1:getEventDefinitionListResponse");
	case SOAP_TYPE_TT1__getAttachmentTypes:
		return soap_in_TT1__getAttachmentTypes(soap, NULL, NULL, "TT1:getAttachmentTypes");
	case SOAP_TYPE_TT1__getAttachmentTypesResponse:
		return soap_in_TT1__getAttachmentTypesResponse(soap, NULL, NULL, "TT1:getAttachmentTypesResponse");
	case SOAP_TYPE_TT1__cancelSaveTestConfig:
		return soap_in_TT1__cancelSaveTestConfig(soap, NULL, NULL, "TT1:cancelSaveTestConfig");
	case SOAP_TYPE_TT1__cancelSaveTestConfigResponse:
		return soap_in_TT1__cancelSaveTestConfigResponse(soap, NULL, NULL, "TT1:cancelSaveTestConfigResponse");
	case SOAP_TYPE_TT1__deleteTestConfigByRecordID:
		return soap_in_TT1__deleteTestConfigByRecordID(soap, NULL, NULL, "TT1:deleteTestConfigByRecordID");
	case SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse:
		return soap_in_TT1__deleteTestConfigByRecordIDResponse(soap, NULL, NULL, "TT1:deleteTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestConfig:
		return soap_in_TT1__deleteTestConfig(soap, NULL, NULL, "TT1:deleteTestConfig");
	case SOAP_TYPE_TT1__deleteTestConfigResponse:
		return soap_in_TT1__deleteTestConfigResponse(soap, NULL, NULL, "TT1:deleteTestConfigResponse");
	case SOAP_TYPE_TT1__saveTestConfig:
		return soap_in_TT1__saveTestConfig(soap, NULL, NULL, "TT1:saveTestConfig");
	case SOAP_TYPE_TT1__saveTestConfigResponse:
		return soap_in_TT1__saveTestConfigResponse(soap, NULL, NULL, "TT1:saveTestConfigResponse");
	case SOAP_TYPE_TT1__editTestConfigByRecordID:
		return soap_in_TT1__editTestConfigByRecordID(soap, NULL, NULL, "TT1:editTestConfigByRecordID");
	case SOAP_TYPE_TT1__editTestConfigByRecordIDResponse:
		return soap_in_TT1__editTestConfigByRecordIDResponse(soap, NULL, NULL, "TT1:editTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestConfig:
		return soap_in_TT1__editTestConfig(soap, NULL, NULL, "TT1:editTestConfig");
	case SOAP_TYPE_TT1__editTestConfigResponse:
		return soap_in_TT1__editTestConfigResponse(soap, NULL, NULL, "TT1:editTestConfigResponse");
	case SOAP_TYPE_TT1__addTestConfig:
		return soap_in_TT1__addTestConfig(soap, NULL, NULL, "TT1:addTestConfig");
	case SOAP_TYPE_TT1__addTestConfigResponse:
		return soap_in_TT1__addTestConfigResponse(soap, NULL, NULL, "TT1:addTestConfigResponse");
	case SOAP_TYPE_TT1__getTestConfigByRecordID:
		return soap_in_TT1__getTestConfigByRecordID(soap, NULL, NULL, "TT1:getTestConfigByRecordID");
	case SOAP_TYPE_TT1__getTestConfigByRecordIDResponse:
		return soap_in_TT1__getTestConfigByRecordIDResponse(soap, NULL, NULL, "TT1:getTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestConfig:
		return soap_in_TT1__getTestConfig(soap, NULL, NULL, "TT1:getTestConfig");
	case SOAP_TYPE_TT1__getTestConfigResponse:
		return soap_in_TT1__getTestConfigResponse(soap, NULL, NULL, "TT1:getTestConfigResponse");
	case SOAP_TYPE_TT1__getRecordListForTable:
		return soap_in_TT1__getRecordListForTable(soap, NULL, NULL, "TT1:getRecordListForTable");
	case SOAP_TYPE_TT1__getRecordListForTableResponse:
		return soap_in_TT1__getRecordListForTableResponse(soap, NULL, NULL, "TT1:getRecordListForTableResponse");
	case SOAP_TYPE_TT1__getFilterListForTable:
		return soap_in_TT1__getFilterListForTable(soap, NULL, NULL, "TT1:getFilterListForTable");
	case SOAP_TYPE_TT1__getFilterListForTableResponse:
		return soap_in_TT1__getFilterListForTableResponse(soap, NULL, NULL, "TT1:getFilterListForTableResponse");
	case SOAP_TYPE_TT1__getFilterList:
		return soap_in_TT1__getFilterList(soap, NULL, NULL, "TT1:getFilterList");
	case SOAP_TYPE_TT1__getFilterListResponse:
		return soap_in_TT1__getFilterListResponse(soap, NULL, NULL, "TT1:getFilterListResponse");
	case SOAP_TYPE_TT1__getColumnsForTable:
		return soap_in_TT1__getColumnsForTable(soap, NULL, NULL, "TT1:getColumnsForTable");
	case SOAP_TYPE_TT1__getColumnsForTableResponse:
		return soap_in_TT1__getColumnsForTableResponse(soap, NULL, NULL, "TT1:getColumnsForTableResponse");
	case SOAP_TYPE_TT1__GetLinkDefinitionValues:
		return soap_in_TT1__GetLinkDefinitionValues(soap, NULL, NULL, "TT1:GetLinkDefinitionValues");
	case SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse:
		return soap_in_TT1__GetLinkDefinitionValuesResponse(soap, NULL, NULL, "TT1:GetLinkDefinitionValuesResponse");
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTable:
		return soap_in_TT1__addDropdownFieldValuesForTable(soap, NULL, NULL, "TT1:addDropdownFieldValuesForTable");
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse:
		return soap_in_TT1__addDropdownFieldValuesForTableResponse(soap, NULL, NULL, "TT1:addDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTable:
		return soap_in_TT1__getDropdownFieldValuesForTable(soap, NULL, NULL, "TT1:getDropdownFieldValuesForTable");
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse:
		return soap_in_TT1__getDropdownFieldValuesForTableResponse(soap, NULL, NULL, "TT1:getDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_TT1__getDropdownFieldForTable:
		return soap_in_TT1__getDropdownFieldForTable(soap, NULL, NULL, "TT1:getDropdownFieldForTable");
	case SOAP_TYPE_TT1__getDropdownFieldForTableResponse:
		return soap_in_TT1__getDropdownFieldForTableResponse(soap, NULL, NULL, "TT1:getDropdownFieldForTableResponse");
	case SOAP_TYPE_TT1__getTableList:
		return soap_in_TT1__getTableList(soap, NULL, NULL, "TT1:getTableList");
	case SOAP_TYPE_TT1__getTableListResponse:
		return soap_in_TT1__getTableListResponse(soap, NULL, NULL, "TT1:getTableListResponse");
	case SOAP_TYPE_TT1__DatabaseLogoff:
		return soap_in_TT1__DatabaseLogoff(soap, NULL, NULL, "TT1:DatabaseLogoff");
	case SOAP_TYPE_TT1__DatabaseLogoffResponse:
		return soap_in_TT1__DatabaseLogoffResponse(soap, NULL, NULL, "TT1:DatabaseLogoffResponse");
	case SOAP_TYPE_TT1__ProjectLogon:
		return soap_in_TT1__ProjectLogon(soap, NULL, NULL, "TT1:ProjectLogon");
	case SOAP_TYPE_TT1__ProjectLogonResponse:
		return soap_in_TT1__ProjectLogonResponse(soap, NULL, NULL, "TT1:ProjectLogonResponse");
	case SOAP_TYPE_TT1__DatabaseLogon:
		return soap_in_TT1__DatabaseLogon(soap, NULL, NULL, "TT1:DatabaseLogon");
	case SOAP_TYPE_TT1__DatabaseLogonResponse:
		return soap_in_TT1__DatabaseLogonResponse(soap, NULL, NULL, "TT1:DatabaseLogonResponse");
	case SOAP_TYPE_TT1__getProjectDataOptionList:
		return soap_in_TT1__getProjectDataOptionList(soap, NULL, NULL, "TT1:getProjectDataOptionList");
	case SOAP_TYPE_TT1__getProjectDataOptionListResponse:
		return soap_in_TT1__getProjectDataOptionListResponse(soap, NULL, NULL, "TT1:getProjectDataOptionListResponse");
	case SOAP_TYPE_TT1__getProjectList:
		return soap_in_TT1__getProjectList(soap, NULL, NULL, "TT1:getProjectList");
	case SOAP_TYPE_TT1__getProjectListResponse:
		return soap_in_TT1__getProjectListResponse(soap, NULL, NULL, "TT1:getProjectListResponse");
	case SOAP_TYPE_TT1__getDatabaseList:
		return soap_in_TT1__getDatabaseList(soap, NULL, NULL, "TT1:getDatabaseList");
	case SOAP_TYPE_TT1__getDatabaseListResponse:
		return soap_in_TT1__getDatabaseListResponse(soap, NULL, NULL, "TT1:getDatabaseListResponse");
	case SOAP_TYPE_PointerToTT1ArrayOfCFolderItem:
		return soap_in_PointerToTT1ArrayOfCFolderItem(soap, NULL, NULL, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToTT1ArrayOfCTestRunVariantField:
		return soap_in_PointerToTT1ArrayOfCTestRunVariantField(soap, NULL, NULL, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToTT1ArrayOfCItemToTrack:
		return soap_in_PointerToTT1ArrayOfCItemToTrack(soap, NULL, NULL, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToTT1__CTestRun:
		return soap_in_PointerToTT1__CTestRun(soap, NULL, NULL, "TT1:CTestRun");
	case SOAP_TYPE_PointerToTT1__CTestCase:
		return soap_in_PointerToTT1__CTestCase(soap, NULL, NULL, "TT1:CTestCase");
	case SOAP_TYPE_PointerToTT1ArrayOfCLink:
		return soap_in_PointerToTT1ArrayOfCLink(soap, NULL, NULL, "TT1:CLink");
	case SOAP_TYPE_PointerToTT1__CUser:
		return soap_in_PointerToTT1__CUser(soap, NULL, NULL, "TT1:CUser");
	case SOAP_TYPE_PointerToTT1ArrayOfCUserLicense:
		return soap_in_PointerToTT1ArrayOfCUserLicense(soap, NULL, NULL, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToTT1ArrayOfCGlobalUser:
		return soap_in_PointerToTT1ArrayOfCGlobalUser(soap, NULL, NULL, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToTT1__CTask:
		return soap_in_PointerToTT1__CTask(soap, NULL, NULL, "TT1:CTask");
	case SOAP_TYPE_PointerToTT1__CDefect:
		return soap_in_PointerToTT1__CDefect(soap, NULL, NULL, "TT1:CDefect");
	case SOAP_TYPE_PointerToTT1ArrayOfCDefectEventDefinition:
		return soap_in_PointerToTT1ArrayOfCDefectEventDefinition(soap, NULL, NULL, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToTT1ArrayOfCEventDefinition:
		return soap_in_PointerToTT1ArrayOfCEventDefinition(soap, NULL, NULL, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToTT1__CRecordListSoap:
		return soap_in_PointerToTT1__CRecordListSoap(soap, NULL, NULL, "TT1:CRecordListSoap");
	case SOAP_TYPE_PointerToTT1ArrayOfCFilter:
		return soap_in_PointerToTT1ArrayOfCFilter(soap, NULL, NULL, "TT1:CFilter");
	case SOAP_TYPE_PointerToTT1ArrayOfCTableField:
		return soap_in_PointerToTT1ArrayOfCTableField(soap, NULL, NULL, "TT1:CTableField");
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabaseTable:
		return soap_in_PointerToTT1ArrayOfCDatabaseTable(soap, NULL, NULL, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToTT1ArrayOfCProject:
		return soap_in_PointerToTT1ArrayOfCProject(soap, NULL, NULL, "TT1:CProject");
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabase:
		return soap_in_PointerToTT1ArrayOfCDatabase(soap, NULL, NULL, "TT1:CDatabase");
	case SOAP_TYPE_PointerToTT1ArrayOfCTestCaseVariantField:
		return soap_in_PointerToTT1ArrayOfCTestCaseVariantField(soap, NULL, NULL, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkHistoryItem:
		return soap_in_PointerToTT1ArrayOfCLinkHistoryItem(soap, NULL, NULL, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkedItem:
		return soap_in_PointerToTT1ArrayOfCLinkedItem(soap, NULL, NULL, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToTT1__PhoneNumber:
		return soap_in_PointerToTT1__PhoneNumber(soap, NULL, NULL, "TT1:PhoneNumber");
	case SOAP_TYPE_PointerToTT1ArrayOfCSCCFileRecord:
		return soap_in_PointerToTT1ArrayOfCSCCFileRecord(soap, NULL, NULL, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerToTT1ArrayOfCEvent:
		return soap_in_PointerToTT1ArrayOfCEvent(soap, NULL, NULL, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1ArrayOfCReportedByRecord:
		return soap_in_PointerToTT1ArrayOfCReportedByRecord(soap, NULL, NULL, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToPointerToTT1__CFolderItem:
		return soap_in_PointerToPointerToTT1__CFolderItem(soap, NULL, NULL, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToTT1__CFolderItem:
		return soap_in_PointerToTT1__CFolderItem(soap, NULL, NULL, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToPointerToTT1__CFolder:
		return soap_in_PointerToPointerToTT1__CFolder(soap, NULL, NULL, "TT1:CFolder");
	case SOAP_TYPE_PointerToTT1__CFolder:
		return soap_in_PointerToTT1__CFolder(soap, NULL, NULL, "TT1:CFolder");
	case SOAP_TYPE_PointerToPointerToTT1__CItemToTrack:
		return soap_in_PointerToPointerToTT1__CItemToTrack(soap, NULL, NULL, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToTT1__CItemToTrack:
		return soap_in_PointerToTT1__CItemToTrack(soap, NULL, NULL, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToPointerToTT1__CLink:
		return soap_in_PointerToPointerToTT1__CLink(soap, NULL, NULL, "TT1:CLink");
	case SOAP_TYPE_PointerToTT1__CLink:
		return soap_in_PointerToTT1__CLink(soap, NULL, NULL, "TT1:CLink");
	case SOAP_TYPE_PointerToPointerToTT1__CLinkHistoryItem:
		return soap_in_PointerToPointerToTT1__CLinkHistoryItem(soap, NULL, NULL, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToTT1__CLinkHistoryItem:
		return soap_in_PointerToTT1__CLinkHistoryItem(soap, NULL, NULL, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToPointerToTT1__CLinkedItem:
		return soap_in_PointerToPointerToTT1__CLinkedItem(soap, NULL, NULL, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToTT1__CLinkedItem:
		return soap_in_PointerToTT1__CLinkedItem(soap, NULL, NULL, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToPointerToTT1__CUserLicense:
		return soap_in_PointerToPointerToTT1__CUserLicense(soap, NULL, NULL, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToTT1__CUserLicense:
		return soap_in_PointerToTT1__CUserLicense(soap, NULL, NULL, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToPointerToTT1__CGlobalUser:
		return soap_in_PointerToPointerToTT1__CGlobalUser(soap, NULL, NULL, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToTT1__CGlobalUser:
		return soap_in_PointerToTT1__CGlobalUser(soap, NULL, NULL, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEventDefinition:
		return soap_in_PointerToPointerToTT1__CDefectEventDefinition(soap, NULL, NULL, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToTT1__CDefectEventDefinition:
		return soap_in_PointerToTT1__CDefectEventDefinition(soap, NULL, NULL, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToPointerToTT1__CEventDefinition:
		return soap_in_PointerToPointerToTT1__CEventDefinition(soap, NULL, NULL, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToTT1__CEventDefinition:
		return soap_in_PointerToTT1__CEventDefinition(soap, NULL, NULL, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEvent:
		return soap_in_PointerToPointerToTT1__CDefectEvent(soap, NULL, NULL, "TT1:CDefectEvent");
	case SOAP_TYPE_PointerToTT1__CDefectEvent:
		return soap_in_PointerToTT1__CDefectEvent(soap, NULL, NULL, "TT1:CDefectEvent");
	case SOAP_TYPE_PointerToPointerToTT1__CEvent:
		return soap_in_PointerToPointerToTT1__CEvent(soap, NULL, NULL, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1__CEvent:
		return soap_in_PointerToTT1__CEvent(soap, NULL, NULL, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1ArrayOfstring:
		return soap_in_PointerToTT1ArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToPointerToTT1__CTestCaseVariantField:
		return soap_in_PointerToPointerToTT1__CTestCaseVariantField(soap, NULL, NULL, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToTT1__CTestCaseVariantField:
		return soap_in_PointerToTT1__CTestCaseVariantField(soap, NULL, NULL, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToPointerToTT1__CTestRunVariantField:
		return soap_in_PointerToPointerToTT1__CTestRunVariantField(soap, NULL, NULL, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToTT1__CTestRunVariantField:
		return soap_in_PointerToTT1__CTestRunVariantField(soap, NULL, NULL, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToPointerToTT1__CField:
		return soap_in_PointerToPointerToTT1__CField(soap, NULL, NULL, "TT1:CField");
	case SOAP_TYPE_PointerToTT1__CField:
		return soap_in_PointerToTT1__CField(soap, NULL, NULL, "TT1:CField");
	case SOAP_TYPE_PointerToPointerToTT1__CReportedByRecord:
		return soap_in_PointerToPointerToTT1__CReportedByRecord(soap, NULL, NULL, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToTT1__CReportedByRecord:
		return soap_in_PointerToTT1__CReportedByRecord(soap, NULL, NULL, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToTT1ArrayOfCFileAttachment:
		return soap_in_PointerToTT1ArrayOfCFileAttachment(soap, NULL, NULL, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToshort:
		return soap_in_PointerToshort(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_PointerToTT1__CSystem:
		return soap_in_PointerToTT1__CSystem(soap, NULL, NULL, "TT1:CSystem");
	case SOAP_TYPE_PointerToPointerToTT1__CFileAttachment:
		return soap_in_PointerToPointerToTT1__CFileAttachment(soap, NULL, NULL, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToTT1__CFileAttachment:
		return soap_in_PointerToTT1__CFileAttachment(soap, NULL, NULL, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerToTT1__CSCCFileRecord:
		return soap_in_PointerToPointerToTT1__CSCCFileRecord(soap, NULL, NULL, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerToTT1__CSCCFileRecord:
		return soap_in_PointerToTT1__CSCCFileRecord(soap, NULL, NULL, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerToTT1__CRecordRowSoap:
		return soap_in_PointerToPointerToTT1__CRecordRowSoap(soap, NULL, NULL, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToTT1__CRecordRowSoap:
		return soap_in_PointerToTT1__CRecordRowSoap(soap, NULL, NULL, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToPointerToTT1__CRecordData:
		return soap_in_PointerToPointerToTT1__CRecordData(soap, NULL, NULL, "TT1:CRecordData");
	case SOAP_TYPE_PointerToTT1__CRecordData:
		return soap_in_PointerToTT1__CRecordData(soap, NULL, NULL, "TT1:CRecordData");
	case SOAP_TYPE_PointerToPointerToTT1__CFilter:
		return soap_in_PointerToPointerToTT1__CFilter(soap, NULL, NULL, "TT1:CFilter");
	case SOAP_TYPE_PointerToTT1__CFilter:
		return soap_in_PointerToTT1__CFilter(soap, NULL, NULL, "TT1:CFilter");
	case SOAP_TYPE_PointerToPointerToTT1__CTableColumn:
		return soap_in_PointerToPointerToTT1__CTableColumn(soap, NULL, NULL, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToTT1__CTableColumn:
		return soap_in_PointerToTT1__CTableColumn(soap, NULL, NULL, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToPointerToTT1__CFieldValue:
		return soap_in_PointerToPointerToTT1__CFieldValue(soap, NULL, NULL, "TT1:CFieldValue");
	case SOAP_TYPE_PointerToTT1__CFieldValue:
		return soap_in_PointerToTT1__CFieldValue(soap, NULL, NULL, "TT1:CFieldValue");
	case SOAP_TYPE_PointerToPointerToTT1__CTableField:
		return soap_in_PointerToPointerToTT1__CTableField(soap, NULL, NULL, "TT1:CTableField");
	case SOAP_TYPE_PointerToTT1__CTableField:
		return soap_in_PointerToTT1__CTableField(soap, NULL, NULL, "TT1:CTableField");
	case SOAP_TYPE_PointerToPointerToTT1__CDatabaseTable:
		return soap_in_PointerToPointerToTT1__CDatabaseTable(soap, NULL, NULL, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToTT1__CDatabaseTable:
		return soap_in_PointerToTT1__CDatabaseTable(soap, NULL, NULL, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToPointerToTT1__CProject:
		return soap_in_PointerToPointerToTT1__CProject(soap, NULL, NULL, "TT1:CProject");
	case SOAP_TYPE_PointerToTT1__CProject:
		return soap_in_PointerToTT1__CProject(soap, NULL, NULL, "TT1:CProject");
	case SOAP_TYPE_PointerToPointerToTT1__CProjectDataOption:
		return soap_in_PointerToPointerToTT1__CProjectDataOption(soap, NULL, NULL, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToTT1__CProjectDataOption:
		return soap_in_PointerToTT1__CProjectDataOption(soap, NULL, NULL, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToPointerToTT1__CDatabase:
		return soap_in_PointerToPointerToTT1__CDatabase(soap, NULL, NULL, "TT1:CDatabase");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToTT1ArrayOfCField:
		return soap_in_PointerToTT1ArrayOfCField(soap, NULL, NULL, "TT1:CField");
	case SOAP_TYPE_PointerToTT1ArrayOfCFieldValue:
		return soap_in_PointerToTT1ArrayOfCFieldValue(soap, NULL, NULL, "TT1:CFieldValue");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordRowSoap:
		return soap_in_PointerToTT1ArrayOfCRecordRowSoap(soap, NULL, NULL, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToTT1ArrayOfCTableColumn:
		return soap_in_PointerToTT1ArrayOfCTableColumn(soap, NULL, NULL, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordData:
		return soap_in_PointerToTT1ArrayOfCRecordData(soap, NULL, NULL, "TT1:CRecordData");
	case SOAP_TYPE_PointerToTT1ArrayOfCProjectDataOption:
		return soap_in_PointerToTT1ArrayOfCProjectDataOption(soap, NULL, NULL, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToTT1__CDatabase:
		return soap_in_PointerToTT1__CDatabase(soap, NULL, NULL, "TT1:CDatabase");
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CFolderItem"))
		{	*type = SOAP_TYPE_TT1ArrayOfCFolderItem;
			return soap_in_TT1ArrayOfCFolderItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CFolder"))
		{	*type = SOAP_TYPE_TT1ArrayOfCFolder;
			return soap_in_TT1ArrayOfCFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CFolderItem"))
		{	*type = SOAP_TYPE_TT1__CFolderItem;
			return soap_in_TT1__CFolderItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CFolder"))
		{	*type = SOAP_TYPE_TT1__CFolder;
			return soap_in_TT1__CFolder(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CItemToTrack"))
		{	*type = SOAP_TYPE_TT1ArrayOfCItemToTrack;
			return soap_in_TT1ArrayOfCItemToTrack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTestRun"))
		{	*type = SOAP_TYPE_TT1__CTestRun;
			return soap_in_TT1__CTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTestCase"))
		{	*type = SOAP_TYPE_TT1__CTestCase;
			return soap_in_TT1__CTestCase(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CLink"))
		{	*type = SOAP_TYPE_TT1ArrayOfCLink;
			return soap_in_TT1ArrayOfCLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CLink"))
		{	*type = SOAP_TYPE_TT1__CLink;
			return soap_in_TT1__CLink(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CLinkHistoryItem"))
		{	*type = SOAP_TYPE_TT1ArrayOfCLinkHistoryItem;
			return soap_in_TT1ArrayOfCLinkHistoryItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CLinkHistoryItem"))
		{	*type = SOAP_TYPE_TT1__CLinkHistoryItem;
			return soap_in_TT1__CLinkHistoryItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CLinkedItem"))
		{	*type = SOAP_TYPE_TT1ArrayOfCLinkedItem;
			return soap_in_TT1ArrayOfCLinkedItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CLinkedItem"))
		{	*type = SOAP_TYPE_TT1__CLinkedItem;
			return soap_in_TT1__CLinkedItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CUserLicense"))
		{	*type = SOAP_TYPE_TT1ArrayOfCUserLicense;
			return soap_in_TT1ArrayOfCUserLicense(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CUserLicense"))
		{	*type = SOAP_TYPE_TT1__CUserLicense;
			return soap_in_TT1__CUserLicense(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CGlobalUser"))
		{	*type = SOAP_TYPE_TT1ArrayOfCGlobalUser;
			return soap_in_TT1ArrayOfCGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CGlobalUser"))
		{	*type = SOAP_TYPE_TT1__CGlobalUser;
			return soap_in_TT1__CGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CUser"))
		{	*type = SOAP_TYPE_TT1__CUser;
			return soap_in_TT1__CUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:PhoneNumber"))
		{	*type = SOAP_TYPE_TT1__PhoneNumber;
			return soap_in_TT1__PhoneNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTask"))
		{	*type = SOAP_TYPE_TT1__CTask;
			return soap_in_TT1__CTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDefect"))
		{	*type = SOAP_TYPE_TT1__CDefect;
			return soap_in_TT1__CDefect(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CDefectEventDefinition"))
		{	*type = SOAP_TYPE_TT1ArrayOfCDefectEventDefinition;
			return soap_in_TT1ArrayOfCDefectEventDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDefectEventDefinition"))
		{	*type = SOAP_TYPE_TT1__CDefectEventDefinition;
			return soap_in_TT1__CDefectEventDefinition(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CEventDefinition"))
		{	*type = SOAP_TYPE_TT1ArrayOfCEventDefinition;
			return soap_in_TT1ArrayOfCEventDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CEventDefinition"))
		{	*type = SOAP_TYPE_TT1__CEventDefinition;
			return soap_in_TT1__CEventDefinition(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CDefectEvent"))
		{	*type = SOAP_TYPE_TT1ArrayOfCDefectEvent;
			return soap_in_TT1ArrayOfCDefectEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDefectEvent"))
		{	*type = SOAP_TYPE_TT1__CDefectEvent;
			return soap_in_TT1__CDefectEvent(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CEvent"))
		{	*type = SOAP_TYPE_TT1ArrayOfCEvent;
			return soap_in_TT1ArrayOfCEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CEvent"))
		{	*type = SOAP_TYPE_TT1__CEvent;
			return soap_in_TT1__CEvent(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CTestCaseVariantField"))
		{	*type = SOAP_TYPE_TT1ArrayOfCTestCaseVariantField;
			return soap_in_TT1ArrayOfCTestCaseVariantField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CTestRunVariantField"))
		{	*type = SOAP_TYPE_TT1ArrayOfCTestRunVariantField;
			return soap_in_TT1ArrayOfCTestRunVariantField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CField"))
		{	*type = SOAP_TYPE_TT1ArrayOfCField;
			return soap_in_TT1ArrayOfCField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CVersionField"))
		{	*type = SOAP_TYPE_TT1__CVersionField;
			return soap_in_TT1__CVersionField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTestCaseVariantField"))
		{	*type = SOAP_TYPE_TT1__CTestCaseVariantField;
			return soap_in_TT1__CTestCaseVariantField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTestRunVariantField"))
		{	*type = SOAP_TYPE_TT1__CTestRunVariantField;
			return soap_in_TT1__CTestRunVariantField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CMultiSelectDropdownField"))
		{	*type = SOAP_TYPE_TT1__CMultiSelectDropdownField;
			return soap_in_TT1__CMultiSelectDropdownField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDropdownField"))
		{	*type = SOAP_TYPE_TT1__CDropdownField;
			return soap_in_TT1__CDropdownField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDateTimeField"))
		{	*type = SOAP_TYPE_TT1__CDateTimeField;
			return soap_in_TT1__CDateTimeField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDateField"))
		{	*type = SOAP_TYPE_TT1__CDateField;
			return soap_in_TT1__CDateField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CBooleanField"))
		{	*type = SOAP_TYPE_TT1__CBooleanField;
			return soap_in_TT1__CBooleanField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDecimalField"))
		{	*type = SOAP_TYPE_TT1__CDecimalField;
			return soap_in_TT1__CDecimalField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CIntegerField"))
		{	*type = SOAP_TYPE_TT1__CIntegerField;
			return soap_in_TT1__CIntegerField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CStringField"))
		{	*type = SOAP_TYPE_TT1__CStringField;
			return soap_in_TT1__CStringField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CField"))
		{	*type = SOAP_TYPE_TT1__CField;
			return soap_in_TT1__CField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CReportedByRecord"))
		{	*type = SOAP_TYPE_TT1ArrayOfCReportedByRecord;
			return soap_in_TT1ArrayOfCReportedByRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CReportedByRecord"))
		{	*type = SOAP_TYPE_TT1__CReportedByRecord;
			return soap_in_TT1__CReportedByRecord(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CFileAttachment"))
		{	*type = SOAP_TYPE_TT1ArrayOfCFileAttachment;
			return soap_in_TT1ArrayOfCFileAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CFileAttachment"))
		{	*type = SOAP_TYPE_TT1__CFileAttachment;
			return soap_in_TT1__CFileAttachment(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CSCCFileRecord"))
		{	*type = SOAP_TYPE_TT1ArrayOfCSCCFileRecord;
			return soap_in_TT1ArrayOfCSCCFileRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CSCCFileRecord"))
		{	*type = SOAP_TYPE_TT1__CSCCFileRecord;
			return soap_in_TT1__CSCCFileRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CSystem"))
		{	*type = SOAP_TYPE_TT1__CSystem;
			return soap_in_TT1__CSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CSystemBase"))
		{	*type = SOAP_TYPE_TT1__CSystemBase;
			return soap_in_TT1__CSystemBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:COrderedItemWithDBRecordId"))
		{	*type = SOAP_TYPE_TT1__COrderedItemWithDBRecordId;
			return soap_in_TT1__COrderedItemWithDBRecordId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CItemToTrack"))
		{	*type = SOAP_TYPE_TT1__CItemToTrack;
			return soap_in_TT1__CItemToTrack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CItemWithDBRecordId"))
		{	*type = SOAP_TYPE_TT1__CItemWithDBRecordId;
			return soap_in_TT1__CItemWithDBRecordId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CRecordListSoap"))
		{	*type = SOAP_TYPE_TT1__CRecordListSoap;
			return soap_in_TT1__CRecordListSoap(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CRecordRowSoap"))
		{	*type = SOAP_TYPE_TT1ArrayOfCRecordRowSoap;
			return soap_in_TT1ArrayOfCRecordRowSoap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CRecordRowSoap"))
		{	*type = SOAP_TYPE_TT1__CRecordRowSoap;
			return soap_in_TT1__CRecordRowSoap(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CRecordData"))
		{	*type = SOAP_TYPE_TT1ArrayOfCRecordData;
			return soap_in_TT1ArrayOfCRecordData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CRecordData"))
		{	*type = SOAP_TYPE_TT1__CRecordData;
			return soap_in_TT1__CRecordData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CFilter"))
		{	*type = SOAP_TYPE_TT1ArrayOfCFilter;
			return soap_in_TT1ArrayOfCFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CFilter"))
		{	*type = SOAP_TYPE_TT1__CFilter;
			return soap_in_TT1__CFilter(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CTableColumn"))
		{	*type = SOAP_TYPE_TT1ArrayOfCTableColumn;
			return soap_in_TT1ArrayOfCTableColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTableColumn"))
		{	*type = SOAP_TYPE_TT1__CTableColumn;
			return soap_in_TT1__CTableColumn(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CFieldValue"))
		{	*type = SOAP_TYPE_TT1ArrayOfCFieldValue;
			return soap_in_TT1ArrayOfCFieldValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CFieldValue"))
		{	*type = SOAP_TYPE_TT1__CFieldValue;
			return soap_in_TT1__CFieldValue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CTableField"))
		{	*type = SOAP_TYPE_TT1ArrayOfCTableField;
			return soap_in_TT1ArrayOfCTableField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CTableField"))
		{	*type = SOAP_TYPE_TT1__CTableField;
			return soap_in_TT1__CTableField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CDatabaseTable"))
		{	*type = SOAP_TYPE_TT1ArrayOfCDatabaseTable;
			return soap_in_TT1ArrayOfCDatabaseTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDatabaseTable"))
		{	*type = SOAP_TYPE_TT1__CDatabaseTable;
			return soap_in_TT1__CDatabaseTable(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CProject"))
		{	*type = SOAP_TYPE_TT1ArrayOfCProject;
			return soap_in_TT1ArrayOfCProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CProject"))
		{	*type = SOAP_TYPE_TT1__CProject;
			return soap_in_TT1__CProject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CProjectDataOption"))
		{	*type = SOAP_TYPE_TT1ArrayOfCProjectDataOption;
			return soap_in_TT1ArrayOfCProjectDataOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CProjectDataOption"))
		{	*type = SOAP_TYPE_TT1__CProjectDataOption;
			return soap_in_TT1__CProjectDataOption(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "TT1:CDatabase"))
		{	*type = SOAP_TYPE_TT1ArrayOfCDatabase;
			return soap_in_TT1ArrayOfCDatabase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:CDatabase"))
		{	*type = SOAP_TYPE_TT1__CDatabase;
			return soap_in_TT1__CDatabase(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_TT1ArrayOfstring;
			return soap_in_TT1ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRootPrivateFolderPath"))
		{	*type = SOAP_TYPE_TT1__getRootPrivateFolderPath;
			return soap_in_TT1__getRootPrivateFolderPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRootPrivateFolderPathResponse"))
		{	*type = SOAP_TYPE_TT1__getRootPrivateFolderPathResponse;
			return soap_in_TT1__getRootPrivateFolderPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRootPublicFolderPath"))
		{	*type = SOAP_TYPE_TT1__getRootPublicFolderPath;
			return soap_in_TT1__getRootPublicFolderPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRootPublicFolderPathResponse"))
		{	*type = SOAP_TYPE_TT1__getRootPublicFolderPathResponse;
			return soap_in_TT1__getRootPublicFolderPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolderPathSeparator"))
		{	*type = SOAP_TYPE_TT1__getFolderPathSeparator;
			return soap_in_TT1__getFolderPathSeparator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolderPathSeparatorResponse"))
		{	*type = SOAP_TYPE_TT1__getFolderPathSeparatorResponse;
			return soap_in_TT1__getFolderPathSeparatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getEntityListForFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__getEntityListForFolderByRecordID;
			return soap_in_TT1__getEntityListForFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getEntityListForFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse;
			return soap_in_TT1__getEntityListForFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:removeEntityFromFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__removeEntityFromFolderByRecordID;
			return soap_in_TT1__removeEntityFromFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:removeEntityFromFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse;
			return soap_in_TT1__removeEntityFromFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addEntityToFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__addEntityToFolderByRecordID;
			return soap_in_TT1__addEntityToFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addEntityToFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse;
			return soap_in_TT1__addEntityToFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteFolderByRecordID;
			return soap_in_TT1__deleteFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteFolderByRecordIDResponse;
			return soap_in_TT1__deleteFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteFolder"))
		{	*type = SOAP_TYPE_TT1__deleteFolder;
			return soap_in_TT1__deleteFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteFolderResponse"))
		{	*type = SOAP_TYPE_TT1__deleteFolderResponse;
			return soap_in_TT1__deleteFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__getFolderByRecordID;
			return soap_in_TT1__getFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getFolderByRecordIDResponse;
			return soap_in_TT1__getFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolder"))
		{	*type = SOAP_TYPE_TT1__getFolder;
			return soap_in_TT1__getFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFolderResponse"))
		{	*type = SOAP_TYPE_TT1__getFolderResponse;
			return soap_in_TT1__getFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveFolder"))
		{	*type = SOAP_TYPE_TT1__cancelSaveFolder;
			return soap_in_TT1__cancelSaveFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveFolderResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveFolderResponse;
			return soap_in_TT1__cancelSaveFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveFolder"))
		{	*type = SOAP_TYPE_TT1__saveFolder;
			return soap_in_TT1__saveFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveFolderResponse"))
		{	*type = SOAP_TYPE_TT1__saveFolderResponse;
			return soap_in_TT1__saveFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editFolderByRecordID"))
		{	*type = SOAP_TYPE_TT1__editFolderByRecordID;
			return soap_in_TT1__editFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editFolderByRecordIDResponse;
			return soap_in_TT1__editFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editFolder"))
		{	*type = SOAP_TYPE_TT1__editFolder;
			return soap_in_TT1__editFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editFolderResponse"))
		{	*type = SOAP_TYPE_TT1__editFolderResponse;
			return soap_in_TT1__editFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addFolder"))
		{	*type = SOAP_TYPE_TT1__addFolder;
			return soap_in_TT1__addFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addFolderResponse"))
		{	*type = SOAP_TYPE_TT1__addFolderResponse;
			return soap_in_TT1__addFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:generateTestRuns"))
		{	*type = SOAP_TYPE_TT1__generateTestRuns;
			return soap_in_TT1__generateTestRuns(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:generateTestRunsResponse"))
		{	*type = SOAP_TYPE_TT1__generateTestRunsResponse;
			return soap_in_TT1__generateTestRunsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:createDefectForTestRun"))
		{	*type = SOAP_TYPE_TT1__createDefectForTestRun;
			return soap_in_TT1__createDefectForTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:createDefectForTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__createDefectForTestRunResponse;
			return soap_in_TT1__createDefectForTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestRun"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestRun;
			return soap_in_TT1__cancelSaveTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestRunResponse;
			return soap_in_TT1__cancelSaveTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestRun"))
		{	*type = SOAP_TYPE_TT1__saveTestRun;
			return soap_in_TT1__saveTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__saveTestRunResponse;
			return soap_in_TT1__saveTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestRunByRecordID"))
		{	*type = SOAP_TYPE_TT1__editTestRunByRecordID;
			return soap_in_TT1__editTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editTestRunByRecordIDResponse;
			return soap_in_TT1__editTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestRun"))
		{	*type = SOAP_TYPE_TT1__editTestRun;
			return soap_in_TT1__editTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__editTestRunResponse;
			return soap_in_TT1__editTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestRunByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteTestRunByRecordID;
			return soap_in_TT1__deleteTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse;
			return soap_in_TT1__deleteTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestRun"))
		{	*type = SOAP_TYPE_TT1__deleteTestRun;
			return soap_in_TT1__deleteTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestRunResponse;
			return soap_in_TT1__deleteTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRunByRecordID"))
		{	*type = SOAP_TYPE_TT1__getTestRunByRecordID;
			return soap_in_TT1__getTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getTestRunByRecordIDResponse;
			return soap_in_TT1__getTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRun"))
		{	*type = SOAP_TYPE_TT1__getTestRun;
			return soap_in_TT1__getTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRunResponse"))
		{	*type = SOAP_TYPE_TT1__getTestRunResponse;
			return soap_in_TT1__getTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestCase"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestCase;
			return soap_in_TT1__cancelSaveTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestCaseResponse;
			return soap_in_TT1__cancelSaveTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestCase"))
		{	*type = SOAP_TYPE_TT1__saveTestCase;
			return soap_in_TT1__saveTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__saveTestCaseResponse;
			return soap_in_TT1__saveTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestCaseByRecordID"))
		{	*type = SOAP_TYPE_TT1__editTestCaseByRecordID;
			return soap_in_TT1__editTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editTestCaseByRecordIDResponse;
			return soap_in_TT1__editTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestCase"))
		{	*type = SOAP_TYPE_TT1__editTestCase;
			return soap_in_TT1__editTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__editTestCaseResponse;
			return soap_in_TT1__editTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestCaseByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteTestCaseByRecordID;
			return soap_in_TT1__deleteTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse;
			return soap_in_TT1__deleteTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestCase"))
		{	*type = SOAP_TYPE_TT1__deleteTestCase;
			return soap_in_TT1__deleteTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestCaseResponse;
			return soap_in_TT1__deleteTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTestCase"))
		{	*type = SOAP_TYPE_TT1__addTestCase;
			return soap_in_TT1__addTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__addTestCaseResponse;
			return soap_in_TT1__addTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestCaseByRecordID"))
		{	*type = SOAP_TYPE_TT1__getTestCaseByRecordID;
			return soap_in_TT1__getTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getTestCaseByRecordIDResponse;
			return soap_in_TT1__getTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestCase"))
		{	*type = SOAP_TYPE_TT1__getTestCase;
			return soap_in_TT1__getTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestCaseResponse"))
		{	*type = SOAP_TYPE_TT1__getTestCaseResponse;
			return soap_in_TT1__getTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRunStepsModes"))
		{	*type = SOAP_TYPE_TT1__getTestRunStepsModes;
			return soap_in_TT1__getTestRunStepsModes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestRunStepsModesResponse"))
		{	*type = SOAP_TYPE_TT1__getTestRunStepsModesResponse;
			return soap_in_TT1__getTestRunStepsModesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestVariantTypes"))
		{	*type = SOAP_TYPE_TT1__getTestVariantTypes;
			return soap_in_TT1__getTestVariantTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestVariantTypesResponse"))
		{	*type = SOAP_TYPE_TT1__getTestVariantTypesResponse;
			return soap_in_TT1__getTestVariantTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveLink"))
		{	*type = SOAP_TYPE_TT1__cancelSaveLink;
			return soap_in_TT1__cancelSaveLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveLinkResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveLinkResponse;
			return soap_in_TT1__cancelSaveLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveLink"))
		{	*type = SOAP_TYPE_TT1__saveLink;
			return soap_in_TT1__saveLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveLinkResponse"))
		{	*type = SOAP_TYPE_TT1__saveLinkResponse;
			return soap_in_TT1__saveLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editLink"))
		{	*type = SOAP_TYPE_TT1__editLink;
			return soap_in_TT1__editLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editLinkResponse"))
		{	*type = SOAP_TYPE_TT1__editLinkResponse;
			return soap_in_TT1__editLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteLink"))
		{	*type = SOAP_TYPE_TT1__deleteLink;
			return soap_in_TT1__deleteLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteLinkResponse"))
		{	*type = SOAP_TYPE_TT1__deleteLinkResponse;
			return soap_in_TT1__deleteLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addLink"))
		{	*type = SOAP_TYPE_TT1__addLink;
			return soap_in_TT1__addLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addLinkResponse"))
		{	*type = SOAP_TYPE_TT1__addLinkResponse;
			return soap_in_TT1__addLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLink"))
		{	*type = SOAP_TYPE_TT1__getLink;
			return soap_in_TT1__getLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLinkResponse"))
		{	*type = SOAP_TYPE_TT1__getLinkResponse;
			return soap_in_TT1__getLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLinksForDefect"))
		{	*type = SOAP_TYPE_TT1__getLinksForDefect;
			return soap_in_TT1__getLinksForDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLinksForDefectResponse"))
		{	*type = SOAP_TYPE_TT1__getLinksForDefectResponse;
			return soap_in_TT1__getLinksForDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLinksForItem"))
		{	*type = SOAP_TYPE_TT1__getLinksForItem;
			return soap_in_TT1__getLinksForItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getLinksForItemResponse"))
		{	*type = SOAP_TYPE_TT1__getLinksForItemResponse;
			return soap_in_TT1__getLinksForItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addGlobalCustomer"))
		{	*type = SOAP_TYPE_TT1__addGlobalCustomer;
			return soap_in_TT1__addGlobalCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addGlobalCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__addGlobalCustomerResponse;
			return soap_in_TT1__addGlobalCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:promoteCustomer"))
		{	*type = SOAP_TYPE_TT1__promoteCustomer;
			return soap_in_TT1__promoteCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:promoteCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__promoteCustomerResponse;
			return soap_in_TT1__promoteCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveCustomer"))
		{	*type = SOAP_TYPE_TT1__cancelSaveCustomer;
			return soap_in_TT1__cancelSaveCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveCustomerResponse;
			return soap_in_TT1__cancelSaveCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteCustomerByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteCustomerByRecordID;
			return soap_in_TT1__deleteCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse;
			return soap_in_TT1__deleteCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteCustomer"))
		{	*type = SOAP_TYPE_TT1__deleteCustomer;
			return soap_in_TT1__deleteCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__deleteCustomerResponse;
			return soap_in_TT1__deleteCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveCustomer"))
		{	*type = SOAP_TYPE_TT1__saveCustomer;
			return soap_in_TT1__saveCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__saveCustomerResponse;
			return soap_in_TT1__saveCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editCustomerByRecordID"))
		{	*type = SOAP_TYPE_TT1__editCustomerByRecordID;
			return soap_in_TT1__editCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editCustomerByRecordIDResponse;
			return soap_in_TT1__editCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editCustomer"))
		{	*type = SOAP_TYPE_TT1__editCustomer;
			return soap_in_TT1__editCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__editCustomerResponse;
			return soap_in_TT1__editCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addCustomer"))
		{	*type = SOAP_TYPE_TT1__addCustomer;
			return soap_in_TT1__addCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__addCustomerResponse;
			return soap_in_TT1__addCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomerByRecordID"))
		{	*type = SOAP_TYPE_TT1__getCustomerByRecordID;
			return soap_in_TT1__getCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getCustomerByRecordIDResponse;
			return soap_in_TT1__getCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomer"))
		{	*type = SOAP_TYPE_TT1__getCustomer;
			return soap_in_TT1__getCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomerResponse"))
		{	*type = SOAP_TYPE_TT1__getCustomerResponse;
			return soap_in_TT1__getCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addGlobalUser"))
		{	*type = SOAP_TYPE_TT1__addGlobalUser;
			return soap_in_TT1__addGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addGlobalUserResponse"))
		{	*type = SOAP_TYPE_TT1__addGlobalUserResponse;
			return soap_in_TT1__addGlobalUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:promoteUser"))
		{	*type = SOAP_TYPE_TT1__promoteUser;
			return soap_in_TT1__promoteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:promoteUserResponse"))
		{	*type = SOAP_TYPE_TT1__promoteUserResponse;
			return soap_in_TT1__promoteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveUser"))
		{	*type = SOAP_TYPE_TT1__cancelSaveUser;
			return soap_in_TT1__cancelSaveUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveUserResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveUserResponse;
			return soap_in_TT1__cancelSaveUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteUserByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteUserByRecordID;
			return soap_in_TT1__deleteUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteUserByRecordIDResponse;
			return soap_in_TT1__deleteUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteUser"))
		{	*type = SOAP_TYPE_TT1__deleteUser;
			return soap_in_TT1__deleteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteUserResponse"))
		{	*type = SOAP_TYPE_TT1__deleteUserResponse;
			return soap_in_TT1__deleteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveUser"))
		{	*type = SOAP_TYPE_TT1__saveUser;
			return soap_in_TT1__saveUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveUserResponse"))
		{	*type = SOAP_TYPE_TT1__saveUserResponse;
			return soap_in_TT1__saveUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editUserByRecordID"))
		{	*type = SOAP_TYPE_TT1__editUserByRecordID;
			return soap_in_TT1__editUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editUserByRecordIDResponse;
			return soap_in_TT1__editUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editUser"))
		{	*type = SOAP_TYPE_TT1__editUser;
			return soap_in_TT1__editUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editUserResponse"))
		{	*type = SOAP_TYPE_TT1__editUserResponse;
			return soap_in_TT1__editUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addUser"))
		{	*type = SOAP_TYPE_TT1__addUser;
			return soap_in_TT1__addUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addUserResponse"))
		{	*type = SOAP_TYPE_TT1__addUserResponse;
			return soap_in_TT1__addUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUserByRecordID"))
		{	*type = SOAP_TYPE_TT1__getUserByRecordID;
			return soap_in_TT1__getUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getUserByRecordIDResponse;
			return soap_in_TT1__getUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUser"))
		{	*type = SOAP_TYPE_TT1__getUser;
			return soap_in_TT1__getUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUserResponse"))
		{	*type = SOAP_TYPE_TT1__getUserResponse;
			return soap_in_TT1__getUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUserLicenseList"))
		{	*type = SOAP_TYPE_TT1__getUserLicenseList;
			return soap_in_TT1__getUserLicenseList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getUserLicenseListResponse"))
		{	*type = SOAP_TYPE_TT1__getUserLicenseListResponse;
			return soap_in_TT1__getUserLicenseListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getGlobalCustomerList"))
		{	*type = SOAP_TYPE_TT1__getGlobalCustomerList;
			return soap_in_TT1__getGlobalCustomerList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getGlobalCustomerListResponse"))
		{	*type = SOAP_TYPE_TT1__getGlobalCustomerListResponse;
			return soap_in_TT1__getGlobalCustomerListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getGlobalUserList"))
		{	*type = SOAP_TYPE_TT1__getGlobalUserList;
			return soap_in_TT1__getGlobalUserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getGlobalUserListResponse"))
		{	*type = SOAP_TYPE_TT1__getGlobalUserListResponse;
			return soap_in_TT1__getGlobalUserListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTask"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTask;
			return soap_in_TT1__cancelSaveTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTaskResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTaskResponse;
			return soap_in_TT1__cancelSaveTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTask"))
		{	*type = SOAP_TYPE_TT1__saveTask;
			return soap_in_TT1__saveTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTaskResponse"))
		{	*type = SOAP_TYPE_TT1__saveTaskResponse;
			return soap_in_TT1__saveTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTaskByRecordID"))
		{	*type = SOAP_TYPE_TT1__editTaskByRecordID;
			return soap_in_TT1__editTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editTaskByRecordIDResponse;
			return soap_in_TT1__editTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTask"))
		{	*type = SOAP_TYPE_TT1__editTask;
			return soap_in_TT1__editTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTaskResponse"))
		{	*type = SOAP_TYPE_TT1__editTaskResponse;
			return soap_in_TT1__editTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTaskByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteTaskByRecordID;
			return soap_in_TT1__deleteTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTaskByRecordIDResponse;
			return soap_in_TT1__deleteTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTask"))
		{	*type = SOAP_TYPE_TT1__deleteTask;
			return soap_in_TT1__deleteTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTaskResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTaskResponse;
			return soap_in_TT1__deleteTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTask"))
		{	*type = SOAP_TYPE_TT1__addTask;
			return soap_in_TT1__addTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTaskResponse"))
		{	*type = SOAP_TYPE_TT1__addTaskResponse;
			return soap_in_TT1__addTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTaskByRecordID"))
		{	*type = SOAP_TYPE_TT1__getTaskByRecordID;
			return soap_in_TT1__getTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getTaskByRecordIDResponse;
			return soap_in_TT1__getTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTask"))
		{	*type = SOAP_TYPE_TT1__getTask;
			return soap_in_TT1__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTaskResponse"))
		{	*type = SOAP_TYPE_TT1__getTaskResponse;
			return soap_in_TT1__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectAttachment"))
		{	*type = SOAP_TYPE_TT1__getDefectAttachment;
			return soap_in_TT1__getDefectAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectAttachmentResponse"))
		{	*type = SOAP_TYPE_TT1__getDefectAttachmentResponse;
			return soap_in_TT1__getDefectAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getAttachment"))
		{	*type = SOAP_TYPE_TT1__getAttachment;
			return soap_in_TT1__getAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getAttachmentResponse"))
		{	*type = SOAP_TYPE_TT1__getAttachmentResponse;
			return soap_in_TT1__getAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveDefect"))
		{	*type = SOAP_TYPE_TT1__cancelSaveDefect;
			return soap_in_TT1__cancelSaveDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveDefectResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveDefectResponse;
			return soap_in_TT1__cancelSaveDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveDefect"))
		{	*type = SOAP_TYPE_TT1__saveDefect;
			return soap_in_TT1__saveDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveDefectResponse"))
		{	*type = SOAP_TYPE_TT1__saveDefectResponse;
			return soap_in_TT1__saveDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editDefectByRecordID"))
		{	*type = SOAP_TYPE_TT1__editDefectByRecordID;
			return soap_in_TT1__editDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editDefectByRecordIDResponse;
			return soap_in_TT1__editDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editDefect"))
		{	*type = SOAP_TYPE_TT1__editDefect;
			return soap_in_TT1__editDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editDefectResponse"))
		{	*type = SOAP_TYPE_TT1__editDefectResponse;
			return soap_in_TT1__editDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteDefectByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteDefectByRecordID;
			return soap_in_TT1__deleteDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteDefectByRecordIDResponse;
			return soap_in_TT1__deleteDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteDefect"))
		{	*type = SOAP_TYPE_TT1__deleteDefect;
			return soap_in_TT1__deleteDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteDefectResponse"))
		{	*type = SOAP_TYPE_TT1__deleteDefectResponse;
			return soap_in_TT1__deleteDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDefectWithLink"))
		{	*type = SOAP_TYPE_TT1__addDefectWithLink;
			return soap_in_TT1__addDefectWithLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDefectWithLinkResponse"))
		{	*type = SOAP_TYPE_TT1__addDefectWithLinkResponse;
			return soap_in_TT1__addDefectWithLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDefect"))
		{	*type = SOAP_TYPE_TT1__addDefect;
			return soap_in_TT1__addDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDefectResponse"))
		{	*type = SOAP_TYPE_TT1__addDefectResponse;
			return soap_in_TT1__addDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectByRecordID"))
		{	*type = SOAP_TYPE_TT1__getDefectByRecordID;
			return soap_in_TT1__getDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getDefectByRecordIDResponse;
			return soap_in_TT1__getDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefect"))
		{	*type = SOAP_TYPE_TT1__getDefect;
			return soap_in_TT1__getDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectResponse"))
		{	*type = SOAP_TYPE_TT1__getDefectResponse;
			return soap_in_TT1__getDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectCustomFieldsDefinitionList"))
		{	*type = SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList;
			return soap_in_TT1__getDefectCustomFieldsDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectCustomFieldsDefinitionListResponse"))
		{	*type = SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse;
			return soap_in_TT1__getDefectCustomFieldsDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomFieldsDefinitionList"))
		{	*type = SOAP_TYPE_TT1__getCustomFieldsDefinitionList;
			return soap_in_TT1__getCustomFieldsDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getCustomFieldsDefinitionListResponse"))
		{	*type = SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse;
			return soap_in_TT1__getCustomFieldsDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectEventDefinitionList"))
		{	*type = SOAP_TYPE_TT1__getDefectEventDefinitionList;
			return soap_in_TT1__getDefectEventDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDefectEventDefinitionListResponse"))
		{	*type = SOAP_TYPE_TT1__getDefectEventDefinitionListResponse;
			return soap_in_TT1__getDefectEventDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getEventDefinitionList"))
		{	*type = SOAP_TYPE_TT1__getEventDefinitionList;
			return soap_in_TT1__getEventDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getEventDefinitionListResponse"))
		{	*type = SOAP_TYPE_TT1__getEventDefinitionListResponse;
			return soap_in_TT1__getEventDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getAttachmentTypes"))
		{	*type = SOAP_TYPE_TT1__getAttachmentTypes;
			return soap_in_TT1__getAttachmentTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getAttachmentTypesResponse"))
		{	*type = SOAP_TYPE_TT1__getAttachmentTypesResponse;
			return soap_in_TT1__getAttachmentTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestConfig"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestConfig;
			return soap_in_TT1__cancelSaveTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:cancelSaveTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__cancelSaveTestConfigResponse;
			return soap_in_TT1__cancelSaveTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestConfigByRecordID"))
		{	*type = SOAP_TYPE_TT1__deleteTestConfigByRecordID;
			return soap_in_TT1__deleteTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse;
			return soap_in_TT1__deleteTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestConfig"))
		{	*type = SOAP_TYPE_TT1__deleteTestConfig;
			return soap_in_TT1__deleteTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:deleteTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__deleteTestConfigResponse;
			return soap_in_TT1__deleteTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestConfig"))
		{	*type = SOAP_TYPE_TT1__saveTestConfig;
			return soap_in_TT1__saveTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:saveTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__saveTestConfigResponse;
			return soap_in_TT1__saveTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestConfigByRecordID"))
		{	*type = SOAP_TYPE_TT1__editTestConfigByRecordID;
			return soap_in_TT1__editTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__editTestConfigByRecordIDResponse;
			return soap_in_TT1__editTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestConfig"))
		{	*type = SOAP_TYPE_TT1__editTestConfig;
			return soap_in_TT1__editTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:editTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__editTestConfigResponse;
			return soap_in_TT1__editTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTestConfig"))
		{	*type = SOAP_TYPE_TT1__addTestConfig;
			return soap_in_TT1__addTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__addTestConfigResponse;
			return soap_in_TT1__addTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestConfigByRecordID"))
		{	*type = SOAP_TYPE_TT1__getTestConfigByRecordID;
			return soap_in_TT1__getTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_TT1__getTestConfigByRecordIDResponse;
			return soap_in_TT1__getTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestConfig"))
		{	*type = SOAP_TYPE_TT1__getTestConfig;
			return soap_in_TT1__getTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTestConfigResponse"))
		{	*type = SOAP_TYPE_TT1__getTestConfigResponse;
			return soap_in_TT1__getTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRecordListForTable"))
		{	*type = SOAP_TYPE_TT1__getRecordListForTable;
			return soap_in_TT1__getRecordListForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getRecordListForTableResponse"))
		{	*type = SOAP_TYPE_TT1__getRecordListForTableResponse;
			return soap_in_TT1__getRecordListForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFilterListForTable"))
		{	*type = SOAP_TYPE_TT1__getFilterListForTable;
			return soap_in_TT1__getFilterListForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFilterListForTableResponse"))
		{	*type = SOAP_TYPE_TT1__getFilterListForTableResponse;
			return soap_in_TT1__getFilterListForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFilterList"))
		{	*type = SOAP_TYPE_TT1__getFilterList;
			return soap_in_TT1__getFilterList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getFilterListResponse"))
		{	*type = SOAP_TYPE_TT1__getFilterListResponse;
			return soap_in_TT1__getFilterListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getColumnsForTable"))
		{	*type = SOAP_TYPE_TT1__getColumnsForTable;
			return soap_in_TT1__getColumnsForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getColumnsForTableResponse"))
		{	*type = SOAP_TYPE_TT1__getColumnsForTableResponse;
			return soap_in_TT1__getColumnsForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:GetLinkDefinitionValues"))
		{	*type = SOAP_TYPE_TT1__GetLinkDefinitionValues;
			return soap_in_TT1__GetLinkDefinitionValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:GetLinkDefinitionValuesResponse"))
		{	*type = SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse;
			return soap_in_TT1__GetLinkDefinitionValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDropdownFieldValuesForTable"))
		{	*type = SOAP_TYPE_TT1__addDropdownFieldValuesForTable;
			return soap_in_TT1__addDropdownFieldValuesForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:addDropdownFieldValuesForTableResponse"))
		{	*type = SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse;
			return soap_in_TT1__addDropdownFieldValuesForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDropdownFieldValuesForTable"))
		{	*type = SOAP_TYPE_TT1__getDropdownFieldValuesForTable;
			return soap_in_TT1__getDropdownFieldValuesForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDropdownFieldValuesForTableResponse"))
		{	*type = SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse;
			return soap_in_TT1__getDropdownFieldValuesForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDropdownFieldForTable"))
		{	*type = SOAP_TYPE_TT1__getDropdownFieldForTable;
			return soap_in_TT1__getDropdownFieldForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDropdownFieldForTableResponse"))
		{	*type = SOAP_TYPE_TT1__getDropdownFieldForTableResponse;
			return soap_in_TT1__getDropdownFieldForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTableList"))
		{	*type = SOAP_TYPE_TT1__getTableList;
			return soap_in_TT1__getTableList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getTableListResponse"))
		{	*type = SOAP_TYPE_TT1__getTableListResponse;
			return soap_in_TT1__getTableListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:DatabaseLogoff"))
		{	*type = SOAP_TYPE_TT1__DatabaseLogoff;
			return soap_in_TT1__DatabaseLogoff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:DatabaseLogoffResponse"))
		{	*type = SOAP_TYPE_TT1__DatabaseLogoffResponse;
			return soap_in_TT1__DatabaseLogoffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:ProjectLogon"))
		{	*type = SOAP_TYPE_TT1__ProjectLogon;
			return soap_in_TT1__ProjectLogon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:ProjectLogonResponse"))
		{	*type = SOAP_TYPE_TT1__ProjectLogonResponse;
			return soap_in_TT1__ProjectLogonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:DatabaseLogon"))
		{	*type = SOAP_TYPE_TT1__DatabaseLogon;
			return soap_in_TT1__DatabaseLogon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:DatabaseLogonResponse"))
		{	*type = SOAP_TYPE_TT1__DatabaseLogonResponse;
			return soap_in_TT1__DatabaseLogonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getProjectDataOptionList"))
		{	*type = SOAP_TYPE_TT1__getProjectDataOptionList;
			return soap_in_TT1__getProjectDataOptionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getProjectDataOptionListResponse"))
		{	*type = SOAP_TYPE_TT1__getProjectDataOptionListResponse;
			return soap_in_TT1__getProjectDataOptionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getProjectList"))
		{	*type = SOAP_TYPE_TT1__getProjectList;
			return soap_in_TT1__getProjectList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getProjectListResponse"))
		{	*type = SOAP_TYPE_TT1__getProjectListResponse;
			return soap_in_TT1__getProjectListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDatabaseList"))
		{	*type = SOAP_TYPE_TT1__getDatabaseList;
			return soap_in_TT1__getDatabaseList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TT1:getDatabaseListResponse"))
		{	*type = SOAP_TYPE_TT1__getDatabaseListResponse;
			return soap_in_TT1__getDatabaseListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_TT1ArrayOfCFolderItem:
		return ((TT1ArrayOfCFolderItem *)ptr)->soap_out(soap, tag, id, "TT1:CFolderItem");
	case SOAP_TYPE_TT1ArrayOfCFolder:
		return ((TT1ArrayOfCFolder *)ptr)->soap_out(soap, tag, id, "TT1:CFolder");
	case SOAP_TYPE_TT1__CFolderItem:
		return ((TT1__CFolderItem *)ptr)->soap_out(soap, tag, id, "TT1:CFolderItem");
	case SOAP_TYPE_TT1__CFolder:
		return ((TT1__CFolder *)ptr)->soap_out(soap, tag, id, "TT1:CFolder");
	case SOAP_TYPE_TT1ArrayOfCItemToTrack:
		return ((TT1ArrayOfCItemToTrack *)ptr)->soap_out(soap, tag, id, "TT1:CItemToTrack");
	case SOAP_TYPE_TT1__CTestRun:
		return ((TT1__CTestRun *)ptr)->soap_out(soap, tag, id, "TT1:CTestRun");
	case SOAP_TYPE_TT1__CTestCase:
		return ((TT1__CTestCase *)ptr)->soap_out(soap, tag, id, "TT1:CTestCase");
	case SOAP_TYPE_TT1ArrayOfCLink:
		return ((TT1ArrayOfCLink *)ptr)->soap_out(soap, tag, id, "TT1:CLink");
	case SOAP_TYPE_TT1__CLink:
		return ((TT1__CLink *)ptr)->soap_out(soap, tag, id, "TT1:CLink");
	case SOAP_TYPE_TT1ArrayOfCLinkHistoryItem:
		return ((TT1ArrayOfCLinkHistoryItem *)ptr)->soap_out(soap, tag, id, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_TT1__CLinkHistoryItem:
		return ((TT1__CLinkHistoryItem *)ptr)->soap_out(soap, tag, id, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_TT1ArrayOfCLinkedItem:
		return ((TT1ArrayOfCLinkedItem *)ptr)->soap_out(soap, tag, id, "TT1:CLinkedItem");
	case SOAP_TYPE_TT1__CLinkedItem:
		return ((TT1__CLinkedItem *)ptr)->soap_out(soap, tag, id, "TT1:CLinkedItem");
	case SOAP_TYPE_TT1ArrayOfCUserLicense:
		return ((TT1ArrayOfCUserLicense *)ptr)->soap_out(soap, tag, id, "TT1:CUserLicense");
	case SOAP_TYPE_TT1__CUserLicense:
		return ((TT1__CUserLicense *)ptr)->soap_out(soap, tag, id, "TT1:CUserLicense");
	case SOAP_TYPE_TT1ArrayOfCGlobalUser:
		return ((TT1ArrayOfCGlobalUser *)ptr)->soap_out(soap, tag, id, "TT1:CGlobalUser");
	case SOAP_TYPE_TT1__CGlobalUser:
		return ((TT1__CGlobalUser *)ptr)->soap_out(soap, tag, id, "TT1:CGlobalUser");
	case SOAP_TYPE_TT1__CUser:
		return ((TT1__CUser *)ptr)->soap_out(soap, tag, id, "TT1:CUser");
	case SOAP_TYPE_TT1__PhoneNumber:
		return ((TT1__PhoneNumber *)ptr)->soap_out(soap, tag, id, "TT1:PhoneNumber");
	case SOAP_TYPE_TT1__CTask:
		return ((TT1__CTask *)ptr)->soap_out(soap, tag, id, "TT1:CTask");
	case SOAP_TYPE_TT1__CDefect:
		return ((TT1__CDefect *)ptr)->soap_out(soap, tag, id, "TT1:CDefect");
	case SOAP_TYPE_TT1ArrayOfCDefectEventDefinition:
		return ((TT1ArrayOfCDefectEventDefinition *)ptr)->soap_out(soap, tag, id, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_TT1__CDefectEventDefinition:
		return ((TT1__CDefectEventDefinition *)ptr)->soap_out(soap, tag, id, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_TT1ArrayOfCEventDefinition:
		return ((TT1ArrayOfCEventDefinition *)ptr)->soap_out(soap, tag, id, "TT1:CEventDefinition");
	case SOAP_TYPE_TT1__CEventDefinition:
		return ((TT1__CEventDefinition *)ptr)->soap_out(soap, tag, id, "TT1:CEventDefinition");
	case SOAP_TYPE_TT1ArrayOfCDefectEvent:
		return ((TT1ArrayOfCDefectEvent *)ptr)->soap_out(soap, tag, id, "TT1:CDefectEvent");
	case SOAP_TYPE_TT1__CDefectEvent:
		return ((TT1__CDefectEvent *)ptr)->soap_out(soap, tag, id, "TT1:CDefectEvent");
	case SOAP_TYPE_TT1ArrayOfCEvent:
		return ((TT1ArrayOfCEvent *)ptr)->soap_out(soap, tag, id, "TT1:CEvent");
	case SOAP_TYPE_TT1__CEvent:
		return ((TT1__CEvent *)ptr)->soap_out(soap, tag, id, "TT1:CEvent");
	case SOAP_TYPE_TT1ArrayOfCTestCaseVariantField:
		return ((TT1ArrayOfCTestCaseVariantField *)ptr)->soap_out(soap, tag, id, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_TT1ArrayOfCTestRunVariantField:
		return ((TT1ArrayOfCTestRunVariantField *)ptr)->soap_out(soap, tag, id, "TT1:CTestRunVariantField");
	case SOAP_TYPE_TT1ArrayOfCField:
		return ((TT1ArrayOfCField *)ptr)->soap_out(soap, tag, id, "TT1:CField");
	case SOAP_TYPE_TT1__CVersionField:
		return ((TT1__CVersionField *)ptr)->soap_out(soap, tag, id, "TT1:CVersionField");
	case SOAP_TYPE_TT1__CTestCaseVariantField:
		return ((TT1__CTestCaseVariantField *)ptr)->soap_out(soap, tag, id, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_TT1__CTestRunVariantField:
		return ((TT1__CTestRunVariantField *)ptr)->soap_out(soap, tag, id, "TT1:CTestRunVariantField");
	case SOAP_TYPE_TT1__CMultiSelectDropdownField:
		return ((TT1__CMultiSelectDropdownField *)ptr)->soap_out(soap, tag, id, "TT1:CMultiSelectDropdownField");
	case SOAP_TYPE_TT1__CDropdownField:
		return ((TT1__CDropdownField *)ptr)->soap_out(soap, tag, id, "TT1:CDropdownField");
	case SOAP_TYPE_TT1__CDateTimeField:
		return ((TT1__CDateTimeField *)ptr)->soap_out(soap, tag, id, "TT1:CDateTimeField");
	case SOAP_TYPE_TT1__CDateField:
		return ((TT1__CDateField *)ptr)->soap_out(soap, tag, id, "TT1:CDateField");
	case SOAP_TYPE_TT1__CBooleanField:
		return ((TT1__CBooleanField *)ptr)->soap_out(soap, tag, id, "TT1:CBooleanField");
	case SOAP_TYPE_TT1__CDecimalField:
		return ((TT1__CDecimalField *)ptr)->soap_out(soap, tag, id, "TT1:CDecimalField");
	case SOAP_TYPE_TT1__CIntegerField:
		return ((TT1__CIntegerField *)ptr)->soap_out(soap, tag, id, "TT1:CIntegerField");
	case SOAP_TYPE_TT1__CStringField:
		return ((TT1__CStringField *)ptr)->soap_out(soap, tag, id, "TT1:CStringField");
	case SOAP_TYPE_TT1__CField:
		return ((TT1__CField *)ptr)->soap_out(soap, tag, id, "TT1:CField");
	case SOAP_TYPE_TT1ArrayOfCReportedByRecord:
		return ((TT1ArrayOfCReportedByRecord *)ptr)->soap_out(soap, tag, id, "TT1:CReportedByRecord");
	case SOAP_TYPE_TT1__CReportedByRecord:
		return ((TT1__CReportedByRecord *)ptr)->soap_out(soap, tag, id, "TT1:CReportedByRecord");
	case SOAP_TYPE_TT1ArrayOfCFileAttachment:
		return ((TT1ArrayOfCFileAttachment *)ptr)->soap_out(soap, tag, id, "TT1:CFileAttachment");
	case SOAP_TYPE_TT1__CFileAttachment:
		return ((TT1__CFileAttachment *)ptr)->soap_out(soap, tag, id, "TT1:CFileAttachment");
	case SOAP_TYPE_TT1ArrayOfCSCCFileRecord:
		return ((TT1ArrayOfCSCCFileRecord *)ptr)->soap_out(soap, tag, id, "TT1:CSCCFileRecord");
	case SOAP_TYPE_TT1__CSCCFileRecord:
		return ((TT1__CSCCFileRecord *)ptr)->soap_out(soap, tag, id, "TT1:CSCCFileRecord");
	case SOAP_TYPE_TT1__CSystem:
		return ((TT1__CSystem *)ptr)->soap_out(soap, tag, id, "TT1:CSystem");
	case SOAP_TYPE_TT1__CSystemBase:
		return ((TT1__CSystemBase *)ptr)->soap_out(soap, tag, id, "TT1:CSystemBase");
	case SOAP_TYPE_TT1__COrderedItemWithDBRecordId:
		return ((TT1__COrderedItemWithDBRecordId *)ptr)->soap_out(soap, tag, id, "TT1:COrderedItemWithDBRecordId");
	case SOAP_TYPE_TT1__CItemToTrack:
		return ((TT1__CItemToTrack *)ptr)->soap_out(soap, tag, id, "TT1:CItemToTrack");
	case SOAP_TYPE_TT1__CItemWithDBRecordId:
		return ((TT1__CItemWithDBRecordId *)ptr)->soap_out(soap, tag, id, "TT1:CItemWithDBRecordId");
	case SOAP_TYPE_TT1__CRecordListSoap:
		return ((TT1__CRecordListSoap *)ptr)->soap_out(soap, tag, id, "TT1:CRecordListSoap");
	case SOAP_TYPE_TT1ArrayOfCRecordRowSoap:
		return ((TT1ArrayOfCRecordRowSoap *)ptr)->soap_out(soap, tag, id, "TT1:CRecordRowSoap");
	case SOAP_TYPE_TT1__CRecordRowSoap:
		return ((TT1__CRecordRowSoap *)ptr)->soap_out(soap, tag, id, "TT1:CRecordRowSoap");
	case SOAP_TYPE_TT1ArrayOfCRecordData:
		return ((TT1ArrayOfCRecordData *)ptr)->soap_out(soap, tag, id, "TT1:CRecordData");
	case SOAP_TYPE_TT1__CRecordData:
		return ((TT1__CRecordData *)ptr)->soap_out(soap, tag, id, "TT1:CRecordData");
	case SOAP_TYPE_TT1ArrayOfCFilter:
		return ((TT1ArrayOfCFilter *)ptr)->soap_out(soap, tag, id, "TT1:CFilter");
	case SOAP_TYPE_TT1__CFilter:
		return ((TT1__CFilter *)ptr)->soap_out(soap, tag, id, "TT1:CFilter");
	case SOAP_TYPE_TT1ArrayOfCTableColumn:
		return ((TT1ArrayOfCTableColumn *)ptr)->soap_out(soap, tag, id, "TT1:CTableColumn");
	case SOAP_TYPE_TT1__CTableColumn:
		return ((TT1__CTableColumn *)ptr)->soap_out(soap, tag, id, "TT1:CTableColumn");
	case SOAP_TYPE_TT1ArrayOfCFieldValue:
		return ((TT1ArrayOfCFieldValue *)ptr)->soap_out(soap, tag, id, "TT1:CFieldValue");
	case SOAP_TYPE_TT1__CFieldValue:
		return ((TT1__CFieldValue *)ptr)->soap_out(soap, tag, id, "TT1:CFieldValue");
	case SOAP_TYPE_TT1ArrayOfCTableField:
		return ((TT1ArrayOfCTableField *)ptr)->soap_out(soap, tag, id, "TT1:CTableField");
	case SOAP_TYPE_TT1__CTableField:
		return ((TT1__CTableField *)ptr)->soap_out(soap, tag, id, "TT1:CTableField");
	case SOAP_TYPE_TT1ArrayOfCDatabaseTable:
		return ((TT1ArrayOfCDatabaseTable *)ptr)->soap_out(soap, tag, id, "TT1:CDatabaseTable");
	case SOAP_TYPE_TT1__CDatabaseTable:
		return ((TT1__CDatabaseTable *)ptr)->soap_out(soap, tag, id, "TT1:CDatabaseTable");
	case SOAP_TYPE_TT1ArrayOfCProject:
		return ((TT1ArrayOfCProject *)ptr)->soap_out(soap, tag, id, "TT1:CProject");
	case SOAP_TYPE_TT1__CProject:
		return ((TT1__CProject *)ptr)->soap_out(soap, tag, id, "TT1:CProject");
	case SOAP_TYPE_TT1ArrayOfCProjectDataOption:
		return ((TT1ArrayOfCProjectDataOption *)ptr)->soap_out(soap, tag, id, "TT1:CProjectDataOption");
	case SOAP_TYPE_TT1__CProjectDataOption:
		return ((TT1__CProjectDataOption *)ptr)->soap_out(soap, tag, id, "TT1:CProjectDataOption");
	case SOAP_TYPE_TT1ArrayOfCDatabase:
		return ((TT1ArrayOfCDatabase *)ptr)->soap_out(soap, tag, id, "TT1:CDatabase");
	case SOAP_TYPE_TT1__CDatabase:
		return ((TT1__CDatabase *)ptr)->soap_out(soap, tag, id, "TT1:CDatabase");
	case SOAP_TYPE_TT1ArrayOfstring:
		return ((TT1ArrayOfstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_TT1__getRootPrivateFolderPath:
		return soap_out_TT1__getRootPrivateFolderPath(soap, tag, id, (const struct TT1__getRootPrivateFolderPath *)ptr, "TT1:getRootPrivateFolderPath");
	case SOAP_TYPE_TT1__getRootPrivateFolderPathResponse:
		return soap_out_TT1__getRootPrivateFolderPathResponse(soap, tag, id, (const struct TT1__getRootPrivateFolderPathResponse *)ptr, "TT1:getRootPrivateFolderPathResponse");
	case SOAP_TYPE_TT1__getRootPublicFolderPath:
		return soap_out_TT1__getRootPublicFolderPath(soap, tag, id, (const struct TT1__getRootPublicFolderPath *)ptr, "TT1:getRootPublicFolderPath");
	case SOAP_TYPE_TT1__getRootPublicFolderPathResponse:
		return soap_out_TT1__getRootPublicFolderPathResponse(soap, tag, id, (const struct TT1__getRootPublicFolderPathResponse *)ptr, "TT1:getRootPublicFolderPathResponse");
	case SOAP_TYPE_TT1__getFolderPathSeparator:
		return soap_out_TT1__getFolderPathSeparator(soap, tag, id, (const struct TT1__getFolderPathSeparator *)ptr, "TT1:getFolderPathSeparator");
	case SOAP_TYPE_TT1__getFolderPathSeparatorResponse:
		return soap_out_TT1__getFolderPathSeparatorResponse(soap, tag, id, (const struct TT1__getFolderPathSeparatorResponse *)ptr, "TT1:getFolderPathSeparatorResponse");
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordID:
		return soap_out_TT1__getEntityListForFolderByRecordID(soap, tag, id, (const struct TT1__getEntityListForFolderByRecordID *)ptr, "TT1:getEntityListForFolderByRecordID");
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse:
		return soap_out_TT1__getEntityListForFolderByRecordIDResponse(soap, tag, id, (const struct TT1__getEntityListForFolderByRecordIDResponse *)ptr, "TT1:getEntityListForFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordID:
		return soap_out_TT1__removeEntityFromFolderByRecordID(soap, tag, id, (const struct TT1__removeEntityFromFolderByRecordID *)ptr, "TT1:removeEntityFromFolderByRecordID");
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse:
		return soap_out_TT1__removeEntityFromFolderByRecordIDResponse(soap, tag, id, (const struct TT1__removeEntityFromFolderByRecordIDResponse *)ptr, "TT1:removeEntityFromFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__addEntityToFolderByRecordID:
		return soap_out_TT1__addEntityToFolderByRecordID(soap, tag, id, (const struct TT1__addEntityToFolderByRecordID *)ptr, "TT1:addEntityToFolderByRecordID");
	case SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse:
		return soap_out_TT1__addEntityToFolderByRecordIDResponse(soap, tag, id, (const struct TT1__addEntityToFolderByRecordIDResponse *)ptr, "TT1:addEntityToFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteFolderByRecordID:
		return soap_out_TT1__deleteFolderByRecordID(soap, tag, id, (const struct TT1__deleteFolderByRecordID *)ptr, "TT1:deleteFolderByRecordID");
	case SOAP_TYPE_TT1__deleteFolderByRecordIDResponse:
		return soap_out_TT1__deleteFolderByRecordIDResponse(soap, tag, id, (const struct TT1__deleteFolderByRecordIDResponse *)ptr, "TT1:deleteFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteFolder:
		return soap_out_TT1__deleteFolder(soap, tag, id, (const struct TT1__deleteFolder *)ptr, "TT1:deleteFolder");
	case SOAP_TYPE_TT1__deleteFolderResponse:
		return soap_out_TT1__deleteFolderResponse(soap, tag, id, (const struct TT1__deleteFolderResponse *)ptr, "TT1:deleteFolderResponse");
	case SOAP_TYPE_TT1__getFolderByRecordID:
		return soap_out_TT1__getFolderByRecordID(soap, tag, id, (const struct TT1__getFolderByRecordID *)ptr, "TT1:getFolderByRecordID");
	case SOAP_TYPE_TT1__getFolderByRecordIDResponse:
		return soap_out_TT1__getFolderByRecordIDResponse(soap, tag, id, (const struct TT1__getFolderByRecordIDResponse *)ptr, "TT1:getFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__getFolder:
		return soap_out_TT1__getFolder(soap, tag, id, (const struct TT1__getFolder *)ptr, "TT1:getFolder");
	case SOAP_TYPE_TT1__getFolderResponse:
		return soap_out_TT1__getFolderResponse(soap, tag, id, (const struct TT1__getFolderResponse *)ptr, "TT1:getFolderResponse");
	case SOAP_TYPE_TT1__cancelSaveFolder:
		return soap_out_TT1__cancelSaveFolder(soap, tag, id, (const struct TT1__cancelSaveFolder *)ptr, "TT1:cancelSaveFolder");
	case SOAP_TYPE_TT1__cancelSaveFolderResponse:
		return soap_out_TT1__cancelSaveFolderResponse(soap, tag, id, (const struct TT1__cancelSaveFolderResponse *)ptr, "TT1:cancelSaveFolderResponse");
	case SOAP_TYPE_TT1__saveFolder:
		return soap_out_TT1__saveFolder(soap, tag, id, (const struct TT1__saveFolder *)ptr, "TT1:saveFolder");
	case SOAP_TYPE_TT1__saveFolderResponse:
		return soap_out_TT1__saveFolderResponse(soap, tag, id, (const struct TT1__saveFolderResponse *)ptr, "TT1:saveFolderResponse");
	case SOAP_TYPE_TT1__editFolderByRecordID:
		return soap_out_TT1__editFolderByRecordID(soap, tag, id, (const struct TT1__editFolderByRecordID *)ptr, "TT1:editFolderByRecordID");
	case SOAP_TYPE_TT1__editFolderByRecordIDResponse:
		return soap_out_TT1__editFolderByRecordIDResponse(soap, tag, id, (const struct TT1__editFolderByRecordIDResponse *)ptr, "TT1:editFolderByRecordIDResponse");
	case SOAP_TYPE_TT1__editFolder:
		return soap_out_TT1__editFolder(soap, tag, id, (const struct TT1__editFolder *)ptr, "TT1:editFolder");
	case SOAP_TYPE_TT1__editFolderResponse:
		return soap_out_TT1__editFolderResponse(soap, tag, id, (const struct TT1__editFolderResponse *)ptr, "TT1:editFolderResponse");
	case SOAP_TYPE_TT1__addFolder:
		return soap_out_TT1__addFolder(soap, tag, id, (const struct TT1__addFolder *)ptr, "TT1:addFolder");
	case SOAP_TYPE_TT1__addFolderResponse:
		return soap_out_TT1__addFolderResponse(soap, tag, id, (const struct TT1__addFolderResponse *)ptr, "TT1:addFolderResponse");
	case SOAP_TYPE_TT1__generateTestRuns:
		return soap_out_TT1__generateTestRuns(soap, tag, id, (const struct TT1__generateTestRuns *)ptr, "TT1:generateTestRuns");
	case SOAP_TYPE_TT1__generateTestRunsResponse:
		return soap_out_TT1__generateTestRunsResponse(soap, tag, id, (const struct TT1__generateTestRunsResponse *)ptr, "TT1:generateTestRunsResponse");
	case SOAP_TYPE_TT1__createDefectForTestRun:
		return soap_out_TT1__createDefectForTestRun(soap, tag, id, (const struct TT1__createDefectForTestRun *)ptr, "TT1:createDefectForTestRun");
	case SOAP_TYPE_TT1__createDefectForTestRunResponse:
		return soap_out_TT1__createDefectForTestRunResponse(soap, tag, id, (const struct TT1__createDefectForTestRunResponse *)ptr, "TT1:createDefectForTestRunResponse");
	case SOAP_TYPE_TT1__cancelSaveTestRun:
		return soap_out_TT1__cancelSaveTestRun(soap, tag, id, (const struct TT1__cancelSaveTestRun *)ptr, "TT1:cancelSaveTestRun");
	case SOAP_TYPE_TT1__cancelSaveTestRunResponse:
		return soap_out_TT1__cancelSaveTestRunResponse(soap, tag, id, (const struct TT1__cancelSaveTestRunResponse *)ptr, "TT1:cancelSaveTestRunResponse");
	case SOAP_TYPE_TT1__saveTestRun:
		return soap_out_TT1__saveTestRun(soap, tag, id, (const struct TT1__saveTestRun *)ptr, "TT1:saveTestRun");
	case SOAP_TYPE_TT1__saveTestRunResponse:
		return soap_out_TT1__saveTestRunResponse(soap, tag, id, (const struct TT1__saveTestRunResponse *)ptr, "TT1:saveTestRunResponse");
	case SOAP_TYPE_TT1__editTestRunByRecordID:
		return soap_out_TT1__editTestRunByRecordID(soap, tag, id, (const struct TT1__editTestRunByRecordID *)ptr, "TT1:editTestRunByRecordID");
	case SOAP_TYPE_TT1__editTestRunByRecordIDResponse:
		return soap_out_TT1__editTestRunByRecordIDResponse(soap, tag, id, (const struct TT1__editTestRunByRecordIDResponse *)ptr, "TT1:editTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestRun:
		return soap_out_TT1__editTestRun(soap, tag, id, (const struct TT1__editTestRun *)ptr, "TT1:editTestRun");
	case SOAP_TYPE_TT1__editTestRunResponse:
		return soap_out_TT1__editTestRunResponse(soap, tag, id, (const struct TT1__editTestRunResponse *)ptr, "TT1:editTestRunResponse");
	case SOAP_TYPE_TT1__deleteTestRunByRecordID:
		return soap_out_TT1__deleteTestRunByRecordID(soap, tag, id, (const struct TT1__deleteTestRunByRecordID *)ptr, "TT1:deleteTestRunByRecordID");
	case SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse:
		return soap_out_TT1__deleteTestRunByRecordIDResponse(soap, tag, id, (const struct TT1__deleteTestRunByRecordIDResponse *)ptr, "TT1:deleteTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestRun:
		return soap_out_TT1__deleteTestRun(soap, tag, id, (const struct TT1__deleteTestRun *)ptr, "TT1:deleteTestRun");
	case SOAP_TYPE_TT1__deleteTestRunResponse:
		return soap_out_TT1__deleteTestRunResponse(soap, tag, id, (const struct TT1__deleteTestRunResponse *)ptr, "TT1:deleteTestRunResponse");
	case SOAP_TYPE_TT1__getTestRunByRecordID:
		return soap_out_TT1__getTestRunByRecordID(soap, tag, id, (const struct TT1__getTestRunByRecordID *)ptr, "TT1:getTestRunByRecordID");
	case SOAP_TYPE_TT1__getTestRunByRecordIDResponse:
		return soap_out_TT1__getTestRunByRecordIDResponse(soap, tag, id, (const struct TT1__getTestRunByRecordIDResponse *)ptr, "TT1:getTestRunByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestRun:
		return soap_out_TT1__getTestRun(soap, tag, id, (const struct TT1__getTestRun *)ptr, "TT1:getTestRun");
	case SOAP_TYPE_TT1__getTestRunResponse:
		return soap_out_TT1__getTestRunResponse(soap, tag, id, (const struct TT1__getTestRunResponse *)ptr, "TT1:getTestRunResponse");
	case SOAP_TYPE_TT1__cancelSaveTestCase:
		return soap_out_TT1__cancelSaveTestCase(soap, tag, id, (const struct TT1__cancelSaveTestCase *)ptr, "TT1:cancelSaveTestCase");
	case SOAP_TYPE_TT1__cancelSaveTestCaseResponse:
		return soap_out_TT1__cancelSaveTestCaseResponse(soap, tag, id, (const struct TT1__cancelSaveTestCaseResponse *)ptr, "TT1:cancelSaveTestCaseResponse");
	case SOAP_TYPE_TT1__saveTestCase:
		return soap_out_TT1__saveTestCase(soap, tag, id, (const struct TT1__saveTestCase *)ptr, "TT1:saveTestCase");
	case SOAP_TYPE_TT1__saveTestCaseResponse:
		return soap_out_TT1__saveTestCaseResponse(soap, tag, id, (const struct TT1__saveTestCaseResponse *)ptr, "TT1:saveTestCaseResponse");
	case SOAP_TYPE_TT1__editTestCaseByRecordID:
		return soap_out_TT1__editTestCaseByRecordID(soap, tag, id, (const struct TT1__editTestCaseByRecordID *)ptr, "TT1:editTestCaseByRecordID");
	case SOAP_TYPE_TT1__editTestCaseByRecordIDResponse:
		return soap_out_TT1__editTestCaseByRecordIDResponse(soap, tag, id, (const struct TT1__editTestCaseByRecordIDResponse *)ptr, "TT1:editTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestCase:
		return soap_out_TT1__editTestCase(soap, tag, id, (const struct TT1__editTestCase *)ptr, "TT1:editTestCase");
	case SOAP_TYPE_TT1__editTestCaseResponse:
		return soap_out_TT1__editTestCaseResponse(soap, tag, id, (const struct TT1__editTestCaseResponse *)ptr, "TT1:editTestCaseResponse");
	case SOAP_TYPE_TT1__deleteTestCaseByRecordID:
		return soap_out_TT1__deleteTestCaseByRecordID(soap, tag, id, (const struct TT1__deleteTestCaseByRecordID *)ptr, "TT1:deleteTestCaseByRecordID");
	case SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse:
		return soap_out_TT1__deleteTestCaseByRecordIDResponse(soap, tag, id, (const struct TT1__deleteTestCaseByRecordIDResponse *)ptr, "TT1:deleteTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestCase:
		return soap_out_TT1__deleteTestCase(soap, tag, id, (const struct TT1__deleteTestCase *)ptr, "TT1:deleteTestCase");
	case SOAP_TYPE_TT1__deleteTestCaseResponse:
		return soap_out_TT1__deleteTestCaseResponse(soap, tag, id, (const struct TT1__deleteTestCaseResponse *)ptr, "TT1:deleteTestCaseResponse");
	case SOAP_TYPE_TT1__addTestCase:
		return soap_out_TT1__addTestCase(soap, tag, id, (const struct TT1__addTestCase *)ptr, "TT1:addTestCase");
	case SOAP_TYPE_TT1__addTestCaseResponse:
		return soap_out_TT1__addTestCaseResponse(soap, tag, id, (const struct TT1__addTestCaseResponse *)ptr, "TT1:addTestCaseResponse");
	case SOAP_TYPE_TT1__getTestCaseByRecordID:
		return soap_out_TT1__getTestCaseByRecordID(soap, tag, id, (const struct TT1__getTestCaseByRecordID *)ptr, "TT1:getTestCaseByRecordID");
	case SOAP_TYPE_TT1__getTestCaseByRecordIDResponse:
		return soap_out_TT1__getTestCaseByRecordIDResponse(soap, tag, id, (const struct TT1__getTestCaseByRecordIDResponse *)ptr, "TT1:getTestCaseByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestCase:
		return soap_out_TT1__getTestCase(soap, tag, id, (const struct TT1__getTestCase *)ptr, "TT1:getTestCase");
	case SOAP_TYPE_TT1__getTestCaseResponse:
		return soap_out_TT1__getTestCaseResponse(soap, tag, id, (const struct TT1__getTestCaseResponse *)ptr, "TT1:getTestCaseResponse");
	case SOAP_TYPE_TT1__getTestRunStepsModes:
		return soap_out_TT1__getTestRunStepsModes(soap, tag, id, (const struct TT1__getTestRunStepsModes *)ptr, "TT1:getTestRunStepsModes");
	case SOAP_TYPE_TT1__getTestRunStepsModesResponse:
		return soap_out_TT1__getTestRunStepsModesResponse(soap, tag, id, (const struct TT1__getTestRunStepsModesResponse *)ptr, "TT1:getTestRunStepsModesResponse");
	case SOAP_TYPE_TT1__getTestVariantTypes:
		return soap_out_TT1__getTestVariantTypes(soap, tag, id, (const struct TT1__getTestVariantTypes *)ptr, "TT1:getTestVariantTypes");
	case SOAP_TYPE_TT1__getTestVariantTypesResponse:
		return soap_out_TT1__getTestVariantTypesResponse(soap, tag, id, (const struct TT1__getTestVariantTypesResponse *)ptr, "TT1:getTestVariantTypesResponse");
	case SOAP_TYPE_TT1__cancelSaveLink:
		return soap_out_TT1__cancelSaveLink(soap, tag, id, (const struct TT1__cancelSaveLink *)ptr, "TT1:cancelSaveLink");
	case SOAP_TYPE_TT1__cancelSaveLinkResponse:
		return soap_out_TT1__cancelSaveLinkResponse(soap, tag, id, (const struct TT1__cancelSaveLinkResponse *)ptr, "TT1:cancelSaveLinkResponse");
	case SOAP_TYPE_TT1__saveLink:
		return soap_out_TT1__saveLink(soap, tag, id, (const struct TT1__saveLink *)ptr, "TT1:saveLink");
	case SOAP_TYPE_TT1__saveLinkResponse:
		return soap_out_TT1__saveLinkResponse(soap, tag, id, (const struct TT1__saveLinkResponse *)ptr, "TT1:saveLinkResponse");
	case SOAP_TYPE_TT1__editLink:
		return soap_out_TT1__editLink(soap, tag, id, (const struct TT1__editLink *)ptr, "TT1:editLink");
	case SOAP_TYPE_TT1__editLinkResponse:
		return soap_out_TT1__editLinkResponse(soap, tag, id, (const struct TT1__editLinkResponse *)ptr, "TT1:editLinkResponse");
	case SOAP_TYPE_TT1__deleteLink:
		return soap_out_TT1__deleteLink(soap, tag, id, (const struct TT1__deleteLink *)ptr, "TT1:deleteLink");
	case SOAP_TYPE_TT1__deleteLinkResponse:
		return soap_out_TT1__deleteLinkResponse(soap, tag, id, (const struct TT1__deleteLinkResponse *)ptr, "TT1:deleteLinkResponse");
	case SOAP_TYPE_TT1__addLink:
		return soap_out_TT1__addLink(soap, tag, id, (const struct TT1__addLink *)ptr, "TT1:addLink");
	case SOAP_TYPE_TT1__addLinkResponse:
		return soap_out_TT1__addLinkResponse(soap, tag, id, (const struct TT1__addLinkResponse *)ptr, "TT1:addLinkResponse");
	case SOAP_TYPE_TT1__getLink:
		return soap_out_TT1__getLink(soap, tag, id, (const struct TT1__getLink *)ptr, "TT1:getLink");
	case SOAP_TYPE_TT1__getLinkResponse:
		return soap_out_TT1__getLinkResponse(soap, tag, id, (const struct TT1__getLinkResponse *)ptr, "TT1:getLinkResponse");
	case SOAP_TYPE_TT1__getLinksForDefect:
		return soap_out_TT1__getLinksForDefect(soap, tag, id, (const struct TT1__getLinksForDefect *)ptr, "TT1:getLinksForDefect");
	case SOAP_TYPE_TT1__getLinksForDefectResponse:
		return soap_out_TT1__getLinksForDefectResponse(soap, tag, id, (const struct TT1__getLinksForDefectResponse *)ptr, "TT1:getLinksForDefectResponse");
	case SOAP_TYPE_TT1__getLinksForItem:
		return soap_out_TT1__getLinksForItem(soap, tag, id, (const struct TT1__getLinksForItem *)ptr, "TT1:getLinksForItem");
	case SOAP_TYPE_TT1__getLinksForItemResponse:
		return soap_out_TT1__getLinksForItemResponse(soap, tag, id, (const struct TT1__getLinksForItemResponse *)ptr, "TT1:getLinksForItemResponse");
	case SOAP_TYPE_TT1__addGlobalCustomer:
		return soap_out_TT1__addGlobalCustomer(soap, tag, id, (const struct TT1__addGlobalCustomer *)ptr, "TT1:addGlobalCustomer");
	case SOAP_TYPE_TT1__addGlobalCustomerResponse:
		return soap_out_TT1__addGlobalCustomerResponse(soap, tag, id, (const struct TT1__addGlobalCustomerResponse *)ptr, "TT1:addGlobalCustomerResponse");
	case SOAP_TYPE_TT1__promoteCustomer:
		return soap_out_TT1__promoteCustomer(soap, tag, id, (const struct TT1__promoteCustomer *)ptr, "TT1:promoteCustomer");
	case SOAP_TYPE_TT1__promoteCustomerResponse:
		return soap_out_TT1__promoteCustomerResponse(soap, tag, id, (const struct TT1__promoteCustomerResponse *)ptr, "TT1:promoteCustomerResponse");
	case SOAP_TYPE_TT1__cancelSaveCustomer:
		return soap_out_TT1__cancelSaveCustomer(soap, tag, id, (const struct TT1__cancelSaveCustomer *)ptr, "TT1:cancelSaveCustomer");
	case SOAP_TYPE_TT1__cancelSaveCustomerResponse:
		return soap_out_TT1__cancelSaveCustomerResponse(soap, tag, id, (const struct TT1__cancelSaveCustomerResponse *)ptr, "TT1:cancelSaveCustomerResponse");
	case SOAP_TYPE_TT1__deleteCustomerByRecordID:
		return soap_out_TT1__deleteCustomerByRecordID(soap, tag, id, (const struct TT1__deleteCustomerByRecordID *)ptr, "TT1:deleteCustomerByRecordID");
	case SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse:
		return soap_out_TT1__deleteCustomerByRecordIDResponse(soap, tag, id, (const struct TT1__deleteCustomerByRecordIDResponse *)ptr, "TT1:deleteCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteCustomer:
		return soap_out_TT1__deleteCustomer(soap, tag, id, (const struct TT1__deleteCustomer *)ptr, "TT1:deleteCustomer");
	case SOAP_TYPE_TT1__deleteCustomerResponse:
		return soap_out_TT1__deleteCustomerResponse(soap, tag, id, (const struct TT1__deleteCustomerResponse *)ptr, "TT1:deleteCustomerResponse");
	case SOAP_TYPE_TT1__saveCustomer:
		return soap_out_TT1__saveCustomer(soap, tag, id, (const struct TT1__saveCustomer *)ptr, "TT1:saveCustomer");
	case SOAP_TYPE_TT1__saveCustomerResponse:
		return soap_out_TT1__saveCustomerResponse(soap, tag, id, (const struct TT1__saveCustomerResponse *)ptr, "TT1:saveCustomerResponse");
	case SOAP_TYPE_TT1__editCustomerByRecordID:
		return soap_out_TT1__editCustomerByRecordID(soap, tag, id, (const struct TT1__editCustomerByRecordID *)ptr, "TT1:editCustomerByRecordID");
	case SOAP_TYPE_TT1__editCustomerByRecordIDResponse:
		return soap_out_TT1__editCustomerByRecordIDResponse(soap, tag, id, (const struct TT1__editCustomerByRecordIDResponse *)ptr, "TT1:editCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__editCustomer:
		return soap_out_TT1__editCustomer(soap, tag, id, (const struct TT1__editCustomer *)ptr, "TT1:editCustomer");
	case SOAP_TYPE_TT1__editCustomerResponse:
		return soap_out_TT1__editCustomerResponse(soap, tag, id, (const struct TT1__editCustomerResponse *)ptr, "TT1:editCustomerResponse");
	case SOAP_TYPE_TT1__addCustomer:
		return soap_out_TT1__addCustomer(soap, tag, id, (const struct TT1__addCustomer *)ptr, "TT1:addCustomer");
	case SOAP_TYPE_TT1__addCustomerResponse:
		return soap_out_TT1__addCustomerResponse(soap, tag, id, (const struct TT1__addCustomerResponse *)ptr, "TT1:addCustomerResponse");
	case SOAP_TYPE_TT1__getCustomerByRecordID:
		return soap_out_TT1__getCustomerByRecordID(soap, tag, id, (const struct TT1__getCustomerByRecordID *)ptr, "TT1:getCustomerByRecordID");
	case SOAP_TYPE_TT1__getCustomerByRecordIDResponse:
		return soap_out_TT1__getCustomerByRecordIDResponse(soap, tag, id, (const struct TT1__getCustomerByRecordIDResponse *)ptr, "TT1:getCustomerByRecordIDResponse");
	case SOAP_TYPE_TT1__getCustomer:
		return soap_out_TT1__getCustomer(soap, tag, id, (const struct TT1__getCustomer *)ptr, "TT1:getCustomer");
	case SOAP_TYPE_TT1__getCustomerResponse:
		return soap_out_TT1__getCustomerResponse(soap, tag, id, (const struct TT1__getCustomerResponse *)ptr, "TT1:getCustomerResponse");
	case SOAP_TYPE_TT1__addGlobalUser:
		return soap_out_TT1__addGlobalUser(soap, tag, id, (const struct TT1__addGlobalUser *)ptr, "TT1:addGlobalUser");
	case SOAP_TYPE_TT1__addGlobalUserResponse:
		return soap_out_TT1__addGlobalUserResponse(soap, tag, id, (const struct TT1__addGlobalUserResponse *)ptr, "TT1:addGlobalUserResponse");
	case SOAP_TYPE_TT1__promoteUser:
		return soap_out_TT1__promoteUser(soap, tag, id, (const struct TT1__promoteUser *)ptr, "TT1:promoteUser");
	case SOAP_TYPE_TT1__promoteUserResponse:
		return soap_out_TT1__promoteUserResponse(soap, tag, id, (const struct TT1__promoteUserResponse *)ptr, "TT1:promoteUserResponse");
	case SOAP_TYPE_TT1__cancelSaveUser:
		return soap_out_TT1__cancelSaveUser(soap, tag, id, (const struct TT1__cancelSaveUser *)ptr, "TT1:cancelSaveUser");
	case SOAP_TYPE_TT1__cancelSaveUserResponse:
		return soap_out_TT1__cancelSaveUserResponse(soap, tag, id, (const struct TT1__cancelSaveUserResponse *)ptr, "TT1:cancelSaveUserResponse");
	case SOAP_TYPE_TT1__deleteUserByRecordID:
		return soap_out_TT1__deleteUserByRecordID(soap, tag, id, (const struct TT1__deleteUserByRecordID *)ptr, "TT1:deleteUserByRecordID");
	case SOAP_TYPE_TT1__deleteUserByRecordIDResponse:
		return soap_out_TT1__deleteUserByRecordIDResponse(soap, tag, id, (const struct TT1__deleteUserByRecordIDResponse *)ptr, "TT1:deleteUserByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteUser:
		return soap_out_TT1__deleteUser(soap, tag, id, (const struct TT1__deleteUser *)ptr, "TT1:deleteUser");
	case SOAP_TYPE_TT1__deleteUserResponse:
		return soap_out_TT1__deleteUserResponse(soap, tag, id, (const struct TT1__deleteUserResponse *)ptr, "TT1:deleteUserResponse");
	case SOAP_TYPE_TT1__saveUser:
		return soap_out_TT1__saveUser(soap, tag, id, (const struct TT1__saveUser *)ptr, "TT1:saveUser");
	case SOAP_TYPE_TT1__saveUserResponse:
		return soap_out_TT1__saveUserResponse(soap, tag, id, (const struct TT1__saveUserResponse *)ptr, "TT1:saveUserResponse");
	case SOAP_TYPE_TT1__editUserByRecordID:
		return soap_out_TT1__editUserByRecordID(soap, tag, id, (const struct TT1__editUserByRecordID *)ptr, "TT1:editUserByRecordID");
	case SOAP_TYPE_TT1__editUserByRecordIDResponse:
		return soap_out_TT1__editUserByRecordIDResponse(soap, tag, id, (const struct TT1__editUserByRecordIDResponse *)ptr, "TT1:editUserByRecordIDResponse");
	case SOAP_TYPE_TT1__editUser:
		return soap_out_TT1__editUser(soap, tag, id, (const struct TT1__editUser *)ptr, "TT1:editUser");
	case SOAP_TYPE_TT1__editUserResponse:
		return soap_out_TT1__editUserResponse(soap, tag, id, (const struct TT1__editUserResponse *)ptr, "TT1:editUserResponse");
	case SOAP_TYPE_TT1__addUser:
		return soap_out_TT1__addUser(soap, tag, id, (const struct TT1__addUser *)ptr, "TT1:addUser");
	case SOAP_TYPE_TT1__addUserResponse:
		return soap_out_TT1__addUserResponse(soap, tag, id, (const struct TT1__addUserResponse *)ptr, "TT1:addUserResponse");
	case SOAP_TYPE_TT1__getUserByRecordID:
		return soap_out_TT1__getUserByRecordID(soap, tag, id, (const struct TT1__getUserByRecordID *)ptr, "TT1:getUserByRecordID");
	case SOAP_TYPE_TT1__getUserByRecordIDResponse:
		return soap_out_TT1__getUserByRecordIDResponse(soap, tag, id, (const struct TT1__getUserByRecordIDResponse *)ptr, "TT1:getUserByRecordIDResponse");
	case SOAP_TYPE_TT1__getUser:
		return soap_out_TT1__getUser(soap, tag, id, (const struct TT1__getUser *)ptr, "TT1:getUser");
	case SOAP_TYPE_TT1__getUserResponse:
		return soap_out_TT1__getUserResponse(soap, tag, id, (const struct TT1__getUserResponse *)ptr, "TT1:getUserResponse");
	case SOAP_TYPE_TT1__getUserLicenseList:
		return soap_out_TT1__getUserLicenseList(soap, tag, id, (const struct TT1__getUserLicenseList *)ptr, "TT1:getUserLicenseList");
	case SOAP_TYPE_TT1__getUserLicenseListResponse:
		return soap_out_TT1__getUserLicenseListResponse(soap, tag, id, (const struct TT1__getUserLicenseListResponse *)ptr, "TT1:getUserLicenseListResponse");
	case SOAP_TYPE_TT1__getGlobalCustomerList:
		return soap_out_TT1__getGlobalCustomerList(soap, tag, id, (const struct TT1__getGlobalCustomerList *)ptr, "TT1:getGlobalCustomerList");
	case SOAP_TYPE_TT1__getGlobalCustomerListResponse:
		return soap_out_TT1__getGlobalCustomerListResponse(soap, tag, id, (const struct TT1__getGlobalCustomerListResponse *)ptr, "TT1:getGlobalCustomerListResponse");
	case SOAP_TYPE_TT1__getGlobalUserList:
		return soap_out_TT1__getGlobalUserList(soap, tag, id, (const struct TT1__getGlobalUserList *)ptr, "TT1:getGlobalUserList");
	case SOAP_TYPE_TT1__getGlobalUserListResponse:
		return soap_out_TT1__getGlobalUserListResponse(soap, tag, id, (const struct TT1__getGlobalUserListResponse *)ptr, "TT1:getGlobalUserListResponse");
	case SOAP_TYPE_TT1__cancelSaveTask:
		return soap_out_TT1__cancelSaveTask(soap, tag, id, (const struct TT1__cancelSaveTask *)ptr, "TT1:cancelSaveTask");
	case SOAP_TYPE_TT1__cancelSaveTaskResponse:
		return soap_out_TT1__cancelSaveTaskResponse(soap, tag, id, (const struct TT1__cancelSaveTaskResponse *)ptr, "TT1:cancelSaveTaskResponse");
	case SOAP_TYPE_TT1__saveTask:
		return soap_out_TT1__saveTask(soap, tag, id, (const struct TT1__saveTask *)ptr, "TT1:saveTask");
	case SOAP_TYPE_TT1__saveTaskResponse:
		return soap_out_TT1__saveTaskResponse(soap, tag, id, (const struct TT1__saveTaskResponse *)ptr, "TT1:saveTaskResponse");
	case SOAP_TYPE_TT1__editTaskByRecordID:
		return soap_out_TT1__editTaskByRecordID(soap, tag, id, (const struct TT1__editTaskByRecordID *)ptr, "TT1:editTaskByRecordID");
	case SOAP_TYPE_TT1__editTaskByRecordIDResponse:
		return soap_out_TT1__editTaskByRecordIDResponse(soap, tag, id, (const struct TT1__editTaskByRecordIDResponse *)ptr, "TT1:editTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__editTask:
		return soap_out_TT1__editTask(soap, tag, id, (const struct TT1__editTask *)ptr, "TT1:editTask");
	case SOAP_TYPE_TT1__editTaskResponse:
		return soap_out_TT1__editTaskResponse(soap, tag, id, (const struct TT1__editTaskResponse *)ptr, "TT1:editTaskResponse");
	case SOAP_TYPE_TT1__deleteTaskByRecordID:
		return soap_out_TT1__deleteTaskByRecordID(soap, tag, id, (const struct TT1__deleteTaskByRecordID *)ptr, "TT1:deleteTaskByRecordID");
	case SOAP_TYPE_TT1__deleteTaskByRecordIDResponse:
		return soap_out_TT1__deleteTaskByRecordIDResponse(soap, tag, id, (const struct TT1__deleteTaskByRecordIDResponse *)ptr, "TT1:deleteTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTask:
		return soap_out_TT1__deleteTask(soap, tag, id, (const struct TT1__deleteTask *)ptr, "TT1:deleteTask");
	case SOAP_TYPE_TT1__deleteTaskResponse:
		return soap_out_TT1__deleteTaskResponse(soap, tag, id, (const struct TT1__deleteTaskResponse *)ptr, "TT1:deleteTaskResponse");
	case SOAP_TYPE_TT1__addTask:
		return soap_out_TT1__addTask(soap, tag, id, (const struct TT1__addTask *)ptr, "TT1:addTask");
	case SOAP_TYPE_TT1__addTaskResponse:
		return soap_out_TT1__addTaskResponse(soap, tag, id, (const struct TT1__addTaskResponse *)ptr, "TT1:addTaskResponse");
	case SOAP_TYPE_TT1__getTaskByRecordID:
		return soap_out_TT1__getTaskByRecordID(soap, tag, id, (const struct TT1__getTaskByRecordID *)ptr, "TT1:getTaskByRecordID");
	case SOAP_TYPE_TT1__getTaskByRecordIDResponse:
		return soap_out_TT1__getTaskByRecordIDResponse(soap, tag, id, (const struct TT1__getTaskByRecordIDResponse *)ptr, "TT1:getTaskByRecordIDResponse");
	case SOAP_TYPE_TT1__getTask:
		return soap_out_TT1__getTask(soap, tag, id, (const struct TT1__getTask *)ptr, "TT1:getTask");
	case SOAP_TYPE_TT1__getTaskResponse:
		return soap_out_TT1__getTaskResponse(soap, tag, id, (const struct TT1__getTaskResponse *)ptr, "TT1:getTaskResponse");
	case SOAP_TYPE_TT1__getDefectAttachment:
		return soap_out_TT1__getDefectAttachment(soap, tag, id, (const struct TT1__getDefectAttachment *)ptr, "TT1:getDefectAttachment");
	case SOAP_TYPE_TT1__getDefectAttachmentResponse:
		return soap_out_TT1__getDefectAttachmentResponse(soap, tag, id, (const struct TT1__getDefectAttachmentResponse *)ptr, "TT1:getDefectAttachmentResponse");
	case SOAP_TYPE_TT1__getAttachment:
		return soap_out_TT1__getAttachment(soap, tag, id, (const struct TT1__getAttachment *)ptr, "TT1:getAttachment");
	case SOAP_TYPE_TT1__getAttachmentResponse:
		return soap_out_TT1__getAttachmentResponse(soap, tag, id, (const struct TT1__getAttachmentResponse *)ptr, "TT1:getAttachmentResponse");
	case SOAP_TYPE_TT1__cancelSaveDefect:
		return soap_out_TT1__cancelSaveDefect(soap, tag, id, (const struct TT1__cancelSaveDefect *)ptr, "TT1:cancelSaveDefect");
	case SOAP_TYPE_TT1__cancelSaveDefectResponse:
		return soap_out_TT1__cancelSaveDefectResponse(soap, tag, id, (const struct TT1__cancelSaveDefectResponse *)ptr, "TT1:cancelSaveDefectResponse");
	case SOAP_TYPE_TT1__saveDefect:
		return soap_out_TT1__saveDefect(soap, tag, id, (const struct TT1__saveDefect *)ptr, "TT1:saveDefect");
	case SOAP_TYPE_TT1__saveDefectResponse:
		return soap_out_TT1__saveDefectResponse(soap, tag, id, (const struct TT1__saveDefectResponse *)ptr, "TT1:saveDefectResponse");
	case SOAP_TYPE_TT1__editDefectByRecordID:
		return soap_out_TT1__editDefectByRecordID(soap, tag, id, (const struct TT1__editDefectByRecordID *)ptr, "TT1:editDefectByRecordID");
	case SOAP_TYPE_TT1__editDefectByRecordIDResponse:
		return soap_out_TT1__editDefectByRecordIDResponse(soap, tag, id, (const struct TT1__editDefectByRecordIDResponse *)ptr, "TT1:editDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__editDefect:
		return soap_out_TT1__editDefect(soap, tag, id, (const struct TT1__editDefect *)ptr, "TT1:editDefect");
	case SOAP_TYPE_TT1__editDefectResponse:
		return soap_out_TT1__editDefectResponse(soap, tag, id, (const struct TT1__editDefectResponse *)ptr, "TT1:editDefectResponse");
	case SOAP_TYPE_TT1__deleteDefectByRecordID:
		return soap_out_TT1__deleteDefectByRecordID(soap, tag, id, (const struct TT1__deleteDefectByRecordID *)ptr, "TT1:deleteDefectByRecordID");
	case SOAP_TYPE_TT1__deleteDefectByRecordIDResponse:
		return soap_out_TT1__deleteDefectByRecordIDResponse(soap, tag, id, (const struct TT1__deleteDefectByRecordIDResponse *)ptr, "TT1:deleteDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteDefect:
		return soap_out_TT1__deleteDefect(soap, tag, id, (const struct TT1__deleteDefect *)ptr, "TT1:deleteDefect");
	case SOAP_TYPE_TT1__deleteDefectResponse:
		return soap_out_TT1__deleteDefectResponse(soap, tag, id, (const struct TT1__deleteDefectResponse *)ptr, "TT1:deleteDefectResponse");
	case SOAP_TYPE_TT1__addDefectWithLink:
		return soap_out_TT1__addDefectWithLink(soap, tag, id, (const struct TT1__addDefectWithLink *)ptr, "TT1:addDefectWithLink");
	case SOAP_TYPE_TT1__addDefectWithLinkResponse:
		return soap_out_TT1__addDefectWithLinkResponse(soap, tag, id, (const struct TT1__addDefectWithLinkResponse *)ptr, "TT1:addDefectWithLinkResponse");
	case SOAP_TYPE_TT1__addDefect:
		return soap_out_TT1__addDefect(soap, tag, id, (const struct TT1__addDefect *)ptr, "TT1:addDefect");
	case SOAP_TYPE_TT1__addDefectResponse:
		return soap_out_TT1__addDefectResponse(soap, tag, id, (const struct TT1__addDefectResponse *)ptr, "TT1:addDefectResponse");
	case SOAP_TYPE_TT1__getDefectByRecordID:
		return soap_out_TT1__getDefectByRecordID(soap, tag, id, (const struct TT1__getDefectByRecordID *)ptr, "TT1:getDefectByRecordID");
	case SOAP_TYPE_TT1__getDefectByRecordIDResponse:
		return soap_out_TT1__getDefectByRecordIDResponse(soap, tag, id, (const struct TT1__getDefectByRecordIDResponse *)ptr, "TT1:getDefectByRecordIDResponse");
	case SOAP_TYPE_TT1__getDefect:
		return soap_out_TT1__getDefect(soap, tag, id, (const struct TT1__getDefect *)ptr, "TT1:getDefect");
	case SOAP_TYPE_TT1__getDefectResponse:
		return soap_out_TT1__getDefectResponse(soap, tag, id, (const struct TT1__getDefectResponse *)ptr, "TT1:getDefectResponse");
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList:
		return soap_out_TT1__getDefectCustomFieldsDefinitionList(soap, tag, id, (const struct TT1__getDefectCustomFieldsDefinitionList *)ptr, "TT1:getDefectCustomFieldsDefinitionList");
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse:
		return soap_out_TT1__getDefectCustomFieldsDefinitionListResponse(soap, tag, id, (const struct TT1__getDefectCustomFieldsDefinitionListResponse *)ptr, "TT1:getDefectCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionList:
		return soap_out_TT1__getCustomFieldsDefinitionList(soap, tag, id, (const struct TT1__getCustomFieldsDefinitionList *)ptr, "TT1:getCustomFieldsDefinitionList");
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse:
		return soap_out_TT1__getCustomFieldsDefinitionListResponse(soap, tag, id, (const struct TT1__getCustomFieldsDefinitionListResponse *)ptr, "TT1:getCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_TT1__getDefectEventDefinitionList:
		return soap_out_TT1__getDefectEventDefinitionList(soap, tag, id, (const struct TT1__getDefectEventDefinitionList *)ptr, "TT1:getDefectEventDefinitionList");
	case SOAP_TYPE_TT1__getDefectEventDefinitionListResponse:
		return soap_out_TT1__getDefectEventDefinitionListResponse(soap, tag, id, (const struct TT1__getDefectEventDefinitionListResponse *)ptr, "TT1:getDefectEventDefinitionListResponse");
	case SOAP_TYPE_TT1__getEventDefinitionList:
		return soap_out_TT1__getEventDefinitionList(soap, tag, id, (const struct TT1__getEventDefinitionList *)ptr, "TT1:getEventDefinitionList");
	case SOAP_TYPE_TT1__getEventDefinitionListResponse:
		return soap_out_TT1__getEventDefinitionListResponse(soap, tag, id, (const struct TT1__getEventDefinitionListResponse *)ptr, "TT1:getEventDefinitionListResponse");
	case SOAP_TYPE_TT1__getAttachmentTypes:
		return soap_out_TT1__getAttachmentTypes(soap, tag, id, (const struct TT1__getAttachmentTypes *)ptr, "TT1:getAttachmentTypes");
	case SOAP_TYPE_TT1__getAttachmentTypesResponse:
		return soap_out_TT1__getAttachmentTypesResponse(soap, tag, id, (const struct TT1__getAttachmentTypesResponse *)ptr, "TT1:getAttachmentTypesResponse");
	case SOAP_TYPE_TT1__cancelSaveTestConfig:
		return soap_out_TT1__cancelSaveTestConfig(soap, tag, id, (const struct TT1__cancelSaveTestConfig *)ptr, "TT1:cancelSaveTestConfig");
	case SOAP_TYPE_TT1__cancelSaveTestConfigResponse:
		return soap_out_TT1__cancelSaveTestConfigResponse(soap, tag, id, (const struct TT1__cancelSaveTestConfigResponse *)ptr, "TT1:cancelSaveTestConfigResponse");
	case SOAP_TYPE_TT1__deleteTestConfigByRecordID:
		return soap_out_TT1__deleteTestConfigByRecordID(soap, tag, id, (const struct TT1__deleteTestConfigByRecordID *)ptr, "TT1:deleteTestConfigByRecordID");
	case SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse:
		return soap_out_TT1__deleteTestConfigByRecordIDResponse(soap, tag, id, (const struct TT1__deleteTestConfigByRecordIDResponse *)ptr, "TT1:deleteTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__deleteTestConfig:
		return soap_out_TT1__deleteTestConfig(soap, tag, id, (const struct TT1__deleteTestConfig *)ptr, "TT1:deleteTestConfig");
	case SOAP_TYPE_TT1__deleteTestConfigResponse:
		return soap_out_TT1__deleteTestConfigResponse(soap, tag, id, (const struct TT1__deleteTestConfigResponse *)ptr, "TT1:deleteTestConfigResponse");
	case SOAP_TYPE_TT1__saveTestConfig:
		return soap_out_TT1__saveTestConfig(soap, tag, id, (const struct TT1__saveTestConfig *)ptr, "TT1:saveTestConfig");
	case SOAP_TYPE_TT1__saveTestConfigResponse:
		return soap_out_TT1__saveTestConfigResponse(soap, tag, id, (const struct TT1__saveTestConfigResponse *)ptr, "TT1:saveTestConfigResponse");
	case SOAP_TYPE_TT1__editTestConfigByRecordID:
		return soap_out_TT1__editTestConfigByRecordID(soap, tag, id, (const struct TT1__editTestConfigByRecordID *)ptr, "TT1:editTestConfigByRecordID");
	case SOAP_TYPE_TT1__editTestConfigByRecordIDResponse:
		return soap_out_TT1__editTestConfigByRecordIDResponse(soap, tag, id, (const struct TT1__editTestConfigByRecordIDResponse *)ptr, "TT1:editTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__editTestConfig:
		return soap_out_TT1__editTestConfig(soap, tag, id, (const struct TT1__editTestConfig *)ptr, "TT1:editTestConfig");
	case SOAP_TYPE_TT1__editTestConfigResponse:
		return soap_out_TT1__editTestConfigResponse(soap, tag, id, (const struct TT1__editTestConfigResponse *)ptr, "TT1:editTestConfigResponse");
	case SOAP_TYPE_TT1__addTestConfig:
		return soap_out_TT1__addTestConfig(soap, tag, id, (const struct TT1__addTestConfig *)ptr, "TT1:addTestConfig");
	case SOAP_TYPE_TT1__addTestConfigResponse:
		return soap_out_TT1__addTestConfigResponse(soap, tag, id, (const struct TT1__addTestConfigResponse *)ptr, "TT1:addTestConfigResponse");
	case SOAP_TYPE_TT1__getTestConfigByRecordID:
		return soap_out_TT1__getTestConfigByRecordID(soap, tag, id, (const struct TT1__getTestConfigByRecordID *)ptr, "TT1:getTestConfigByRecordID");
	case SOAP_TYPE_TT1__getTestConfigByRecordIDResponse:
		return soap_out_TT1__getTestConfigByRecordIDResponse(soap, tag, id, (const struct TT1__getTestConfigByRecordIDResponse *)ptr, "TT1:getTestConfigByRecordIDResponse");
	case SOAP_TYPE_TT1__getTestConfig:
		return soap_out_TT1__getTestConfig(soap, tag, id, (const struct TT1__getTestConfig *)ptr, "TT1:getTestConfig");
	case SOAP_TYPE_TT1__getTestConfigResponse:
		return soap_out_TT1__getTestConfigResponse(soap, tag, id, (const struct TT1__getTestConfigResponse *)ptr, "TT1:getTestConfigResponse");
	case SOAP_TYPE_TT1__getRecordListForTable:
		return soap_out_TT1__getRecordListForTable(soap, tag, id, (const struct TT1__getRecordListForTable *)ptr, "TT1:getRecordListForTable");
	case SOAP_TYPE_TT1__getRecordListForTableResponse:
		return soap_out_TT1__getRecordListForTableResponse(soap, tag, id, (const struct TT1__getRecordListForTableResponse *)ptr, "TT1:getRecordListForTableResponse");
	case SOAP_TYPE_TT1__getFilterListForTable:
		return soap_out_TT1__getFilterListForTable(soap, tag, id, (const struct TT1__getFilterListForTable *)ptr, "TT1:getFilterListForTable");
	case SOAP_TYPE_TT1__getFilterListForTableResponse:
		return soap_out_TT1__getFilterListForTableResponse(soap, tag, id, (const struct TT1__getFilterListForTableResponse *)ptr, "TT1:getFilterListForTableResponse");
	case SOAP_TYPE_TT1__getFilterList:
		return soap_out_TT1__getFilterList(soap, tag, id, (const struct TT1__getFilterList *)ptr, "TT1:getFilterList");
	case SOAP_TYPE_TT1__getFilterListResponse:
		return soap_out_TT1__getFilterListResponse(soap, tag, id, (const struct TT1__getFilterListResponse *)ptr, "TT1:getFilterListResponse");
	case SOAP_TYPE_TT1__getColumnsForTable:
		return soap_out_TT1__getColumnsForTable(soap, tag, id, (const struct TT1__getColumnsForTable *)ptr, "TT1:getColumnsForTable");
	case SOAP_TYPE_TT1__getColumnsForTableResponse:
		return soap_out_TT1__getColumnsForTableResponse(soap, tag, id, (const struct TT1__getColumnsForTableResponse *)ptr, "TT1:getColumnsForTableResponse");
	case SOAP_TYPE_TT1__GetLinkDefinitionValues:
		return soap_out_TT1__GetLinkDefinitionValues(soap, tag, id, (const struct TT1__GetLinkDefinitionValues *)ptr, "TT1:GetLinkDefinitionValues");
	case SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse:
		return soap_out_TT1__GetLinkDefinitionValuesResponse(soap, tag, id, (const struct TT1__GetLinkDefinitionValuesResponse *)ptr, "TT1:GetLinkDefinitionValuesResponse");
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTable:
		return soap_out_TT1__addDropdownFieldValuesForTable(soap, tag, id, (const struct TT1__addDropdownFieldValuesForTable *)ptr, "TT1:addDropdownFieldValuesForTable");
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse:
		return soap_out_TT1__addDropdownFieldValuesForTableResponse(soap, tag, id, (const struct TT1__addDropdownFieldValuesForTableResponse *)ptr, "TT1:addDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTable:
		return soap_out_TT1__getDropdownFieldValuesForTable(soap, tag, id, (const struct TT1__getDropdownFieldValuesForTable *)ptr, "TT1:getDropdownFieldValuesForTable");
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse:
		return soap_out_TT1__getDropdownFieldValuesForTableResponse(soap, tag, id, (const struct TT1__getDropdownFieldValuesForTableResponse *)ptr, "TT1:getDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_TT1__getDropdownFieldForTable:
		return soap_out_TT1__getDropdownFieldForTable(soap, tag, id, (const struct TT1__getDropdownFieldForTable *)ptr, "TT1:getDropdownFieldForTable");
	case SOAP_TYPE_TT1__getDropdownFieldForTableResponse:
		return soap_out_TT1__getDropdownFieldForTableResponse(soap, tag, id, (const struct TT1__getDropdownFieldForTableResponse *)ptr, "TT1:getDropdownFieldForTableResponse");
	case SOAP_TYPE_TT1__getTableList:
		return soap_out_TT1__getTableList(soap, tag, id, (const struct TT1__getTableList *)ptr, "TT1:getTableList");
	case SOAP_TYPE_TT1__getTableListResponse:
		return soap_out_TT1__getTableListResponse(soap, tag, id, (const struct TT1__getTableListResponse *)ptr, "TT1:getTableListResponse");
	case SOAP_TYPE_TT1__DatabaseLogoff:
		return soap_out_TT1__DatabaseLogoff(soap, tag, id, (const struct TT1__DatabaseLogoff *)ptr, "TT1:DatabaseLogoff");
	case SOAP_TYPE_TT1__DatabaseLogoffResponse:
		return soap_out_TT1__DatabaseLogoffResponse(soap, tag, id, (const struct TT1__DatabaseLogoffResponse *)ptr, "TT1:DatabaseLogoffResponse");
	case SOAP_TYPE_TT1__ProjectLogon:
		return soap_out_TT1__ProjectLogon(soap, tag, id, (const struct TT1__ProjectLogon *)ptr, "TT1:ProjectLogon");
	case SOAP_TYPE_TT1__ProjectLogonResponse:
		return soap_out_TT1__ProjectLogonResponse(soap, tag, id, (const struct TT1__ProjectLogonResponse *)ptr, "TT1:ProjectLogonResponse");
	case SOAP_TYPE_TT1__DatabaseLogon:
		return soap_out_TT1__DatabaseLogon(soap, tag, id, (const struct TT1__DatabaseLogon *)ptr, "TT1:DatabaseLogon");
	case SOAP_TYPE_TT1__DatabaseLogonResponse:
		return soap_out_TT1__DatabaseLogonResponse(soap, tag, id, (const struct TT1__DatabaseLogonResponse *)ptr, "TT1:DatabaseLogonResponse");
	case SOAP_TYPE_TT1__getProjectDataOptionList:
		return soap_out_TT1__getProjectDataOptionList(soap, tag, id, (const struct TT1__getProjectDataOptionList *)ptr, "TT1:getProjectDataOptionList");
	case SOAP_TYPE_TT1__getProjectDataOptionListResponse:
		return soap_out_TT1__getProjectDataOptionListResponse(soap, tag, id, (const struct TT1__getProjectDataOptionListResponse *)ptr, "TT1:getProjectDataOptionListResponse");
	case SOAP_TYPE_TT1__getProjectList:
		return soap_out_TT1__getProjectList(soap, tag, id, (const struct TT1__getProjectList *)ptr, "TT1:getProjectList");
	case SOAP_TYPE_TT1__getProjectListResponse:
		return soap_out_TT1__getProjectListResponse(soap, tag, id, (const struct TT1__getProjectListResponse *)ptr, "TT1:getProjectListResponse");
	case SOAP_TYPE_TT1__getDatabaseList:
		return soap_out_TT1__getDatabaseList(soap, tag, id, (const struct TT1__getDatabaseList *)ptr, "TT1:getDatabaseList");
	case SOAP_TYPE_TT1__getDatabaseListResponse:
		return soap_out_TT1__getDatabaseListResponse(soap, tag, id, (const struct TT1__getDatabaseListResponse *)ptr, "TT1:getDatabaseListResponse");
	case SOAP_TYPE_PointerToTT1ArrayOfCFolderItem:
		return soap_out_PointerToTT1ArrayOfCFolderItem(soap, tag, id, (TT1ArrayOfCFolderItem *const*)ptr, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToTT1ArrayOfCTestRunVariantField:
		return soap_out_PointerToTT1ArrayOfCTestRunVariantField(soap, tag, id, (TT1ArrayOfCTestRunVariantField *const*)ptr, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToTT1ArrayOfCItemToTrack:
		return soap_out_PointerToTT1ArrayOfCItemToTrack(soap, tag, id, (TT1ArrayOfCItemToTrack *const*)ptr, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToTT1__CTestRun:
		return soap_out_PointerToTT1__CTestRun(soap, tag, id, (TT1__CTestRun *const*)ptr, "TT1:CTestRun");
	case SOAP_TYPE_PointerToTT1__CTestCase:
		return soap_out_PointerToTT1__CTestCase(soap, tag, id, (TT1__CTestCase *const*)ptr, "TT1:CTestCase");
	case SOAP_TYPE_PointerToTT1ArrayOfCLink:
		return soap_out_PointerToTT1ArrayOfCLink(soap, tag, id, (TT1ArrayOfCLink *const*)ptr, "TT1:CLink");
	case SOAP_TYPE_PointerToTT1__CUser:
		return soap_out_PointerToTT1__CUser(soap, tag, id, (TT1__CUser *const*)ptr, "TT1:CUser");
	case SOAP_TYPE_PointerToTT1ArrayOfCUserLicense:
		return soap_out_PointerToTT1ArrayOfCUserLicense(soap, tag, id, (TT1ArrayOfCUserLicense *const*)ptr, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToTT1ArrayOfCGlobalUser:
		return soap_out_PointerToTT1ArrayOfCGlobalUser(soap, tag, id, (TT1ArrayOfCGlobalUser *const*)ptr, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToTT1__CTask:
		return soap_out_PointerToTT1__CTask(soap, tag, id, (TT1__CTask *const*)ptr, "TT1:CTask");
	case SOAP_TYPE_PointerToTT1__CDefect:
		return soap_out_PointerToTT1__CDefect(soap, tag, id, (TT1__CDefect *const*)ptr, "TT1:CDefect");
	case SOAP_TYPE_PointerToTT1ArrayOfCDefectEventDefinition:
		return soap_out_PointerToTT1ArrayOfCDefectEventDefinition(soap, tag, id, (TT1ArrayOfCDefectEventDefinition *const*)ptr, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToTT1ArrayOfCEventDefinition:
		return soap_out_PointerToTT1ArrayOfCEventDefinition(soap, tag, id, (TT1ArrayOfCEventDefinition *const*)ptr, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToTT1__CRecordListSoap:
		return soap_out_PointerToTT1__CRecordListSoap(soap, tag, id, (TT1__CRecordListSoap *const*)ptr, "TT1:CRecordListSoap");
	case SOAP_TYPE_PointerToTT1ArrayOfCFilter:
		return soap_out_PointerToTT1ArrayOfCFilter(soap, tag, id, (TT1ArrayOfCFilter *const*)ptr, "TT1:CFilter");
	case SOAP_TYPE_PointerToTT1ArrayOfCTableField:
		return soap_out_PointerToTT1ArrayOfCTableField(soap, tag, id, (TT1ArrayOfCTableField *const*)ptr, "TT1:CTableField");
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabaseTable:
		return soap_out_PointerToTT1ArrayOfCDatabaseTable(soap, tag, id, (TT1ArrayOfCDatabaseTable *const*)ptr, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToTT1ArrayOfCProject:
		return soap_out_PointerToTT1ArrayOfCProject(soap, tag, id, (TT1ArrayOfCProject *const*)ptr, "TT1:CProject");
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabase:
		return soap_out_PointerToTT1ArrayOfCDatabase(soap, tag, id, (TT1ArrayOfCDatabase *const*)ptr, "TT1:CDatabase");
	case SOAP_TYPE_PointerToTT1ArrayOfCTestCaseVariantField:
		return soap_out_PointerToTT1ArrayOfCTestCaseVariantField(soap, tag, id, (TT1ArrayOfCTestCaseVariantField *const*)ptr, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkHistoryItem:
		return soap_out_PointerToTT1ArrayOfCLinkHistoryItem(soap, tag, id, (TT1ArrayOfCLinkHistoryItem *const*)ptr, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkedItem:
		return soap_out_PointerToTT1ArrayOfCLinkedItem(soap, tag, id, (TT1ArrayOfCLinkedItem *const*)ptr, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToTT1__PhoneNumber:
		return soap_out_PointerToTT1__PhoneNumber(soap, tag, id, (TT1__PhoneNumber *const*)ptr, "TT1:PhoneNumber");
	case SOAP_TYPE_PointerToTT1ArrayOfCSCCFileRecord:
		return soap_out_PointerToTT1ArrayOfCSCCFileRecord(soap, tag, id, (TT1ArrayOfCSCCFileRecord *const*)ptr, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerToTT1ArrayOfCEvent:
		return soap_out_PointerToTT1ArrayOfCEvent(soap, tag, id, (TT1ArrayOfCEvent *const*)ptr, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1ArrayOfCReportedByRecord:
		return soap_out_PointerToTT1ArrayOfCReportedByRecord(soap, tag, id, (TT1ArrayOfCReportedByRecord *const*)ptr, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToPointerToTT1__CFolderItem:
		return soap_out_PointerToPointerToTT1__CFolderItem(soap, tag, id, (TT1__CFolderItem **const*)ptr, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToTT1__CFolderItem:
		return soap_out_PointerToTT1__CFolderItem(soap, tag, id, (TT1__CFolderItem *const*)ptr, "TT1:CFolderItem");
	case SOAP_TYPE_PointerToPointerToTT1__CFolder:
		return soap_out_PointerToPointerToTT1__CFolder(soap, tag, id, (TT1__CFolder **const*)ptr, "TT1:CFolder");
	case SOAP_TYPE_PointerToTT1__CFolder:
		return soap_out_PointerToTT1__CFolder(soap, tag, id, (TT1__CFolder *const*)ptr, "TT1:CFolder");
	case SOAP_TYPE_PointerToPointerToTT1__CItemToTrack:
		return soap_out_PointerToPointerToTT1__CItemToTrack(soap, tag, id, (TT1__CItemToTrack **const*)ptr, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToTT1__CItemToTrack:
		return soap_out_PointerToTT1__CItemToTrack(soap, tag, id, (TT1__CItemToTrack *const*)ptr, "TT1:CItemToTrack");
	case SOAP_TYPE_PointerToPointerToTT1__CLink:
		return soap_out_PointerToPointerToTT1__CLink(soap, tag, id, (TT1__CLink **const*)ptr, "TT1:CLink");
	case SOAP_TYPE_PointerToTT1__CLink:
		return soap_out_PointerToTT1__CLink(soap, tag, id, (TT1__CLink *const*)ptr, "TT1:CLink");
	case SOAP_TYPE_PointerToPointerToTT1__CLinkHistoryItem:
		return soap_out_PointerToPointerToTT1__CLinkHistoryItem(soap, tag, id, (TT1__CLinkHistoryItem **const*)ptr, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToTT1__CLinkHistoryItem:
		return soap_out_PointerToTT1__CLinkHistoryItem(soap, tag, id, (TT1__CLinkHistoryItem *const*)ptr, "TT1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToPointerToTT1__CLinkedItem:
		return soap_out_PointerToPointerToTT1__CLinkedItem(soap, tag, id, (TT1__CLinkedItem **const*)ptr, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToTT1__CLinkedItem:
		return soap_out_PointerToTT1__CLinkedItem(soap, tag, id, (TT1__CLinkedItem *const*)ptr, "TT1:CLinkedItem");
	case SOAP_TYPE_PointerToPointerToTT1__CUserLicense:
		return soap_out_PointerToPointerToTT1__CUserLicense(soap, tag, id, (TT1__CUserLicense **const*)ptr, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToTT1__CUserLicense:
		return soap_out_PointerToTT1__CUserLicense(soap, tag, id, (TT1__CUserLicense *const*)ptr, "TT1:CUserLicense");
	case SOAP_TYPE_PointerToPointerToTT1__CGlobalUser:
		return soap_out_PointerToPointerToTT1__CGlobalUser(soap, tag, id, (TT1__CGlobalUser **const*)ptr, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToTT1__CGlobalUser:
		return soap_out_PointerToTT1__CGlobalUser(soap, tag, id, (TT1__CGlobalUser *const*)ptr, "TT1:CGlobalUser");
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEventDefinition:
		return soap_out_PointerToPointerToTT1__CDefectEventDefinition(soap, tag, id, (TT1__CDefectEventDefinition **const*)ptr, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToTT1__CDefectEventDefinition:
		return soap_out_PointerToTT1__CDefectEventDefinition(soap, tag, id, (TT1__CDefectEventDefinition *const*)ptr, "TT1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToPointerToTT1__CEventDefinition:
		return soap_out_PointerToPointerToTT1__CEventDefinition(soap, tag, id, (TT1__CEventDefinition **const*)ptr, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToTT1__CEventDefinition:
		return soap_out_PointerToTT1__CEventDefinition(soap, tag, id, (TT1__CEventDefinition *const*)ptr, "TT1:CEventDefinition");
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEvent:
		return soap_out_PointerToPointerToTT1__CDefectEvent(soap, tag, id, (TT1__CDefectEvent **const*)ptr, "TT1:CDefectEvent");
	case SOAP_TYPE_PointerToTT1__CDefectEvent:
		return soap_out_PointerToTT1__CDefectEvent(soap, tag, id, (TT1__CDefectEvent *const*)ptr, "TT1:CDefectEvent");
	case SOAP_TYPE_PointerToPointerToTT1__CEvent:
		return soap_out_PointerToPointerToTT1__CEvent(soap, tag, id, (TT1__CEvent **const*)ptr, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1__CEvent:
		return soap_out_PointerToTT1__CEvent(soap, tag, id, (TT1__CEvent *const*)ptr, "TT1:CEvent");
	case SOAP_TYPE_PointerToTT1ArrayOfstring:
		return soap_out_PointerToTT1ArrayOfstring(soap, tag, id, (TT1ArrayOfstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerToPointerToTT1__CTestCaseVariantField:
		return soap_out_PointerToPointerToTT1__CTestCaseVariantField(soap, tag, id, (TT1__CTestCaseVariantField **const*)ptr, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToTT1__CTestCaseVariantField:
		return soap_out_PointerToTT1__CTestCaseVariantField(soap, tag, id, (TT1__CTestCaseVariantField *const*)ptr, "TT1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToPointerToTT1__CTestRunVariantField:
		return soap_out_PointerToPointerToTT1__CTestRunVariantField(soap, tag, id, (TT1__CTestRunVariantField **const*)ptr, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToTT1__CTestRunVariantField:
		return soap_out_PointerToTT1__CTestRunVariantField(soap, tag, id, (TT1__CTestRunVariantField *const*)ptr, "TT1:CTestRunVariantField");
	case SOAP_TYPE_PointerToPointerToTT1__CField:
		return soap_out_PointerToPointerToTT1__CField(soap, tag, id, (TT1__CField **const*)ptr, "TT1:CField");
	case SOAP_TYPE_PointerToTT1__CField:
		return soap_out_PointerToTT1__CField(soap, tag, id, (TT1__CField *const*)ptr, "TT1:CField");
	case SOAP_TYPE_PointerToPointerToTT1__CReportedByRecord:
		return soap_out_PointerToPointerToTT1__CReportedByRecord(soap, tag, id, (TT1__CReportedByRecord **const*)ptr, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToTT1__CReportedByRecord:
		return soap_out_PointerToTT1__CReportedByRecord(soap, tag, id, (TT1__CReportedByRecord *const*)ptr, "TT1:CReportedByRecord");
	case SOAP_TYPE_PointerToTT1ArrayOfCFileAttachment:
		return soap_out_PointerToTT1ArrayOfCFileAttachment(soap, tag, id, (TT1ArrayOfCFileAttachment *const*)ptr, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToshort:
		return soap_out_PointerToshort(soap, tag, id, (short *const*)ptr, "xsd:short");
	case SOAP_TYPE_PointerToTT1__CSystem:
		return soap_out_PointerToTT1__CSystem(soap, tag, id, (TT1__CSystem *const*)ptr, "TT1:CSystem");
	case SOAP_TYPE_PointerToPointerToTT1__CFileAttachment:
		return soap_out_PointerToPointerToTT1__CFileAttachment(soap, tag, id, (TT1__CFileAttachment **const*)ptr, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToTT1__CFileAttachment:
		return soap_out_PointerToTT1__CFileAttachment(soap, tag, id, (TT1__CFileAttachment *const*)ptr, "TT1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerToTT1__CSCCFileRecord:
		return soap_out_PointerToPointerToTT1__CSCCFileRecord(soap, tag, id, (TT1__CSCCFileRecord **const*)ptr, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerToTT1__CSCCFileRecord:
		return soap_out_PointerToTT1__CSCCFileRecord(soap, tag, id, (TT1__CSCCFileRecord *const*)ptr, "TT1:CSCCFileRecord");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerToTT1__CRecordRowSoap:
		return soap_out_PointerToPointerToTT1__CRecordRowSoap(soap, tag, id, (TT1__CRecordRowSoap **const*)ptr, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToTT1__CRecordRowSoap:
		return soap_out_PointerToTT1__CRecordRowSoap(soap, tag, id, (TT1__CRecordRowSoap *const*)ptr, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToPointerToTT1__CRecordData:
		return soap_out_PointerToPointerToTT1__CRecordData(soap, tag, id, (TT1__CRecordData **const*)ptr, "TT1:CRecordData");
	case SOAP_TYPE_PointerToTT1__CRecordData:
		return soap_out_PointerToTT1__CRecordData(soap, tag, id, (TT1__CRecordData *const*)ptr, "TT1:CRecordData");
	case SOAP_TYPE_PointerToPointerToTT1__CFilter:
		return soap_out_PointerToPointerToTT1__CFilter(soap, tag, id, (TT1__CFilter **const*)ptr, "TT1:CFilter");
	case SOAP_TYPE_PointerToTT1__CFilter:
		return soap_out_PointerToTT1__CFilter(soap, tag, id, (TT1__CFilter *const*)ptr, "TT1:CFilter");
	case SOAP_TYPE_PointerToPointerToTT1__CTableColumn:
		return soap_out_PointerToPointerToTT1__CTableColumn(soap, tag, id, (TT1__CTableColumn **const*)ptr, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToTT1__CTableColumn:
		return soap_out_PointerToTT1__CTableColumn(soap, tag, id, (TT1__CTableColumn *const*)ptr, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToPointerToTT1__CFieldValue:
		return soap_out_PointerToPointerToTT1__CFieldValue(soap, tag, id, (TT1__CFieldValue **const*)ptr, "TT1:CFieldValue");
	case SOAP_TYPE_PointerToTT1__CFieldValue:
		return soap_out_PointerToTT1__CFieldValue(soap, tag, id, (TT1__CFieldValue *const*)ptr, "TT1:CFieldValue");
	case SOAP_TYPE_PointerToPointerToTT1__CTableField:
		return soap_out_PointerToPointerToTT1__CTableField(soap, tag, id, (TT1__CTableField **const*)ptr, "TT1:CTableField");
	case SOAP_TYPE_PointerToTT1__CTableField:
		return soap_out_PointerToTT1__CTableField(soap, tag, id, (TT1__CTableField *const*)ptr, "TT1:CTableField");
	case SOAP_TYPE_PointerToPointerToTT1__CDatabaseTable:
		return soap_out_PointerToPointerToTT1__CDatabaseTable(soap, tag, id, (TT1__CDatabaseTable **const*)ptr, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToTT1__CDatabaseTable:
		return soap_out_PointerToTT1__CDatabaseTable(soap, tag, id, (TT1__CDatabaseTable *const*)ptr, "TT1:CDatabaseTable");
	case SOAP_TYPE_PointerToPointerToTT1__CProject:
		return soap_out_PointerToPointerToTT1__CProject(soap, tag, id, (TT1__CProject **const*)ptr, "TT1:CProject");
	case SOAP_TYPE_PointerToTT1__CProject:
		return soap_out_PointerToTT1__CProject(soap, tag, id, (TT1__CProject *const*)ptr, "TT1:CProject");
	case SOAP_TYPE_PointerToPointerToTT1__CProjectDataOption:
		return soap_out_PointerToPointerToTT1__CProjectDataOption(soap, tag, id, (TT1__CProjectDataOption **const*)ptr, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToTT1__CProjectDataOption:
		return soap_out_PointerToTT1__CProjectDataOption(soap, tag, id, (TT1__CProjectDataOption *const*)ptr, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToPointerToTT1__CDatabase:
		return soap_out_PointerToPointerToTT1__CDatabase(soap, tag, id, (TT1__CDatabase **const*)ptr, "TT1:CDatabase");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToTT1ArrayOfCField:
		return soap_out_PointerToTT1ArrayOfCField(soap, tag, id, (TT1ArrayOfCField *const*)ptr, "TT1:CField");
	case SOAP_TYPE_PointerToTT1ArrayOfCFieldValue:
		return soap_out_PointerToTT1ArrayOfCFieldValue(soap, tag, id, (TT1ArrayOfCFieldValue *const*)ptr, "TT1:CFieldValue");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordRowSoap:
		return soap_out_PointerToTT1ArrayOfCRecordRowSoap(soap, tag, id, (TT1ArrayOfCRecordRowSoap *const*)ptr, "TT1:CRecordRowSoap");
	case SOAP_TYPE_PointerToTT1ArrayOfCTableColumn:
		return soap_out_PointerToTT1ArrayOfCTableColumn(soap, tag, id, (TT1ArrayOfCTableColumn *const*)ptr, "TT1:CTableColumn");
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordData:
		return soap_out_PointerToTT1ArrayOfCRecordData(soap, tag, id, (TT1ArrayOfCRecordData *const*)ptr, "TT1:CRecordData");
	case SOAP_TYPE_PointerToTT1ArrayOfCProjectDataOption:
		return soap_out_PointerToTT1ArrayOfCProjectDataOption(soap, tag, id, (TT1ArrayOfCProjectDataOption *const*)ptr, "TT1:CProjectDataOption");
	case SOAP_TYPE_PointerToTT1__CDatabase:
		return soap_out_PointerToTT1__CDatabase(soap, tag, id, (TT1__CDatabase *const*)ptr, "TT1:CDatabase");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_TT1ArrayOfCFolderItem:
		((TT1ArrayOfCFolderItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCFolder:
		((TT1ArrayOfCFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CFolderItem:
		((TT1__CFolderItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CFolder:
		((TT1__CFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCItemToTrack:
		((TT1ArrayOfCItemToTrack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTestRun:
		((TT1__CTestRun *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTestCase:
		((TT1__CTestCase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCLink:
		((TT1ArrayOfCLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CLink:
		((TT1__CLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCLinkHistoryItem:
		((TT1ArrayOfCLinkHistoryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CLinkHistoryItem:
		((TT1__CLinkHistoryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCLinkedItem:
		((TT1ArrayOfCLinkedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CLinkedItem:
		((TT1__CLinkedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCUserLicense:
		((TT1ArrayOfCUserLicense *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CUserLicense:
		((TT1__CUserLicense *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCGlobalUser:
		((TT1ArrayOfCGlobalUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CGlobalUser:
		((TT1__CGlobalUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CUser:
		((TT1__CUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__PhoneNumber:
		((TT1__PhoneNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTask:
		((TT1__CTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDefect:
		((TT1__CDefect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCDefectEventDefinition:
		((TT1ArrayOfCDefectEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDefectEventDefinition:
		((TT1__CDefectEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCEventDefinition:
		((TT1ArrayOfCEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CEventDefinition:
		((TT1__CEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCDefectEvent:
		((TT1ArrayOfCDefectEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDefectEvent:
		((TT1__CDefectEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCEvent:
		((TT1ArrayOfCEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CEvent:
		((TT1__CEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCTestCaseVariantField:
		((TT1ArrayOfCTestCaseVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCTestRunVariantField:
		((TT1ArrayOfCTestRunVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCField:
		((TT1ArrayOfCField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CVersionField:
		((TT1__CVersionField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTestCaseVariantField:
		((TT1__CTestCaseVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTestRunVariantField:
		((TT1__CTestRunVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CMultiSelectDropdownField:
		((TT1__CMultiSelectDropdownField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDropdownField:
		((TT1__CDropdownField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDateTimeField:
		((TT1__CDateTimeField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDateField:
		((TT1__CDateField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CBooleanField:
		((TT1__CBooleanField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDecimalField:
		((TT1__CDecimalField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CIntegerField:
		((TT1__CIntegerField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CStringField:
		((TT1__CStringField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CField:
		((TT1__CField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCReportedByRecord:
		((TT1ArrayOfCReportedByRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CReportedByRecord:
		((TT1__CReportedByRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCFileAttachment:
		((TT1ArrayOfCFileAttachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CFileAttachment:
		((TT1__CFileAttachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCSCCFileRecord:
		((TT1ArrayOfCSCCFileRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CSCCFileRecord:
		((TT1__CSCCFileRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CSystem:
		((TT1__CSystem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CSystemBase:
		((TT1__CSystemBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__COrderedItemWithDBRecordId:
		((TT1__COrderedItemWithDBRecordId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CItemToTrack:
		((TT1__CItemToTrack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CItemWithDBRecordId:
		((TT1__CItemWithDBRecordId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CRecordListSoap:
		((TT1__CRecordListSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCRecordRowSoap:
		((TT1ArrayOfCRecordRowSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CRecordRowSoap:
		((TT1__CRecordRowSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCRecordData:
		((TT1ArrayOfCRecordData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CRecordData:
		((TT1__CRecordData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCFilter:
		((TT1ArrayOfCFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CFilter:
		((TT1__CFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCTableColumn:
		((TT1ArrayOfCTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTableColumn:
		((TT1__CTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCFieldValue:
		((TT1ArrayOfCFieldValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CFieldValue:
		((TT1__CFieldValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCTableField:
		((TT1ArrayOfCTableField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CTableField:
		((TT1__CTableField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCDatabaseTable:
		((TT1ArrayOfCDatabaseTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDatabaseTable:
		((TT1__CDatabaseTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCProject:
		((TT1ArrayOfCProject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CProject:
		((TT1__CProject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCProjectDataOption:
		((TT1ArrayOfCProjectDataOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CProjectDataOption:
		((TT1__CProjectDataOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfCDatabase:
		((TT1ArrayOfCDatabase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__CDatabase:
		((TT1__CDatabase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1ArrayOfstring:
		((TT1ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TT1__getRootPrivateFolderPath:
		soap_serialize_TT1__getRootPrivateFolderPath(soap, (const struct TT1__getRootPrivateFolderPath *)ptr);
		break;
	case SOAP_TYPE_TT1__getRootPrivateFolderPathResponse:
		soap_serialize_TT1__getRootPrivateFolderPathResponse(soap, (const struct TT1__getRootPrivateFolderPathResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getRootPublicFolderPath:
		soap_serialize_TT1__getRootPublicFolderPath(soap, (const struct TT1__getRootPublicFolderPath *)ptr);
		break;
	case SOAP_TYPE_TT1__getRootPublicFolderPathResponse:
		soap_serialize_TT1__getRootPublicFolderPathResponse(soap, (const struct TT1__getRootPublicFolderPathResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolderPathSeparator:
		soap_serialize_TT1__getFolderPathSeparator(soap, (const struct TT1__getFolderPathSeparator *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolderPathSeparatorResponse:
		soap_serialize_TT1__getFolderPathSeparatorResponse(soap, (const struct TT1__getFolderPathSeparatorResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordID:
		soap_serialize_TT1__getEntityListForFolderByRecordID(soap, (const struct TT1__getEntityListForFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse:
		soap_serialize_TT1__getEntityListForFolderByRecordIDResponse(soap, (const struct TT1__getEntityListForFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordID:
		soap_serialize_TT1__removeEntityFromFolderByRecordID(soap, (const struct TT1__removeEntityFromFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse:
		soap_serialize_TT1__removeEntityFromFolderByRecordIDResponse(soap, (const struct TT1__removeEntityFromFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addEntityToFolderByRecordID:
		soap_serialize_TT1__addEntityToFolderByRecordID(soap, (const struct TT1__addEntityToFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse:
		soap_serialize_TT1__addEntityToFolderByRecordIDResponse(soap, (const struct TT1__addEntityToFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteFolderByRecordID:
		soap_serialize_TT1__deleteFolderByRecordID(soap, (const struct TT1__deleteFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteFolderByRecordIDResponse:
		soap_serialize_TT1__deleteFolderByRecordIDResponse(soap, (const struct TT1__deleteFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteFolder:
		soap_serialize_TT1__deleteFolder(soap, (const struct TT1__deleteFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteFolderResponse:
		soap_serialize_TT1__deleteFolderResponse(soap, (const struct TT1__deleteFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolderByRecordID:
		soap_serialize_TT1__getFolderByRecordID(soap, (const struct TT1__getFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolderByRecordIDResponse:
		soap_serialize_TT1__getFolderByRecordIDResponse(soap, (const struct TT1__getFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolder:
		soap_serialize_TT1__getFolder(soap, (const struct TT1__getFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__getFolderResponse:
		soap_serialize_TT1__getFolderResponse(soap, (const struct TT1__getFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveFolder:
		soap_serialize_TT1__cancelSaveFolder(soap, (const struct TT1__cancelSaveFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveFolderResponse:
		soap_serialize_TT1__cancelSaveFolderResponse(soap, (const struct TT1__cancelSaveFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveFolder:
		soap_serialize_TT1__saveFolder(soap, (const struct TT1__saveFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__saveFolderResponse:
		soap_serialize_TT1__saveFolderResponse(soap, (const struct TT1__saveFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editFolderByRecordID:
		soap_serialize_TT1__editFolderByRecordID(soap, (const struct TT1__editFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editFolderByRecordIDResponse:
		soap_serialize_TT1__editFolderByRecordIDResponse(soap, (const struct TT1__editFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editFolder:
		soap_serialize_TT1__editFolder(soap, (const struct TT1__editFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__editFolderResponse:
		soap_serialize_TT1__editFolderResponse(soap, (const struct TT1__editFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addFolder:
		soap_serialize_TT1__addFolder(soap, (const struct TT1__addFolder *)ptr);
		break;
	case SOAP_TYPE_TT1__addFolderResponse:
		soap_serialize_TT1__addFolderResponse(soap, (const struct TT1__addFolderResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__generateTestRuns:
		soap_serialize_TT1__generateTestRuns(soap, (const struct TT1__generateTestRuns *)ptr);
		break;
	case SOAP_TYPE_TT1__generateTestRunsResponse:
		soap_serialize_TT1__generateTestRunsResponse(soap, (const struct TT1__generateTestRunsResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__createDefectForTestRun:
		soap_serialize_TT1__createDefectForTestRun(soap, (const struct TT1__createDefectForTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__createDefectForTestRunResponse:
		soap_serialize_TT1__createDefectForTestRunResponse(soap, (const struct TT1__createDefectForTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestRun:
		soap_serialize_TT1__cancelSaveTestRun(soap, (const struct TT1__cancelSaveTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestRunResponse:
		soap_serialize_TT1__cancelSaveTestRunResponse(soap, (const struct TT1__cancelSaveTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestRun:
		soap_serialize_TT1__saveTestRun(soap, (const struct TT1__saveTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestRunResponse:
		soap_serialize_TT1__saveTestRunResponse(soap, (const struct TT1__saveTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestRunByRecordID:
		soap_serialize_TT1__editTestRunByRecordID(soap, (const struct TT1__editTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestRunByRecordIDResponse:
		soap_serialize_TT1__editTestRunByRecordIDResponse(soap, (const struct TT1__editTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestRun:
		soap_serialize_TT1__editTestRun(soap, (const struct TT1__editTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestRunResponse:
		soap_serialize_TT1__editTestRunResponse(soap, (const struct TT1__editTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestRunByRecordID:
		soap_serialize_TT1__deleteTestRunByRecordID(soap, (const struct TT1__deleteTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse:
		soap_serialize_TT1__deleteTestRunByRecordIDResponse(soap, (const struct TT1__deleteTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestRun:
		soap_serialize_TT1__deleteTestRun(soap, (const struct TT1__deleteTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestRunResponse:
		soap_serialize_TT1__deleteTestRunResponse(soap, (const struct TT1__deleteTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRunByRecordID:
		soap_serialize_TT1__getTestRunByRecordID(soap, (const struct TT1__getTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRunByRecordIDResponse:
		soap_serialize_TT1__getTestRunByRecordIDResponse(soap, (const struct TT1__getTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRun:
		soap_serialize_TT1__getTestRun(soap, (const struct TT1__getTestRun *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRunResponse:
		soap_serialize_TT1__getTestRunResponse(soap, (const struct TT1__getTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestCase:
		soap_serialize_TT1__cancelSaveTestCase(soap, (const struct TT1__cancelSaveTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestCaseResponse:
		soap_serialize_TT1__cancelSaveTestCaseResponse(soap, (const struct TT1__cancelSaveTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestCase:
		soap_serialize_TT1__saveTestCase(soap, (const struct TT1__saveTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestCaseResponse:
		soap_serialize_TT1__saveTestCaseResponse(soap, (const struct TT1__saveTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestCaseByRecordID:
		soap_serialize_TT1__editTestCaseByRecordID(soap, (const struct TT1__editTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestCaseByRecordIDResponse:
		soap_serialize_TT1__editTestCaseByRecordIDResponse(soap, (const struct TT1__editTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestCase:
		soap_serialize_TT1__editTestCase(soap, (const struct TT1__editTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestCaseResponse:
		soap_serialize_TT1__editTestCaseResponse(soap, (const struct TT1__editTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestCaseByRecordID:
		soap_serialize_TT1__deleteTestCaseByRecordID(soap, (const struct TT1__deleteTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse:
		soap_serialize_TT1__deleteTestCaseByRecordIDResponse(soap, (const struct TT1__deleteTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestCase:
		soap_serialize_TT1__deleteTestCase(soap, (const struct TT1__deleteTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestCaseResponse:
		soap_serialize_TT1__deleteTestCaseResponse(soap, (const struct TT1__deleteTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addTestCase:
		soap_serialize_TT1__addTestCase(soap, (const struct TT1__addTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__addTestCaseResponse:
		soap_serialize_TT1__addTestCaseResponse(soap, (const struct TT1__addTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestCaseByRecordID:
		soap_serialize_TT1__getTestCaseByRecordID(soap, (const struct TT1__getTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestCaseByRecordIDResponse:
		soap_serialize_TT1__getTestCaseByRecordIDResponse(soap, (const struct TT1__getTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestCase:
		soap_serialize_TT1__getTestCase(soap, (const struct TT1__getTestCase *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestCaseResponse:
		soap_serialize_TT1__getTestCaseResponse(soap, (const struct TT1__getTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRunStepsModes:
		soap_serialize_TT1__getTestRunStepsModes(soap, (const struct TT1__getTestRunStepsModes *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestRunStepsModesResponse:
		soap_serialize_TT1__getTestRunStepsModesResponse(soap, (const struct TT1__getTestRunStepsModesResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestVariantTypes:
		soap_serialize_TT1__getTestVariantTypes(soap, (const struct TT1__getTestVariantTypes *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestVariantTypesResponse:
		soap_serialize_TT1__getTestVariantTypesResponse(soap, (const struct TT1__getTestVariantTypesResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveLink:
		soap_serialize_TT1__cancelSaveLink(soap, (const struct TT1__cancelSaveLink *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveLinkResponse:
		soap_serialize_TT1__cancelSaveLinkResponse(soap, (const struct TT1__cancelSaveLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveLink:
		soap_serialize_TT1__saveLink(soap, (const struct TT1__saveLink *)ptr);
		break;
	case SOAP_TYPE_TT1__saveLinkResponse:
		soap_serialize_TT1__saveLinkResponse(soap, (const struct TT1__saveLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editLink:
		soap_serialize_TT1__editLink(soap, (const struct TT1__editLink *)ptr);
		break;
	case SOAP_TYPE_TT1__editLinkResponse:
		soap_serialize_TT1__editLinkResponse(soap, (const struct TT1__editLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteLink:
		soap_serialize_TT1__deleteLink(soap, (const struct TT1__deleteLink *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteLinkResponse:
		soap_serialize_TT1__deleteLinkResponse(soap, (const struct TT1__deleteLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addLink:
		soap_serialize_TT1__addLink(soap, (const struct TT1__addLink *)ptr);
		break;
	case SOAP_TYPE_TT1__addLinkResponse:
		soap_serialize_TT1__addLinkResponse(soap, (const struct TT1__addLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getLink:
		soap_serialize_TT1__getLink(soap, (const struct TT1__getLink *)ptr);
		break;
	case SOAP_TYPE_TT1__getLinkResponse:
		soap_serialize_TT1__getLinkResponse(soap, (const struct TT1__getLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getLinksForDefect:
		soap_serialize_TT1__getLinksForDefect(soap, (const struct TT1__getLinksForDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__getLinksForDefectResponse:
		soap_serialize_TT1__getLinksForDefectResponse(soap, (const struct TT1__getLinksForDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getLinksForItem:
		soap_serialize_TT1__getLinksForItem(soap, (const struct TT1__getLinksForItem *)ptr);
		break;
	case SOAP_TYPE_TT1__getLinksForItemResponse:
		soap_serialize_TT1__getLinksForItemResponse(soap, (const struct TT1__getLinksForItemResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addGlobalCustomer:
		soap_serialize_TT1__addGlobalCustomer(soap, (const struct TT1__addGlobalCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__addGlobalCustomerResponse:
		soap_serialize_TT1__addGlobalCustomerResponse(soap, (const struct TT1__addGlobalCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__promoteCustomer:
		soap_serialize_TT1__promoteCustomer(soap, (const struct TT1__promoteCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__promoteCustomerResponse:
		soap_serialize_TT1__promoteCustomerResponse(soap, (const struct TT1__promoteCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveCustomer:
		soap_serialize_TT1__cancelSaveCustomer(soap, (const struct TT1__cancelSaveCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveCustomerResponse:
		soap_serialize_TT1__cancelSaveCustomerResponse(soap, (const struct TT1__cancelSaveCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteCustomerByRecordID:
		soap_serialize_TT1__deleteCustomerByRecordID(soap, (const struct TT1__deleteCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse:
		soap_serialize_TT1__deleteCustomerByRecordIDResponse(soap, (const struct TT1__deleteCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteCustomer:
		soap_serialize_TT1__deleteCustomer(soap, (const struct TT1__deleteCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteCustomerResponse:
		soap_serialize_TT1__deleteCustomerResponse(soap, (const struct TT1__deleteCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveCustomer:
		soap_serialize_TT1__saveCustomer(soap, (const struct TT1__saveCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__saveCustomerResponse:
		soap_serialize_TT1__saveCustomerResponse(soap, (const struct TT1__saveCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editCustomerByRecordID:
		soap_serialize_TT1__editCustomerByRecordID(soap, (const struct TT1__editCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editCustomerByRecordIDResponse:
		soap_serialize_TT1__editCustomerByRecordIDResponse(soap, (const struct TT1__editCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editCustomer:
		soap_serialize_TT1__editCustomer(soap, (const struct TT1__editCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__editCustomerResponse:
		soap_serialize_TT1__editCustomerResponse(soap, (const struct TT1__editCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addCustomer:
		soap_serialize_TT1__addCustomer(soap, (const struct TT1__addCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__addCustomerResponse:
		soap_serialize_TT1__addCustomerResponse(soap, (const struct TT1__addCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomerByRecordID:
		soap_serialize_TT1__getCustomerByRecordID(soap, (const struct TT1__getCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomerByRecordIDResponse:
		soap_serialize_TT1__getCustomerByRecordIDResponse(soap, (const struct TT1__getCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomer:
		soap_serialize_TT1__getCustomer(soap, (const struct TT1__getCustomer *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomerResponse:
		soap_serialize_TT1__getCustomerResponse(soap, (const struct TT1__getCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addGlobalUser:
		soap_serialize_TT1__addGlobalUser(soap, (const struct TT1__addGlobalUser *)ptr);
		break;
	case SOAP_TYPE_TT1__addGlobalUserResponse:
		soap_serialize_TT1__addGlobalUserResponse(soap, (const struct TT1__addGlobalUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__promoteUser:
		soap_serialize_TT1__promoteUser(soap, (const struct TT1__promoteUser *)ptr);
		break;
	case SOAP_TYPE_TT1__promoteUserResponse:
		soap_serialize_TT1__promoteUserResponse(soap, (const struct TT1__promoteUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveUser:
		soap_serialize_TT1__cancelSaveUser(soap, (const struct TT1__cancelSaveUser *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveUserResponse:
		soap_serialize_TT1__cancelSaveUserResponse(soap, (const struct TT1__cancelSaveUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteUserByRecordID:
		soap_serialize_TT1__deleteUserByRecordID(soap, (const struct TT1__deleteUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteUserByRecordIDResponse:
		soap_serialize_TT1__deleteUserByRecordIDResponse(soap, (const struct TT1__deleteUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteUser:
		soap_serialize_TT1__deleteUser(soap, (const struct TT1__deleteUser *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteUserResponse:
		soap_serialize_TT1__deleteUserResponse(soap, (const struct TT1__deleteUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveUser:
		soap_serialize_TT1__saveUser(soap, (const struct TT1__saveUser *)ptr);
		break;
	case SOAP_TYPE_TT1__saveUserResponse:
		soap_serialize_TT1__saveUserResponse(soap, (const struct TT1__saveUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editUserByRecordID:
		soap_serialize_TT1__editUserByRecordID(soap, (const struct TT1__editUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editUserByRecordIDResponse:
		soap_serialize_TT1__editUserByRecordIDResponse(soap, (const struct TT1__editUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editUser:
		soap_serialize_TT1__editUser(soap, (const struct TT1__editUser *)ptr);
		break;
	case SOAP_TYPE_TT1__editUserResponse:
		soap_serialize_TT1__editUserResponse(soap, (const struct TT1__editUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addUser:
		soap_serialize_TT1__addUser(soap, (const struct TT1__addUser *)ptr);
		break;
	case SOAP_TYPE_TT1__addUserResponse:
		soap_serialize_TT1__addUserResponse(soap, (const struct TT1__addUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getUserByRecordID:
		soap_serialize_TT1__getUserByRecordID(soap, (const struct TT1__getUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getUserByRecordIDResponse:
		soap_serialize_TT1__getUserByRecordIDResponse(soap, (const struct TT1__getUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getUser:
		soap_serialize_TT1__getUser(soap, (const struct TT1__getUser *)ptr);
		break;
	case SOAP_TYPE_TT1__getUserResponse:
		soap_serialize_TT1__getUserResponse(soap, (const struct TT1__getUserResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getUserLicenseList:
		soap_serialize_TT1__getUserLicenseList(soap, (const struct TT1__getUserLicenseList *)ptr);
		break;
	case SOAP_TYPE_TT1__getUserLicenseListResponse:
		soap_serialize_TT1__getUserLicenseListResponse(soap, (const struct TT1__getUserLicenseListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getGlobalCustomerList:
		soap_serialize_TT1__getGlobalCustomerList(soap, (const struct TT1__getGlobalCustomerList *)ptr);
		break;
	case SOAP_TYPE_TT1__getGlobalCustomerListResponse:
		soap_serialize_TT1__getGlobalCustomerListResponse(soap, (const struct TT1__getGlobalCustomerListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getGlobalUserList:
		soap_serialize_TT1__getGlobalUserList(soap, (const struct TT1__getGlobalUserList *)ptr);
		break;
	case SOAP_TYPE_TT1__getGlobalUserListResponse:
		soap_serialize_TT1__getGlobalUserListResponse(soap, (const struct TT1__getGlobalUserListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTask:
		soap_serialize_TT1__cancelSaveTask(soap, (const struct TT1__cancelSaveTask *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTaskResponse:
		soap_serialize_TT1__cancelSaveTaskResponse(soap, (const struct TT1__cancelSaveTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTask:
		soap_serialize_TT1__saveTask(soap, (const struct TT1__saveTask *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTaskResponse:
		soap_serialize_TT1__saveTaskResponse(soap, (const struct TT1__saveTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTaskByRecordID:
		soap_serialize_TT1__editTaskByRecordID(soap, (const struct TT1__editTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editTaskByRecordIDResponse:
		soap_serialize_TT1__editTaskByRecordIDResponse(soap, (const struct TT1__editTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTask:
		soap_serialize_TT1__editTask(soap, (const struct TT1__editTask *)ptr);
		break;
	case SOAP_TYPE_TT1__editTaskResponse:
		soap_serialize_TT1__editTaskResponse(soap, (const struct TT1__editTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTaskByRecordID:
		soap_serialize_TT1__deleteTaskByRecordID(soap, (const struct TT1__deleteTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTaskByRecordIDResponse:
		soap_serialize_TT1__deleteTaskByRecordIDResponse(soap, (const struct TT1__deleteTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTask:
		soap_serialize_TT1__deleteTask(soap, (const struct TT1__deleteTask *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTaskResponse:
		soap_serialize_TT1__deleteTaskResponse(soap, (const struct TT1__deleteTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addTask:
		soap_serialize_TT1__addTask(soap, (const struct TT1__addTask *)ptr);
		break;
	case SOAP_TYPE_TT1__addTaskResponse:
		soap_serialize_TT1__addTaskResponse(soap, (const struct TT1__addTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTaskByRecordID:
		soap_serialize_TT1__getTaskByRecordID(soap, (const struct TT1__getTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getTaskByRecordIDResponse:
		soap_serialize_TT1__getTaskByRecordIDResponse(soap, (const struct TT1__getTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTask:
		soap_serialize_TT1__getTask(soap, (const struct TT1__getTask *)ptr);
		break;
	case SOAP_TYPE_TT1__getTaskResponse:
		soap_serialize_TT1__getTaskResponse(soap, (const struct TT1__getTaskResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectAttachment:
		soap_serialize_TT1__getDefectAttachment(soap, (const struct TT1__getDefectAttachment *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectAttachmentResponse:
		soap_serialize_TT1__getDefectAttachmentResponse(soap, (const struct TT1__getDefectAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getAttachment:
		soap_serialize_TT1__getAttachment(soap, (const struct TT1__getAttachment *)ptr);
		break;
	case SOAP_TYPE_TT1__getAttachmentResponse:
		soap_serialize_TT1__getAttachmentResponse(soap, (const struct TT1__getAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveDefect:
		soap_serialize_TT1__cancelSaveDefect(soap, (const struct TT1__cancelSaveDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveDefectResponse:
		soap_serialize_TT1__cancelSaveDefectResponse(soap, (const struct TT1__cancelSaveDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveDefect:
		soap_serialize_TT1__saveDefect(soap, (const struct TT1__saveDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__saveDefectResponse:
		soap_serialize_TT1__saveDefectResponse(soap, (const struct TT1__saveDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editDefectByRecordID:
		soap_serialize_TT1__editDefectByRecordID(soap, (const struct TT1__editDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editDefectByRecordIDResponse:
		soap_serialize_TT1__editDefectByRecordIDResponse(soap, (const struct TT1__editDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editDefect:
		soap_serialize_TT1__editDefect(soap, (const struct TT1__editDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__editDefectResponse:
		soap_serialize_TT1__editDefectResponse(soap, (const struct TT1__editDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteDefectByRecordID:
		soap_serialize_TT1__deleteDefectByRecordID(soap, (const struct TT1__deleteDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteDefectByRecordIDResponse:
		soap_serialize_TT1__deleteDefectByRecordIDResponse(soap, (const struct TT1__deleteDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteDefect:
		soap_serialize_TT1__deleteDefect(soap, (const struct TT1__deleteDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteDefectResponse:
		soap_serialize_TT1__deleteDefectResponse(soap, (const struct TT1__deleteDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addDefectWithLink:
		soap_serialize_TT1__addDefectWithLink(soap, (const struct TT1__addDefectWithLink *)ptr);
		break;
	case SOAP_TYPE_TT1__addDefectWithLinkResponse:
		soap_serialize_TT1__addDefectWithLinkResponse(soap, (const struct TT1__addDefectWithLinkResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addDefect:
		soap_serialize_TT1__addDefect(soap, (const struct TT1__addDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__addDefectResponse:
		soap_serialize_TT1__addDefectResponse(soap, (const struct TT1__addDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectByRecordID:
		soap_serialize_TT1__getDefectByRecordID(soap, (const struct TT1__getDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectByRecordIDResponse:
		soap_serialize_TT1__getDefectByRecordIDResponse(soap, (const struct TT1__getDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefect:
		soap_serialize_TT1__getDefect(soap, (const struct TT1__getDefect *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectResponse:
		soap_serialize_TT1__getDefectResponse(soap, (const struct TT1__getDefectResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList:
		soap_serialize_TT1__getDefectCustomFieldsDefinitionList(soap, (const struct TT1__getDefectCustomFieldsDefinitionList *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse:
		soap_serialize_TT1__getDefectCustomFieldsDefinitionListResponse(soap, (const struct TT1__getDefectCustomFieldsDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionList:
		soap_serialize_TT1__getCustomFieldsDefinitionList(soap, (const struct TT1__getCustomFieldsDefinitionList *)ptr);
		break;
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse:
		soap_serialize_TT1__getCustomFieldsDefinitionListResponse(soap, (const struct TT1__getCustomFieldsDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectEventDefinitionList:
		soap_serialize_TT1__getDefectEventDefinitionList(soap, (const struct TT1__getDefectEventDefinitionList *)ptr);
		break;
	case SOAP_TYPE_TT1__getDefectEventDefinitionListResponse:
		soap_serialize_TT1__getDefectEventDefinitionListResponse(soap, (const struct TT1__getDefectEventDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getEventDefinitionList:
		soap_serialize_TT1__getEventDefinitionList(soap, (const struct TT1__getEventDefinitionList *)ptr);
		break;
	case SOAP_TYPE_TT1__getEventDefinitionListResponse:
		soap_serialize_TT1__getEventDefinitionListResponse(soap, (const struct TT1__getEventDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getAttachmentTypes:
		soap_serialize_TT1__getAttachmentTypes(soap, (const struct TT1__getAttachmentTypes *)ptr);
		break;
	case SOAP_TYPE_TT1__getAttachmentTypesResponse:
		soap_serialize_TT1__getAttachmentTypesResponse(soap, (const struct TT1__getAttachmentTypesResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestConfig:
		soap_serialize_TT1__cancelSaveTestConfig(soap, (const struct TT1__cancelSaveTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__cancelSaveTestConfigResponse:
		soap_serialize_TT1__cancelSaveTestConfigResponse(soap, (const struct TT1__cancelSaveTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestConfigByRecordID:
		soap_serialize_TT1__deleteTestConfigByRecordID(soap, (const struct TT1__deleteTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse:
		soap_serialize_TT1__deleteTestConfigByRecordIDResponse(soap, (const struct TT1__deleteTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestConfig:
		soap_serialize_TT1__deleteTestConfig(soap, (const struct TT1__deleteTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__deleteTestConfigResponse:
		soap_serialize_TT1__deleteTestConfigResponse(soap, (const struct TT1__deleteTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestConfig:
		soap_serialize_TT1__saveTestConfig(soap, (const struct TT1__saveTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__saveTestConfigResponse:
		soap_serialize_TT1__saveTestConfigResponse(soap, (const struct TT1__saveTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestConfigByRecordID:
		soap_serialize_TT1__editTestConfigByRecordID(soap, (const struct TT1__editTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestConfigByRecordIDResponse:
		soap_serialize_TT1__editTestConfigByRecordIDResponse(soap, (const struct TT1__editTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestConfig:
		soap_serialize_TT1__editTestConfig(soap, (const struct TT1__editTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__editTestConfigResponse:
		soap_serialize_TT1__editTestConfigResponse(soap, (const struct TT1__editTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addTestConfig:
		soap_serialize_TT1__addTestConfig(soap, (const struct TT1__addTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__addTestConfigResponse:
		soap_serialize_TT1__addTestConfigResponse(soap, (const struct TT1__addTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestConfigByRecordID:
		soap_serialize_TT1__getTestConfigByRecordID(soap, (const struct TT1__getTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestConfigByRecordIDResponse:
		soap_serialize_TT1__getTestConfigByRecordIDResponse(soap, (const struct TT1__getTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestConfig:
		soap_serialize_TT1__getTestConfig(soap, (const struct TT1__getTestConfig *)ptr);
		break;
	case SOAP_TYPE_TT1__getTestConfigResponse:
		soap_serialize_TT1__getTestConfigResponse(soap, (const struct TT1__getTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getRecordListForTable:
		soap_serialize_TT1__getRecordListForTable(soap, (const struct TT1__getRecordListForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__getRecordListForTableResponse:
		soap_serialize_TT1__getRecordListForTableResponse(soap, (const struct TT1__getRecordListForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getFilterListForTable:
		soap_serialize_TT1__getFilterListForTable(soap, (const struct TT1__getFilterListForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__getFilterListForTableResponse:
		soap_serialize_TT1__getFilterListForTableResponse(soap, (const struct TT1__getFilterListForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getFilterList:
		soap_serialize_TT1__getFilterList(soap, (const struct TT1__getFilterList *)ptr);
		break;
	case SOAP_TYPE_TT1__getFilterListResponse:
		soap_serialize_TT1__getFilterListResponse(soap, (const struct TT1__getFilterListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getColumnsForTable:
		soap_serialize_TT1__getColumnsForTable(soap, (const struct TT1__getColumnsForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__getColumnsForTableResponse:
		soap_serialize_TT1__getColumnsForTableResponse(soap, (const struct TT1__getColumnsForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__GetLinkDefinitionValues:
		soap_serialize_TT1__GetLinkDefinitionValues(soap, (const struct TT1__GetLinkDefinitionValues *)ptr);
		break;
	case SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse:
		soap_serialize_TT1__GetLinkDefinitionValuesResponse(soap, (const struct TT1__GetLinkDefinitionValuesResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTable:
		soap_serialize_TT1__addDropdownFieldValuesForTable(soap, (const struct TT1__addDropdownFieldValuesForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse:
		soap_serialize_TT1__addDropdownFieldValuesForTableResponse(soap, (const struct TT1__addDropdownFieldValuesForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTable:
		soap_serialize_TT1__getDropdownFieldValuesForTable(soap, (const struct TT1__getDropdownFieldValuesForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse:
		soap_serialize_TT1__getDropdownFieldValuesForTableResponse(soap, (const struct TT1__getDropdownFieldValuesForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDropdownFieldForTable:
		soap_serialize_TT1__getDropdownFieldForTable(soap, (const struct TT1__getDropdownFieldForTable *)ptr);
		break;
	case SOAP_TYPE_TT1__getDropdownFieldForTableResponse:
		soap_serialize_TT1__getDropdownFieldForTableResponse(soap, (const struct TT1__getDropdownFieldForTableResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getTableList:
		soap_serialize_TT1__getTableList(soap, (const struct TT1__getTableList *)ptr);
		break;
	case SOAP_TYPE_TT1__getTableListResponse:
		soap_serialize_TT1__getTableListResponse(soap, (const struct TT1__getTableListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__DatabaseLogoff:
		soap_serialize_TT1__DatabaseLogoff(soap, (const struct TT1__DatabaseLogoff *)ptr);
		break;
	case SOAP_TYPE_TT1__DatabaseLogoffResponse:
		soap_serialize_TT1__DatabaseLogoffResponse(soap, (const struct TT1__DatabaseLogoffResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__ProjectLogon:
		soap_serialize_TT1__ProjectLogon(soap, (const struct TT1__ProjectLogon *)ptr);
		break;
	case SOAP_TYPE_TT1__ProjectLogonResponse:
		soap_serialize_TT1__ProjectLogonResponse(soap, (const struct TT1__ProjectLogonResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__DatabaseLogon:
		soap_serialize_TT1__DatabaseLogon(soap, (const struct TT1__DatabaseLogon *)ptr);
		break;
	case SOAP_TYPE_TT1__DatabaseLogonResponse:
		soap_serialize_TT1__DatabaseLogonResponse(soap, (const struct TT1__DatabaseLogonResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getProjectDataOptionList:
		soap_serialize_TT1__getProjectDataOptionList(soap, (const struct TT1__getProjectDataOptionList *)ptr);
		break;
	case SOAP_TYPE_TT1__getProjectDataOptionListResponse:
		soap_serialize_TT1__getProjectDataOptionListResponse(soap, (const struct TT1__getProjectDataOptionListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getProjectList:
		soap_serialize_TT1__getProjectList(soap, (const struct TT1__getProjectList *)ptr);
		break;
	case SOAP_TYPE_TT1__getProjectListResponse:
		soap_serialize_TT1__getProjectListResponse(soap, (const struct TT1__getProjectListResponse *)ptr);
		break;
	case SOAP_TYPE_TT1__getDatabaseList:
		soap_serialize_TT1__getDatabaseList(soap, (const struct TT1__getDatabaseList *)ptr);
		break;
	case SOAP_TYPE_TT1__getDatabaseListResponse:
		soap_serialize_TT1__getDatabaseListResponse(soap, (const struct TT1__getDatabaseListResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCFolderItem:
		soap_serialize_PointerToTT1ArrayOfCFolderItem(soap, (TT1ArrayOfCFolderItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCTestRunVariantField:
		soap_serialize_PointerToTT1ArrayOfCTestRunVariantField(soap, (TT1ArrayOfCTestRunVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCItemToTrack:
		soap_serialize_PointerToTT1ArrayOfCItemToTrack(soap, (TT1ArrayOfCItemToTrack *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTestRun:
		soap_serialize_PointerToTT1__CTestRun(soap, (TT1__CTestRun *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTestCase:
		soap_serialize_PointerToTT1__CTestCase(soap, (TT1__CTestCase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCLink:
		soap_serialize_PointerToTT1ArrayOfCLink(soap, (TT1ArrayOfCLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CUser:
		soap_serialize_PointerToTT1__CUser(soap, (TT1__CUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCUserLicense:
		soap_serialize_PointerToTT1ArrayOfCUserLicense(soap, (TT1ArrayOfCUserLicense *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCGlobalUser:
		soap_serialize_PointerToTT1ArrayOfCGlobalUser(soap, (TT1ArrayOfCGlobalUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTask:
		soap_serialize_PointerToTT1__CTask(soap, (TT1__CTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CDefect:
		soap_serialize_PointerToTT1__CDefect(soap, (TT1__CDefect *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCDefectEventDefinition:
		soap_serialize_PointerToTT1ArrayOfCDefectEventDefinition(soap, (TT1ArrayOfCDefectEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCEventDefinition:
		soap_serialize_PointerToTT1ArrayOfCEventDefinition(soap, (TT1ArrayOfCEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CRecordListSoap:
		soap_serialize_PointerToTT1__CRecordListSoap(soap, (TT1__CRecordListSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCFilter:
		soap_serialize_PointerToTT1ArrayOfCFilter(soap, (TT1ArrayOfCFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCTableField:
		soap_serialize_PointerToTT1ArrayOfCTableField(soap, (TT1ArrayOfCTableField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabaseTable:
		soap_serialize_PointerToTT1ArrayOfCDatabaseTable(soap, (TT1ArrayOfCDatabaseTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCProject:
		soap_serialize_PointerToTT1ArrayOfCProject(soap, (TT1ArrayOfCProject *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCDatabase:
		soap_serialize_PointerToTT1ArrayOfCDatabase(soap, (TT1ArrayOfCDatabase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCTestCaseVariantField:
		soap_serialize_PointerToTT1ArrayOfCTestCaseVariantField(soap, (TT1ArrayOfCTestCaseVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkHistoryItem:
		soap_serialize_PointerToTT1ArrayOfCLinkHistoryItem(soap, (TT1ArrayOfCLinkHistoryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCLinkedItem:
		soap_serialize_PointerToTT1ArrayOfCLinkedItem(soap, (TT1ArrayOfCLinkedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__PhoneNumber:
		soap_serialize_PointerToTT1__PhoneNumber(soap, (TT1__PhoneNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCSCCFileRecord:
		soap_serialize_PointerToTT1ArrayOfCSCCFileRecord(soap, (TT1ArrayOfCSCCFileRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCEvent:
		soap_serialize_PointerToTT1ArrayOfCEvent(soap, (TT1ArrayOfCEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCReportedByRecord:
		soap_serialize_PointerToTT1ArrayOfCReportedByRecord(soap, (TT1ArrayOfCReportedByRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CFolderItem:
		soap_serialize_PointerToPointerToTT1__CFolderItem(soap, (TT1__CFolderItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CFolderItem:
		soap_serialize_PointerToTT1__CFolderItem(soap, (TT1__CFolderItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CFolder:
		soap_serialize_PointerToPointerToTT1__CFolder(soap, (TT1__CFolder **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CFolder:
		soap_serialize_PointerToTT1__CFolder(soap, (TT1__CFolder *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CItemToTrack:
		soap_serialize_PointerToPointerToTT1__CItemToTrack(soap, (TT1__CItemToTrack **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CItemToTrack:
		soap_serialize_PointerToTT1__CItemToTrack(soap, (TT1__CItemToTrack *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CLink:
		soap_serialize_PointerToPointerToTT1__CLink(soap, (TT1__CLink **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CLink:
		soap_serialize_PointerToTT1__CLink(soap, (TT1__CLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CLinkHistoryItem:
		soap_serialize_PointerToPointerToTT1__CLinkHistoryItem(soap, (TT1__CLinkHistoryItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CLinkHistoryItem:
		soap_serialize_PointerToTT1__CLinkHistoryItem(soap, (TT1__CLinkHistoryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CLinkedItem:
		soap_serialize_PointerToPointerToTT1__CLinkedItem(soap, (TT1__CLinkedItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CLinkedItem:
		soap_serialize_PointerToTT1__CLinkedItem(soap, (TT1__CLinkedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CUserLicense:
		soap_serialize_PointerToPointerToTT1__CUserLicense(soap, (TT1__CUserLicense **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CUserLicense:
		soap_serialize_PointerToTT1__CUserLicense(soap, (TT1__CUserLicense *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CGlobalUser:
		soap_serialize_PointerToPointerToTT1__CGlobalUser(soap, (TT1__CGlobalUser **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CGlobalUser:
		soap_serialize_PointerToTT1__CGlobalUser(soap, (TT1__CGlobalUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEventDefinition:
		soap_serialize_PointerToPointerToTT1__CDefectEventDefinition(soap, (TT1__CDefectEventDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CDefectEventDefinition:
		soap_serialize_PointerToTT1__CDefectEventDefinition(soap, (TT1__CDefectEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CEventDefinition:
		soap_serialize_PointerToPointerToTT1__CEventDefinition(soap, (TT1__CEventDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CEventDefinition:
		soap_serialize_PointerToTT1__CEventDefinition(soap, (TT1__CEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CDefectEvent:
		soap_serialize_PointerToPointerToTT1__CDefectEvent(soap, (TT1__CDefectEvent **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CDefectEvent:
		soap_serialize_PointerToTT1__CDefectEvent(soap, (TT1__CDefectEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CEvent:
		soap_serialize_PointerToPointerToTT1__CEvent(soap, (TT1__CEvent **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CEvent:
		soap_serialize_PointerToTT1__CEvent(soap, (TT1__CEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfstring:
		soap_serialize_PointerToTT1ArrayOfstring(soap, (TT1ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CTestCaseVariantField:
		soap_serialize_PointerToPointerToTT1__CTestCaseVariantField(soap, (TT1__CTestCaseVariantField **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTestCaseVariantField:
		soap_serialize_PointerToTT1__CTestCaseVariantField(soap, (TT1__CTestCaseVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CTestRunVariantField:
		soap_serialize_PointerToPointerToTT1__CTestRunVariantField(soap, (TT1__CTestRunVariantField **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTestRunVariantField:
		soap_serialize_PointerToTT1__CTestRunVariantField(soap, (TT1__CTestRunVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CField:
		soap_serialize_PointerToPointerToTT1__CField(soap, (TT1__CField **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CField:
		soap_serialize_PointerToTT1__CField(soap, (TT1__CField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CReportedByRecord:
		soap_serialize_PointerToPointerToTT1__CReportedByRecord(soap, (TT1__CReportedByRecord **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CReportedByRecord:
		soap_serialize_PointerToTT1__CReportedByRecord(soap, (TT1__CReportedByRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCFileAttachment:
		soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, (TT1ArrayOfCFileAttachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerToshort:
		soap_serialize_PointerToshort(soap, (short *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CSystem:
		soap_serialize_PointerToTT1__CSystem(soap, (TT1__CSystem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CFileAttachment:
		soap_serialize_PointerToPointerToTT1__CFileAttachment(soap, (TT1__CFileAttachment **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CFileAttachment:
		soap_serialize_PointerToTT1__CFileAttachment(soap, (TT1__CFileAttachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CSCCFileRecord:
		soap_serialize_PointerToPointerToTT1__CSCCFileRecord(soap, (TT1__CSCCFileRecord **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CSCCFileRecord:
		soap_serialize_PointerToTT1__CSCCFileRecord(soap, (TT1__CSCCFileRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CRecordRowSoap:
		soap_serialize_PointerToPointerToTT1__CRecordRowSoap(soap, (TT1__CRecordRowSoap **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CRecordRowSoap:
		soap_serialize_PointerToTT1__CRecordRowSoap(soap, (TT1__CRecordRowSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CRecordData:
		soap_serialize_PointerToPointerToTT1__CRecordData(soap, (TT1__CRecordData **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CRecordData:
		soap_serialize_PointerToTT1__CRecordData(soap, (TT1__CRecordData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CFilter:
		soap_serialize_PointerToPointerToTT1__CFilter(soap, (TT1__CFilter **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CFilter:
		soap_serialize_PointerToTT1__CFilter(soap, (TT1__CFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CTableColumn:
		soap_serialize_PointerToPointerToTT1__CTableColumn(soap, (TT1__CTableColumn **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTableColumn:
		soap_serialize_PointerToTT1__CTableColumn(soap, (TT1__CTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CFieldValue:
		soap_serialize_PointerToPointerToTT1__CFieldValue(soap, (TT1__CFieldValue **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CFieldValue:
		soap_serialize_PointerToTT1__CFieldValue(soap, (TT1__CFieldValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CTableField:
		soap_serialize_PointerToPointerToTT1__CTableField(soap, (TT1__CTableField **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CTableField:
		soap_serialize_PointerToTT1__CTableField(soap, (TT1__CTableField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CDatabaseTable:
		soap_serialize_PointerToPointerToTT1__CDatabaseTable(soap, (TT1__CDatabaseTable **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CDatabaseTable:
		soap_serialize_PointerToTT1__CDatabaseTable(soap, (TT1__CDatabaseTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CProject:
		soap_serialize_PointerToPointerToTT1__CProject(soap, (TT1__CProject **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CProject:
		soap_serialize_PointerToTT1__CProject(soap, (TT1__CProject *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CProjectDataOption:
		soap_serialize_PointerToPointerToTT1__CProjectDataOption(soap, (TT1__CProjectDataOption **const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CProjectDataOption:
		soap_serialize_PointerToTT1__CProjectDataOption(soap, (TT1__CProjectDataOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToTT1__CDatabase:
		soap_serialize_PointerToPointerToTT1__CDatabase(soap, (TT1__CDatabase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCField:
		soap_serialize_PointerToTT1ArrayOfCField(soap, (TT1ArrayOfCField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCFieldValue:
		soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, (TT1ArrayOfCFieldValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordRowSoap:
		soap_serialize_PointerToTT1ArrayOfCRecordRowSoap(soap, (TT1ArrayOfCRecordRowSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCTableColumn:
		soap_serialize_PointerToTT1ArrayOfCTableColumn(soap, (TT1ArrayOfCTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCRecordData:
		soap_serialize_PointerToTT1ArrayOfCRecordData(soap, (TT1ArrayOfCRecordData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1ArrayOfCProjectDataOption:
		soap_serialize_PointerToTT1ArrayOfCProjectDataOption(soap, (TT1ArrayOfCProjectDataOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTT1__CDatabase:
		soap_serialize_PointerToTT1__CDatabase(soap, (TT1__CDatabase *const*)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDatabase:
		return (void*)soap_instantiate_TT1__CDatabase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CProjectDataOption:
		return (void*)soap_instantiate_TT1__CProjectDataOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CProject:
		return (void*)soap_instantiate_TT1__CProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDatabaseTable:
		return (void*)soap_instantiate_TT1__CDatabaseTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTableField:
		return (void*)soap_instantiate_TT1__CTableField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CFieldValue:
		return (void*)soap_instantiate_TT1__CFieldValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTableColumn:
		return (void*)soap_instantiate_TT1__CTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CFilter:
		return (void*)soap_instantiate_TT1__CFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CRecordData:
		return (void*)soap_instantiate_TT1__CRecordData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CRecordRowSoap:
		return (void*)soap_instantiate_TT1__CRecordRowSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CRecordListSoap:
		return (void*)soap_instantiate_TT1__CRecordListSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CItemWithDBRecordId:
		return (void*)soap_instantiate_TT1__CItemWithDBRecordId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CFileAttachment:
		return (void*)soap_instantiate_TT1__CFileAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CEventDefinition:
		return (void*)soap_instantiate_TT1__CEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__PhoneNumber:
		return (void*)soap_instantiate_TT1__PhoneNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CGlobalUser:
		return (void*)soap_instantiate_TT1__CGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CUserLicense:
		return (void*)soap_instantiate_TT1__CUserLicense(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfstring:
		return (void*)soap_instantiate_TT1ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCDatabase:
		return (void*)soap_instantiate_TT1ArrayOfCDatabase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCProjectDataOption:
		return (void*)soap_instantiate_TT1ArrayOfCProjectDataOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCProject:
		return (void*)soap_instantiate_TT1ArrayOfCProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCDatabaseTable:
		return (void*)soap_instantiate_TT1ArrayOfCDatabaseTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCTableField:
		return (void*)soap_instantiate_TT1ArrayOfCTableField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCFieldValue:
		return (void*)soap_instantiate_TT1ArrayOfCFieldValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCTableColumn:
		return (void*)soap_instantiate_TT1ArrayOfCTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCFilter:
		return (void*)soap_instantiate_TT1ArrayOfCFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCRecordData:
		return (void*)soap_instantiate_TT1ArrayOfCRecordData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCRecordRowSoap:
		return (void*)soap_instantiate_TT1ArrayOfCRecordRowSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CItemToTrack:
		return (void*)soap_instantiate_TT1__CItemToTrack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__COrderedItemWithDBRecordId:
		return (void*)soap_instantiate_TT1__COrderedItemWithDBRecordId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CSCCFileRecord:
		return (void*)soap_instantiate_TT1__CSCCFileRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCSCCFileRecord:
		return (void*)soap_instantiate_TT1ArrayOfCSCCFileRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCFileAttachment:
		return (void*)soap_instantiate_TT1ArrayOfCFileAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CReportedByRecord:
		return (void*)soap_instantiate_TT1__CReportedByRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCReportedByRecord:
		return (void*)soap_instantiate_TT1ArrayOfCReportedByRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CField:
		return (void*)soap_instantiate_TT1__CField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCField:
		return (void*)soap_instantiate_TT1ArrayOfCField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCTestRunVariantField:
		return (void*)soap_instantiate_TT1ArrayOfCTestRunVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCTestCaseVariantField:
		return (void*)soap_instantiate_TT1ArrayOfCTestCaseVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CEvent:
		return (void*)soap_instantiate_TT1__CEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCEvent:
		return (void*)soap_instantiate_TT1ArrayOfCEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCDefectEvent:
		return (void*)soap_instantiate_TT1ArrayOfCDefectEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCEventDefinition:
		return (void*)soap_instantiate_TT1ArrayOfCEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDefectEventDefinition:
		return (void*)soap_instantiate_TT1__CDefectEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCDefectEventDefinition:
		return (void*)soap_instantiate_TT1ArrayOfCDefectEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCGlobalUser:
		return (void*)soap_instantiate_TT1ArrayOfCGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCUserLicense:
		return (void*)soap_instantiate_TT1ArrayOfCUserLicense(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCLinkedItem:
		return (void*)soap_instantiate_TT1ArrayOfCLinkedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCLinkHistoryItem:
		return (void*)soap_instantiate_TT1ArrayOfCLinkHistoryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCLink:
		return (void*)soap_instantiate_TT1ArrayOfCLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCItemToTrack:
		return (void*)soap_instantiate_TT1ArrayOfCItemToTrack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CFolderItem:
		return (void*)soap_instantiate_TT1__CFolderItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCFolder:
		return (void*)soap_instantiate_TT1ArrayOfCFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1ArrayOfCFolderItem:
		return (void*)soap_instantiate_TT1ArrayOfCFolderItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CSystemBase:
		return (void*)soap_instantiate_TT1__CSystemBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CStringField:
		return (void*)soap_instantiate_TT1__CStringField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CIntegerField:
		return (void*)soap_instantiate_TT1__CIntegerField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDecimalField:
		return (void*)soap_instantiate_TT1__CDecimalField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CBooleanField:
		return (void*)soap_instantiate_TT1__CBooleanField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDateField:
		return (void*)soap_instantiate_TT1__CDateField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDateTimeField:
		return (void*)soap_instantiate_TT1__CDateTimeField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDropdownField:
		return (void*)soap_instantiate_TT1__CDropdownField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CMultiSelectDropdownField:
		return (void*)soap_instantiate_TT1__CMultiSelectDropdownField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CVersionField:
		return (void*)soap_instantiate_TT1__CVersionField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDefectEvent:
		return (void*)soap_instantiate_TT1__CDefectEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CDefect:
		return (void*)soap_instantiate_TT1__CDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTask:
		return (void*)soap_instantiate_TT1__CTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CUser:
		return (void*)soap_instantiate_TT1__CUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CLinkedItem:
		return (void*)soap_instantiate_TT1__CLinkedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CLinkHistoryItem:
		return (void*)soap_instantiate_TT1__CLinkHistoryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CLink:
		return (void*)soap_instantiate_TT1__CLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTestCase:
		return (void*)soap_instantiate_TT1__CTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTestRun:
		return (void*)soap_instantiate_TT1__CTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CFolder:
		return (void*)soap_instantiate_TT1__CFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CSystem:
		return (void*)soap_instantiate_TT1__CSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTestRunVariantField:
		return (void*)soap_instantiate_TT1__CTestRunVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__CTestCaseVariantField:
		return (void*)soap_instantiate_TT1__CTestCaseVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDatabaseListResponse:
		return (void*)soap_instantiate_TT1__getDatabaseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDatabaseList:
		return (void*)soap_instantiate_TT1__getDatabaseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getProjectListResponse:
		return (void*)soap_instantiate_TT1__getProjectListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getProjectList:
		return (void*)soap_instantiate_TT1__getProjectList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getProjectDataOptionListResponse:
		return (void*)soap_instantiate_TT1__getProjectDataOptionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getProjectDataOptionList:
		return (void*)soap_instantiate_TT1__getProjectDataOptionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__DatabaseLogonResponse:
		return (void*)soap_instantiate_TT1__DatabaseLogonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__DatabaseLogon:
		return (void*)soap_instantiate_TT1__DatabaseLogon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__ProjectLogonResponse:
		return (void*)soap_instantiate_TT1__ProjectLogonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__ProjectLogon:
		return (void*)soap_instantiate_TT1__ProjectLogon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__DatabaseLogoffResponse:
		return (void*)soap_instantiate_TT1__DatabaseLogoffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__DatabaseLogoff:
		return (void*)soap_instantiate_TT1__DatabaseLogoff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTableListResponse:
		return (void*)soap_instantiate_TT1__getTableListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTableList:
		return (void*)soap_instantiate_TT1__getTableList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDropdownFieldForTableResponse:
		return (void*)soap_instantiate_TT1__getDropdownFieldForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDropdownFieldForTable:
		return (void*)soap_instantiate_TT1__getDropdownFieldForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse:
		return (void*)soap_instantiate_TT1__getDropdownFieldValuesForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTable:
		return (void*)soap_instantiate_TT1__getDropdownFieldValuesForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse:
		return (void*)soap_instantiate_TT1__addDropdownFieldValuesForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTable:
		return (void*)soap_instantiate_TT1__addDropdownFieldValuesForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse:
		return (void*)soap_instantiate_TT1__GetLinkDefinitionValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__GetLinkDefinitionValues:
		return (void*)soap_instantiate_TT1__GetLinkDefinitionValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getColumnsForTableResponse:
		return (void*)soap_instantiate_TT1__getColumnsForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getColumnsForTable:
		return (void*)soap_instantiate_TT1__getColumnsForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFilterListResponse:
		return (void*)soap_instantiate_TT1__getFilterListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFilterList:
		return (void*)soap_instantiate_TT1__getFilterList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFilterListForTableResponse:
		return (void*)soap_instantiate_TT1__getFilterListForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFilterListForTable:
		return (void*)soap_instantiate_TT1__getFilterListForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRecordListForTableResponse:
		return (void*)soap_instantiate_TT1__getRecordListForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRecordListForTable:
		return (void*)soap_instantiate_TT1__getRecordListForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestConfigResponse:
		return (void*)soap_instantiate_TT1__getTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestConfig:
		return (void*)soap_instantiate_TT1__getTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestConfigByRecordID:
		return (void*)soap_instantiate_TT1__getTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTestConfigResponse:
		return (void*)soap_instantiate_TT1__addTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTestConfig:
		return (void*)soap_instantiate_TT1__addTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestConfigResponse:
		return (void*)soap_instantiate_TT1__editTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestConfig:
		return (void*)soap_instantiate_TT1__editTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestConfigByRecordID:
		return (void*)soap_instantiate_TT1__editTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestConfigResponse:
		return (void*)soap_instantiate_TT1__saveTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestConfig:
		return (void*)soap_instantiate_TT1__saveTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestConfigResponse:
		return (void*)soap_instantiate_TT1__deleteTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestConfig:
		return (void*)soap_instantiate_TT1__deleteTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestConfigByRecordID:
		return (void*)soap_instantiate_TT1__deleteTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestConfigResponse:
		return (void*)soap_instantiate_TT1__cancelSaveTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestConfig:
		return (void*)soap_instantiate_TT1__cancelSaveTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getAttachmentTypesResponse:
		return (void*)soap_instantiate_TT1__getAttachmentTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getAttachmentTypes:
		return (void*)soap_instantiate_TT1__getAttachmentTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getEventDefinitionListResponse:
		return (void*)soap_instantiate_TT1__getEventDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getEventDefinitionList:
		return (void*)soap_instantiate_TT1__getEventDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectEventDefinitionListResponse:
		return (void*)soap_instantiate_TT1__getDefectEventDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectEventDefinitionList:
		return (void*)soap_instantiate_TT1__getDefectEventDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse:
		return (void*)soap_instantiate_TT1__getCustomFieldsDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionList:
		return (void*)soap_instantiate_TT1__getCustomFieldsDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse:
		return (void*)soap_instantiate_TT1__getDefectCustomFieldsDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList:
		return (void*)soap_instantiate_TT1__getDefectCustomFieldsDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectResponse:
		return (void*)soap_instantiate_TT1__getDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefect:
		return (void*)soap_instantiate_TT1__getDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectByRecordID:
		return (void*)soap_instantiate_TT1__getDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDefectResponse:
		return (void*)soap_instantiate_TT1__addDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDefect:
		return (void*)soap_instantiate_TT1__addDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDefectWithLinkResponse:
		return (void*)soap_instantiate_TT1__addDefectWithLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addDefectWithLink:
		return (void*)soap_instantiate_TT1__addDefectWithLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteDefectResponse:
		return (void*)soap_instantiate_TT1__deleteDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteDefect:
		return (void*)soap_instantiate_TT1__deleteDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteDefectByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteDefectByRecordID:
		return (void*)soap_instantiate_TT1__deleteDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editDefectResponse:
		return (void*)soap_instantiate_TT1__editDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editDefect:
		return (void*)soap_instantiate_TT1__editDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editDefectByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editDefectByRecordID:
		return (void*)soap_instantiate_TT1__editDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveDefectResponse:
		return (void*)soap_instantiate_TT1__saveDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveDefect:
		return (void*)soap_instantiate_TT1__saveDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveDefectResponse:
		return (void*)soap_instantiate_TT1__cancelSaveDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveDefect:
		return (void*)soap_instantiate_TT1__cancelSaveDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getAttachmentResponse:
		return (void*)soap_instantiate_TT1__getAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getAttachment:
		return (void*)soap_instantiate_TT1__getAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectAttachmentResponse:
		return (void*)soap_instantiate_TT1__getDefectAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getDefectAttachment:
		return (void*)soap_instantiate_TT1__getDefectAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTaskResponse:
		return (void*)soap_instantiate_TT1__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTask:
		return (void*)soap_instantiate_TT1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTaskByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTaskByRecordID:
		return (void*)soap_instantiate_TT1__getTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTaskResponse:
		return (void*)soap_instantiate_TT1__addTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTask:
		return (void*)soap_instantiate_TT1__addTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTaskResponse:
		return (void*)soap_instantiate_TT1__deleteTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTask:
		return (void*)soap_instantiate_TT1__deleteTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTaskByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTaskByRecordID:
		return (void*)soap_instantiate_TT1__deleteTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTaskResponse:
		return (void*)soap_instantiate_TT1__editTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTask:
		return (void*)soap_instantiate_TT1__editTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTaskByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTaskByRecordID:
		return (void*)soap_instantiate_TT1__editTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTaskResponse:
		return (void*)soap_instantiate_TT1__saveTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTask:
		return (void*)soap_instantiate_TT1__saveTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTaskResponse:
		return (void*)soap_instantiate_TT1__cancelSaveTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTask:
		return (void*)soap_instantiate_TT1__cancelSaveTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getGlobalUserListResponse:
		return (void*)soap_instantiate_TT1__getGlobalUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getGlobalUserList:
		return (void*)soap_instantiate_TT1__getGlobalUserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getGlobalCustomerListResponse:
		return (void*)soap_instantiate_TT1__getGlobalCustomerListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getGlobalCustomerList:
		return (void*)soap_instantiate_TT1__getGlobalCustomerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUserLicenseListResponse:
		return (void*)soap_instantiate_TT1__getUserLicenseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUserLicenseList:
		return (void*)soap_instantiate_TT1__getUserLicenseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUserResponse:
		return (void*)soap_instantiate_TT1__getUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUser:
		return (void*)soap_instantiate_TT1__getUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUserByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getUserByRecordID:
		return (void*)soap_instantiate_TT1__getUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addUserResponse:
		return (void*)soap_instantiate_TT1__addUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addUser:
		return (void*)soap_instantiate_TT1__addUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editUserResponse:
		return (void*)soap_instantiate_TT1__editUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editUser:
		return (void*)soap_instantiate_TT1__editUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editUserByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editUserByRecordID:
		return (void*)soap_instantiate_TT1__editUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveUserResponse:
		return (void*)soap_instantiate_TT1__saveUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveUser:
		return (void*)soap_instantiate_TT1__saveUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteUserResponse:
		return (void*)soap_instantiate_TT1__deleteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteUser:
		return (void*)soap_instantiate_TT1__deleteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteUserByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteUserByRecordID:
		return (void*)soap_instantiate_TT1__deleteUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveUserResponse:
		return (void*)soap_instantiate_TT1__cancelSaveUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveUser:
		return (void*)soap_instantiate_TT1__cancelSaveUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__promoteUserResponse:
		return (void*)soap_instantiate_TT1__promoteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__promoteUser:
		return (void*)soap_instantiate_TT1__promoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addGlobalUserResponse:
		return (void*)soap_instantiate_TT1__addGlobalUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addGlobalUser:
		return (void*)soap_instantiate_TT1__addGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomerResponse:
		return (void*)soap_instantiate_TT1__getCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomer:
		return (void*)soap_instantiate_TT1__getCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomerByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getCustomerByRecordID:
		return (void*)soap_instantiate_TT1__getCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addCustomerResponse:
		return (void*)soap_instantiate_TT1__addCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addCustomer:
		return (void*)soap_instantiate_TT1__addCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editCustomerResponse:
		return (void*)soap_instantiate_TT1__editCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editCustomer:
		return (void*)soap_instantiate_TT1__editCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editCustomerByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editCustomerByRecordID:
		return (void*)soap_instantiate_TT1__editCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveCustomerResponse:
		return (void*)soap_instantiate_TT1__saveCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveCustomer:
		return (void*)soap_instantiate_TT1__saveCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteCustomerResponse:
		return (void*)soap_instantiate_TT1__deleteCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteCustomer:
		return (void*)soap_instantiate_TT1__deleteCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteCustomerByRecordID:
		return (void*)soap_instantiate_TT1__deleteCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveCustomerResponse:
		return (void*)soap_instantiate_TT1__cancelSaveCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveCustomer:
		return (void*)soap_instantiate_TT1__cancelSaveCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__promoteCustomerResponse:
		return (void*)soap_instantiate_TT1__promoteCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__promoteCustomer:
		return (void*)soap_instantiate_TT1__promoteCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addGlobalCustomerResponse:
		return (void*)soap_instantiate_TT1__addGlobalCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addGlobalCustomer:
		return (void*)soap_instantiate_TT1__addGlobalCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLinksForItemResponse:
		return (void*)soap_instantiate_TT1__getLinksForItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLinksForItem:
		return (void*)soap_instantiate_TT1__getLinksForItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLinksForDefectResponse:
		return (void*)soap_instantiate_TT1__getLinksForDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLinksForDefect:
		return (void*)soap_instantiate_TT1__getLinksForDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLinkResponse:
		return (void*)soap_instantiate_TT1__getLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getLink:
		return (void*)soap_instantiate_TT1__getLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addLinkResponse:
		return (void*)soap_instantiate_TT1__addLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addLink:
		return (void*)soap_instantiate_TT1__addLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteLinkResponse:
		return (void*)soap_instantiate_TT1__deleteLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteLink:
		return (void*)soap_instantiate_TT1__deleteLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editLinkResponse:
		return (void*)soap_instantiate_TT1__editLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editLink:
		return (void*)soap_instantiate_TT1__editLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveLinkResponse:
		return (void*)soap_instantiate_TT1__saveLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveLink:
		return (void*)soap_instantiate_TT1__saveLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveLinkResponse:
		return (void*)soap_instantiate_TT1__cancelSaveLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveLink:
		return (void*)soap_instantiate_TT1__cancelSaveLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestVariantTypesResponse:
		return (void*)soap_instantiate_TT1__getTestVariantTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestVariantTypes:
		return (void*)soap_instantiate_TT1__getTestVariantTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRunStepsModesResponse:
		return (void*)soap_instantiate_TT1__getTestRunStepsModesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRunStepsModes:
		return (void*)soap_instantiate_TT1__getTestRunStepsModes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestCaseResponse:
		return (void*)soap_instantiate_TT1__getTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestCase:
		return (void*)soap_instantiate_TT1__getTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestCaseByRecordID:
		return (void*)soap_instantiate_TT1__getTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTestCaseResponse:
		return (void*)soap_instantiate_TT1__addTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addTestCase:
		return (void*)soap_instantiate_TT1__addTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestCaseResponse:
		return (void*)soap_instantiate_TT1__deleteTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestCase:
		return (void*)soap_instantiate_TT1__deleteTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestCaseByRecordID:
		return (void*)soap_instantiate_TT1__deleteTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestCaseResponse:
		return (void*)soap_instantiate_TT1__editTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestCase:
		return (void*)soap_instantiate_TT1__editTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestCaseByRecordID:
		return (void*)soap_instantiate_TT1__editTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestCaseResponse:
		return (void*)soap_instantiate_TT1__saveTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestCase:
		return (void*)soap_instantiate_TT1__saveTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestCaseResponse:
		return (void*)soap_instantiate_TT1__cancelSaveTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestCase:
		return (void*)soap_instantiate_TT1__cancelSaveTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRunResponse:
		return (void*)soap_instantiate_TT1__getTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRun:
		return (void*)soap_instantiate_TT1__getTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRunByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getTestRunByRecordID:
		return (void*)soap_instantiate_TT1__getTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestRunResponse:
		return (void*)soap_instantiate_TT1__deleteTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestRun:
		return (void*)soap_instantiate_TT1__deleteTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteTestRunByRecordID:
		return (void*)soap_instantiate_TT1__deleteTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestRunResponse:
		return (void*)soap_instantiate_TT1__editTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestRun:
		return (void*)soap_instantiate_TT1__editTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestRunByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editTestRunByRecordID:
		return (void*)soap_instantiate_TT1__editTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestRunResponse:
		return (void*)soap_instantiate_TT1__saveTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveTestRun:
		return (void*)soap_instantiate_TT1__saveTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestRunResponse:
		return (void*)soap_instantiate_TT1__cancelSaveTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveTestRun:
		return (void*)soap_instantiate_TT1__cancelSaveTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__createDefectForTestRunResponse:
		return (void*)soap_instantiate_TT1__createDefectForTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__createDefectForTestRun:
		return (void*)soap_instantiate_TT1__createDefectForTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__generateTestRunsResponse:
		return (void*)soap_instantiate_TT1__generateTestRunsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__generateTestRuns:
		return (void*)soap_instantiate_TT1__generateTestRuns(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addFolderResponse:
		return (void*)soap_instantiate_TT1__addFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addFolder:
		return (void*)soap_instantiate_TT1__addFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editFolderResponse:
		return (void*)soap_instantiate_TT1__editFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editFolder:
		return (void*)soap_instantiate_TT1__editFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__editFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__editFolderByRecordID:
		return (void*)soap_instantiate_TT1__editFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveFolderResponse:
		return (void*)soap_instantiate_TT1__saveFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__saveFolder:
		return (void*)soap_instantiate_TT1__saveFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveFolderResponse:
		return (void*)soap_instantiate_TT1__cancelSaveFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__cancelSaveFolder:
		return (void*)soap_instantiate_TT1__cancelSaveFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolderResponse:
		return (void*)soap_instantiate_TT1__getFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolder:
		return (void*)soap_instantiate_TT1__getFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolderByRecordID:
		return (void*)soap_instantiate_TT1__getFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteFolderResponse:
		return (void*)soap_instantiate_TT1__deleteFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteFolder:
		return (void*)soap_instantiate_TT1__deleteFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__deleteFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__deleteFolderByRecordID:
		return (void*)soap_instantiate_TT1__deleteFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__addEntityToFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__addEntityToFolderByRecordID:
		return (void*)soap_instantiate_TT1__addEntityToFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__removeEntityFromFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordID:
		return (void*)soap_instantiate_TT1__removeEntityFromFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse:
		return (void*)soap_instantiate_TT1__getEntityListForFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordID:
		return (void*)soap_instantiate_TT1__getEntityListForFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolderPathSeparatorResponse:
		return (void*)soap_instantiate_TT1__getFolderPathSeparatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getFolderPathSeparator:
		return (void*)soap_instantiate_TT1__getFolderPathSeparator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRootPublicFolderPathResponse:
		return (void*)soap_instantiate_TT1__getRootPublicFolderPathResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRootPublicFolderPath:
		return (void*)soap_instantiate_TT1__getRootPublicFolderPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRootPrivateFolderPathResponse:
		return (void*)soap_instantiate_TT1__getRootPrivateFolderPathResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TT1__getRootPrivateFolderPath:
		return (void*)soap_instantiate_TT1__getRootPrivateFolderPath(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDatabase:
		if (p->size < 0)
			delete (TT1__CDatabase*)p->ptr;
		else
			delete[] (TT1__CDatabase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CProjectDataOption:
		if (p->size < 0)
			delete (TT1__CProjectDataOption*)p->ptr;
		else
			delete[] (TT1__CProjectDataOption*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CProject:
		if (p->size < 0)
			delete (TT1__CProject*)p->ptr;
		else
			delete[] (TT1__CProject*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDatabaseTable:
		if (p->size < 0)
			delete (TT1__CDatabaseTable*)p->ptr;
		else
			delete[] (TT1__CDatabaseTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTableField:
		if (p->size < 0)
			delete (TT1__CTableField*)p->ptr;
		else
			delete[] (TT1__CTableField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CFieldValue:
		if (p->size < 0)
			delete (TT1__CFieldValue*)p->ptr;
		else
			delete[] (TT1__CFieldValue*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTableColumn:
		if (p->size < 0)
			delete (TT1__CTableColumn*)p->ptr;
		else
			delete[] (TT1__CTableColumn*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CFilter:
		if (p->size < 0)
			delete (TT1__CFilter*)p->ptr;
		else
			delete[] (TT1__CFilter*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CRecordData:
		if (p->size < 0)
			delete (TT1__CRecordData*)p->ptr;
		else
			delete[] (TT1__CRecordData*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CRecordRowSoap:
		if (p->size < 0)
			delete (TT1__CRecordRowSoap*)p->ptr;
		else
			delete[] (TT1__CRecordRowSoap*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CRecordListSoap:
		if (p->size < 0)
			delete (TT1__CRecordListSoap*)p->ptr;
		else
			delete[] (TT1__CRecordListSoap*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CItemWithDBRecordId:
		if (p->size < 0)
			delete (TT1__CItemWithDBRecordId*)p->ptr;
		else
			delete[] (TT1__CItemWithDBRecordId*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CFileAttachment:
		if (p->size < 0)
			delete (TT1__CFileAttachment*)p->ptr;
		else
			delete[] (TT1__CFileAttachment*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CEventDefinition:
		if (p->size < 0)
			delete (TT1__CEventDefinition*)p->ptr;
		else
			delete[] (TT1__CEventDefinition*)p->ptr;
		break;
	case SOAP_TYPE_TT1__PhoneNumber:
		if (p->size < 0)
			delete (TT1__PhoneNumber*)p->ptr;
		else
			delete[] (TT1__PhoneNumber*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CGlobalUser:
		if (p->size < 0)
			delete (TT1__CGlobalUser*)p->ptr;
		else
			delete[] (TT1__CGlobalUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CUserLicense:
		if (p->size < 0)
			delete (TT1__CUserLicense*)p->ptr;
		else
			delete[] (TT1__CUserLicense*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfstring:
		if (p->size < 0)
			delete (TT1ArrayOfstring*)p->ptr;
		else
			delete[] (TT1ArrayOfstring*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCDatabase:
		if (p->size < 0)
			delete (TT1ArrayOfCDatabase*)p->ptr;
		else
			delete[] (TT1ArrayOfCDatabase*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCProjectDataOption:
		if (p->size < 0)
			delete (TT1ArrayOfCProjectDataOption*)p->ptr;
		else
			delete[] (TT1ArrayOfCProjectDataOption*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCProject:
		if (p->size < 0)
			delete (TT1ArrayOfCProject*)p->ptr;
		else
			delete[] (TT1ArrayOfCProject*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCDatabaseTable:
		if (p->size < 0)
			delete (TT1ArrayOfCDatabaseTable*)p->ptr;
		else
			delete[] (TT1ArrayOfCDatabaseTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCTableField:
		if (p->size < 0)
			delete (TT1ArrayOfCTableField*)p->ptr;
		else
			delete[] (TT1ArrayOfCTableField*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCFieldValue:
		if (p->size < 0)
			delete (TT1ArrayOfCFieldValue*)p->ptr;
		else
			delete[] (TT1ArrayOfCFieldValue*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCTableColumn:
		if (p->size < 0)
			delete (TT1ArrayOfCTableColumn*)p->ptr;
		else
			delete[] (TT1ArrayOfCTableColumn*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCFilter:
		if (p->size < 0)
			delete (TT1ArrayOfCFilter*)p->ptr;
		else
			delete[] (TT1ArrayOfCFilter*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCRecordData:
		if (p->size < 0)
			delete (TT1ArrayOfCRecordData*)p->ptr;
		else
			delete[] (TT1ArrayOfCRecordData*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCRecordRowSoap:
		if (p->size < 0)
			delete (TT1ArrayOfCRecordRowSoap*)p->ptr;
		else
			delete[] (TT1ArrayOfCRecordRowSoap*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CItemToTrack:
		if (p->size < 0)
			delete (TT1__CItemToTrack*)p->ptr;
		else
			delete[] (TT1__CItemToTrack*)p->ptr;
		break;
	case SOAP_TYPE_TT1__COrderedItemWithDBRecordId:
		if (p->size < 0)
			delete (TT1__COrderedItemWithDBRecordId*)p->ptr;
		else
			delete[] (TT1__COrderedItemWithDBRecordId*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CSCCFileRecord:
		if (p->size < 0)
			delete (TT1__CSCCFileRecord*)p->ptr;
		else
			delete[] (TT1__CSCCFileRecord*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCSCCFileRecord:
		if (p->size < 0)
			delete (TT1ArrayOfCSCCFileRecord*)p->ptr;
		else
			delete[] (TT1ArrayOfCSCCFileRecord*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCFileAttachment:
		if (p->size < 0)
			delete (TT1ArrayOfCFileAttachment*)p->ptr;
		else
			delete[] (TT1ArrayOfCFileAttachment*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CReportedByRecord:
		if (p->size < 0)
			delete (TT1__CReportedByRecord*)p->ptr;
		else
			delete[] (TT1__CReportedByRecord*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCReportedByRecord:
		if (p->size < 0)
			delete (TT1ArrayOfCReportedByRecord*)p->ptr;
		else
			delete[] (TT1ArrayOfCReportedByRecord*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CField:
		if (p->size < 0)
			delete (TT1__CField*)p->ptr;
		else
			delete[] (TT1__CField*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCField:
		if (p->size < 0)
			delete (TT1ArrayOfCField*)p->ptr;
		else
			delete[] (TT1ArrayOfCField*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCTestRunVariantField:
		if (p->size < 0)
			delete (TT1ArrayOfCTestRunVariantField*)p->ptr;
		else
			delete[] (TT1ArrayOfCTestRunVariantField*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCTestCaseVariantField:
		if (p->size < 0)
			delete (TT1ArrayOfCTestCaseVariantField*)p->ptr;
		else
			delete[] (TT1ArrayOfCTestCaseVariantField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CEvent:
		if (p->size < 0)
			delete (TT1__CEvent*)p->ptr;
		else
			delete[] (TT1__CEvent*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCEvent:
		if (p->size < 0)
			delete (TT1ArrayOfCEvent*)p->ptr;
		else
			delete[] (TT1ArrayOfCEvent*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCDefectEvent:
		if (p->size < 0)
			delete (TT1ArrayOfCDefectEvent*)p->ptr;
		else
			delete[] (TT1ArrayOfCDefectEvent*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCEventDefinition:
		if (p->size < 0)
			delete (TT1ArrayOfCEventDefinition*)p->ptr;
		else
			delete[] (TT1ArrayOfCEventDefinition*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDefectEventDefinition:
		if (p->size < 0)
			delete (TT1__CDefectEventDefinition*)p->ptr;
		else
			delete[] (TT1__CDefectEventDefinition*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCDefectEventDefinition:
		if (p->size < 0)
			delete (TT1ArrayOfCDefectEventDefinition*)p->ptr;
		else
			delete[] (TT1ArrayOfCDefectEventDefinition*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCGlobalUser:
		if (p->size < 0)
			delete (TT1ArrayOfCGlobalUser*)p->ptr;
		else
			delete[] (TT1ArrayOfCGlobalUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCUserLicense:
		if (p->size < 0)
			delete (TT1ArrayOfCUserLicense*)p->ptr;
		else
			delete[] (TT1ArrayOfCUserLicense*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCLinkedItem:
		if (p->size < 0)
			delete (TT1ArrayOfCLinkedItem*)p->ptr;
		else
			delete[] (TT1ArrayOfCLinkedItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCLinkHistoryItem:
		if (p->size < 0)
			delete (TT1ArrayOfCLinkHistoryItem*)p->ptr;
		else
			delete[] (TT1ArrayOfCLinkHistoryItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCLink:
		if (p->size < 0)
			delete (TT1ArrayOfCLink*)p->ptr;
		else
			delete[] (TT1ArrayOfCLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCItemToTrack:
		if (p->size < 0)
			delete (TT1ArrayOfCItemToTrack*)p->ptr;
		else
			delete[] (TT1ArrayOfCItemToTrack*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CFolderItem:
		if (p->size < 0)
			delete (TT1__CFolderItem*)p->ptr;
		else
			delete[] (TT1__CFolderItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCFolder:
		if (p->size < 0)
			delete (TT1ArrayOfCFolder*)p->ptr;
		else
			delete[] (TT1ArrayOfCFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1ArrayOfCFolderItem:
		if (p->size < 0)
			delete (TT1ArrayOfCFolderItem*)p->ptr;
		else
			delete[] (TT1ArrayOfCFolderItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CSystemBase:
		if (p->size < 0)
			delete (TT1__CSystemBase*)p->ptr;
		else
			delete[] (TT1__CSystemBase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CStringField:
		if (p->size < 0)
			delete (TT1__CStringField*)p->ptr;
		else
			delete[] (TT1__CStringField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CIntegerField:
		if (p->size < 0)
			delete (TT1__CIntegerField*)p->ptr;
		else
			delete[] (TT1__CIntegerField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDecimalField:
		if (p->size < 0)
			delete (TT1__CDecimalField*)p->ptr;
		else
			delete[] (TT1__CDecimalField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CBooleanField:
		if (p->size < 0)
			delete (TT1__CBooleanField*)p->ptr;
		else
			delete[] (TT1__CBooleanField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDateField:
		if (p->size < 0)
			delete (TT1__CDateField*)p->ptr;
		else
			delete[] (TT1__CDateField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDateTimeField:
		if (p->size < 0)
			delete (TT1__CDateTimeField*)p->ptr;
		else
			delete[] (TT1__CDateTimeField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDropdownField:
		if (p->size < 0)
			delete (TT1__CDropdownField*)p->ptr;
		else
			delete[] (TT1__CDropdownField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CMultiSelectDropdownField:
		if (p->size < 0)
			delete (TT1__CMultiSelectDropdownField*)p->ptr;
		else
			delete[] (TT1__CMultiSelectDropdownField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CVersionField:
		if (p->size < 0)
			delete (TT1__CVersionField*)p->ptr;
		else
			delete[] (TT1__CVersionField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDefectEvent:
		if (p->size < 0)
			delete (TT1__CDefectEvent*)p->ptr;
		else
			delete[] (TT1__CDefectEvent*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CDefect:
		if (p->size < 0)
			delete (TT1__CDefect*)p->ptr;
		else
			delete[] (TT1__CDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTask:
		if (p->size < 0)
			delete (TT1__CTask*)p->ptr;
		else
			delete[] (TT1__CTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CUser:
		if (p->size < 0)
			delete (TT1__CUser*)p->ptr;
		else
			delete[] (TT1__CUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CLinkedItem:
		if (p->size < 0)
			delete (TT1__CLinkedItem*)p->ptr;
		else
			delete[] (TT1__CLinkedItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CLinkHistoryItem:
		if (p->size < 0)
			delete (TT1__CLinkHistoryItem*)p->ptr;
		else
			delete[] (TT1__CLinkHistoryItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CLink:
		if (p->size < 0)
			delete (TT1__CLink*)p->ptr;
		else
			delete[] (TT1__CLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTestCase:
		if (p->size < 0)
			delete (TT1__CTestCase*)p->ptr;
		else
			delete[] (TT1__CTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTestRun:
		if (p->size < 0)
			delete (TT1__CTestRun*)p->ptr;
		else
			delete[] (TT1__CTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CFolder:
		if (p->size < 0)
			delete (TT1__CFolder*)p->ptr;
		else
			delete[] (TT1__CFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CSystem:
		if (p->size < 0)
			delete (TT1__CSystem*)p->ptr;
		else
			delete[] (TT1__CSystem*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTestRunVariantField:
		if (p->size < 0)
			delete (TT1__CTestRunVariantField*)p->ptr;
		else
			delete[] (TT1__CTestRunVariantField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__CTestCaseVariantField:
		if (p->size < 0)
			delete (TT1__CTestCaseVariantField*)p->ptr;
		else
			delete[] (TT1__CTestCaseVariantField*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDatabaseListResponse:
		if (p->size < 0)
			delete (struct TT1__getDatabaseListResponse*)p->ptr;
		else
			delete[] (struct TT1__getDatabaseListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDatabaseList:
		if (p->size < 0)
			delete (struct TT1__getDatabaseList*)p->ptr;
		else
			delete[] (struct TT1__getDatabaseList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getProjectListResponse:
		if (p->size < 0)
			delete (struct TT1__getProjectListResponse*)p->ptr;
		else
			delete[] (struct TT1__getProjectListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getProjectList:
		if (p->size < 0)
			delete (struct TT1__getProjectList*)p->ptr;
		else
			delete[] (struct TT1__getProjectList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getProjectDataOptionListResponse:
		if (p->size < 0)
			delete (struct TT1__getProjectDataOptionListResponse*)p->ptr;
		else
			delete[] (struct TT1__getProjectDataOptionListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getProjectDataOptionList:
		if (p->size < 0)
			delete (struct TT1__getProjectDataOptionList*)p->ptr;
		else
			delete[] (struct TT1__getProjectDataOptionList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__DatabaseLogonResponse:
		if (p->size < 0)
			delete (struct TT1__DatabaseLogonResponse*)p->ptr;
		else
			delete[] (struct TT1__DatabaseLogonResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__DatabaseLogon:
		if (p->size < 0)
			delete (struct TT1__DatabaseLogon*)p->ptr;
		else
			delete[] (struct TT1__DatabaseLogon*)p->ptr;
		break;
	case SOAP_TYPE_TT1__ProjectLogonResponse:
		if (p->size < 0)
			delete (struct TT1__ProjectLogonResponse*)p->ptr;
		else
			delete[] (struct TT1__ProjectLogonResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__ProjectLogon:
		if (p->size < 0)
			delete (struct TT1__ProjectLogon*)p->ptr;
		else
			delete[] (struct TT1__ProjectLogon*)p->ptr;
		break;
	case SOAP_TYPE_TT1__DatabaseLogoffResponse:
		if (p->size < 0)
			delete (struct TT1__DatabaseLogoffResponse*)p->ptr;
		else
			delete[] (struct TT1__DatabaseLogoffResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__DatabaseLogoff:
		if (p->size < 0)
			delete (struct TT1__DatabaseLogoff*)p->ptr;
		else
			delete[] (struct TT1__DatabaseLogoff*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTableListResponse:
		if (p->size < 0)
			delete (struct TT1__getTableListResponse*)p->ptr;
		else
			delete[] (struct TT1__getTableListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTableList:
		if (p->size < 0)
			delete (struct TT1__getTableList*)p->ptr;
		else
			delete[] (struct TT1__getTableList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDropdownFieldForTableResponse:
		if (p->size < 0)
			delete (struct TT1__getDropdownFieldForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__getDropdownFieldForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDropdownFieldForTable:
		if (p->size < 0)
			delete (struct TT1__getDropdownFieldForTable*)p->ptr;
		else
			delete[] (struct TT1__getDropdownFieldForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse:
		if (p->size < 0)
			delete (struct TT1__getDropdownFieldValuesForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__getDropdownFieldValuesForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDropdownFieldValuesForTable:
		if (p->size < 0)
			delete (struct TT1__getDropdownFieldValuesForTable*)p->ptr;
		else
			delete[] (struct TT1__getDropdownFieldValuesForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse:
		if (p->size < 0)
			delete (struct TT1__addDropdownFieldValuesForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__addDropdownFieldValuesForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDropdownFieldValuesForTable:
		if (p->size < 0)
			delete (struct TT1__addDropdownFieldValuesForTable*)p->ptr;
		else
			delete[] (struct TT1__addDropdownFieldValuesForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse:
		if (p->size < 0)
			delete (struct TT1__GetLinkDefinitionValuesResponse*)p->ptr;
		else
			delete[] (struct TT1__GetLinkDefinitionValuesResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__GetLinkDefinitionValues:
		if (p->size < 0)
			delete (struct TT1__GetLinkDefinitionValues*)p->ptr;
		else
			delete[] (struct TT1__GetLinkDefinitionValues*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getColumnsForTableResponse:
		if (p->size < 0)
			delete (struct TT1__getColumnsForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__getColumnsForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getColumnsForTable:
		if (p->size < 0)
			delete (struct TT1__getColumnsForTable*)p->ptr;
		else
			delete[] (struct TT1__getColumnsForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFilterListResponse:
		if (p->size < 0)
			delete (struct TT1__getFilterListResponse*)p->ptr;
		else
			delete[] (struct TT1__getFilterListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFilterList:
		if (p->size < 0)
			delete (struct TT1__getFilterList*)p->ptr;
		else
			delete[] (struct TT1__getFilterList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFilterListForTableResponse:
		if (p->size < 0)
			delete (struct TT1__getFilterListForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__getFilterListForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFilterListForTable:
		if (p->size < 0)
			delete (struct TT1__getFilterListForTable*)p->ptr;
		else
			delete[] (struct TT1__getFilterListForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRecordListForTableResponse:
		if (p->size < 0)
			delete (struct TT1__getRecordListForTableResponse*)p->ptr;
		else
			delete[] (struct TT1__getRecordListForTableResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRecordListForTable:
		if (p->size < 0)
			delete (struct TT1__getRecordListForTable*)p->ptr;
		else
			delete[] (struct TT1__getRecordListForTable*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__getTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestConfig:
		if (p->size < 0)
			delete (struct TT1__getTestConfig*)p->ptr;
		else
			delete[] (struct TT1__getTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestConfigByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getTestConfigByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestConfigByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestConfigByRecordID:
		if (p->size < 0)
			delete (struct TT1__getTestConfigByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getTestConfigByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__addTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__addTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTestConfig:
		if (p->size < 0)
			delete (struct TT1__addTestConfig*)p->ptr;
		else
			delete[] (struct TT1__addTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__editTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestConfig:
		if (p->size < 0)
			delete (struct TT1__editTestConfig*)p->ptr;
		else
			delete[] (struct TT1__editTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestConfigByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editTestConfigByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestConfigByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestConfigByRecordID:
		if (p->size < 0)
			delete (struct TT1__editTestConfigByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editTestConfigByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__saveTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__saveTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestConfig:
		if (p->size < 0)
			delete (struct TT1__saveTestConfig*)p->ptr;
		else
			delete[] (struct TT1__saveTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestConfig:
		if (p->size < 0)
			delete (struct TT1__deleteTestConfig*)p->ptr;
		else
			delete[] (struct TT1__deleteTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestConfigByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestConfigByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestConfigByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteTestConfigByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteTestConfigByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestConfigResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestConfigResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestConfig:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestConfig*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestConfig*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getAttachmentTypesResponse:
		if (p->size < 0)
			delete (struct TT1__getAttachmentTypesResponse*)p->ptr;
		else
			delete[] (struct TT1__getAttachmentTypesResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getAttachmentTypes:
		if (p->size < 0)
			delete (struct TT1__getAttachmentTypes*)p->ptr;
		else
			delete[] (struct TT1__getAttachmentTypes*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getEventDefinitionListResponse:
		if (p->size < 0)
			delete (struct TT1__getEventDefinitionListResponse*)p->ptr;
		else
			delete[] (struct TT1__getEventDefinitionListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getEventDefinitionList:
		if (p->size < 0)
			delete (struct TT1__getEventDefinitionList*)p->ptr;
		else
			delete[] (struct TT1__getEventDefinitionList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectEventDefinitionListResponse:
		if (p->size < 0)
			delete (struct TT1__getDefectEventDefinitionListResponse*)p->ptr;
		else
			delete[] (struct TT1__getDefectEventDefinitionListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectEventDefinitionList:
		if (p->size < 0)
			delete (struct TT1__getDefectEventDefinitionList*)p->ptr;
		else
			delete[] (struct TT1__getDefectEventDefinitionList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse:
		if (p->size < 0)
			delete (struct TT1__getCustomFieldsDefinitionListResponse*)p->ptr;
		else
			delete[] (struct TT1__getCustomFieldsDefinitionListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomFieldsDefinitionList:
		if (p->size < 0)
			delete (struct TT1__getCustomFieldsDefinitionList*)p->ptr;
		else
			delete[] (struct TT1__getCustomFieldsDefinitionList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse:
		if (p->size < 0)
			delete (struct TT1__getDefectCustomFieldsDefinitionListResponse*)p->ptr;
		else
			delete[] (struct TT1__getDefectCustomFieldsDefinitionListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList:
		if (p->size < 0)
			delete (struct TT1__getDefectCustomFieldsDefinitionList*)p->ptr;
		else
			delete[] (struct TT1__getDefectCustomFieldsDefinitionList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectResponse:
		if (p->size < 0)
			delete (struct TT1__getDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__getDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefect:
		if (p->size < 0)
			delete (struct TT1__getDefect*)p->ptr;
		else
			delete[] (struct TT1__getDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getDefectByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getDefectByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectByRecordID:
		if (p->size < 0)
			delete (struct TT1__getDefectByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getDefectByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDefectResponse:
		if (p->size < 0)
			delete (struct TT1__addDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__addDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDefect:
		if (p->size < 0)
			delete (struct TT1__addDefect*)p->ptr;
		else
			delete[] (struct TT1__addDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDefectWithLinkResponse:
		if (p->size < 0)
			delete (struct TT1__addDefectWithLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__addDefectWithLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addDefectWithLink:
		if (p->size < 0)
			delete (struct TT1__addDefectWithLink*)p->ptr;
		else
			delete[] (struct TT1__addDefectWithLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteDefectResponse:
		if (p->size < 0)
			delete (struct TT1__deleteDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteDefect:
		if (p->size < 0)
			delete (struct TT1__deleteDefect*)p->ptr;
		else
			delete[] (struct TT1__deleteDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteDefectByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteDefectByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteDefectByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteDefectByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteDefectByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteDefectByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editDefectResponse:
		if (p->size < 0)
			delete (struct TT1__editDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__editDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editDefect:
		if (p->size < 0)
			delete (struct TT1__editDefect*)p->ptr;
		else
			delete[] (struct TT1__editDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editDefectByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editDefectByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editDefectByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editDefectByRecordID:
		if (p->size < 0)
			delete (struct TT1__editDefectByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editDefectByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveDefectResponse:
		if (p->size < 0)
			delete (struct TT1__saveDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__saveDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveDefect:
		if (p->size < 0)
			delete (struct TT1__saveDefect*)p->ptr;
		else
			delete[] (struct TT1__saveDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveDefectResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveDefect:
		if (p->size < 0)
			delete (struct TT1__cancelSaveDefect*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getAttachmentResponse:
		if (p->size < 0)
			delete (struct TT1__getAttachmentResponse*)p->ptr;
		else
			delete[] (struct TT1__getAttachmentResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getAttachment:
		if (p->size < 0)
			delete (struct TT1__getAttachment*)p->ptr;
		else
			delete[] (struct TT1__getAttachment*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectAttachmentResponse:
		if (p->size < 0)
			delete (struct TT1__getDefectAttachmentResponse*)p->ptr;
		else
			delete[] (struct TT1__getDefectAttachmentResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getDefectAttachment:
		if (p->size < 0)
			delete (struct TT1__getDefectAttachment*)p->ptr;
		else
			delete[] (struct TT1__getDefectAttachment*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTaskResponse:
		if (p->size < 0)
			delete (struct TT1__getTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__getTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTask:
		if (p->size < 0)
			delete (struct TT1__getTask*)p->ptr;
		else
			delete[] (struct TT1__getTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTaskByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getTaskByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getTaskByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTaskByRecordID:
		if (p->size < 0)
			delete (struct TT1__getTaskByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getTaskByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTaskResponse:
		if (p->size < 0)
			delete (struct TT1__addTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__addTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTask:
		if (p->size < 0)
			delete (struct TT1__addTask*)p->ptr;
		else
			delete[] (struct TT1__addTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTaskResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTask:
		if (p->size < 0)
			delete (struct TT1__deleteTask*)p->ptr;
		else
			delete[] (struct TT1__deleteTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTaskByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTaskByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTaskByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTaskByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteTaskByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteTaskByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTaskResponse:
		if (p->size < 0)
			delete (struct TT1__editTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__editTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTask:
		if (p->size < 0)
			delete (struct TT1__editTask*)p->ptr;
		else
			delete[] (struct TT1__editTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTaskByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editTaskByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editTaskByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTaskByRecordID:
		if (p->size < 0)
			delete (struct TT1__editTaskByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editTaskByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTaskResponse:
		if (p->size < 0)
			delete (struct TT1__saveTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__saveTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTask:
		if (p->size < 0)
			delete (struct TT1__saveTask*)p->ptr;
		else
			delete[] (struct TT1__saveTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTaskResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTaskResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTask:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTask*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTask*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getGlobalUserListResponse:
		if (p->size < 0)
			delete (struct TT1__getGlobalUserListResponse*)p->ptr;
		else
			delete[] (struct TT1__getGlobalUserListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getGlobalUserList:
		if (p->size < 0)
			delete (struct TT1__getGlobalUserList*)p->ptr;
		else
			delete[] (struct TT1__getGlobalUserList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getGlobalCustomerListResponse:
		if (p->size < 0)
			delete (struct TT1__getGlobalCustomerListResponse*)p->ptr;
		else
			delete[] (struct TT1__getGlobalCustomerListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getGlobalCustomerList:
		if (p->size < 0)
			delete (struct TT1__getGlobalCustomerList*)p->ptr;
		else
			delete[] (struct TT1__getGlobalCustomerList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUserLicenseListResponse:
		if (p->size < 0)
			delete (struct TT1__getUserLicenseListResponse*)p->ptr;
		else
			delete[] (struct TT1__getUserLicenseListResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUserLicenseList:
		if (p->size < 0)
			delete (struct TT1__getUserLicenseList*)p->ptr;
		else
			delete[] (struct TT1__getUserLicenseList*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUserResponse:
		if (p->size < 0)
			delete (struct TT1__getUserResponse*)p->ptr;
		else
			delete[] (struct TT1__getUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUser:
		if (p->size < 0)
			delete (struct TT1__getUser*)p->ptr;
		else
			delete[] (struct TT1__getUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUserByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getUserByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getUserByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getUserByRecordID:
		if (p->size < 0)
			delete (struct TT1__getUserByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getUserByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addUserResponse:
		if (p->size < 0)
			delete (struct TT1__addUserResponse*)p->ptr;
		else
			delete[] (struct TT1__addUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addUser:
		if (p->size < 0)
			delete (struct TT1__addUser*)p->ptr;
		else
			delete[] (struct TT1__addUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editUserResponse:
		if (p->size < 0)
			delete (struct TT1__editUserResponse*)p->ptr;
		else
			delete[] (struct TT1__editUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editUser:
		if (p->size < 0)
			delete (struct TT1__editUser*)p->ptr;
		else
			delete[] (struct TT1__editUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editUserByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editUserByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editUserByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editUserByRecordID:
		if (p->size < 0)
			delete (struct TT1__editUserByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editUserByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveUserResponse:
		if (p->size < 0)
			delete (struct TT1__saveUserResponse*)p->ptr;
		else
			delete[] (struct TT1__saveUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveUser:
		if (p->size < 0)
			delete (struct TT1__saveUser*)p->ptr;
		else
			delete[] (struct TT1__saveUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteUserResponse:
		if (p->size < 0)
			delete (struct TT1__deleteUserResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteUser:
		if (p->size < 0)
			delete (struct TT1__deleteUser*)p->ptr;
		else
			delete[] (struct TT1__deleteUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteUserByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteUserByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteUserByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteUserByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteUserByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteUserByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveUserResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveUserResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveUser:
		if (p->size < 0)
			delete (struct TT1__cancelSaveUser*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__promoteUserResponse:
		if (p->size < 0)
			delete (struct TT1__promoteUserResponse*)p->ptr;
		else
			delete[] (struct TT1__promoteUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__promoteUser:
		if (p->size < 0)
			delete (struct TT1__promoteUser*)p->ptr;
		else
			delete[] (struct TT1__promoteUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addGlobalUserResponse:
		if (p->size < 0)
			delete (struct TT1__addGlobalUserResponse*)p->ptr;
		else
			delete[] (struct TT1__addGlobalUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addGlobalUser:
		if (p->size < 0)
			delete (struct TT1__addGlobalUser*)p->ptr;
		else
			delete[] (struct TT1__addGlobalUser*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__getCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__getCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomer:
		if (p->size < 0)
			delete (struct TT1__getCustomer*)p->ptr;
		else
			delete[] (struct TT1__getCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomerByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getCustomerByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getCustomerByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getCustomerByRecordID:
		if (p->size < 0)
			delete (struct TT1__getCustomerByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getCustomerByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__addCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__addCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addCustomer:
		if (p->size < 0)
			delete (struct TT1__addCustomer*)p->ptr;
		else
			delete[] (struct TT1__addCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__editCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__editCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editCustomer:
		if (p->size < 0)
			delete (struct TT1__editCustomer*)p->ptr;
		else
			delete[] (struct TT1__editCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editCustomerByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editCustomerByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editCustomerByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editCustomerByRecordID:
		if (p->size < 0)
			delete (struct TT1__editCustomerByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editCustomerByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__saveCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__saveCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveCustomer:
		if (p->size < 0)
			delete (struct TT1__saveCustomer*)p->ptr;
		else
			delete[] (struct TT1__saveCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__deleteCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteCustomer:
		if (p->size < 0)
			delete (struct TT1__deleteCustomer*)p->ptr;
		else
			delete[] (struct TT1__deleteCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteCustomerByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteCustomerByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteCustomerByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteCustomerByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteCustomerByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveCustomer:
		if (p->size < 0)
			delete (struct TT1__cancelSaveCustomer*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__promoteCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__promoteCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__promoteCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__promoteCustomer:
		if (p->size < 0)
			delete (struct TT1__promoteCustomer*)p->ptr;
		else
			delete[] (struct TT1__promoteCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addGlobalCustomerResponse:
		if (p->size < 0)
			delete (struct TT1__addGlobalCustomerResponse*)p->ptr;
		else
			delete[] (struct TT1__addGlobalCustomerResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addGlobalCustomer:
		if (p->size < 0)
			delete (struct TT1__addGlobalCustomer*)p->ptr;
		else
			delete[] (struct TT1__addGlobalCustomer*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLinksForItemResponse:
		if (p->size < 0)
			delete (struct TT1__getLinksForItemResponse*)p->ptr;
		else
			delete[] (struct TT1__getLinksForItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLinksForItem:
		if (p->size < 0)
			delete (struct TT1__getLinksForItem*)p->ptr;
		else
			delete[] (struct TT1__getLinksForItem*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLinksForDefectResponse:
		if (p->size < 0)
			delete (struct TT1__getLinksForDefectResponse*)p->ptr;
		else
			delete[] (struct TT1__getLinksForDefectResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLinksForDefect:
		if (p->size < 0)
			delete (struct TT1__getLinksForDefect*)p->ptr;
		else
			delete[] (struct TT1__getLinksForDefect*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLinkResponse:
		if (p->size < 0)
			delete (struct TT1__getLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__getLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getLink:
		if (p->size < 0)
			delete (struct TT1__getLink*)p->ptr;
		else
			delete[] (struct TT1__getLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addLinkResponse:
		if (p->size < 0)
			delete (struct TT1__addLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__addLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addLink:
		if (p->size < 0)
			delete (struct TT1__addLink*)p->ptr;
		else
			delete[] (struct TT1__addLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteLinkResponse:
		if (p->size < 0)
			delete (struct TT1__deleteLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteLink:
		if (p->size < 0)
			delete (struct TT1__deleteLink*)p->ptr;
		else
			delete[] (struct TT1__deleteLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editLinkResponse:
		if (p->size < 0)
			delete (struct TT1__editLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__editLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editLink:
		if (p->size < 0)
			delete (struct TT1__editLink*)p->ptr;
		else
			delete[] (struct TT1__editLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveLinkResponse:
		if (p->size < 0)
			delete (struct TT1__saveLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__saveLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveLink:
		if (p->size < 0)
			delete (struct TT1__saveLink*)p->ptr;
		else
			delete[] (struct TT1__saveLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveLinkResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveLinkResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveLinkResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveLink:
		if (p->size < 0)
			delete (struct TT1__cancelSaveLink*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveLink*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestVariantTypesResponse:
		if (p->size < 0)
			delete (struct TT1__getTestVariantTypesResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestVariantTypesResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestVariantTypes:
		if (p->size < 0)
			delete (struct TT1__getTestVariantTypes*)p->ptr;
		else
			delete[] (struct TT1__getTestVariantTypes*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRunStepsModesResponse:
		if (p->size < 0)
			delete (struct TT1__getTestRunStepsModesResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestRunStepsModesResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRunStepsModes:
		if (p->size < 0)
			delete (struct TT1__getTestRunStepsModes*)p->ptr;
		else
			delete[] (struct TT1__getTestRunStepsModes*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__getTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestCase:
		if (p->size < 0)
			delete (struct TT1__getTestCase*)p->ptr;
		else
			delete[] (struct TT1__getTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestCaseByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getTestCaseByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestCaseByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestCaseByRecordID:
		if (p->size < 0)
			delete (struct TT1__getTestCaseByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getTestCaseByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__addTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__addTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addTestCase:
		if (p->size < 0)
			delete (struct TT1__addTestCase*)p->ptr;
		else
			delete[] (struct TT1__addTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestCase:
		if (p->size < 0)
			delete (struct TT1__deleteTestCase*)p->ptr;
		else
			delete[] (struct TT1__deleteTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestCaseByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestCaseByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestCaseByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteTestCaseByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteTestCaseByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__editTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestCase:
		if (p->size < 0)
			delete (struct TT1__editTestCase*)p->ptr;
		else
			delete[] (struct TT1__editTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestCaseByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editTestCaseByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestCaseByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestCaseByRecordID:
		if (p->size < 0)
			delete (struct TT1__editTestCaseByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editTestCaseByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__saveTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__saveTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestCase:
		if (p->size < 0)
			delete (struct TT1__saveTestCase*)p->ptr;
		else
			delete[] (struct TT1__saveTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestCaseResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestCaseResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestCaseResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestCase:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestCase*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestCase*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__getTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRun:
		if (p->size < 0)
			delete (struct TT1__getTestRun*)p->ptr;
		else
			delete[] (struct TT1__getTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRunByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getTestRunByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getTestRunByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getTestRunByRecordID:
		if (p->size < 0)
			delete (struct TT1__getTestRunByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getTestRunByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestRun:
		if (p->size < 0)
			delete (struct TT1__deleteTestRun*)p->ptr;
		else
			delete[] (struct TT1__deleteTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteTestRunByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteTestRunByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteTestRunByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteTestRunByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteTestRunByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__editTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestRun:
		if (p->size < 0)
			delete (struct TT1__editTestRun*)p->ptr;
		else
			delete[] (struct TT1__editTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestRunByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editTestRunByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editTestRunByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editTestRunByRecordID:
		if (p->size < 0)
			delete (struct TT1__editTestRunByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editTestRunByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__saveTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__saveTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveTestRun:
		if (p->size < 0)
			delete (struct TT1__saveTestRun*)p->ptr;
		else
			delete[] (struct TT1__saveTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveTestRun:
		if (p->size < 0)
			delete (struct TT1__cancelSaveTestRun*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__createDefectForTestRunResponse:
		if (p->size < 0)
			delete (struct TT1__createDefectForTestRunResponse*)p->ptr;
		else
			delete[] (struct TT1__createDefectForTestRunResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__createDefectForTestRun:
		if (p->size < 0)
			delete (struct TT1__createDefectForTestRun*)p->ptr;
		else
			delete[] (struct TT1__createDefectForTestRun*)p->ptr;
		break;
	case SOAP_TYPE_TT1__generateTestRunsResponse:
		if (p->size < 0)
			delete (struct TT1__generateTestRunsResponse*)p->ptr;
		else
			delete[] (struct TT1__generateTestRunsResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__generateTestRuns:
		if (p->size < 0)
			delete (struct TT1__generateTestRuns*)p->ptr;
		else
			delete[] (struct TT1__generateTestRuns*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addFolderResponse:
		if (p->size < 0)
			delete (struct TT1__addFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__addFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addFolder:
		if (p->size < 0)
			delete (struct TT1__addFolder*)p->ptr;
		else
			delete[] (struct TT1__addFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editFolderResponse:
		if (p->size < 0)
			delete (struct TT1__editFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__editFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editFolder:
		if (p->size < 0)
			delete (struct TT1__editFolder*)p->ptr;
		else
			delete[] (struct TT1__editFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__editFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__editFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__editFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__editFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__editFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveFolderResponse:
		if (p->size < 0)
			delete (struct TT1__saveFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__saveFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__saveFolder:
		if (p->size < 0)
			delete (struct TT1__saveFolder*)p->ptr;
		else
			delete[] (struct TT1__saveFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveFolderResponse:
		if (p->size < 0)
			delete (struct TT1__cancelSaveFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__cancelSaveFolder:
		if (p->size < 0)
			delete (struct TT1__cancelSaveFolder*)p->ptr;
		else
			delete[] (struct TT1__cancelSaveFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolderResponse:
		if (p->size < 0)
			delete (struct TT1__getFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__getFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolder:
		if (p->size < 0)
			delete (struct TT1__getFolder*)p->ptr;
		else
			delete[] (struct TT1__getFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__getFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteFolderResponse:
		if (p->size < 0)
			delete (struct TT1__deleteFolderResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteFolder:
		if (p->size < 0)
			delete (struct TT1__deleteFolder*)p->ptr;
		else
			delete[] (struct TT1__deleteFolder*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__deleteFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__deleteFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__deleteFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__deleteFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__deleteFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__addEntityToFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__addEntityToFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__addEntityToFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__addEntityToFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__addEntityToFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__removeEntityFromFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__removeEntityFromFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__removeEntityFromFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__removeEntityFromFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__removeEntityFromFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse:
		if (p->size < 0)
			delete (struct TT1__getEntityListForFolderByRecordIDResponse*)p->ptr;
		else
			delete[] (struct TT1__getEntityListForFolderByRecordIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getEntityListForFolderByRecordID:
		if (p->size < 0)
			delete (struct TT1__getEntityListForFolderByRecordID*)p->ptr;
		else
			delete[] (struct TT1__getEntityListForFolderByRecordID*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolderPathSeparatorResponse:
		if (p->size < 0)
			delete (struct TT1__getFolderPathSeparatorResponse*)p->ptr;
		else
			delete[] (struct TT1__getFolderPathSeparatorResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getFolderPathSeparator:
		if (p->size < 0)
			delete (struct TT1__getFolderPathSeparator*)p->ptr;
		else
			delete[] (struct TT1__getFolderPathSeparator*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRootPublicFolderPathResponse:
		if (p->size < 0)
			delete (struct TT1__getRootPublicFolderPathResponse*)p->ptr;
		else
			delete[] (struct TT1__getRootPublicFolderPathResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRootPublicFolderPath:
		if (p->size < 0)
			delete (struct TT1__getRootPublicFolderPath*)p->ptr;
		else
			delete[] (struct TT1__getRootPublicFolderPath*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRootPrivateFolderPathResponse:
		if (p->size < 0)
			delete (struct TT1__getRootPrivateFolderPathResponse*)p->ptr;
		else
			delete[] (struct TT1__getRootPrivateFolderPathResponse*)p->ptr;
		break;
	case SOAP_TYPE_TT1__getRootPrivateFolderPath:
		if (p->size < 0)
			delete (struct TT1__getRootPrivateFolderPath*)p->ptr;
		else
			delete[] (struct TT1__getRootPrivateFolderPath*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__byte(struct soap *soap, char *a)
{	soap_default_byte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void TT1ArrayOfCFolderItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCFolderItem::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCFolderItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CFolderItem(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCFolderItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCFolderItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCFolderItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCFolderItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCFolderItem(struct soap *soap, const char *tag, int id, const TT1ArrayOfCFolderItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CFolderItem", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFolderItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CFolderItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCFolderItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCFolderItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCFolderItem * SOAP_FMAC4 soap_get_TT1ArrayOfCFolderItem(struct soap *soap, TT1ArrayOfCFolderItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCFolderItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCFolderItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCFolderItem * SOAP_FMAC4 soap_in_TT1ArrayOfCFolderItem(struct soap *soap, const char *tag, TT1ArrayOfCFolderItem *a, const char *type)
{	int i, j;
	TT1__CFolderItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCFolderItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCFolderItem, sizeof(TT1ArrayOfCFolderItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CFolderItem **)soap_malloc(soap, sizeof(TT1__CFolderItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CFolderItem(soap, NULL, a->__ptritem + i, "TT1:CFolderItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CFolderItem **)soap_push_block(soap, sizeof(TT1__CFolderItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CFolderItem(soap, NULL, p, "TT1:CFolderItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CFolderItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCFolderItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCFolderItem, 0, sizeof(TT1ArrayOfCFolderItem), 0, soap_copy_TT1ArrayOfCFolderItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCFolderItem * SOAP_FMAC6 soap_new_TT1ArrayOfCFolderItem(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCFolderItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCFolderItem(struct soap *soap, TT1ArrayOfCFolderItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCFolderItem * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCFolderItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCFolderItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCFolderItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCFolderItem;
		if (size)
			*size = sizeof(TT1ArrayOfCFolderItem);
		((TT1ArrayOfCFolderItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCFolderItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCFolderItem);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCFolderItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCFolderItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCFolderItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCFolderItem %p -> %p\n", q, p));
	*(TT1ArrayOfCFolderItem*)p = *(TT1ArrayOfCFolderItem*)q;
}

void TT1ArrayOfCFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCFolder::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCFolder))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CFolder(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCFolder(struct soap *soap, const char *tag, int id, const TT1ArrayOfCFolder *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CFolder", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFolder);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CFolder(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCFolder(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCFolder * SOAP_FMAC4 soap_get_TT1ArrayOfCFolder(struct soap *soap, TT1ArrayOfCFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCFolder(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCFolder * SOAP_FMAC4 soap_in_TT1ArrayOfCFolder(struct soap *soap, const char *tag, TT1ArrayOfCFolder *a, const char *type)
{	int i, j;
	TT1__CFolder **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCFolder, sizeof(TT1ArrayOfCFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CFolder **)soap_malloc(soap, sizeof(TT1__CFolder *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CFolder(soap, NULL, a->__ptritem + i, "TT1:CFolder"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CFolder **)soap_push_block(soap, sizeof(TT1__CFolder *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CFolder(soap, NULL, p, "TT1:CFolder"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CFolder **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCFolder, 0, sizeof(TT1ArrayOfCFolder), 0, soap_copy_TT1ArrayOfCFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCFolder * SOAP_FMAC6 soap_new_TT1ArrayOfCFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCFolder(struct soap *soap, TT1ArrayOfCFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCFolder * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCFolder;
		if (size)
			*size = sizeof(TT1ArrayOfCFolder);
		((TT1ArrayOfCFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCFolder);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCFolder %p -> %p\n", q, p));
	*(TT1ArrayOfCFolder*)p = *(TT1ArrayOfCFolder*)q;
}

void TT1__CFolderItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CFolderItem::entitytablename);
	soap_default_LONG64(soap, &this->TT1__CFolderItem::entityrecordid);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CFolderItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CFolderItem::entitytablename);
	soap_embedded(soap, &this->TT1__CFolderItem::entityrecordid, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CFolderItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CFolderItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CFolderItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CFolderItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CFolderItem(struct soap *soap, const char *tag, int id, const TT1__CFolderItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CFolderItem), "TT1:CFolderItem"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "entitytablename", -1, &(a->TT1__CFolderItem::entitytablename), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityrecordid", -1, &(a->TT1__CFolderItem::entityrecordid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CFolderItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CFolderItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CFolderItem * SOAP_FMAC4 soap_get_TT1__CFolderItem(struct soap *soap, TT1__CFolderItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CFolderItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CFolderItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CFolderItem * SOAP_FMAC4 soap_in_TT1__CFolderItem(struct soap *soap, const char *tag, TT1__CFolderItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CFolderItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CFolderItem, sizeof(TT1__CFolderItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CFolderItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CFolderItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_entitytablename1 = 1, soap_flag_entityrecordid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_entitytablename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entitytablename", &(a->TT1__CFolderItem::entitytablename), "xsd:string"))
				{	soap_flag_entitytablename1--;
					continue;
				}
			if (soap_flag_entityrecordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityrecordid", &(a->TT1__CFolderItem::entityrecordid), "xsd:long"))
				{	soap_flag_entityrecordid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CFolderItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CFolderItem, 0, sizeof(TT1__CFolderItem), 0, soap_copy_TT1__CFolderItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_entitytablename1 > 0 || soap_flag_entityrecordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CFolderItem * SOAP_FMAC6 soap_new_TT1__CFolderItem(struct soap *soap, int n)
{	return soap_instantiate_TT1__CFolderItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CFolderItem(struct soap *soap, TT1__CFolderItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CFolderItem * SOAP_FMAC4 soap_instantiate_TT1__CFolderItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CFolderItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CFolderItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CFolderItem;
		if (size)
			*size = sizeof(TT1__CFolderItem);
		((TT1__CFolderItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CFolderItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CFolderItem);
		for (int i = 0; i < n; i++)
			((TT1__CFolderItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CFolderItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CFolderItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CFolderItem %p -> %p\n", q, p));
	*(TT1__CFolderItem*)p = *(TT1__CFolderItem*)q;
}

void TT1__CFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CFolder::createdbyuser = NULL;
	this->TT1__CFolder::ispublic = NULL;
	this->TT1__CFolder::modifiedbyuser = NULL;
	soap_default_string(soap, &this->TT1__CFolder::locationaddedfrom);
	this->TT1__CFolder::datetimecreated = NULL;
	this->TT1__CFolder::datetimemodified = NULL;
	soap_default_string(soap, &this->TT1__CFolder::name);
	soap_default_string(soap, &this->TT1__CFolder::description);
	soap_default_string(soap, &this->TT1__CFolder::path);
	this->TT1__CFolder::order = NULL;
	this->TT1__CFolder::parentid = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CFolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->TT1__CFolder::createdbyuser);
	soap_serialize_PointerTobool(soap, &this->TT1__CFolder::ispublic);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CFolder::modifiedbyuser);
	soap_serialize_string(soap, &this->TT1__CFolder::locationaddedfrom);
	soap_serialize_PointerTotime(soap, &this->TT1__CFolder::datetimecreated);
	soap_serialize_PointerTotime(soap, &this->TT1__CFolder::datetimemodified);
	soap_serialize_string(soap, &this->TT1__CFolder::name);
	soap_serialize_string(soap, &this->TT1__CFolder::description);
	soap_serialize_string(soap, &this->TT1__CFolder::path);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CFolder::order);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CFolder::parentid);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CFolder(struct soap *soap, const char *tag, int id, const TT1__CFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CFolder), "TT1:CFolder"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "createdbyuser", -1, &(a->TT1__CFolder::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ispublic", -1, &(a->TT1__CFolder::ispublic), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "modifiedbyuser", -1, &(a->TT1__CFolder::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->TT1__CFolder::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->TT1__CFolder::datetimecreated), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->TT1__CFolder::datetimemodified), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CFolder::name), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->TT1__CFolder::description), ""))
		return soap->error;
	if (soap_out_string(soap, "path", -1, &(a->TT1__CFolder::path), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "order", -1, &(a->TT1__CFolder::order), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parentid", -1, &(a->TT1__CFolder::parentid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CFolder(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CFolder * SOAP_FMAC4 soap_get_TT1__CFolder(struct soap *soap, TT1__CFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CFolder(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CFolder * SOAP_FMAC4 soap_in_TT1__CFolder(struct soap *soap, const char *tag, TT1__CFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CFolder, sizeof(TT1__CFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CFolder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_createdbyuser1 = 1, soap_flag_ispublic1 = 1, soap_flag_modifiedbyuser1 = 1, soap_flag_locationaddedfrom1 = 1, soap_flag_datetimecreated1 = 1, soap_flag_datetimemodified1 = 1, soap_flag_name1 = 1, soap_flag_description1 = 1, soap_flag_path1 = 1, soap_flag_order1 = 1, soap_flag_parentid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_createdbyuser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "createdbyuser", &(a->TT1__CFolder::createdbyuser), "xsd:long"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_ispublic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ispublic", &(a->TT1__CFolder::ispublic), "xsd:boolean"))
				{	soap_flag_ispublic1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "modifiedbyuser", &(a->TT1__CFolder::modifiedbyuser), "xsd:long"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->TT1__CFolder::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->TT1__CFolder::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->TT1__CFolder::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CFolder::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->TT1__CFolder::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &(a->TT1__CFolder::path), "xsd:string"))
				{	soap_flag_path1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "order", &(a->TT1__CFolder::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap_flag_parentid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parentid", &(a->TT1__CFolder::parentid), "xsd:long"))
				{	soap_flag_parentid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CFolder, 0, sizeof(TT1__CFolder), 0, soap_copy_TT1__CFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CFolder * SOAP_FMAC6 soap_new_TT1__CFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__CFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CFolder(struct soap *soap, TT1__CFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CFolder * SOAP_FMAC4 soap_instantiate_TT1__CFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CFolder;
		if (size)
			*size = sizeof(TT1__CFolder);
		((TT1__CFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CFolder);
		for (int i = 0; i < n; i++)
			((TT1__CFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CFolder %p -> %p\n", q, p));
	*(TT1__CFolder*)p = *(TT1__CFolder*)q;
}

void TT1ArrayOfCItemToTrack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCItemToTrack::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCItemToTrack))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CItemToTrack(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCItemToTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCItemToTrack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCItemToTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCItemToTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCItemToTrack(struct soap *soap, const char *tag, int id, const TT1ArrayOfCItemToTrack *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CItemToTrack", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCItemToTrack);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CItemToTrack(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCItemToTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCItemToTrack(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCItemToTrack * SOAP_FMAC4 soap_get_TT1ArrayOfCItemToTrack(struct soap *soap, TT1ArrayOfCItemToTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCItemToTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCItemToTrack(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCItemToTrack * SOAP_FMAC4 soap_in_TT1ArrayOfCItemToTrack(struct soap *soap, const char *tag, TT1ArrayOfCItemToTrack *a, const char *type)
{	int i, j;
	TT1__CItemToTrack **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCItemToTrack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCItemToTrack, sizeof(TT1ArrayOfCItemToTrack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CItemToTrack **)soap_malloc(soap, sizeof(TT1__CItemToTrack *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CItemToTrack(soap, NULL, a->__ptritem + i, "TT1:CItemToTrack"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CItemToTrack **)soap_push_block(soap, sizeof(TT1__CItemToTrack *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CItemToTrack(soap, NULL, p, "TT1:CItemToTrack"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CItemToTrack **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCItemToTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCItemToTrack, 0, sizeof(TT1ArrayOfCItemToTrack), 0, soap_copy_TT1ArrayOfCItemToTrack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCItemToTrack * SOAP_FMAC6 soap_new_TT1ArrayOfCItemToTrack(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCItemToTrack(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCItemToTrack(struct soap *soap, TT1ArrayOfCItemToTrack *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCItemToTrack * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCItemToTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCItemToTrack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCItemToTrack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCItemToTrack;
		if (size)
			*size = sizeof(TT1ArrayOfCItemToTrack);
		((TT1ArrayOfCItemToTrack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCItemToTrack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCItemToTrack);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCItemToTrack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCItemToTrack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCItemToTrack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCItemToTrack %p -> %p\n", q, p));
	*(TT1ArrayOfCItemToTrack*)p = *(TT1ArrayOfCItemToTrack*)q;
}

void TT1__CTestRun::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CTestRun::testrunnumber = NULL;
	soap_default_string(soap, &this->TT1__CTestRun::summary);
	soap_default_string(soap, &this->TT1__CTestRun::state);
	soap_default_string(soap, &this->TT1__CTestRun::createdbyuser);
	this->TT1__CTestRun::datetimecreated = NULL;
	soap_default_string(soap, &this->TT1__CTestRun::locationaddedfrom);
	soap_default_string(soap, &this->TT1__CTestRun::modifiedbyuser);
	this->TT1__CTestRun::datetimemodified = NULL;
	this->TT1__CTestRun::customFieldList = NULL;
	this->TT1__CTestRun::eventlist = NULL;
	this->TT1__CTestRun::actualhours = NULL;
	this->TT1__CTestRun::estimatedhours = NULL;
	this->TT1__CTestRun::testcasenumber = NULL;
	this->TT1__CTestRun::testcaserecordid = NULL;
	soap_default_string(soap, &this->TT1__CTestRun::type);
	soap_default_string(soap, &this->TT1__CTestRun::testrunset);
	this->TT1__CTestRun::isautomated = NULL;
	soap_default_string(soap, &this->TT1__CTestRun::estimatedtime);
	soap_default_string(soap, &this->TT1__CTestRun::steps);
	soap_default_string(soap, &this->TT1__CTestRun::problemstatement);
	this->TT1__CTestRun::testVariants = NULL;
	this->TT1__CTestRun::attachmentlist = NULL;
	this->TT1__CTestRun::sccFileList = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CTestRun::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->TT1__CTestRun::testrunnumber);
	soap_serialize_string(soap, &this->TT1__CTestRun::summary);
	soap_serialize_string(soap, &this->TT1__CTestRun::state);
	soap_serialize_string(soap, &this->TT1__CTestRun::createdbyuser);
	soap_serialize_PointerTotime(soap, &this->TT1__CTestRun::datetimecreated);
	soap_serialize_string(soap, &this->TT1__CTestRun::locationaddedfrom);
	soap_serialize_string(soap, &this->TT1__CTestRun::modifiedbyuser);
	soap_serialize_PointerTotime(soap, &this->TT1__CTestRun::datetimemodified);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CTestRun::customFieldList);
	soap_serialize_PointerToTT1ArrayOfCEvent(soap, &this->TT1__CTestRun::eventlist);
	soap_serialize_PointerTodouble(soap, &this->TT1__CTestRun::actualhours);
	soap_serialize_PointerTodouble(soap, &this->TT1__CTestRun::estimatedhours);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CTestRun::testcasenumber);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CTestRun::testcaserecordid);
	soap_serialize_string(soap, &this->TT1__CTestRun::type);
	soap_serialize_string(soap, &this->TT1__CTestRun::testrunset);
	soap_serialize_PointerTobool(soap, &this->TT1__CTestRun::isautomated);
	soap_serialize_string(soap, &this->TT1__CTestRun::estimatedtime);
	soap_serialize_string(soap, &this->TT1__CTestRun::steps);
	soap_serialize_string(soap, &this->TT1__CTestRun::problemstatement);
	soap_serialize_PointerToTT1ArrayOfCTestCaseVariantField(soap, &this->TT1__CTestRun::testVariants);
	soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, &this->TT1__CTestRun::attachmentlist);
	soap_serialize_PointerToTT1ArrayOfCSCCFileRecord(soap, &this->TT1__CTestRun::sccFileList);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CTestRun::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTestRun);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTestRun::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTestRun(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTestRun(struct soap *soap, const char *tag, int id, const TT1__CTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTestRun), "TT1:CTestRun"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "testrunnumber", -1, &(a->TT1__CTestRun::testrunnumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->TT1__CTestRun::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->TT1__CTestRun::state), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->TT1__CTestRun::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->TT1__CTestRun::datetimecreated), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->TT1__CTestRun::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->TT1__CTestRun::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->TT1__CTestRun::datetimemodified), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFieldList", -1, &(a->TT1__CTestRun::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCEvent(soap, "eventlist", -1, &(a->TT1__CTestRun::eventlist), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhours", -1, &(a->TT1__CTestRun::actualhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->TT1__CTestRun::estimatedhours), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testcasenumber", -1, &(a->TT1__CTestRun::testcasenumber), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testcaserecordid", -1, &(a->TT1__CTestRun::testcaserecordid), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->TT1__CTestRun::type), ""))
		return soap->error;
	if (soap_out_string(soap, "testrunset", -1, &(a->TT1__CTestRun::testrunset), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isautomated", -1, &(a->TT1__CTestRun::isautomated), ""))
		return soap->error;
	if (soap_out_string(soap, "estimatedtime", -1, &(a->TT1__CTestRun::estimatedtime), ""))
		return soap->error;
	if (soap_out_string(soap, "steps", -1, &(a->TT1__CTestRun::steps), ""))
		return soap->error;
	if (soap_out_string(soap, "problemstatement", -1, &(a->TT1__CTestRun::problemstatement), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTestCaseVariantField(soap, "testVariants", -1, &(a->TT1__CTestRun::testVariants), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->TT1__CTestRun::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->TT1__CTestRun::sccFileList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CTestRun::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTestRun(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTestRun * SOAP_FMAC4 soap_get_TT1__CTestRun(struct soap *soap, TT1__CTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTestRun::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTestRun(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTestRun * SOAP_FMAC4 soap_in_TT1__CTestRun(struct soap *soap, const char *tag, TT1__CTestRun *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTestRun *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTestRun, sizeof(TT1__CTestRun), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTestRun)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTestRun *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_testrunnumber1 = 1, soap_flag_summary1 = 1, soap_flag_state1 = 1, soap_flag_createdbyuser1 = 1, soap_flag_datetimecreated1 = 1, soap_flag_locationaddedfrom1 = 1, soap_flag_modifiedbyuser1 = 1, soap_flag_datetimemodified1 = 1, soap_flag_customFieldList1 = 1, soap_flag_eventlist1 = 1, soap_flag_actualhours1 = 1, soap_flag_estimatedhours1 = 1, soap_flag_testcasenumber1 = 1, soap_flag_testcaserecordid1 = 1, soap_flag_type1 = 1, soap_flag_testrunset1 = 1, soap_flag_isautomated1 = 1, soap_flag_estimatedtime1 = 1, soap_flag_steps1 = 1, soap_flag_problemstatement1 = 1, soap_flag_testVariants1 = 1, soap_flag_attachmentlist1 = 1, soap_flag_sccFileList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_testrunnumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testrunnumber", &(a->TT1__CTestRun::testrunnumber), "xsd:long"))
				{	soap_flag_testrunnumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->TT1__CTestRun::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->TT1__CTestRun::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->TT1__CTestRun::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->TT1__CTestRun::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->TT1__CTestRun::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->TT1__CTestRun::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->TT1__CTestRun::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFieldList", &(a->TT1__CTestRun::customFieldList), "TT1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCEvent(soap, "eventlist", &(a->TT1__CTestRun::eventlist), "TT1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_actualhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhours", &(a->TT1__CTestRun::actualhours), "xsd:double"))
				{	soap_flag_actualhours1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->TT1__CTestRun::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_testcasenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcasenumber", &(a->TT1__CTestRun::testcasenumber), "xsd:long"))
				{	soap_flag_testcasenumber1--;
					continue;
				}
			if (soap_flag_testcaserecordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcaserecordid", &(a->TT1__CTestRun::testcaserecordid), "xsd:long"))
				{	soap_flag_testcaserecordid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->TT1__CTestRun::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_testrunset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testrunset", &(a->TT1__CTestRun::testrunset), "xsd:string"))
				{	soap_flag_testrunset1--;
					continue;
				}
			if (soap_flag_isautomated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isautomated", &(a->TT1__CTestRun::isautomated), "xsd:boolean"))
				{	soap_flag_isautomated1--;
					continue;
				}
			if (soap_flag_estimatedtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "estimatedtime", &(a->TT1__CTestRun::estimatedtime), "xsd:string"))
				{	soap_flag_estimatedtime1--;
					continue;
				}
			if (soap_flag_steps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "steps", &(a->TT1__CTestRun::steps), "xsd:string"))
				{	soap_flag_steps1--;
					continue;
				}
			if (soap_flag_problemstatement1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "problemstatement", &(a->TT1__CTestRun::problemstatement), "xsd:string"))
				{	soap_flag_problemstatement1--;
					continue;
				}
			if (soap_flag_testVariants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTestCaseVariantField(soap, "testVariants", &(a->TT1__CTestRun::testVariants), "TT1:CTestCaseVariantField"))
				{	soap_flag_testVariants1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", &(a->TT1__CTestRun::attachmentlist), "TT1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCSCCFileRecord(soap, "sccFileList", &(a->TT1__CTestRun::sccFileList), "TT1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTestRun, 0, sizeof(TT1__CTestRun), 0, soap_copy_TT1__CTestRun);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTestRun * SOAP_FMAC6 soap_new_TT1__CTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTestRun(struct soap *soap, TT1__CTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTestRun * SOAP_FMAC4 soap_instantiate_TT1__CTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTestRun;
		if (size)
			*size = sizeof(TT1__CTestRun);
		((TT1__CTestRun*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTestRun);
		for (int i = 0; i < n; i++)
			((TT1__CTestRun*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTestRun %p -> %p\n", q, p));
	*(TT1__CTestRun*)p = *(TT1__CTestRun*)q;
}

void TT1__CTestCase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CTestCase::testcasenumber = NULL;
	soap_default_string(soap, &this->TT1__CTestCase::summary);
	soap_default_string(soap, &this->TT1__CTestCase::state);
	soap_default_string(soap, &this->TT1__CTestCase::createdbyuser);
	this->TT1__CTestCase::datetimecreated = NULL;
	soap_default_string(soap, &this->TT1__CTestCase::locationaddedfrom);
	soap_default_string(soap, &this->TT1__CTestCase::modifiedbyuser);
	this->TT1__CTestCase::datetimemodified = NULL;
	this->TT1__CTestCase::customFieldList = NULL;
	this->TT1__CTestCase::eventlist = NULL;
	this->TT1__CTestCase::actualhours = NULL;
	this->TT1__CTestCase::estimatedhours = NULL;
	soap_default_string(soap, &this->TT1__CTestCase::type);
	soap_default_string(soap, &this->TT1__CTestCase::testrunstepsmode);
	this->TT1__CTestCase::isautomated = NULL;
	soap_default_string(soap, &this->TT1__CTestCase::estimatedtime);
	soap_default_string(soap, &this->TT1__CTestCase::steps);
	this->TT1__CTestCase::testVariants = NULL;
	this->TT1__CTestCase::attachmentlist = NULL;
	this->TT1__CTestCase::sccFileList = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CTestCase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->TT1__CTestCase::testcasenumber);
	soap_serialize_string(soap, &this->TT1__CTestCase::summary);
	soap_serialize_string(soap, &this->TT1__CTestCase::state);
	soap_serialize_string(soap, &this->TT1__CTestCase::createdbyuser);
	soap_serialize_PointerTotime(soap, &this->TT1__CTestCase::datetimecreated);
	soap_serialize_string(soap, &this->TT1__CTestCase::locationaddedfrom);
	soap_serialize_string(soap, &this->TT1__CTestCase::modifiedbyuser);
	soap_serialize_PointerTotime(soap, &this->TT1__CTestCase::datetimemodified);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CTestCase::customFieldList);
	soap_serialize_PointerToTT1ArrayOfCEvent(soap, &this->TT1__CTestCase::eventlist);
	soap_serialize_PointerTodouble(soap, &this->TT1__CTestCase::actualhours);
	soap_serialize_PointerTodouble(soap, &this->TT1__CTestCase::estimatedhours);
	soap_serialize_string(soap, &this->TT1__CTestCase::type);
	soap_serialize_string(soap, &this->TT1__CTestCase::testrunstepsmode);
	soap_serialize_PointerTobool(soap, &this->TT1__CTestCase::isautomated);
	soap_serialize_string(soap, &this->TT1__CTestCase::estimatedtime);
	soap_serialize_string(soap, &this->TT1__CTestCase::steps);
	soap_serialize_PointerToTT1ArrayOfCTestCaseVariantField(soap, &this->TT1__CTestCase::testVariants);
	soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, &this->TT1__CTestCase::attachmentlist);
	soap_serialize_PointerToTT1ArrayOfCSCCFileRecord(soap, &this->TT1__CTestCase::sccFileList);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CTestCase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTestCase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTestCase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTestCase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTestCase(struct soap *soap, const char *tag, int id, const TT1__CTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTestCase), "TT1:CTestCase"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "testcasenumber", -1, &(a->TT1__CTestCase::testcasenumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->TT1__CTestCase::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->TT1__CTestCase::state), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->TT1__CTestCase::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->TT1__CTestCase::datetimecreated), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->TT1__CTestCase::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->TT1__CTestCase::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->TT1__CTestCase::datetimemodified), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFieldList", -1, &(a->TT1__CTestCase::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCEvent(soap, "eventlist", -1, &(a->TT1__CTestCase::eventlist), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhours", -1, &(a->TT1__CTestCase::actualhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->TT1__CTestCase::estimatedhours), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->TT1__CTestCase::type), ""))
		return soap->error;
	if (soap_out_string(soap, "testrunstepsmode", -1, &(a->TT1__CTestCase::testrunstepsmode), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isautomated", -1, &(a->TT1__CTestCase::isautomated), ""))
		return soap->error;
	if (soap_out_string(soap, "estimatedtime", -1, &(a->TT1__CTestCase::estimatedtime), ""))
		return soap->error;
	if (soap_out_string(soap, "steps", -1, &(a->TT1__CTestCase::steps), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTestCaseVariantField(soap, "testVariants", -1, &(a->TT1__CTestCase::testVariants), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->TT1__CTestCase::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->TT1__CTestCase::sccFileList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CTestCase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTestCase(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTestCase * SOAP_FMAC4 soap_get_TT1__CTestCase(struct soap *soap, TT1__CTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTestCase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTestCase(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTestCase * SOAP_FMAC4 soap_in_TT1__CTestCase(struct soap *soap, const char *tag, TT1__CTestCase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTestCase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTestCase, sizeof(TT1__CTestCase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTestCase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTestCase *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_testcasenumber1 = 1, soap_flag_summary1 = 1, soap_flag_state1 = 1, soap_flag_createdbyuser1 = 1, soap_flag_datetimecreated1 = 1, soap_flag_locationaddedfrom1 = 1, soap_flag_modifiedbyuser1 = 1, soap_flag_datetimemodified1 = 1, soap_flag_customFieldList1 = 1, soap_flag_eventlist1 = 1, soap_flag_actualhours1 = 1, soap_flag_estimatedhours1 = 1, soap_flag_type1 = 1, soap_flag_testrunstepsmode1 = 1, soap_flag_isautomated1 = 1, soap_flag_estimatedtime1 = 1, soap_flag_steps1 = 1, soap_flag_testVariants1 = 1, soap_flag_attachmentlist1 = 1, soap_flag_sccFileList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_testcasenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcasenumber", &(a->TT1__CTestCase::testcasenumber), "xsd:long"))
				{	soap_flag_testcasenumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->TT1__CTestCase::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->TT1__CTestCase::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->TT1__CTestCase::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->TT1__CTestCase::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->TT1__CTestCase::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->TT1__CTestCase::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->TT1__CTestCase::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFieldList", &(a->TT1__CTestCase::customFieldList), "TT1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCEvent(soap, "eventlist", &(a->TT1__CTestCase::eventlist), "TT1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_actualhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhours", &(a->TT1__CTestCase::actualhours), "xsd:double"))
				{	soap_flag_actualhours1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->TT1__CTestCase::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->TT1__CTestCase::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_testrunstepsmode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testrunstepsmode", &(a->TT1__CTestCase::testrunstepsmode), "xsd:string"))
				{	soap_flag_testrunstepsmode1--;
					continue;
				}
			if (soap_flag_isautomated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isautomated", &(a->TT1__CTestCase::isautomated), "xsd:boolean"))
				{	soap_flag_isautomated1--;
					continue;
				}
			if (soap_flag_estimatedtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "estimatedtime", &(a->TT1__CTestCase::estimatedtime), "xsd:string"))
				{	soap_flag_estimatedtime1--;
					continue;
				}
			if (soap_flag_steps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "steps", &(a->TT1__CTestCase::steps), "xsd:string"))
				{	soap_flag_steps1--;
					continue;
				}
			if (soap_flag_testVariants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTestCaseVariantField(soap, "testVariants", &(a->TT1__CTestCase::testVariants), "TT1:CTestCaseVariantField"))
				{	soap_flag_testVariants1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", &(a->TT1__CTestCase::attachmentlist), "TT1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCSCCFileRecord(soap, "sccFileList", &(a->TT1__CTestCase::sccFileList), "TT1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTestCase, 0, sizeof(TT1__CTestCase), 0, soap_copy_TT1__CTestCase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTestCase * SOAP_FMAC6 soap_new_TT1__CTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTestCase(struct soap *soap, TT1__CTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTestCase * SOAP_FMAC4 soap_instantiate_TT1__CTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTestCase;
		if (size)
			*size = sizeof(TT1__CTestCase);
		((TT1__CTestCase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTestCase);
		for (int i = 0; i < n; i++)
			((TT1__CTestCase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTestCase %p -> %p\n", q, p));
	*(TT1__CTestCase*)p = *(TT1__CTestCase*)q;
}

void TT1ArrayOfCLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCLink::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCLink))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CLink(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCLink);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCLink(struct soap *soap, const char *tag, int id, const TT1ArrayOfCLink *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CLink", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLink);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CLink(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCLink(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCLink * SOAP_FMAC4 soap_get_TT1ArrayOfCLink(struct soap *soap, TT1ArrayOfCLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCLink(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCLink * SOAP_FMAC4 soap_in_TT1ArrayOfCLink(struct soap *soap, const char *tag, TT1ArrayOfCLink *a, const char *type)
{	int i, j;
	TT1__CLink **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCLink, sizeof(TT1ArrayOfCLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CLink **)soap_malloc(soap, sizeof(TT1__CLink *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CLink(soap, NULL, a->__ptritem + i, "TT1:CLink"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CLink **)soap_push_block(soap, sizeof(TT1__CLink *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CLink(soap, NULL, p, "TT1:CLink"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CLink **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCLink, 0, sizeof(TT1ArrayOfCLink), 0, soap_copy_TT1ArrayOfCLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCLink * SOAP_FMAC6 soap_new_TT1ArrayOfCLink(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCLink(struct soap *soap, TT1ArrayOfCLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCLink * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCLink;
		if (size)
			*size = sizeof(TT1ArrayOfCLink);
		((TT1ArrayOfCLink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCLink);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCLink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCLink %p -> %p\n", q, p));
	*(TT1ArrayOfCLink*)p = *(TT1ArrayOfCLink*)q;
}

void TT1__CLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CLink::linkDefinitionName);
	soap_default_string(soap, &this->TT1__CLink::comment);
	this->TT1__CLink::linkbroken = NULL;
	this->TT1__CLink::linkparent = NULL;
	this->TT1__CLink::childList = NULL;
	this->TT1__CLink::historyList = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CLink::linkDefinitionName);
	soap_serialize_string(soap, &this->TT1__CLink::comment);
	soap_serialize_PointerTobool(soap, &this->TT1__CLink::linkbroken);
	soap_serialize_PointerToTT1__CLinkedItem(soap, &this->TT1__CLink::linkparent);
	soap_serialize_PointerToTT1ArrayOfCLinkedItem(soap, &this->TT1__CLink::childList);
	soap_serialize_PointerToTT1ArrayOfCLinkHistoryItem(soap, &this->TT1__CLink::historyList);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CLink);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CLink(struct soap *soap, const char *tag, int id, const TT1__CLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CLink), "TT1:CLink"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "linkDefinitionName", -1, &(a->TT1__CLink::linkDefinitionName), ""))
		return soap->error;
	if (soap_out_string(soap, "comment", -1, &(a->TT1__CLink::comment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "linkbroken", -1, &(a->TT1__CLink::linkbroken), ""))
		return soap->error;
	if (soap_out_PointerToTT1__CLinkedItem(soap, "linkparent", -1, &(a->TT1__CLink::linkparent), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCLinkedItem(soap, "childList", -1, &(a->TT1__CLink::childList), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCLinkHistoryItem(soap, "historyList", -1, &(a->TT1__CLink::historyList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CLink(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CLink * SOAP_FMAC4 soap_get_TT1__CLink(struct soap *soap, TT1__CLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CLink(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CLink * SOAP_FMAC4 soap_in_TT1__CLink(struct soap *soap, const char *tag, TT1__CLink *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CLink, sizeof(TT1__CLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CLink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CLink *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_linkDefinitionName1 = 1, soap_flag_comment1 = 1, soap_flag_linkbroken1 = 1, soap_flag_linkparent1 = 1, soap_flag_childList1 = 1, soap_flag_historyList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_linkDefinitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "linkDefinitionName", &(a->TT1__CLink::linkDefinitionName), "xsd:string"))
				{	soap_flag_linkDefinitionName1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comment", &(a->TT1__CLink::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap_flag_linkbroken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "linkbroken", &(a->TT1__CLink::linkbroken), "xsd:boolean"))
				{	soap_flag_linkbroken1--;
					continue;
				}
			if (soap_flag_linkparent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CLinkedItem(soap, "linkparent", &(a->TT1__CLink::linkparent), "TT1:CLinkedItem"))
				{	soap_flag_linkparent1--;
					continue;
				}
			if (soap_flag_childList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCLinkedItem(soap, "childList", &(a->TT1__CLink::childList), "TT1:CLinkedItem"))
				{	soap_flag_childList1--;
					continue;
				}
			if (soap_flag_historyList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCLinkHistoryItem(soap, "historyList", &(a->TT1__CLink::historyList), "TT1:CLinkHistoryItem"))
				{	soap_flag_historyList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CLink, 0, sizeof(TT1__CLink), 0, soap_copy_TT1__CLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_linkDefinitionName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CLink * SOAP_FMAC6 soap_new_TT1__CLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__CLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CLink(struct soap *soap, TT1__CLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CLink * SOAP_FMAC4 soap_instantiate_TT1__CLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CLink;
		if (size)
			*size = sizeof(TT1__CLink);
		((TT1__CLink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CLink);
		for (int i = 0; i < n; i++)
			((TT1__CLink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CLink %p -> %p\n", q, p));
	*(TT1__CLink*)p = *(TT1__CLink*)q;
}

void TT1ArrayOfCLinkHistoryItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCLinkHistoryItem::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CLinkHistoryItem(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCLinkHistoryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCLinkHistoryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCLinkHistoryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, int id, const TT1ArrayOfCLinkHistoryItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CLinkHistoryItem", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CLinkHistoryItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCLinkHistoryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCLinkHistoryItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkHistoryItem * SOAP_FMAC4 soap_get_TT1ArrayOfCLinkHistoryItem(struct soap *soap, TT1ArrayOfCLinkHistoryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCLinkHistoryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCLinkHistoryItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkHistoryItem * SOAP_FMAC4 soap_in_TT1ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, TT1ArrayOfCLinkHistoryItem *a, const char *type)
{	int i, j;
	TT1__CLinkHistoryItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCLinkHistoryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem, sizeof(TT1ArrayOfCLinkHistoryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CLinkHistoryItem **)soap_malloc(soap, sizeof(TT1__CLinkHistoryItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CLinkHistoryItem(soap, NULL, a->__ptritem + i, "TT1:CLinkHistoryItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CLinkHistoryItem **)soap_push_block(soap, sizeof(TT1__CLinkHistoryItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CLinkHistoryItem(soap, NULL, p, "TT1:CLinkHistoryItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CLinkHistoryItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCLinkHistoryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem, 0, sizeof(TT1ArrayOfCLinkHistoryItem), 0, soap_copy_TT1ArrayOfCLinkHistoryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCLinkHistoryItem * SOAP_FMAC6 soap_new_TT1ArrayOfCLinkHistoryItem(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCLinkHistoryItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCLinkHistoryItem(struct soap *soap, TT1ArrayOfCLinkHistoryItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCLinkHistoryItem * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCLinkHistoryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCLinkHistoryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCLinkHistoryItem;
		if (size)
			*size = sizeof(TT1ArrayOfCLinkHistoryItem);
		((TT1ArrayOfCLinkHistoryItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCLinkHistoryItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCLinkHistoryItem);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCLinkHistoryItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCLinkHistoryItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCLinkHistoryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCLinkHistoryItem %p -> %p\n", q, p));
	*(TT1ArrayOfCLinkHistoryItem*)p = *(TT1ArrayOfCLinkHistoryItem*)q;
}

void TT1__CLinkHistoryItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CLinkHistoryItem::date = NULL;
	soap_default_string(soap, &this->TT1__CLinkHistoryItem::firstname);
	soap_default_string(soap, &this->TT1__CLinkHistoryItem::lastname);
	soap_default_string(soap, &this->TT1__CLinkHistoryItem::history);
	soap_default_LONG64(soap, &this->TT1__COrderedItemWithDBRecordId::order);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CLinkHistoryItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->TT1__CLinkHistoryItem::date);
	soap_serialize_string(soap, &this->TT1__CLinkHistoryItem::firstname);
	soap_serialize_string(soap, &this->TT1__CLinkHistoryItem::lastname);
	soap_serialize_string(soap, &this->TT1__CLinkHistoryItem::history);
	soap_embedded(soap, &this->TT1__COrderedItemWithDBRecordId::order, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CLinkHistoryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CLinkHistoryItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CLinkHistoryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CLinkHistoryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, const TT1__CLinkHistoryItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CLinkHistoryItem), "TT1:CLinkHistoryItem"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_LONG64(soap, "order", -1, &(a->TT1__COrderedItemWithDBRecordId::order), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date", -1, &(a->TT1__CLinkHistoryItem::date), ""))
		return soap->error;
	if (soap_out_string(soap, "firstname", -1, &(a->TT1__CLinkHistoryItem::firstname), ""))
		return soap->error;
	if (soap_out_string(soap, "lastname", -1, &(a->TT1__CLinkHistoryItem::lastname), ""))
		return soap->error;
	if (soap_out_string(soap, "history", -1, &(a->TT1__CLinkHistoryItem::history), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CLinkHistoryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CLinkHistoryItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CLinkHistoryItem * SOAP_FMAC4 soap_get_TT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CLinkHistoryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CLinkHistoryItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CLinkHistoryItem * SOAP_FMAC4 soap_in_TT1__CLinkHistoryItem(struct soap *soap, const char *tag, TT1__CLinkHistoryItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CLinkHistoryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CLinkHistoryItem, sizeof(TT1__CLinkHistoryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CLinkHistoryItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CLinkHistoryItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_order2 = 1, soap_flag_date1 = 1, soap_flag_firstname1 = 1, soap_flag_lastname1 = 1, soap_flag_history1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->TT1__COrderedItemWithDBRecordId::order), "xsd:long"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date", &(a->TT1__CLinkHistoryItem::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_firstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstname", &(a->TT1__CLinkHistoryItem::firstname), "xsd:string"))
				{	soap_flag_firstname1--;
					continue;
				}
			if (soap_flag_lastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastname", &(a->TT1__CLinkHistoryItem::lastname), "xsd:string"))
				{	soap_flag_lastname1--;
					continue;
				}
			if (soap_flag_history1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "history", &(a->TT1__CLinkHistoryItem::history), "xsd:string"))
				{	soap_flag_history1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CLinkHistoryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CLinkHistoryItem, 0, sizeof(TT1__CLinkHistoryItem), 0, soap_copy_TT1__CLinkHistoryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_order2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CLinkHistoryItem * SOAP_FMAC6 soap_new_TT1__CLinkHistoryItem(struct soap *soap, int n)
{	return soap_instantiate_TT1__CLinkHistoryItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CLinkHistoryItem * SOAP_FMAC4 soap_instantiate_TT1__CLinkHistoryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CLinkHistoryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CLinkHistoryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CLinkHistoryItem;
		if (size)
			*size = sizeof(TT1__CLinkHistoryItem);
		((TT1__CLinkHistoryItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CLinkHistoryItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CLinkHistoryItem);
		for (int i = 0; i < n; i++)
			((TT1__CLinkHistoryItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CLinkHistoryItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CLinkHistoryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CLinkHistoryItem %p -> %p\n", q, p));
	*(TT1__CLinkHistoryItem*)p = *(TT1__CLinkHistoryItem*)q;
}

void TT1ArrayOfCLinkedItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCLinkedItem::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCLinkedItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CLinkedItem(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCLinkedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCLinkedItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCLinkedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCLinkedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCLinkedItem(struct soap *soap, const char *tag, int id, const TT1ArrayOfCLinkedItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CLinkedItem", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLinkedItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CLinkedItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCLinkedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCLinkedItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkedItem * SOAP_FMAC4 soap_get_TT1ArrayOfCLinkedItem(struct soap *soap, TT1ArrayOfCLinkedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCLinkedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCLinkedItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkedItem * SOAP_FMAC4 soap_in_TT1ArrayOfCLinkedItem(struct soap *soap, const char *tag, TT1ArrayOfCLinkedItem *a, const char *type)
{	int i, j;
	TT1__CLinkedItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCLinkedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCLinkedItem, sizeof(TT1ArrayOfCLinkedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CLinkedItem **)soap_malloc(soap, sizeof(TT1__CLinkedItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CLinkedItem(soap, NULL, a->__ptritem + i, "TT1:CLinkedItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CLinkedItem **)soap_push_block(soap, sizeof(TT1__CLinkedItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CLinkedItem(soap, NULL, p, "TT1:CLinkedItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CLinkedItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCLinkedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCLinkedItem, 0, sizeof(TT1ArrayOfCLinkedItem), 0, soap_copy_TT1ArrayOfCLinkedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCLinkedItem * SOAP_FMAC6 soap_new_TT1ArrayOfCLinkedItem(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCLinkedItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCLinkedItem(struct soap *soap, TT1ArrayOfCLinkedItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCLinkedItem * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCLinkedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCLinkedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCLinkedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCLinkedItem;
		if (size)
			*size = sizeof(TT1ArrayOfCLinkedItem);
		((TT1ArrayOfCLinkedItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCLinkedItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCLinkedItem);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCLinkedItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCLinkedItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCLinkedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCLinkedItem %p -> %p\n", q, p));
	*(TT1ArrayOfCLinkedItem*)p = *(TT1ArrayOfCLinkedItem*)q;
}

void TT1__CLinkedItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CLinkedItem::entityType = NULL;
	soap_default_string(soap, &this->TT1__CLinkedItem::tablename);
	soap_default_LONG64(soap, &this->TT1__CLinkedItem::entityID);
	soap_default_string(soap, &this->TT1__CLinkedItem::number);
	soap_default_string(soap, &this->TT1__CLinkedItem::summary);
	soap_default_string(soap, &this->TT1__CLinkedItem::status);
	soap_default_string(soap, &this->TT1__CLinkedItem::state);
	soap_default_LONG64(soap, &this->TT1__COrderedItemWithDBRecordId::order);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CLinkedItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->TT1__CLinkedItem::entityType);
	soap_serialize_string(soap, &this->TT1__CLinkedItem::tablename);
	soap_embedded(soap, &this->TT1__CLinkedItem::entityID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->TT1__CLinkedItem::number);
	soap_serialize_string(soap, &this->TT1__CLinkedItem::summary);
	soap_serialize_string(soap, &this->TT1__CLinkedItem::status);
	soap_serialize_string(soap, &this->TT1__CLinkedItem::state);
	soap_embedded(soap, &this->TT1__COrderedItemWithDBRecordId::order, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CLinkedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CLinkedItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CLinkedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CLinkedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CLinkedItem(struct soap *soap, const char *tag, int id, const TT1__CLinkedItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CLinkedItem), "TT1:CLinkedItem"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_LONG64(soap, "order", -1, &(a->TT1__COrderedItemWithDBRecordId::order), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "entityType", -1, &(a->TT1__CLinkedItem::entityType), ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &(a->TT1__CLinkedItem::tablename), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityID", -1, &(a->TT1__CLinkedItem::entityID), ""))
		return soap->error;
	if (soap_out_string(soap, "number", -1, &(a->TT1__CLinkedItem::number), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->TT1__CLinkedItem::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "status", -1, &(a->TT1__CLinkedItem::status), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->TT1__CLinkedItem::state), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CLinkedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CLinkedItem(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CLinkedItem * SOAP_FMAC4 soap_get_TT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CLinkedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CLinkedItem(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CLinkedItem * SOAP_FMAC4 soap_in_TT1__CLinkedItem(struct soap *soap, const char *tag, TT1__CLinkedItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CLinkedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CLinkedItem, sizeof(TT1__CLinkedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CLinkedItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CLinkedItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_order2 = 1, soap_flag_entityType1 = 1, soap_flag_tablename1 = 1, soap_flag_entityID1 = 1, soap_flag_number1 = 1, soap_flag_summary1 = 1, soap_flag_status1 = 1, soap_flag_state1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->TT1__COrderedItemWithDBRecordId::order), "xsd:long"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_entityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "entityType", &(a->TT1__CLinkedItem::entityType), "xsd:long"))
				{	soap_flag_entityType1--;
					continue;
				}
			if (soap_flag_tablename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &(a->TT1__CLinkedItem::tablename), "xsd:string"))
				{	soap_flag_tablename1--;
					continue;
				}
			if (soap_flag_entityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityID", &(a->TT1__CLinkedItem::entityID), "xsd:long"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "number", &(a->TT1__CLinkedItem::number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->TT1__CLinkedItem::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status", &(a->TT1__CLinkedItem::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->TT1__CLinkedItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CLinkedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CLinkedItem, 0, sizeof(TT1__CLinkedItem), 0, soap_copy_TT1__CLinkedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_order2 > 0 || soap_flag_tablename1 > 0 || soap_flag_entityID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CLinkedItem * SOAP_FMAC6 soap_new_TT1__CLinkedItem(struct soap *soap, int n)
{	return soap_instantiate_TT1__CLinkedItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CLinkedItem * SOAP_FMAC4 soap_instantiate_TT1__CLinkedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CLinkedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CLinkedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CLinkedItem;
		if (size)
			*size = sizeof(TT1__CLinkedItem);
		((TT1__CLinkedItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CLinkedItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CLinkedItem);
		for (int i = 0; i < n; i++)
			((TT1__CLinkedItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CLinkedItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CLinkedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CLinkedItem %p -> %p\n", q, p));
	*(TT1__CLinkedItem*)p = *(TT1__CLinkedItem*)q;
}

void TT1ArrayOfCUserLicense::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCUserLicense::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCUserLicense))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CUserLicense(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCUserLicense::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCUserLicense);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCUserLicense::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCUserLicense(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCUserLicense(struct soap *soap, const char *tag, int id, const TT1ArrayOfCUserLicense *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CUserLicense", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCUserLicense);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CUserLicense(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCUserLicense::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCUserLicense(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCUserLicense * SOAP_FMAC4 soap_get_TT1ArrayOfCUserLicense(struct soap *soap, TT1ArrayOfCUserLicense *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCUserLicense::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCUserLicense(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCUserLicense * SOAP_FMAC4 soap_in_TT1ArrayOfCUserLicense(struct soap *soap, const char *tag, TT1ArrayOfCUserLicense *a, const char *type)
{	int i, j;
	TT1__CUserLicense **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCUserLicense *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCUserLicense, sizeof(TT1ArrayOfCUserLicense), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CUserLicense **)soap_malloc(soap, sizeof(TT1__CUserLicense *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CUserLicense(soap, NULL, a->__ptritem + i, "TT1:CUserLicense"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CUserLicense **)soap_push_block(soap, sizeof(TT1__CUserLicense *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CUserLicense(soap, NULL, p, "TT1:CUserLicense"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CUserLicense **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCUserLicense *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCUserLicense, 0, sizeof(TT1ArrayOfCUserLicense), 0, soap_copy_TT1ArrayOfCUserLicense);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCUserLicense * SOAP_FMAC6 soap_new_TT1ArrayOfCUserLicense(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCUserLicense(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCUserLicense(struct soap *soap, TT1ArrayOfCUserLicense *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCUserLicense * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCUserLicense(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCUserLicense(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCUserLicense, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCUserLicense;
		if (size)
			*size = sizeof(TT1ArrayOfCUserLicense);
		((TT1ArrayOfCUserLicense*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCUserLicense[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCUserLicense);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCUserLicense*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCUserLicense*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCUserLicense(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCUserLicense %p -> %p\n", q, p));
	*(TT1ArrayOfCUserLicense*)p = *(TT1ArrayOfCUserLicense*)q;
}

void TT1__CUserLicense::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CUserLicense::name);
	this->TT1__CUserLicense::numberUsed = NULL;
	this->TT1__CUserLicense::numberTotal = NULL;
	/* transient soap skipped */
}

void TT1__CUserLicense::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CUserLicense::name);
	soap_serialize_PointerToint(soap, &this->TT1__CUserLicense::numberUsed);
	soap_serialize_PointerToint(soap, &this->TT1__CUserLicense::numberTotal);
	/* transient soap skipped */
}

int TT1__CUserLicense::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CUserLicense);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CUserLicense::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CUserLicense(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CUserLicense(struct soap *soap, const char *tag, int id, const TT1__CUserLicense *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CUserLicense), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CUserLicense::name), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numberUsed", -1, &(a->TT1__CUserLicense::numberUsed), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numberTotal", -1, &(a->TT1__CUserLicense::numberTotal), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CUserLicense::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CUserLicense(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CUserLicense * SOAP_FMAC4 soap_get_TT1__CUserLicense(struct soap *soap, TT1__CUserLicense *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CUserLicense::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CUserLicense(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CUserLicense * SOAP_FMAC4 soap_in_TT1__CUserLicense(struct soap *soap, const char *tag, TT1__CUserLicense *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CUserLicense *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CUserLicense, sizeof(TT1__CUserLicense), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CUserLicense)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CUserLicense *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_numberUsed1 = 1, soap_flag_numberTotal1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CUserLicense::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_numberUsed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberUsed", &(a->TT1__CUserLicense::numberUsed), "xsd:int"))
				{	soap_flag_numberUsed1--;
					continue;
				}
			if (soap_flag_numberTotal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberTotal", &(a->TT1__CUserLicense::numberTotal), "xsd:int"))
				{	soap_flag_numberTotal1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CUserLicense *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CUserLicense, 0, sizeof(TT1__CUserLicense), 0, soap_copy_TT1__CUserLicense);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CUserLicense * SOAP_FMAC6 soap_new_TT1__CUserLicense(struct soap *soap, int n)
{	return soap_instantiate_TT1__CUserLicense(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CUserLicense(struct soap *soap, TT1__CUserLicense *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CUserLicense * SOAP_FMAC4 soap_instantiate_TT1__CUserLicense(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CUserLicense(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CUserLicense, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CUserLicense;
		if (size)
			*size = sizeof(TT1__CUserLicense);
		((TT1__CUserLicense*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CUserLicense[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CUserLicense);
		for (int i = 0; i < n; i++)
			((TT1__CUserLicense*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CUserLicense*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CUserLicense(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CUserLicense %p -> %p\n", q, p));
	*(TT1__CUserLicense*)p = *(TT1__CUserLicense*)q;
}

void TT1ArrayOfCGlobalUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCGlobalUser::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCGlobalUser))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CGlobalUser(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCGlobalUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCGlobalUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCGlobalUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCGlobalUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCGlobalUser(struct soap *soap, const char *tag, int id, const TT1ArrayOfCGlobalUser *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CGlobalUser", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCGlobalUser);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CGlobalUser(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCGlobalUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCGlobalUser(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCGlobalUser * SOAP_FMAC4 soap_get_TT1ArrayOfCGlobalUser(struct soap *soap, TT1ArrayOfCGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCGlobalUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCGlobalUser(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCGlobalUser * SOAP_FMAC4 soap_in_TT1ArrayOfCGlobalUser(struct soap *soap, const char *tag, TT1ArrayOfCGlobalUser *a, const char *type)
{	int i, j;
	TT1__CGlobalUser **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCGlobalUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCGlobalUser, sizeof(TT1ArrayOfCGlobalUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CGlobalUser **)soap_malloc(soap, sizeof(TT1__CGlobalUser *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CGlobalUser(soap, NULL, a->__ptritem + i, "TT1:CGlobalUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CGlobalUser **)soap_push_block(soap, sizeof(TT1__CGlobalUser *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CGlobalUser(soap, NULL, p, "TT1:CGlobalUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CGlobalUser **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCGlobalUser, 0, sizeof(TT1ArrayOfCGlobalUser), 0, soap_copy_TT1ArrayOfCGlobalUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCGlobalUser * SOAP_FMAC6 soap_new_TT1ArrayOfCGlobalUser(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCGlobalUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCGlobalUser(struct soap *soap, TT1ArrayOfCGlobalUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCGlobalUser * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCGlobalUser;
		if (size)
			*size = sizeof(TT1ArrayOfCGlobalUser);
		((TT1ArrayOfCGlobalUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCGlobalUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCGlobalUser);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCGlobalUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCGlobalUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCGlobalUser %p -> %p\n", q, p));
	*(TT1ArrayOfCGlobalUser*)p = *(TT1ArrayOfCGlobalUser*)q;
}

void TT1__CGlobalUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CGlobalUser::loginname);
	soap_default_string(soap, &this->TT1__CGlobalUser::name);
	/* transient soap skipped */
}

void TT1__CGlobalUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CGlobalUser::loginname);
	soap_serialize_string(soap, &this->TT1__CGlobalUser::name);
	/* transient soap skipped */
}

int TT1__CGlobalUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CGlobalUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CGlobalUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CGlobalUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CGlobalUser(struct soap *soap, const char *tag, int id, const TT1__CGlobalUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CGlobalUser), type))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &(a->TT1__CGlobalUser::loginname), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CGlobalUser::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CGlobalUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CGlobalUser(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CGlobalUser * SOAP_FMAC4 soap_get_TT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CGlobalUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CGlobalUser(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CGlobalUser * SOAP_FMAC4 soap_in_TT1__CGlobalUser(struct soap *soap, const char *tag, TT1__CGlobalUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CGlobalUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CGlobalUser, sizeof(TT1__CGlobalUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CGlobalUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CGlobalUser *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_loginname1 = 1, soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &(a->TT1__CGlobalUser::loginname), "xsd:string"))
				{	soap_flag_loginname1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CGlobalUser::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CGlobalUser, 0, sizeof(TT1__CGlobalUser), 0, soap_copy_TT1__CGlobalUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CGlobalUser * SOAP_FMAC6 soap_new_TT1__CGlobalUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__CGlobalUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CGlobalUser * SOAP_FMAC4 soap_instantiate_TT1__CGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CGlobalUser;
		if (size)
			*size = sizeof(TT1__CGlobalUser);
		((TT1__CGlobalUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CGlobalUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CGlobalUser);
		for (int i = 0; i < n; i++)
			((TT1__CGlobalUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CGlobalUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CGlobalUser %p -> %p\n", q, p));
	*(TT1__CGlobalUser*)p = *(TT1__CGlobalUser*)q;
}

void TT1__CUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CUser::firstname);
	soap_default_string(soap, &this->TT1__CUser::middleinitials);
	soap_default_string(soap, &this->TT1__CUser::lastname);
	soap_default_string(soap, &this->TT1__CUser::usergroupname);
	soap_default_string(soap, &this->TT1__CUser::company);
	soap_default_string(soap, &this->TT1__CUser::emailtype);
	soap_default_string(soap, &this->TT1__CUser::emailaddress);
	this->TT1__CUser::isactive = NULL;
	this->TT1__CUser::iscustomer = NULL;
	this->TT1__CUser::isglobal = NULL;
	this->TT1__CUser::isactiveglobal = NULL;
	soap_default_string(soap, &this->TT1__CUser::userLicense);
	soap_default_string(soap, &this->TT1__CUser::userLicenseTCM);
	soap_default_string(soap, &this->TT1__CUser::password);
	soap_default_string(soap, &this->TT1__CUser::loginname);
	this->TT1__CUser::phoneone = NULL;
	this->TT1__CUser::phonetwo = NULL;
	soap_default_string(soap, &this->TT1__CUser::notes);
	this->TT1__CUser::betasite = NULL;
	soap_default_string(soap, &this->TT1__CUser::address);
	this->TT1__CUser::testconfig = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CUser::firstname);
	soap_serialize_string(soap, &this->TT1__CUser::middleinitials);
	soap_serialize_string(soap, &this->TT1__CUser::lastname);
	soap_serialize_string(soap, &this->TT1__CUser::usergroupname);
	soap_serialize_string(soap, &this->TT1__CUser::company);
	soap_serialize_string(soap, &this->TT1__CUser::emailtype);
	soap_serialize_string(soap, &this->TT1__CUser::emailaddress);
	soap_serialize_PointerTobool(soap, &this->TT1__CUser::isactive);
	soap_serialize_PointerTobool(soap, &this->TT1__CUser::iscustomer);
	soap_serialize_PointerTobool(soap, &this->TT1__CUser::isglobal);
	soap_serialize_PointerTobool(soap, &this->TT1__CUser::isactiveglobal);
	soap_serialize_string(soap, &this->TT1__CUser::userLicense);
	soap_serialize_string(soap, &this->TT1__CUser::userLicenseTCM);
	soap_serialize_string(soap, &this->TT1__CUser::password);
	soap_serialize_string(soap, &this->TT1__CUser::loginname);
	soap_serialize_PointerToTT1__PhoneNumber(soap, &this->TT1__CUser::phoneone);
	soap_serialize_PointerToTT1__PhoneNumber(soap, &this->TT1__CUser::phonetwo);
	soap_serialize_string(soap, &this->TT1__CUser::notes);
	soap_serialize_PointerTobool(soap, &this->TT1__CUser::betasite);
	soap_serialize_string(soap, &this->TT1__CUser::address);
	soap_serialize_PointerToTT1__CSystem(soap, &this->TT1__CUser::testconfig);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CUser(struct soap *soap, const char *tag, int id, const TT1__CUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CUser), "TT1:CUser"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "firstname", -1, &(a->TT1__CUser::firstname), ""))
		return soap->error;
	if (soap_out_string(soap, "middleinitials", -1, &(a->TT1__CUser::middleinitials), ""))
		return soap->error;
	if (soap_out_string(soap, "lastname", -1, &(a->TT1__CUser::lastname), ""))
		return soap->error;
	if (soap_out_string(soap, "usergroupname", -1, &(a->TT1__CUser::usergroupname), ""))
		return soap->error;
	if (soap_out_string(soap, "company", -1, &(a->TT1__CUser::company), ""))
		return soap->error;
	if (soap_out_string(soap, "emailtype", -1, &(a->TT1__CUser::emailtype), ""))
		return soap->error;
	if (soap_out_string(soap, "emailaddress", -1, &(a->TT1__CUser::emailaddress), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isactive", -1, &(a->TT1__CUser::isactive), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "iscustomer", -1, &(a->TT1__CUser::iscustomer), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isglobal", -1, &(a->TT1__CUser::isglobal), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isactiveglobal", -1, &(a->TT1__CUser::isactiveglobal), ""))
		return soap->error;
	if (soap_out_string(soap, "userLicense", -1, &(a->TT1__CUser::userLicense), ""))
		return soap->error;
	if (soap_out_string(soap, "userLicenseTCM", -1, &(a->TT1__CUser::userLicenseTCM), ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &(a->TT1__CUser::password), ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &(a->TT1__CUser::loginname), ""))
		return soap->error;
	if (soap_out_PointerToTT1__PhoneNumber(soap, "phoneone", -1, &(a->TT1__CUser::phoneone), ""))
		return soap->error;
	if (soap_out_PointerToTT1__PhoneNumber(soap, "phonetwo", -1, &(a->TT1__CUser::phonetwo), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->TT1__CUser::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "betasite", -1, &(a->TT1__CUser::betasite), ""))
		return soap->error;
	if (soap_out_string(soap, "address", -1, &(a->TT1__CUser::address), ""))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "testconfig", -1, &(a->TT1__CUser::testconfig), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CUser(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CUser * SOAP_FMAC4 soap_get_TT1__CUser(struct soap *soap, TT1__CUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CUser(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CUser * SOAP_FMAC4 soap_in_TT1__CUser(struct soap *soap, const char *tag, TT1__CUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CUser, sizeof(TT1__CUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CUser *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_firstname1 = 1, soap_flag_middleinitials1 = 1, soap_flag_lastname1 = 1, soap_flag_usergroupname1 = 1, soap_flag_company1 = 1, soap_flag_emailtype1 = 1, soap_flag_emailaddress1 = 1, soap_flag_isactive1 = 1, soap_flag_iscustomer1 = 1, soap_flag_isglobal1 = 1, soap_flag_isactiveglobal1 = 1, soap_flag_userLicense1 = 1, soap_flag_userLicenseTCM1 = 1, soap_flag_password1 = 1, soap_flag_loginname1 = 1, soap_flag_phoneone1 = 1, soap_flag_phonetwo1 = 1, soap_flag_notes1 = 1, soap_flag_betasite1 = 1, soap_flag_address1 = 1, soap_flag_testconfig1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_firstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstname", &(a->TT1__CUser::firstname), "xsd:string"))
				{	soap_flag_firstname1--;
					continue;
				}
			if (soap_flag_middleinitials1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleinitials", &(a->TT1__CUser::middleinitials), "xsd:string"))
				{	soap_flag_middleinitials1--;
					continue;
				}
			if (soap_flag_lastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastname", &(a->TT1__CUser::lastname), "xsd:string"))
				{	soap_flag_lastname1--;
					continue;
				}
			if (soap_flag_usergroupname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "usergroupname", &(a->TT1__CUser::usergroupname), "xsd:string"))
				{	soap_flag_usergroupname1--;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "company", &(a->TT1__CUser::company), "xsd:string"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_emailtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailtype", &(a->TT1__CUser::emailtype), "xsd:string"))
				{	soap_flag_emailtype1--;
					continue;
				}
			if (soap_flag_emailaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailaddress", &(a->TT1__CUser::emailaddress), "xsd:string"))
				{	soap_flag_emailaddress1--;
					continue;
				}
			if (soap_flag_isactive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isactive", &(a->TT1__CUser::isactive), "xsd:boolean"))
				{	soap_flag_isactive1--;
					continue;
				}
			if (soap_flag_iscustomer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "iscustomer", &(a->TT1__CUser::iscustomer), "xsd:boolean"))
				{	soap_flag_iscustomer1--;
					continue;
				}
			if (soap_flag_isglobal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isglobal", &(a->TT1__CUser::isglobal), "xsd:boolean"))
				{	soap_flag_isglobal1--;
					continue;
				}
			if (soap_flag_isactiveglobal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isactiveglobal", &(a->TT1__CUser::isactiveglobal), "xsd:boolean"))
				{	soap_flag_isactiveglobal1--;
					continue;
				}
			if (soap_flag_userLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userLicense", &(a->TT1__CUser::userLicense), "xsd:string"))
				{	soap_flag_userLicense1--;
					continue;
				}
			if (soap_flag_userLicenseTCM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userLicenseTCM", &(a->TT1__CUser::userLicenseTCM), "xsd:string"))
				{	soap_flag_userLicenseTCM1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &(a->TT1__CUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_loginname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &(a->TT1__CUser::loginname), "xsd:string"))
				{	soap_flag_loginname1--;
					continue;
				}
			if (soap_flag_phoneone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__PhoneNumber(soap, "phoneone", &(a->TT1__CUser::phoneone), "TT1:PhoneNumber"))
				{	soap_flag_phoneone1--;
					continue;
				}
			if (soap_flag_phonetwo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__PhoneNumber(soap, "phonetwo", &(a->TT1__CUser::phonetwo), "TT1:PhoneNumber"))
				{	soap_flag_phonetwo1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->TT1__CUser::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_betasite1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "betasite", &(a->TT1__CUser::betasite), "xsd:boolean"))
				{	soap_flag_betasite1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "address", &(a->TT1__CUser::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_testconfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "testconfig", &(a->TT1__CUser::testconfig), "TT1:CSystem"))
				{	soap_flag_testconfig1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CUser, 0, sizeof(TT1__CUser), 0, soap_copy_TT1__CUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CUser * SOAP_FMAC6 soap_new_TT1__CUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__CUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CUser(struct soap *soap, TT1__CUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CUser * SOAP_FMAC4 soap_instantiate_TT1__CUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CUser;
		if (size)
			*size = sizeof(TT1__CUser);
		((TT1__CUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CUser);
		for (int i = 0; i < n; i++)
			((TT1__CUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CUser %p -> %p\n", q, p));
	*(TT1__CUser*)p = *(TT1__CUser*)q;
}

void TT1__PhoneNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__PhoneNumber::numbertype);
	soap_default_string(soap, &this->TT1__PhoneNumber::phonenumber);
	/* transient soap skipped */
}

void TT1__PhoneNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__PhoneNumber::numbertype);
	soap_serialize_string(soap, &this->TT1__PhoneNumber::phonenumber);
	/* transient soap skipped */
}

int TT1__PhoneNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__PhoneNumber);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__PhoneNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__PhoneNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__PhoneNumber(struct soap *soap, const char *tag, int id, const TT1__PhoneNumber *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__PhoneNumber), type))
		return soap->error;
	if (soap_out_string(soap, "numbertype", -1, &(a->TT1__PhoneNumber::numbertype), ""))
		return soap->error;
	if (soap_out_string(soap, "phonenumber", -1, &(a->TT1__PhoneNumber::phonenumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__PhoneNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__PhoneNumber(soap, this, tag, type);
}

SOAP_FMAC3 TT1__PhoneNumber * SOAP_FMAC4 soap_get_TT1__PhoneNumber(struct soap *soap, TT1__PhoneNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__PhoneNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__PhoneNumber(soap, tag, this, type);
}

SOAP_FMAC3 TT1__PhoneNumber * SOAP_FMAC4 soap_in_TT1__PhoneNumber(struct soap *soap, const char *tag, TT1__PhoneNumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__PhoneNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__PhoneNumber, sizeof(TT1__PhoneNumber), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__PhoneNumber)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__PhoneNumber *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_numbertype1 = 1, soap_flag_phonenumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numbertype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "numbertype", &(a->TT1__PhoneNumber::numbertype), "xsd:string"))
				{	soap_flag_numbertype1--;
					continue;
				}
			if (soap_flag_phonenumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phonenumber", &(a->TT1__PhoneNumber::phonenumber), "xsd:string"))
				{	soap_flag_phonenumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__PhoneNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__PhoneNumber, 0, sizeof(TT1__PhoneNumber), 0, soap_copy_TT1__PhoneNumber);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__PhoneNumber * SOAP_FMAC6 soap_new_TT1__PhoneNumber(struct soap *soap, int n)
{	return soap_instantiate_TT1__PhoneNumber(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__PhoneNumber(struct soap *soap, TT1__PhoneNumber *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__PhoneNumber * SOAP_FMAC4 soap_instantiate_TT1__PhoneNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__PhoneNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__PhoneNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__PhoneNumber;
		if (size)
			*size = sizeof(TT1__PhoneNumber);
		((TT1__PhoneNumber*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__PhoneNumber[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__PhoneNumber);
		for (int i = 0; i < n; i++)
			((TT1__PhoneNumber*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__PhoneNumber*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__PhoneNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__PhoneNumber %p -> %p\n", q, p));
	*(TT1__PhoneNumber*)p = *(TT1__PhoneNumber*)q;
}

void TT1__CTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CTask::status);
	soap_default_string(soap, &this->TT1__CTask::priority);
	soap_default_string(soap, &this->TT1__CTask::summary);
	soap_default_string(soap, &this->TT1__CTask::description);
	soap_default_xsd__date(soap, &this->TT1__CTask::datedue);
	soap_default_xsd__date(soap, &this->TT1__CTask::dateassigned);
	soap_default_string(soap, &this->TT1__CTask::versiondue);
	soap_default_string(soap, &this->TT1__CTask::assignedto);
	soap_default_string(soap, &this->TT1__CTask::assignedby);
	this->TT1__CTask::assigneddefect = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CTask::status);
	soap_serialize_string(soap, &this->TT1__CTask::priority);
	soap_serialize_string(soap, &this->TT1__CTask::summary);
	soap_serialize_string(soap, &this->TT1__CTask::description);
	soap_serialize_xsd__date(soap, &this->TT1__CTask::datedue);
	soap_serialize_xsd__date(soap, &this->TT1__CTask::dateassigned);
	soap_serialize_string(soap, &this->TT1__CTask::versiondue);
	soap_serialize_string(soap, &this->TT1__CTask::assignedto);
	soap_serialize_string(soap, &this->TT1__CTask::assignedby);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CTask::assigneddefect);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTask);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTask(struct soap *soap, const char *tag, int id, const TT1__CTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTask), "TT1:CTask"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "status", -1, &(a->TT1__CTask::status), ""))
		return soap->error;
	if (soap_out_string(soap, "priority", -1, &(a->TT1__CTask::priority), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->TT1__CTask::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->TT1__CTask::description), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "datedue", -1, &(a->TT1__CTask::datedue), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "dateassigned", -1, &(a->TT1__CTask::dateassigned), ""))
		return soap->error;
	if (soap_out_string(soap, "versiondue", -1, &(a->TT1__CTask::versiondue), ""))
		return soap->error;
	if (soap_out_string(soap, "assignedto", -1, &(a->TT1__CTask::assignedto), ""))
		return soap->error;
	if (soap_out_string(soap, "assignedby", -1, &(a->TT1__CTask::assignedby), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "assigneddefect", -1, &(a->TT1__CTask::assigneddefect), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTask(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTask * SOAP_FMAC4 soap_get_TT1__CTask(struct soap *soap, TT1__CTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTask(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTask * SOAP_FMAC4 soap_in_TT1__CTask(struct soap *soap, const char *tag, TT1__CTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTask, sizeof(TT1__CTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTask *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_status1 = 1, soap_flag_priority1 = 1, soap_flag_summary1 = 1, soap_flag_description1 = 1, soap_flag_datedue1 = 1, soap_flag_dateassigned1 = 1, soap_flag_versiondue1 = 1, soap_flag_assignedto1 = 1, soap_flag_assignedby1 = 1, soap_flag_assigneddefect1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status", &(a->TT1__CTask::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "priority", &(a->TT1__CTask::priority), "xsd:string"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->TT1__CTask::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->TT1__CTask::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_datedue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "datedue", &(a->TT1__CTask::datedue), "xsd:date"))
				{	soap_flag_datedue1--;
					continue;
				}
			if (soap_flag_dateassigned1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "dateassigned", &(a->TT1__CTask::dateassigned), "xsd:date"))
				{	soap_flag_dateassigned1--;
					continue;
				}
			if (soap_flag_versiondue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "versiondue", &(a->TT1__CTask::versiondue), "xsd:string"))
				{	soap_flag_versiondue1--;
					continue;
				}
			if (soap_flag_assignedto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "assignedto", &(a->TT1__CTask::assignedto), "xsd:string"))
				{	soap_flag_assignedto1--;
					continue;
				}
			if (soap_flag_assignedby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "assignedby", &(a->TT1__CTask::assignedby), "xsd:string"))
				{	soap_flag_assignedby1--;
					continue;
				}
			if (soap_flag_assigneddefect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "assigneddefect", &(a->TT1__CTask::assigneddefect), "xsd:long"))
				{	soap_flag_assigneddefect1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTask, 0, sizeof(TT1__CTask), 0, soap_copy_TT1__CTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTask * SOAP_FMAC6 soap_new_TT1__CTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTask(struct soap *soap, TT1__CTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTask * SOAP_FMAC4 soap_instantiate_TT1__CTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTask;
		if (size)
			*size = sizeof(TT1__CTask);
		((TT1__CTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTask);
		for (int i = 0; i < n; i++)
			((TT1__CTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTask %p -> %p\n", q, p));
	*(TT1__CTask*)p = *(TT1__CTask*)q;
}

void TT1__CDefect::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CDefect::defectnumber = NULL;
	soap_default_string(soap, &this->TT1__CDefect::summary);
	soap_default_string(soap, &this->TT1__CDefect::state);
	soap_default_string(soap, &this->TT1__CDefect::disposition);
	soap_default_string(soap, &this->TT1__CDefect::type);
	soap_default_string(soap, &this->TT1__CDefect::priority);
	soap_default_string(soap, &this->TT1__CDefect::product);
	soap_default_string(soap, &this->TT1__CDefect::component);
	soap_default_string(soap, &this->TT1__CDefect::reference);
	soap_default_string(soap, &this->TT1__CDefect::severity);
	soap_default_string(soap, &this->TT1__CDefect::enteredby);
	soap_default_string(soap, &this->TT1__CDefect::workaround);
	soap_default_xsd__date(soap, &this->TT1__CDefect::dateentered);
	soap_default_string(soap, &this->TT1__CDefect::locationaddedfrom);
	this->TT1__CDefect::datetimecreated = NULL;
	this->TT1__CDefect::datetimemodified = NULL;
	soap_default_string(soap, &this->TT1__CDefect::createdbyuser);
	soap_default_string(soap, &this->TT1__CDefect::modifiedbyuser);
	this->TT1__CDefect::actualhourstofix = NULL;
	this->TT1__CDefect::estimatedhours = NULL;
	this->TT1__CDefect::reportedbylist = NULL;
	this->TT1__CDefect::eventlist = NULL;
	this->TT1__CDefect::pSCCFileList = NULL;
	this->TT1__CDefect::customFieldList = NULL;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDefect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->TT1__CDefect::defectnumber);
	soap_serialize_string(soap, &this->TT1__CDefect::summary);
	soap_serialize_string(soap, &this->TT1__CDefect::state);
	soap_serialize_string(soap, &this->TT1__CDefect::disposition);
	soap_serialize_string(soap, &this->TT1__CDefect::type);
	soap_serialize_string(soap, &this->TT1__CDefect::priority);
	soap_serialize_string(soap, &this->TT1__CDefect::product);
	soap_serialize_string(soap, &this->TT1__CDefect::component);
	soap_serialize_string(soap, &this->TT1__CDefect::reference);
	soap_serialize_string(soap, &this->TT1__CDefect::severity);
	soap_serialize_string(soap, &this->TT1__CDefect::enteredby);
	soap_serialize_string(soap, &this->TT1__CDefect::workaround);
	soap_serialize_xsd__date(soap, &this->TT1__CDefect::dateentered);
	soap_serialize_string(soap, &this->TT1__CDefect::locationaddedfrom);
	soap_serialize_PointerTotime(soap, &this->TT1__CDefect::datetimecreated);
	soap_serialize_PointerTotime(soap, &this->TT1__CDefect::datetimemodified);
	soap_serialize_string(soap, &this->TT1__CDefect::createdbyuser);
	soap_serialize_string(soap, &this->TT1__CDefect::modifiedbyuser);
	soap_serialize_PointerTodouble(soap, &this->TT1__CDefect::actualhourstofix);
	soap_serialize_PointerTodouble(soap, &this->TT1__CDefect::estimatedhours);
	soap_serialize_PointerToTT1ArrayOfCReportedByRecord(soap, &this->TT1__CDefect::reportedbylist);
	soap_serialize_PointerToTT1ArrayOfCEvent(soap, &this->TT1__CDefect::eventlist);
	soap_serialize_PointerToTT1ArrayOfCSCCFileRecord(soap, &this->TT1__CDefect::pSCCFileList);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CDefect::customFieldList);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDefect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDefect);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDefect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDefect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDefect(struct soap *soap, const char *tag, int id, const TT1__CDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDefect), "TT1:CDefect"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "defectnumber", -1, &(a->TT1__CDefect::defectnumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->TT1__CDefect::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->TT1__CDefect::state), ""))
		return soap->error;
	if (soap_out_string(soap, "disposition", -1, &(a->TT1__CDefect::disposition), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->TT1__CDefect::type), ""))
		return soap->error;
	if (soap_out_string(soap, "priority", -1, &(a->TT1__CDefect::priority), ""))
		return soap->error;
	if (soap_out_string(soap, "product", -1, &(a->TT1__CDefect::product), ""))
		return soap->error;
	if (soap_out_string(soap, "component", -1, &(a->TT1__CDefect::component), ""))
		return soap->error;
	if (soap_out_string(soap, "reference", -1, &(a->TT1__CDefect::reference), ""))
		return soap->error;
	if (soap_out_string(soap, "severity", -1, &(a->TT1__CDefect::severity), ""))
		return soap->error;
	if (soap_out_string(soap, "enteredby", -1, &(a->TT1__CDefect::enteredby), ""))
		return soap->error;
	if (soap_out_string(soap, "workaround", -1, &(a->TT1__CDefect::workaround), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "dateentered", -1, &(a->TT1__CDefect::dateentered), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->TT1__CDefect::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->TT1__CDefect::datetimecreated), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->TT1__CDefect::datetimemodified), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->TT1__CDefect::createdbyuser), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->TT1__CDefect::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhourstofix", -1, &(a->TT1__CDefect::actualhourstofix), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->TT1__CDefect::estimatedhours), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCReportedByRecord(soap, "reportedbylist", -1, &(a->TT1__CDefect::reportedbylist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCEvent(soap, "eventlist", -1, &(a->TT1__CDefect::eventlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCSCCFileRecord(soap, "pSCCFileList", -1, &(a->TT1__CDefect::pSCCFileList), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFieldList", -1, &(a->TT1__CDefect::customFieldList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDefect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDefect(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDefect * SOAP_FMAC4 soap_get_TT1__CDefect(struct soap *soap, TT1__CDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDefect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDefect(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDefect * SOAP_FMAC4 soap_in_TT1__CDefect(struct soap *soap, const char *tag, TT1__CDefect *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDefect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDefect, sizeof(TT1__CDefect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDefect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDefect *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_defectnumber1 = 1, soap_flag_summary1 = 1, soap_flag_state1 = 1, soap_flag_disposition1 = 1, soap_flag_type1 = 1, soap_flag_priority1 = 1, soap_flag_product1 = 1, soap_flag_component1 = 1, soap_flag_reference1 = 1, soap_flag_severity1 = 1, soap_flag_enteredby1 = 1, soap_flag_workaround1 = 1, soap_flag_dateentered1 = 1, soap_flag_locationaddedfrom1 = 1, soap_flag_datetimecreated1 = 1, soap_flag_datetimemodified1 = 1, soap_flag_createdbyuser1 = 1, soap_flag_modifiedbyuser1 = 1, soap_flag_actualhourstofix1 = 1, soap_flag_estimatedhours1 = 1, soap_flag_reportedbylist1 = 1, soap_flag_eventlist1 = 1, soap_flag_pSCCFileList1 = 1, soap_flag_customFieldList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_defectnumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "defectnumber", &(a->TT1__CDefect::defectnumber), "xsd:long"))
				{	soap_flag_defectnumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->TT1__CDefect::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->TT1__CDefect::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_disposition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "disposition", &(a->TT1__CDefect::disposition), "xsd:string"))
				{	soap_flag_disposition1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->TT1__CDefect::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "priority", &(a->TT1__CDefect::priority), "xsd:string"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_product1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "product", &(a->TT1__CDefect::product), "xsd:string"))
				{	soap_flag_product1--;
					continue;
				}
			if (soap_flag_component1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "component", &(a->TT1__CDefect::component), "xsd:string"))
				{	soap_flag_component1--;
					continue;
				}
			if (soap_flag_reference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reference", &(a->TT1__CDefect::reference), "xsd:string"))
				{	soap_flag_reference1--;
					continue;
				}
			if (soap_flag_severity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "severity", &(a->TT1__CDefect::severity), "xsd:string"))
				{	soap_flag_severity1--;
					continue;
				}
			if (soap_flag_enteredby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "enteredby", &(a->TT1__CDefect::enteredby), "xsd:string"))
				{	soap_flag_enteredby1--;
					continue;
				}
			if (soap_flag_workaround1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "workaround", &(a->TT1__CDefect::workaround), "xsd:string"))
				{	soap_flag_workaround1--;
					continue;
				}
			if (soap_flag_dateentered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "dateentered", &(a->TT1__CDefect::dateentered), "xsd:date"))
				{	soap_flag_dateentered1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->TT1__CDefect::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->TT1__CDefect::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->TT1__CDefect::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->TT1__CDefect::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->TT1__CDefect::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_actualhourstofix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhourstofix", &(a->TT1__CDefect::actualhourstofix), "xsd:double"))
				{	soap_flag_actualhourstofix1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->TT1__CDefect::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_reportedbylist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCReportedByRecord(soap, "reportedbylist", &(a->TT1__CDefect::reportedbylist), "TT1:CReportedByRecord"))
				{	soap_flag_reportedbylist1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCEvent(soap, "eventlist", &(a->TT1__CDefect::eventlist), "TT1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_pSCCFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCSCCFileRecord(soap, "pSCCFileList", &(a->TT1__CDefect::pSCCFileList), "TT1:CSCCFileRecord"))
				{	soap_flag_pSCCFileList1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFieldList", &(a->TT1__CDefect::customFieldList), "TT1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDefect, 0, sizeof(TT1__CDefect), 0, soap_copy_TT1__CDefect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDefect * SOAP_FMAC6 soap_new_TT1__CDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDefect(struct soap *soap, TT1__CDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDefect * SOAP_FMAC4 soap_instantiate_TT1__CDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDefect;
		if (size)
			*size = sizeof(TT1__CDefect);
		((TT1__CDefect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDefect);
		for (int i = 0; i < n; i++)
			((TT1__CDefect*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDefect %p -> %p\n", q, p));
	*(TT1__CDefect*)p = *(TT1__CDefect*)q;
}

void TT1ArrayOfCDefectEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCDefectEventDefinition::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CDefectEventDefinition(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCDefectEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCDefectEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCDefectEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, int id, const TT1ArrayOfCDefectEventDefinition *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CDefectEventDefinition", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CDefectEventDefinition(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCDefectEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCDefectEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCDefectEventDefinition * SOAP_FMAC4 soap_get_TT1ArrayOfCDefectEventDefinition(struct soap *soap, TT1ArrayOfCDefectEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCDefectEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCDefectEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCDefectEventDefinition * SOAP_FMAC4 soap_in_TT1ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, TT1ArrayOfCDefectEventDefinition *a, const char *type)
{	int i, j;
	TT1__CDefectEventDefinition **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCDefectEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition, sizeof(TT1ArrayOfCDefectEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CDefectEventDefinition **)soap_malloc(soap, sizeof(TT1__CDefectEventDefinition *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CDefectEventDefinition(soap, NULL, a->__ptritem + i, "TT1:CDefectEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CDefectEventDefinition **)soap_push_block(soap, sizeof(TT1__CDefectEventDefinition *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CDefectEventDefinition(soap, NULL, p, "TT1:CDefectEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CDefectEventDefinition **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCDefectEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition, 0, sizeof(TT1ArrayOfCDefectEventDefinition), 0, soap_copy_TT1ArrayOfCDefectEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCDefectEventDefinition * SOAP_FMAC6 soap_new_TT1ArrayOfCDefectEventDefinition(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCDefectEventDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCDefectEventDefinition(struct soap *soap, TT1ArrayOfCDefectEventDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCDefectEventDefinition * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCDefectEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCDefectEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCDefectEventDefinition;
		if (size)
			*size = sizeof(TT1ArrayOfCDefectEventDefinition);
		((TT1ArrayOfCDefectEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCDefectEventDefinition[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCDefectEventDefinition);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCDefectEventDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCDefectEventDefinition*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCDefectEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCDefectEventDefinition %p -> %p\n", q, p));
	*(TT1ArrayOfCDefectEventDefinition*)p = *(TT1ArrayOfCDefectEventDefinition*)q;
}

void TT1__CDefectEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CEventDefinition::name);
	this->TT1__CEventDefinition::user = NULL;
	this->TT1__CEventDefinition::datetime = NULL;
	this->TT1__CEventDefinition::notes = NULL;
	this->TT1__CEventDefinition::resultingState = NULL;
	this->TT1__CEventDefinition::resultingStateValues = NULL;
	this->TT1__CEventDefinition::fileattachments = NULL;
	this->TT1__CEventDefinition::timeTracking = NULL;
	this->TT1__CEventDefinition::timeSumOfAll = NULL;
	this->TT1__CEventDefinition::timeHoursSinceLast = NULL;
	this->TT1__CEventDefinition::newAssignment = NULL;
	this->TT1__CEventDefinition::releaseNotes = NULL;
	this->TT1__CEventDefinition::customFields = NULL;
	/* transient soap skipped */
}

void TT1__CDefectEventDefinition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CEventDefinition::name);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::user);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::datetime);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::notes);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::resultingState);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CEventDefinition::resultingStateValues);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::fileattachments);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeTracking);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeSumOfAll);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeHoursSinceLast);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::newAssignment);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::releaseNotes);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CEventDefinition::customFields);
	/* transient soap skipped */
}

int TT1__CDefectEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDefectEventDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDefectEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDefectEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, const TT1__CDefectEventDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDefectEventDefinition), "TT1:CDefectEventDefinition"))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CEventDefinition::name), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "user", -1, &(a->TT1__CEventDefinition::user), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "datetime", -1, &(a->TT1__CEventDefinition::datetime), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "notes", -1, &(a->TT1__CEventDefinition::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "resultingState", -1, &(a->TT1__CEventDefinition::resultingState), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "resultingStateValues", -1, &(a->TT1__CEventDefinition::resultingStateValues), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fileattachments", -1, &(a->TT1__CEventDefinition::fileattachments), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeTracking", -1, &(a->TT1__CEventDefinition::timeTracking), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeSumOfAll", -1, &(a->TT1__CEventDefinition::timeSumOfAll), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeHoursSinceLast", -1, &(a->TT1__CEventDefinition::timeHoursSinceLast), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "newAssignment", -1, &(a->TT1__CEventDefinition::newAssignment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "releaseNotes", -1, &(a->TT1__CEventDefinition::releaseNotes), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFields", -1, &(a->TT1__CEventDefinition::customFields), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CDefectEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDefectEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDefectEventDefinition * SOAP_FMAC4 soap_get_TT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDefectEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDefectEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDefectEventDefinition * SOAP_FMAC4 soap_in_TT1__CDefectEventDefinition(struct soap *soap, const char *tag, TT1__CDefectEventDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDefectEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDefectEventDefinition, sizeof(TT1__CDefectEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDefectEventDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDefectEventDefinition *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name2 = 1, soap_flag_user2 = 1, soap_flag_datetime2 = 1, soap_flag_notes2 = 1, soap_flag_resultingState2 = 1, soap_flag_resultingStateValues2 = 1, soap_flag_fileattachments2 = 1, soap_flag_timeTracking2 = 1, soap_flag_timeSumOfAll2 = 1, soap_flag_timeHoursSinceLast2 = 1, soap_flag_newAssignment2 = 1, soap_flag_releaseNotes2 = 1, soap_flag_customFields2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CEventDefinition::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_user2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "user", &(a->TT1__CEventDefinition::user), "xsd:boolean"))
				{	soap_flag_user2--;
					continue;
				}
			if (soap_flag_datetime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "datetime", &(a->TT1__CEventDefinition::datetime), "xsd:boolean"))
				{	soap_flag_datetime2--;
					continue;
				}
			if (soap_flag_notes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "notes", &(a->TT1__CEventDefinition::notes), "xsd:boolean"))
				{	soap_flag_notes2--;
					continue;
				}
			if (soap_flag_resultingState2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "resultingState", &(a->TT1__CEventDefinition::resultingState), "xsd:boolean"))
				{	soap_flag_resultingState2--;
					continue;
				}
			if (soap_flag_resultingStateValues2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "resultingStateValues", &(a->TT1__CEventDefinition::resultingStateValues), "TT1:CFieldValue"))
				{	soap_flag_resultingStateValues2--;
					continue;
				}
			if (soap_flag_fileattachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fileattachments", &(a->TT1__CEventDefinition::fileattachments), "xsd:boolean"))
				{	soap_flag_fileattachments2--;
					continue;
				}
			if (soap_flag_timeTracking2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeTracking", &(a->TT1__CEventDefinition::timeTracking), "xsd:boolean"))
				{	soap_flag_timeTracking2--;
					continue;
				}
			if (soap_flag_timeSumOfAll2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeSumOfAll", &(a->TT1__CEventDefinition::timeSumOfAll), "xsd:boolean"))
				{	soap_flag_timeSumOfAll2--;
					continue;
				}
			if (soap_flag_timeHoursSinceLast2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeHoursSinceLast", &(a->TT1__CEventDefinition::timeHoursSinceLast), "xsd:boolean"))
				{	soap_flag_timeHoursSinceLast2--;
					continue;
				}
			if (soap_flag_newAssignment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "newAssignment", &(a->TT1__CEventDefinition::newAssignment), "xsd:boolean"))
				{	soap_flag_newAssignment2--;
					continue;
				}
			if (soap_flag_releaseNotes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "releaseNotes", &(a->TT1__CEventDefinition::releaseNotes), "xsd:boolean"))
				{	soap_flag_releaseNotes2--;
					continue;
				}
			if (soap_flag_customFields2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFields", &(a->TT1__CEventDefinition::customFields), "TT1:CField"))
				{	soap_flag_customFields2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDefectEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDefectEventDefinition, 0, sizeof(TT1__CDefectEventDefinition), 0, soap_copy_TT1__CDefectEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDefectEventDefinition * SOAP_FMAC6 soap_new_TT1__CDefectEventDefinition(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDefectEventDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDefectEventDefinition * SOAP_FMAC4 soap_instantiate_TT1__CDefectEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDefectEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDefectEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDefectEventDefinition;
		if (size)
			*size = sizeof(TT1__CDefectEventDefinition);
		((TT1__CDefectEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDefectEventDefinition[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDefectEventDefinition);
		for (int i = 0; i < n; i++)
			((TT1__CDefectEventDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDefectEventDefinition*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDefectEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDefectEventDefinition %p -> %p\n", q, p));
	*(TT1__CDefectEventDefinition*)p = *(TT1__CDefectEventDefinition*)q;
}

void TT1ArrayOfCEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCEventDefinition::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCEventDefinition))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CEventDefinition(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCEventDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCEventDefinition(struct soap *soap, const char *tag, int id, const TT1ArrayOfCEventDefinition *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CEventDefinition", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCEventDefinition);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CEventDefinition(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCEventDefinition * SOAP_FMAC4 soap_get_TT1ArrayOfCEventDefinition(struct soap *soap, TT1ArrayOfCEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCEventDefinition * SOAP_FMAC4 soap_in_TT1ArrayOfCEventDefinition(struct soap *soap, const char *tag, TT1ArrayOfCEventDefinition *a, const char *type)
{	int i, j;
	TT1__CEventDefinition **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCEventDefinition, sizeof(TT1ArrayOfCEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CEventDefinition **)soap_malloc(soap, sizeof(TT1__CEventDefinition *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CEventDefinition(soap, NULL, a->__ptritem + i, "TT1:CEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CEventDefinition **)soap_push_block(soap, sizeof(TT1__CEventDefinition *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CEventDefinition(soap, NULL, p, "TT1:CEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CEventDefinition **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCEventDefinition, 0, sizeof(TT1ArrayOfCEventDefinition), 0, soap_copy_TT1ArrayOfCEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCEventDefinition * SOAP_FMAC6 soap_new_TT1ArrayOfCEventDefinition(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCEventDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCEventDefinition(struct soap *soap, TT1ArrayOfCEventDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCEventDefinition * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCEventDefinition;
		if (size)
			*size = sizeof(TT1ArrayOfCEventDefinition);
		((TT1ArrayOfCEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCEventDefinition[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCEventDefinition);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCEventDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCEventDefinition*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCEventDefinition %p -> %p\n", q, p));
	*(TT1ArrayOfCEventDefinition*)p = *(TT1ArrayOfCEventDefinition*)q;
}

void TT1__CEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CEventDefinition::name);
	this->TT1__CEventDefinition::user = NULL;
	this->TT1__CEventDefinition::datetime = NULL;
	this->TT1__CEventDefinition::notes = NULL;
	this->TT1__CEventDefinition::resultingState = NULL;
	this->TT1__CEventDefinition::resultingStateValues = NULL;
	this->TT1__CEventDefinition::fileattachments = NULL;
	this->TT1__CEventDefinition::timeTracking = NULL;
	this->TT1__CEventDefinition::timeSumOfAll = NULL;
	this->TT1__CEventDefinition::timeHoursSinceLast = NULL;
	this->TT1__CEventDefinition::newAssignment = NULL;
	this->TT1__CEventDefinition::releaseNotes = NULL;
	this->TT1__CEventDefinition::customFields = NULL;
	/* transient soap skipped */
}

void TT1__CEventDefinition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CEventDefinition::name);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::user);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::datetime);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::notes);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::resultingState);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CEventDefinition::resultingStateValues);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::fileattachments);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeTracking);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeSumOfAll);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::timeHoursSinceLast);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::newAssignment);
	soap_serialize_PointerTobool(soap, &this->TT1__CEventDefinition::releaseNotes);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CEventDefinition::customFields);
	/* transient soap skipped */
}

int TT1__CEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CEventDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CEventDefinition(struct soap *soap, const char *tag, int id, const TT1__CEventDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CEventDefinition), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CEventDefinition::name), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "user", -1, &(a->TT1__CEventDefinition::user), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "datetime", -1, &(a->TT1__CEventDefinition::datetime), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "notes", -1, &(a->TT1__CEventDefinition::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "resultingState", -1, &(a->TT1__CEventDefinition::resultingState), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "resultingStateValues", -1, &(a->TT1__CEventDefinition::resultingStateValues), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fileattachments", -1, &(a->TT1__CEventDefinition::fileattachments), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeTracking", -1, &(a->TT1__CEventDefinition::timeTracking), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeSumOfAll", -1, &(a->TT1__CEventDefinition::timeSumOfAll), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeHoursSinceLast", -1, &(a->TT1__CEventDefinition::timeHoursSinceLast), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "newAssignment", -1, &(a->TT1__CEventDefinition::newAssignment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "releaseNotes", -1, &(a->TT1__CEventDefinition::releaseNotes), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFields", -1, &(a->TT1__CEventDefinition::customFields), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CEventDefinition * SOAP_FMAC4 soap_get_TT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CEventDefinition * SOAP_FMAC4 soap_in_TT1__CEventDefinition(struct soap *soap, const char *tag, TT1__CEventDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CEventDefinition, sizeof(TT1__CEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CEventDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CEventDefinition *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_user1 = 1, soap_flag_datetime1 = 1, soap_flag_notes1 = 1, soap_flag_resultingState1 = 1, soap_flag_resultingStateValues1 = 1, soap_flag_fileattachments1 = 1, soap_flag_timeTracking1 = 1, soap_flag_timeSumOfAll1 = 1, soap_flag_timeHoursSinceLast1 = 1, soap_flag_newAssignment1 = 1, soap_flag_releaseNotes1 = 1, soap_flag_customFields1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CEventDefinition::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "user", &(a->TT1__CEventDefinition::user), "xsd:boolean"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "datetime", &(a->TT1__CEventDefinition::datetime), "xsd:boolean"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_notes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "notes", &(a->TT1__CEventDefinition::notes), "xsd:boolean"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_resultingState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "resultingState", &(a->TT1__CEventDefinition::resultingState), "xsd:boolean"))
				{	soap_flag_resultingState1--;
					continue;
				}
			if (soap_flag_resultingStateValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "resultingStateValues", &(a->TT1__CEventDefinition::resultingStateValues), "TT1:CFieldValue"))
				{	soap_flag_resultingStateValues1--;
					continue;
				}
			if (soap_flag_fileattachments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fileattachments", &(a->TT1__CEventDefinition::fileattachments), "xsd:boolean"))
				{	soap_flag_fileattachments1--;
					continue;
				}
			if (soap_flag_timeTracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeTracking", &(a->TT1__CEventDefinition::timeTracking), "xsd:boolean"))
				{	soap_flag_timeTracking1--;
					continue;
				}
			if (soap_flag_timeSumOfAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeSumOfAll", &(a->TT1__CEventDefinition::timeSumOfAll), "xsd:boolean"))
				{	soap_flag_timeSumOfAll1--;
					continue;
				}
			if (soap_flag_timeHoursSinceLast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeHoursSinceLast", &(a->TT1__CEventDefinition::timeHoursSinceLast), "xsd:boolean"))
				{	soap_flag_timeHoursSinceLast1--;
					continue;
				}
			if (soap_flag_newAssignment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "newAssignment", &(a->TT1__CEventDefinition::newAssignment), "xsd:boolean"))
				{	soap_flag_newAssignment1--;
					continue;
				}
			if (soap_flag_releaseNotes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "releaseNotes", &(a->TT1__CEventDefinition::releaseNotes), "xsd:boolean"))
				{	soap_flag_releaseNotes1--;
					continue;
				}
			if (soap_flag_customFields1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFields", &(a->TT1__CEventDefinition::customFields), "TT1:CField"))
				{	soap_flag_customFields1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CEventDefinition, 0, sizeof(TT1__CEventDefinition), 0, soap_copy_TT1__CEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CEventDefinition * SOAP_FMAC6 soap_new_TT1__CEventDefinition(struct soap *soap, int n)
{	return soap_instantiate_TT1__CEventDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CEventDefinition * SOAP_FMAC4 soap_instantiate_TT1__CEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CDefectEventDefinition"))
	{	cp->type = SOAP_TYPE_TT1__CDefectEventDefinition;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDefectEventDefinition;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDefectEventDefinition);
			((TT1__CDefectEventDefinition*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDefectEventDefinition[n];
			if (size)
				*size = n * sizeof(TT1__CDefectEventDefinition);
			for (int i = 0; i < n; i++)
				((TT1__CDefectEventDefinition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDefectEventDefinition*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CEventDefinition;
		if (size)
			*size = sizeof(TT1__CEventDefinition);
		((TT1__CEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CEventDefinition[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CEventDefinition);
		for (int i = 0; i < n; i++)
			((TT1__CEventDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CEventDefinition*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CEventDefinition %p -> %p\n", q, p));
	*(TT1__CEventDefinition*)p = *(TT1__CEventDefinition*)q;
}

void TT1ArrayOfCDefectEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCDefectEvent::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCDefectEvent))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CDefectEvent(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCDefectEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCDefectEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCDefectEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCDefectEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCDefectEvent(struct soap *soap, const char *tag, int id, const TT1ArrayOfCDefectEvent *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CDefectEvent", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDefectEvent);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CDefectEvent(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCDefectEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCDefectEvent(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCDefectEvent * SOAP_FMAC4 soap_get_TT1ArrayOfCDefectEvent(struct soap *soap, TT1ArrayOfCDefectEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCDefectEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCDefectEvent(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCDefectEvent * SOAP_FMAC4 soap_in_TT1ArrayOfCDefectEvent(struct soap *soap, const char *tag, TT1ArrayOfCDefectEvent *a, const char *type)
{	int i, j;
	TT1__CDefectEvent **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCDefectEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCDefectEvent, sizeof(TT1ArrayOfCDefectEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CDefectEvent **)soap_malloc(soap, sizeof(TT1__CDefectEvent *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CDefectEvent(soap, NULL, a->__ptritem + i, "TT1:CDefectEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CDefectEvent **)soap_push_block(soap, sizeof(TT1__CDefectEvent *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CDefectEvent(soap, NULL, p, "TT1:CDefectEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CDefectEvent **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCDefectEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCDefectEvent, 0, sizeof(TT1ArrayOfCDefectEvent), 0, soap_copy_TT1ArrayOfCDefectEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCDefectEvent * SOAP_FMAC6 soap_new_TT1ArrayOfCDefectEvent(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCDefectEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCDefectEvent(struct soap *soap, TT1ArrayOfCDefectEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCDefectEvent * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCDefectEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCDefectEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCDefectEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCDefectEvent;
		if (size)
			*size = sizeof(TT1ArrayOfCDefectEvent);
		((TT1ArrayOfCDefectEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCDefectEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCDefectEvent);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCDefectEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCDefectEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCDefectEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCDefectEvent %p -> %p\n", q, p));
	*(TT1ArrayOfCDefectEvent*)p = *(TT1ArrayOfCDefectEvent*)q;
}

void TT1__CDefectEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CEvent::user);
	soap_default_time(soap, &this->TT1__CEvent::date);
	soap_default_string(soap, &this->TT1__CEvent::notes);
	soap_default_short(soap, &this->TT1__CEvent::eventaddorder);
	soap_default_string(soap, &this->TT1__CEvent::name);
	this->TT1__CEvent::parenteventid = NULL;
	this->TT1__CEvent::attachmentlist = NULL;
	this->TT1__CEvent::fieldlist = NULL;
	soap_default_string(soap, &this->TT1__CEvent::resultingstate);
	this->TT1__CEvent::hours = NULL;
	this->TT1__CEvent::assigntolist = NULL;
	soap_default_string(soap, &this->TT1__CEvent::releasenotesversion);
	soap_default_string(soap, &this->TT1__CEvent::generatedeventtype);
	soap_default_string(soap, &this->TT1__CEvent::generatedbyname);
	this->TT1__CEvent::totaltimespent = NULL;
	soap_default_string(soap, &this->TT1__CEvent::overrideuser);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDefectEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CEvent::user);
	soap_embedded(soap, &this->TT1__CEvent::date, SOAP_TYPE_time);
	soap_serialize_string(soap, &this->TT1__CEvent::notes);
	soap_embedded(soap, &this->TT1__CEvent::eventaddorder, SOAP_TYPE_short);
	soap_serialize_string(soap, &this->TT1__CEvent::name);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CEvent::parenteventid);
	soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, &this->TT1__CEvent::attachmentlist);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CEvent::fieldlist);
	soap_serialize_string(soap, &this->TT1__CEvent::resultingstate);
	soap_serialize_PointerTodouble(soap, &this->TT1__CEvent::hours);
	soap_serialize_PointerToTT1ArrayOfstring(soap, &this->TT1__CEvent::assigntolist);
	soap_serialize_string(soap, &this->TT1__CEvent::releasenotesversion);
	soap_serialize_string(soap, &this->TT1__CEvent::generatedeventtype);
	soap_serialize_string(soap, &this->TT1__CEvent::generatedbyname);
	soap_serialize_PointerTodouble(soap, &this->TT1__CEvent::totaltimespent);
	soap_serialize_string(soap, &this->TT1__CEvent::overrideuser);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDefectEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDefectEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDefectEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDefectEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDefectEvent(struct soap *soap, const char *tag, int id, const TT1__CDefectEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDefectEvent), "TT1:CDefectEvent"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "user", -1, &(a->TT1__CEvent::user), ""))
		return soap->error;
	if (soap_out_time(soap, "date", -1, &(a->TT1__CEvent::date), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->TT1__CEvent::notes), ""))
		return soap->error;
	if (soap_out_short(soap, "eventaddorder", -1, &(a->TT1__CEvent::eventaddorder), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CEvent::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parenteventid", -1, &(a->TT1__CEvent::parenteventid), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->TT1__CEvent::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "fieldlist", -1, &(a->TT1__CEvent::fieldlist), ""))
		return soap->error;
	if (soap_out_string(soap, "resultingstate", -1, &(a->TT1__CEvent::resultingstate), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "hours", -1, &(a->TT1__CEvent::hours), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfstring(soap, "assigntolist", -1, &(a->TT1__CEvent::assigntolist), ""))
		return soap->error;
	if (soap_out_string(soap, "releasenotesversion", -1, &(a->TT1__CEvent::releasenotesversion), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedeventtype", -1, &(a->TT1__CEvent::generatedeventtype), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedbyname", -1, &(a->TT1__CEvent::generatedbyname), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "totaltimespent", -1, &(a->TT1__CEvent::totaltimespent), ""))
		return soap->error;
	if (soap_out_string(soap, "overrideuser", -1, &(a->TT1__CEvent::overrideuser), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDefectEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDefectEvent(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDefectEvent * SOAP_FMAC4 soap_get_TT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDefectEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDefectEvent(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDefectEvent * SOAP_FMAC4 soap_in_TT1__CDefectEvent(struct soap *soap, const char *tag, TT1__CDefectEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDefectEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDefectEvent, sizeof(TT1__CDefectEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDefectEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDefectEvent *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_user2 = 1, soap_flag_date2 = 1, soap_flag_notes2 = 1, soap_flag_eventaddorder2 = 1, soap_flag_name2 = 1, soap_flag_parenteventid2 = 1, soap_flag_attachmentlist2 = 1, soap_flag_fieldlist2 = 1, soap_flag_resultingstate2 = 1, soap_flag_hours2 = 1, soap_flag_assigntolist2 = 1, soap_flag_releasenotesversion2 = 1, soap_flag_generatedeventtype2 = 1, soap_flag_generatedbyname2 = 1, soap_flag_totaltimespent2 = 1, soap_flag_overrideuser2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_user2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &(a->TT1__CEvent::user), "xsd:string"))
				{	soap_flag_user2--;
					continue;
				}
			if (soap_flag_date2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "date", &(a->TT1__CEvent::date), "xsd:dateTime"))
				{	soap_flag_date2--;
					continue;
				}
			if (soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->TT1__CEvent::notes), "xsd:string"))
				{	soap_flag_notes2--;
					continue;
				}
			if (soap_flag_eventaddorder2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "eventaddorder", &(a->TT1__CEvent::eventaddorder), "xsd:short"))
				{	soap_flag_eventaddorder2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CEvent::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_parenteventid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parenteventid", &(a->TT1__CEvent::parenteventid), "xsd:long"))
				{	soap_flag_parenteventid2--;
					continue;
				}
			if (soap_flag_attachmentlist2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", &(a->TT1__CEvent::attachmentlist), "TT1:CFileAttachment"))
				{	soap_flag_attachmentlist2--;
					continue;
				}
			if (soap_flag_fieldlist2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "fieldlist", &(a->TT1__CEvent::fieldlist), "TT1:CField"))
				{	soap_flag_fieldlist2--;
					continue;
				}
			if (soap_flag_resultingstate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "resultingstate", &(a->TT1__CEvent::resultingstate), "xsd:string"))
				{	soap_flag_resultingstate2--;
					continue;
				}
			if (soap_flag_hours2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "hours", &(a->TT1__CEvent::hours), "xsd:double"))
				{	soap_flag_hours2--;
					continue;
				}
			if (soap_flag_assigntolist2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfstring(soap, "assigntolist", &(a->TT1__CEvent::assigntolist), "xsd:string"))
				{	soap_flag_assigntolist2--;
					continue;
				}
			if (soap_flag_releasenotesversion2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "releasenotesversion", &(a->TT1__CEvent::releasenotesversion), "xsd:string"))
				{	soap_flag_releasenotesversion2--;
					continue;
				}
			if (soap_flag_generatedeventtype2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedeventtype", &(a->TT1__CEvent::generatedeventtype), "xsd:string"))
				{	soap_flag_generatedeventtype2--;
					continue;
				}
			if (soap_flag_generatedbyname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedbyname", &(a->TT1__CEvent::generatedbyname), "xsd:string"))
				{	soap_flag_generatedbyname2--;
					continue;
				}
			if (soap_flag_totaltimespent2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "totaltimespent", &(a->TT1__CEvent::totaltimespent), "xsd:double"))
				{	soap_flag_totaltimespent2--;
					continue;
				}
			if (soap_flag_overrideuser2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "overrideuser", &(a->TT1__CEvent::overrideuser), "xsd:string"))
				{	soap_flag_overrideuser2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDefectEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDefectEvent, 0, sizeof(TT1__CDefectEvent), 0, soap_copy_TT1__CDefectEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_date2 > 0 || soap_flag_eventaddorder2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDefectEvent * SOAP_FMAC6 soap_new_TT1__CDefectEvent(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDefectEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDefectEvent * SOAP_FMAC4 soap_instantiate_TT1__CDefectEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDefectEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDefectEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDefectEvent;
		if (size)
			*size = sizeof(TT1__CDefectEvent);
		((TT1__CDefectEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDefectEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDefectEvent);
		for (int i = 0; i < n; i++)
			((TT1__CDefectEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDefectEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDefectEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDefectEvent %p -> %p\n", q, p));
	*(TT1__CDefectEvent*)p = *(TT1__CDefectEvent*)q;
}

void TT1ArrayOfCEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCEvent::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCEvent))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CEvent(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCEvent(struct soap *soap, const char *tag, int id, const TT1ArrayOfCEvent *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CEvent", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCEvent);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CEvent(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCEvent(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCEvent * SOAP_FMAC4 soap_get_TT1ArrayOfCEvent(struct soap *soap, TT1ArrayOfCEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCEvent(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCEvent * SOAP_FMAC4 soap_in_TT1ArrayOfCEvent(struct soap *soap, const char *tag, TT1ArrayOfCEvent *a, const char *type)
{	int i, j;
	TT1__CEvent **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCEvent, sizeof(TT1ArrayOfCEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CEvent **)soap_malloc(soap, sizeof(TT1__CEvent *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CEvent(soap, NULL, a->__ptritem + i, "TT1:CEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CEvent **)soap_push_block(soap, sizeof(TT1__CEvent *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CEvent(soap, NULL, p, "TT1:CEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CEvent **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCEvent, 0, sizeof(TT1ArrayOfCEvent), 0, soap_copy_TT1ArrayOfCEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCEvent * SOAP_FMAC6 soap_new_TT1ArrayOfCEvent(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCEvent(struct soap *soap, TT1ArrayOfCEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCEvent * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCEvent;
		if (size)
			*size = sizeof(TT1ArrayOfCEvent);
		((TT1ArrayOfCEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCEvent);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCEvent %p -> %p\n", q, p));
	*(TT1ArrayOfCEvent*)p = *(TT1ArrayOfCEvent*)q;
}

void TT1__CEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CEvent::user);
	soap_default_time(soap, &this->TT1__CEvent::date);
	soap_default_string(soap, &this->TT1__CEvent::notes);
	soap_default_short(soap, &this->TT1__CEvent::eventaddorder);
	soap_default_string(soap, &this->TT1__CEvent::name);
	this->TT1__CEvent::parenteventid = NULL;
	this->TT1__CEvent::attachmentlist = NULL;
	this->TT1__CEvent::fieldlist = NULL;
	soap_default_string(soap, &this->TT1__CEvent::resultingstate);
	this->TT1__CEvent::hours = NULL;
	this->TT1__CEvent::assigntolist = NULL;
	soap_default_string(soap, &this->TT1__CEvent::releasenotesversion);
	soap_default_string(soap, &this->TT1__CEvent::generatedeventtype);
	soap_default_string(soap, &this->TT1__CEvent::generatedbyname);
	this->TT1__CEvent::totaltimespent = NULL;
	soap_default_string(soap, &this->TT1__CEvent::overrideuser);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CEvent::user);
	soap_embedded(soap, &this->TT1__CEvent::date, SOAP_TYPE_time);
	soap_serialize_string(soap, &this->TT1__CEvent::notes);
	soap_embedded(soap, &this->TT1__CEvent::eventaddorder, SOAP_TYPE_short);
	soap_serialize_string(soap, &this->TT1__CEvent::name);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CEvent::parenteventid);
	soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, &this->TT1__CEvent::attachmentlist);
	soap_serialize_PointerToTT1ArrayOfCField(soap, &this->TT1__CEvent::fieldlist);
	soap_serialize_string(soap, &this->TT1__CEvent::resultingstate);
	soap_serialize_PointerTodouble(soap, &this->TT1__CEvent::hours);
	soap_serialize_PointerToTT1ArrayOfstring(soap, &this->TT1__CEvent::assigntolist);
	soap_serialize_string(soap, &this->TT1__CEvent::releasenotesversion);
	soap_serialize_string(soap, &this->TT1__CEvent::generatedeventtype);
	soap_serialize_string(soap, &this->TT1__CEvent::generatedbyname);
	soap_serialize_PointerTodouble(soap, &this->TT1__CEvent::totaltimespent);
	soap_serialize_string(soap, &this->TT1__CEvent::overrideuser);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CEvent(struct soap *soap, const char *tag, int id, const TT1__CEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CEvent), "TT1:CEvent"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "user", -1, &(a->TT1__CEvent::user), ""))
		return soap->error;
	if (soap_out_time(soap, "date", -1, &(a->TT1__CEvent::date), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->TT1__CEvent::notes), ""))
		return soap->error;
	if (soap_out_short(soap, "eventaddorder", -1, &(a->TT1__CEvent::eventaddorder), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CEvent::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parenteventid", -1, &(a->TT1__CEvent::parenteventid), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->TT1__CEvent::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "fieldlist", -1, &(a->TT1__CEvent::fieldlist), ""))
		return soap->error;
	if (soap_out_string(soap, "resultingstate", -1, &(a->TT1__CEvent::resultingstate), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "hours", -1, &(a->TT1__CEvent::hours), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfstring(soap, "assigntolist", -1, &(a->TT1__CEvent::assigntolist), ""))
		return soap->error;
	if (soap_out_string(soap, "releasenotesversion", -1, &(a->TT1__CEvent::releasenotesversion), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedeventtype", -1, &(a->TT1__CEvent::generatedeventtype), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedbyname", -1, &(a->TT1__CEvent::generatedbyname), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "totaltimespent", -1, &(a->TT1__CEvent::totaltimespent), ""))
		return soap->error;
	if (soap_out_string(soap, "overrideuser", -1, &(a->TT1__CEvent::overrideuser), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CEvent(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CEvent * SOAP_FMAC4 soap_get_TT1__CEvent(struct soap *soap, TT1__CEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CEvent(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CEvent * SOAP_FMAC4 soap_in_TT1__CEvent(struct soap *soap, const char *tag, TT1__CEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CEvent, sizeof(TT1__CEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CEvent *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_user1 = 1, soap_flag_date1 = 1, soap_flag_notes1 = 1, soap_flag_eventaddorder1 = 1, soap_flag_name1 = 1, soap_flag_parenteventid1 = 1, soap_flag_attachmentlist1 = 1, soap_flag_fieldlist1 = 1, soap_flag_resultingstate1 = 1, soap_flag_hours1 = 1, soap_flag_assigntolist1 = 1, soap_flag_releasenotesversion1 = 1, soap_flag_generatedeventtype1 = 1, soap_flag_generatedbyname1 = 1, soap_flag_totaltimespent1 = 1, soap_flag_overrideuser1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &(a->TT1__CEvent::user), "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "date", &(a->TT1__CEvent::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->TT1__CEvent::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_eventaddorder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "eventaddorder", &(a->TT1__CEvent::eventaddorder), "xsd:short"))
				{	soap_flag_eventaddorder1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CEvent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_parenteventid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parenteventid", &(a->TT1__CEvent::parenteventid), "xsd:long"))
				{	soap_flag_parenteventid1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", &(a->TT1__CEvent::attachmentlist), "TT1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_fieldlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "fieldlist", &(a->TT1__CEvent::fieldlist), "TT1:CField"))
				{	soap_flag_fieldlist1--;
					continue;
				}
			if (soap_flag_resultingstate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "resultingstate", &(a->TT1__CEvent::resultingstate), "xsd:string"))
				{	soap_flag_resultingstate1--;
					continue;
				}
			if (soap_flag_hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "hours", &(a->TT1__CEvent::hours), "xsd:double"))
				{	soap_flag_hours1--;
					continue;
				}
			if (soap_flag_assigntolist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfstring(soap, "assigntolist", &(a->TT1__CEvent::assigntolist), "xsd:string"))
				{	soap_flag_assigntolist1--;
					continue;
				}
			if (soap_flag_releasenotesversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "releasenotesversion", &(a->TT1__CEvent::releasenotesversion), "xsd:string"))
				{	soap_flag_releasenotesversion1--;
					continue;
				}
			if (soap_flag_generatedeventtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedeventtype", &(a->TT1__CEvent::generatedeventtype), "xsd:string"))
				{	soap_flag_generatedeventtype1--;
					continue;
				}
			if (soap_flag_generatedbyname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedbyname", &(a->TT1__CEvent::generatedbyname), "xsd:string"))
				{	soap_flag_generatedbyname1--;
					continue;
				}
			if (soap_flag_totaltimespent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "totaltimespent", &(a->TT1__CEvent::totaltimespent), "xsd:double"))
				{	soap_flag_totaltimespent1--;
					continue;
				}
			if (soap_flag_overrideuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "overrideuser", &(a->TT1__CEvent::overrideuser), "xsd:string"))
				{	soap_flag_overrideuser1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CEvent, 0, sizeof(TT1__CEvent), 0, soap_copy_TT1__CEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_date1 > 0 || soap_flag_eventaddorder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CEvent * SOAP_FMAC6 soap_new_TT1__CEvent(struct soap *soap, int n)
{	return soap_instantiate_TT1__CEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CEvent(struct soap *soap, TT1__CEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CEvent * SOAP_FMAC4 soap_instantiate_TT1__CEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CDefectEvent"))
	{	cp->type = SOAP_TYPE_TT1__CDefectEvent;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDefectEvent;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDefectEvent);
			((TT1__CDefectEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDefectEvent[n];
			if (size)
				*size = n * sizeof(TT1__CDefectEvent);
			for (int i = 0; i < n; i++)
				((TT1__CDefectEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDefectEvent*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CEvent;
		if (size)
			*size = sizeof(TT1__CEvent);
		((TT1__CEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CEvent);
		for (int i = 0; i < n; i++)
			((TT1__CEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CEvent %p -> %p\n", q, p));
	*(TT1__CEvent*)p = *(TT1__CEvent*)q;
}

void TT1ArrayOfCTestCaseVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCTestCaseVariantField::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CTestCaseVariantField(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCTestCaseVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCTestCaseVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCTestCaseVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, int id, const TT1ArrayOfCTestCaseVariantField *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CTestCaseVariantField", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CTestCaseVariantField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCTestCaseVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCTestCaseVariantField(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCTestCaseVariantField * SOAP_FMAC4 soap_get_TT1ArrayOfCTestCaseVariantField(struct soap *soap, TT1ArrayOfCTestCaseVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCTestCaseVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCTestCaseVariantField(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCTestCaseVariantField * SOAP_FMAC4 soap_in_TT1ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, TT1ArrayOfCTestCaseVariantField *a, const char *type)
{	int i, j;
	TT1__CTestCaseVariantField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCTestCaseVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField, sizeof(TT1ArrayOfCTestCaseVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CTestCaseVariantField **)soap_malloc(soap, sizeof(TT1__CTestCaseVariantField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CTestCaseVariantField(soap, NULL, a->__ptritem + i, "TT1:CTestCaseVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CTestCaseVariantField **)soap_push_block(soap, sizeof(TT1__CTestCaseVariantField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CTestCaseVariantField(soap, NULL, p, "TT1:CTestCaseVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CTestCaseVariantField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCTestCaseVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField, 0, sizeof(TT1ArrayOfCTestCaseVariantField), 0, soap_copy_TT1ArrayOfCTestCaseVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCTestCaseVariantField * SOAP_FMAC6 soap_new_TT1ArrayOfCTestCaseVariantField(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCTestCaseVariantField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCTestCaseVariantField(struct soap *soap, TT1ArrayOfCTestCaseVariantField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCTestCaseVariantField * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCTestCaseVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCTestCaseVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCTestCaseVariantField;
		if (size)
			*size = sizeof(TT1ArrayOfCTestCaseVariantField);
		((TT1ArrayOfCTestCaseVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCTestCaseVariantField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCTestCaseVariantField);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCTestCaseVariantField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCTestCaseVariantField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCTestCaseVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCTestCaseVariantField %p -> %p\n", q, p));
	*(TT1ArrayOfCTestCaseVariantField*)p = *(TT1ArrayOfCTestCaseVariantField*)q;
}

void TT1ArrayOfCTestRunVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCTestRunVariantField::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCTestRunVariantField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CTestRunVariantField(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCTestRunVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCTestRunVariantField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCTestRunVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCTestRunVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, int id, const TT1ArrayOfCTestRunVariantField *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CTestRunVariantField", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTestRunVariantField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CTestRunVariantField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCTestRunVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCTestRunVariantField(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCTestRunVariantField * SOAP_FMAC4 soap_get_TT1ArrayOfCTestRunVariantField(struct soap *soap, TT1ArrayOfCTestRunVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCTestRunVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCTestRunVariantField(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCTestRunVariantField * SOAP_FMAC4 soap_in_TT1ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, TT1ArrayOfCTestRunVariantField *a, const char *type)
{	int i, j;
	TT1__CTestRunVariantField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCTestRunVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCTestRunVariantField, sizeof(TT1ArrayOfCTestRunVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CTestRunVariantField **)soap_malloc(soap, sizeof(TT1__CTestRunVariantField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CTestRunVariantField(soap, NULL, a->__ptritem + i, "TT1:CTestRunVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CTestRunVariantField **)soap_push_block(soap, sizeof(TT1__CTestRunVariantField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CTestRunVariantField(soap, NULL, p, "TT1:CTestRunVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CTestRunVariantField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCTestRunVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCTestRunVariantField, 0, sizeof(TT1ArrayOfCTestRunVariantField), 0, soap_copy_TT1ArrayOfCTestRunVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCTestRunVariantField * SOAP_FMAC6 soap_new_TT1ArrayOfCTestRunVariantField(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCTestRunVariantField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCTestRunVariantField(struct soap *soap, TT1ArrayOfCTestRunVariantField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCTestRunVariantField * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCTestRunVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCTestRunVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCTestRunVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCTestRunVariantField;
		if (size)
			*size = sizeof(TT1ArrayOfCTestRunVariantField);
		((TT1ArrayOfCTestRunVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCTestRunVariantField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCTestRunVariantField);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCTestRunVariantField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCTestRunVariantField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCTestRunVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCTestRunVariantField %p -> %p\n", q, p));
	*(TT1ArrayOfCTestRunVariantField*)p = *(TT1ArrayOfCTestRunVariantField*)q;
}

void TT1ArrayOfCField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCField::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CField(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCField(struct soap *soap, const char *tag, int id, const TT1ArrayOfCField *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CField", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCField(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCField * SOAP_FMAC4 soap_get_TT1ArrayOfCField(struct soap *soap, TT1ArrayOfCField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCField(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCField * SOAP_FMAC4 soap_in_TT1ArrayOfCField(struct soap *soap, const char *tag, TT1ArrayOfCField *a, const char *type)
{	int i, j;
	TT1__CField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCField, sizeof(TT1ArrayOfCField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CField **)soap_malloc(soap, sizeof(TT1__CField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CField(soap, NULL, a->__ptritem + i, "TT1:CField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CField **)soap_push_block(soap, sizeof(TT1__CField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CField(soap, NULL, p, "TT1:CField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCField, 0, sizeof(TT1ArrayOfCField), 0, soap_copy_TT1ArrayOfCField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCField * SOAP_FMAC6 soap_new_TT1ArrayOfCField(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCField(struct soap *soap, TT1ArrayOfCField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCField * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCField;
		if (size)
			*size = sizeof(TT1ArrayOfCField);
		((TT1ArrayOfCField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCField);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCField %p -> %p\n", q, p));
	*(TT1ArrayOfCField*)p = *(TT1ArrayOfCField*)q;
}

void TT1__CVersionField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CVersionField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CVersionField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CVersionField::value);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CVersionField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CVersionField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CVersionField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CVersionField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CVersionField(struct soap *soap, const char *tag, int id, const TT1__CVersionField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CVersionField), "TT1:CVersionField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->TT1__CVersionField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CVersionField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CVersionField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CVersionField * SOAP_FMAC4 soap_get_TT1__CVersionField(struct soap *soap, TT1__CVersionField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CVersionField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CVersionField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CVersionField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CVersionField * SOAP_FMAC4 soap_in_TT1__CVersionField(struct soap *soap, const char *tag, TT1__CVersionField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CVersionField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CVersionField, sizeof(TT1__CVersionField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CVersionField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CVersionField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->TT1__CVersionField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CVersionField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CVersionField, 0, sizeof(TT1__CVersionField), 0, soap_copy_TT1__CVersionField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CVersionField * SOAP_FMAC6 soap_new_TT1__CVersionField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CVersionField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CVersionField(struct soap *soap, TT1__CVersionField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CVersionField * SOAP_FMAC4 soap_instantiate_TT1__CVersionField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CVersionField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CVersionField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CVersionField;
		if (size)
			*size = sizeof(TT1__CVersionField);
		((TT1__CVersionField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CVersionField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CVersionField);
		for (int i = 0; i < n; i++)
			((TT1__CVersionField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CVersionField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CVersionField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CVersionField %p -> %p\n", q, p));
	*(TT1__CVersionField*)p = *(TT1__CVersionField*)q;
}

void TT1__CTestCaseVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CTestCaseVariantField::type);
	this->TT1__CMultiSelectDropdownField::values = NULL;
	this->TT1__CMultiSelectDropdownField::dropdownValues = NULL;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CTestCaseVariantField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CTestCaseVariantField::type);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::values);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::dropdownValues);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CTestCaseVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTestCaseVariantField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTestCaseVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTestCaseVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, const TT1__CTestCaseVariantField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTestCaseVariantField), "TT1:CTestCaseVariantField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "values", -1, &(a->TT1__CMultiSelectDropdownField::values), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->TT1__CMultiSelectDropdownField::dropdownValues), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->TT1__CTestCaseVariantField::type), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CTestCaseVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTestCaseVariantField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTestCaseVariantField * SOAP_FMAC4 soap_get_TT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTestCaseVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTestCaseVariantField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTestCaseVariantField * SOAP_FMAC4 soap_in_TT1__CTestCaseVariantField(struct soap *soap, const char *tag, TT1__CTestCaseVariantField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTestCaseVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTestCaseVariantField, sizeof(TT1__CTestCaseVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTestCaseVariantField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTestCaseVariantField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid5 = 1, soap_flag_name4 = 1, soap_flag_values3 = 1, soap_flag_dropdownValues3 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid5--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name4--;
					continue;
				}
			if (soap_flag_values3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "values", &(a->TT1__CMultiSelectDropdownField::values), "TT1:CFieldValue"))
				{	soap_flag_values3--;
					continue;
				}
			if (soap_flag_dropdownValues3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", &(a->TT1__CMultiSelectDropdownField::dropdownValues), "TT1:CFieldValue"))
				{	soap_flag_dropdownValues3--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->TT1__CTestCaseVariantField::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTestCaseVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTestCaseVariantField, 0, sizeof(TT1__CTestCaseVariantField), 0, soap_copy_TT1__CTestCaseVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid5 > 0 || soap_flag_name4 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTestCaseVariantField * SOAP_FMAC6 soap_new_TT1__CTestCaseVariantField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTestCaseVariantField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTestCaseVariantField * SOAP_FMAC4 soap_instantiate_TT1__CTestCaseVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTestCaseVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTestCaseVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTestCaseVariantField;
		if (size)
			*size = sizeof(TT1__CTestCaseVariantField);
		((TT1__CTestCaseVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTestCaseVariantField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTestCaseVariantField);
		for (int i = 0; i < n; i++)
			((TT1__CTestCaseVariantField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTestCaseVariantField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTestCaseVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTestCaseVariantField %p -> %p\n", q, p));
	*(TT1__CTestCaseVariantField*)p = *(TT1__CTestCaseVariantField*)q;
}

void TT1__CTestRunVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CMultiSelectDropdownField::values = NULL;
	this->TT1__CMultiSelectDropdownField::dropdownValues = NULL;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CTestRunVariantField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::values);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::dropdownValues);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CTestRunVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTestRunVariantField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTestRunVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTestRunVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTestRunVariantField(struct soap *soap, const char *tag, int id, const TT1__CTestRunVariantField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTestRunVariantField), "TT1:CTestRunVariantField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "values", -1, &(a->TT1__CMultiSelectDropdownField::values), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->TT1__CMultiSelectDropdownField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CTestRunVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTestRunVariantField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTestRunVariantField * SOAP_FMAC4 soap_get_TT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTestRunVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTestRunVariantField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTestRunVariantField * SOAP_FMAC4 soap_in_TT1__CTestRunVariantField(struct soap *soap, const char *tag, TT1__CTestRunVariantField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTestRunVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTestRunVariantField, sizeof(TT1__CTestRunVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTestRunVariantField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTestRunVariantField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid4 = 1, soap_flag_name3 = 1, soap_flag_values2 = 1, soap_flag_dropdownValues2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name3--;
					continue;
				}
			if (soap_flag_values2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "values", &(a->TT1__CMultiSelectDropdownField::values), "TT1:CFieldValue"))
				{	soap_flag_values2--;
					continue;
				}
			if (soap_flag_dropdownValues2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", &(a->TT1__CMultiSelectDropdownField::dropdownValues), "TT1:CFieldValue"))
				{	soap_flag_dropdownValues2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTestRunVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTestRunVariantField, 0, sizeof(TT1__CTestRunVariantField), 0, soap_copy_TT1__CTestRunVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid4 > 0 || soap_flag_name3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTestRunVariantField * SOAP_FMAC6 soap_new_TT1__CTestRunVariantField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTestRunVariantField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTestRunVariantField * SOAP_FMAC4 soap_instantiate_TT1__CTestRunVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTestRunVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTestRunVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CTestCaseVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestCaseVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCaseVariantField);
			((TT1__CTestCaseVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestCaseVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestCaseVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCaseVariantField*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTestRunVariantField;
		if (size)
			*size = sizeof(TT1__CTestRunVariantField);
		((TT1__CTestRunVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTestRunVariantField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTestRunVariantField);
		for (int i = 0; i < n; i++)
			((TT1__CTestRunVariantField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTestRunVariantField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTestRunVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTestRunVariantField %p -> %p\n", q, p));
	*(TT1__CTestRunVariantField*)p = *(TT1__CTestRunVariantField*)q;
}

void TT1__CMultiSelectDropdownField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CMultiSelectDropdownField::values = NULL;
	this->TT1__CMultiSelectDropdownField::dropdownValues = NULL;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CMultiSelectDropdownField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::values);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CMultiSelectDropdownField::dropdownValues);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CMultiSelectDropdownField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CMultiSelectDropdownField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CMultiSelectDropdownField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CMultiSelectDropdownField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CMultiSelectDropdownField(struct soap *soap, const char *tag, int id, const TT1__CMultiSelectDropdownField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CMultiSelectDropdownField), "TT1:CMultiSelectDropdownField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "values", -1, &(a->TT1__CMultiSelectDropdownField::values), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->TT1__CMultiSelectDropdownField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CMultiSelectDropdownField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CMultiSelectDropdownField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CMultiSelectDropdownField * SOAP_FMAC4 soap_get_TT1__CMultiSelectDropdownField(struct soap *soap, TT1__CMultiSelectDropdownField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CMultiSelectDropdownField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CMultiSelectDropdownField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CMultiSelectDropdownField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CMultiSelectDropdownField * SOAP_FMAC4 soap_in_TT1__CMultiSelectDropdownField(struct soap *soap, const char *tag, TT1__CMultiSelectDropdownField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CMultiSelectDropdownField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CMultiSelectDropdownField, sizeof(TT1__CMultiSelectDropdownField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CMultiSelectDropdownField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CMultiSelectDropdownField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_values1 = 1, soap_flag_dropdownValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "values", &(a->TT1__CMultiSelectDropdownField::values), "TT1:CFieldValue"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", &(a->TT1__CMultiSelectDropdownField::dropdownValues), "TT1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CMultiSelectDropdownField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CMultiSelectDropdownField, 0, sizeof(TT1__CMultiSelectDropdownField), 0, soap_copy_TT1__CMultiSelectDropdownField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CMultiSelectDropdownField * SOAP_FMAC6 soap_new_TT1__CMultiSelectDropdownField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CMultiSelectDropdownField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CMultiSelectDropdownField(struct soap *soap, TT1__CMultiSelectDropdownField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CMultiSelectDropdownField * SOAP_FMAC4 soap_instantiate_TT1__CMultiSelectDropdownField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CMultiSelectDropdownField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CMultiSelectDropdownField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CTestRunVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestRunVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestRunVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestRunVariantField);
			((TT1__CTestRunVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestRunVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestRunVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestRunVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestRunVariantField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestCaseVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestCaseVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCaseVariantField);
			((TT1__CTestCaseVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestCaseVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestCaseVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCaseVariantField*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField;
		if (size)
			*size = sizeof(TT1__CMultiSelectDropdownField);
		((TT1__CMultiSelectDropdownField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CMultiSelectDropdownField);
		for (int i = 0; i < n; i++)
			((TT1__CMultiSelectDropdownField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CMultiSelectDropdownField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CMultiSelectDropdownField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CMultiSelectDropdownField %p -> %p\n", q, p));
	*(TT1__CMultiSelectDropdownField*)p = *(TT1__CMultiSelectDropdownField*)q;
}

void TT1__CDropdownField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CDropdownField::value);
	this->TT1__CDropdownField::dropdownValues = NULL;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDropdownField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CDropdownField::value);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &this->TT1__CDropdownField::dropdownValues);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDropdownField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDropdownField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDropdownField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDropdownField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDropdownField(struct soap *soap, const char *tag, int id, const TT1__CDropdownField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDropdownField), "TT1:CDropdownField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->TT1__CDropdownField::value), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->TT1__CDropdownField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDropdownField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDropdownField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDropdownField * SOAP_FMAC4 soap_get_TT1__CDropdownField(struct soap *soap, TT1__CDropdownField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDropdownField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDropdownField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDropdownField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDropdownField * SOAP_FMAC4 soap_in_TT1__CDropdownField(struct soap *soap, const char *tag, TT1__CDropdownField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDropdownField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDropdownField, sizeof(TT1__CDropdownField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDropdownField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDropdownField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1, soap_flag_dropdownValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->TT1__CDropdownField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "dropdownValues", &(a->TT1__CDropdownField::dropdownValues), "TT1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDropdownField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDropdownField, 0, sizeof(TT1__CDropdownField), 0, soap_copy_TT1__CDropdownField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDropdownField * SOAP_FMAC6 soap_new_TT1__CDropdownField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDropdownField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDropdownField(struct soap *soap, TT1__CDropdownField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDropdownField * SOAP_FMAC4 soap_instantiate_TT1__CDropdownField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDropdownField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDropdownField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDropdownField;
		if (size)
			*size = sizeof(TT1__CDropdownField);
		((TT1__CDropdownField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDropdownField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDropdownField);
		for (int i = 0; i < n; i++)
			((TT1__CDropdownField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDropdownField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDropdownField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDropdownField %p -> %p\n", q, p));
	*(TT1__CDropdownField*)p = *(TT1__CDropdownField*)q;
}

void TT1__CDateTimeField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CDateTimeField::value = NULL;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDateTimeField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->TT1__CDateTimeField::value);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDateTimeField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDateTimeField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDateTimeField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDateTimeField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDateTimeField(struct soap *soap, const char *tag, int id, const TT1__CDateTimeField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDateTimeField), "TT1:CDateTimeField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "value", -1, &(a->TT1__CDateTimeField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDateTimeField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDateTimeField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDateTimeField * SOAP_FMAC4 soap_get_TT1__CDateTimeField(struct soap *soap, TT1__CDateTimeField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDateTimeField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDateTimeField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDateTimeField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDateTimeField * SOAP_FMAC4 soap_in_TT1__CDateTimeField(struct soap *soap, const char *tag, TT1__CDateTimeField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDateTimeField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDateTimeField, sizeof(TT1__CDateTimeField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDateTimeField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDateTimeField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "value", &(a->TT1__CDateTimeField::value), "xsd:dateTime"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDateTimeField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDateTimeField, 0, sizeof(TT1__CDateTimeField), 0, soap_copy_TT1__CDateTimeField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDateTimeField * SOAP_FMAC6 soap_new_TT1__CDateTimeField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDateTimeField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDateTimeField(struct soap *soap, TT1__CDateTimeField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDateTimeField * SOAP_FMAC4 soap_instantiate_TT1__CDateTimeField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDateTimeField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDateTimeField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDateTimeField;
		if (size)
			*size = sizeof(TT1__CDateTimeField);
		((TT1__CDateTimeField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDateTimeField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDateTimeField);
		for (int i = 0; i < n; i++)
			((TT1__CDateTimeField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDateTimeField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDateTimeField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDateTimeField %p -> %p\n", q, p));
	*(TT1__CDateTimeField*)p = *(TT1__CDateTimeField*)q;
}

void TT1__CDateField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->TT1__CDateField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDateField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->TT1__CDateField::value);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDateField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDateField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDateField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDateField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDateField(struct soap *soap, const char *tag, int id, const TT1__CDateField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDateField), "TT1:CDateField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "value", -1, &(a->TT1__CDateField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDateField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDateField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDateField * SOAP_FMAC4 soap_get_TT1__CDateField(struct soap *soap, TT1__CDateField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDateField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDateField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDateField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDateField * SOAP_FMAC4 soap_in_TT1__CDateField(struct soap *soap, const char *tag, TT1__CDateField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDateField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDateField, sizeof(TT1__CDateField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDateField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDateField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "value", &(a->TT1__CDateField::value), "xsd:date"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDateField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDateField, 0, sizeof(TT1__CDateField), 0, soap_copy_TT1__CDateField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDateField * SOAP_FMAC6 soap_new_TT1__CDateField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDateField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDateField(struct soap *soap, TT1__CDateField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDateField * SOAP_FMAC4 soap_instantiate_TT1__CDateField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDateField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDateField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDateField;
		if (size)
			*size = sizeof(TT1__CDateField);
		((TT1__CDateField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDateField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDateField);
		for (int i = 0; i < n; i++)
			((TT1__CDateField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDateField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDateField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDateField %p -> %p\n", q, p));
	*(TT1__CDateField*)p = *(TT1__CDateField*)q;
}

void TT1__CBooleanField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->TT1__CBooleanField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CBooleanField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__CBooleanField::value, SOAP_TYPE_bool);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CBooleanField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CBooleanField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CBooleanField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CBooleanField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CBooleanField(struct soap *soap, const char *tag, int id, const TT1__CBooleanField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CBooleanField), "TT1:CBooleanField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &(a->TT1__CBooleanField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CBooleanField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CBooleanField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CBooleanField * SOAP_FMAC4 soap_get_TT1__CBooleanField(struct soap *soap, TT1__CBooleanField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CBooleanField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CBooleanField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CBooleanField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CBooleanField * SOAP_FMAC4 soap_in_TT1__CBooleanField(struct soap *soap, const char *tag, TT1__CBooleanField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CBooleanField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CBooleanField, sizeof(TT1__CBooleanField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CBooleanField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CBooleanField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "value", &(a->TT1__CBooleanField::value), "xsd:boolean"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CBooleanField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CBooleanField, 0, sizeof(TT1__CBooleanField), 0, soap_copy_TT1__CBooleanField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CBooleanField * SOAP_FMAC6 soap_new_TT1__CBooleanField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CBooleanField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CBooleanField(struct soap *soap, TT1__CBooleanField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CBooleanField * SOAP_FMAC4 soap_instantiate_TT1__CBooleanField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CBooleanField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CBooleanField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CBooleanField;
		if (size)
			*size = sizeof(TT1__CBooleanField);
		((TT1__CBooleanField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CBooleanField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CBooleanField);
		for (int i = 0; i < n; i++)
			((TT1__CBooleanField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CBooleanField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CBooleanField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CBooleanField %p -> %p\n", q, p));
	*(TT1__CBooleanField*)p = *(TT1__CBooleanField*)q;
}

void TT1__CDecimalField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->TT1__CDecimalField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CDecimalField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__CDecimalField::value, SOAP_TYPE_double);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CDecimalField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDecimalField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDecimalField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDecimalField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDecimalField(struct soap *soap, const char *tag, int id, const TT1__CDecimalField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDecimalField), "TT1:CDecimalField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &(a->TT1__CDecimalField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CDecimalField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDecimalField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDecimalField * SOAP_FMAC4 soap_get_TT1__CDecimalField(struct soap *soap, TT1__CDecimalField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDecimalField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDecimalField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDecimalField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDecimalField * SOAP_FMAC4 soap_in_TT1__CDecimalField(struct soap *soap, const char *tag, TT1__CDecimalField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDecimalField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDecimalField, sizeof(TT1__CDecimalField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDecimalField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDecimalField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &(a->TT1__CDecimalField::value), "xsd:double"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDecimalField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDecimalField, 0, sizeof(TT1__CDecimalField), 0, soap_copy_TT1__CDecimalField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDecimalField * SOAP_FMAC6 soap_new_TT1__CDecimalField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDecimalField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDecimalField(struct soap *soap, TT1__CDecimalField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDecimalField * SOAP_FMAC4 soap_instantiate_TT1__CDecimalField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDecimalField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDecimalField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDecimalField;
		if (size)
			*size = sizeof(TT1__CDecimalField);
		((TT1__CDecimalField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDecimalField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDecimalField);
		for (int i = 0; i < n; i++)
			((TT1__CDecimalField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDecimalField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDecimalField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDecimalField %p -> %p\n", q, p));
	*(TT1__CDecimalField*)p = *(TT1__CDecimalField*)q;
}

void TT1__CIntegerField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->TT1__CIntegerField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CIntegerField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__CIntegerField::value, SOAP_TYPE_int);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CIntegerField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CIntegerField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CIntegerField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CIntegerField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CIntegerField(struct soap *soap, const char *tag, int id, const TT1__CIntegerField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CIntegerField), "TT1:CIntegerField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &(a->TT1__CIntegerField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CIntegerField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CIntegerField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CIntegerField * SOAP_FMAC4 soap_get_TT1__CIntegerField(struct soap *soap, TT1__CIntegerField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CIntegerField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CIntegerField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CIntegerField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CIntegerField * SOAP_FMAC4 soap_in_TT1__CIntegerField(struct soap *soap, const char *tag, TT1__CIntegerField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CIntegerField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CIntegerField, sizeof(TT1__CIntegerField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CIntegerField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CIntegerField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &(a->TT1__CIntegerField::value), "xsd:int"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CIntegerField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CIntegerField, 0, sizeof(TT1__CIntegerField), 0, soap_copy_TT1__CIntegerField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CIntegerField * SOAP_FMAC6 soap_new_TT1__CIntegerField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CIntegerField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CIntegerField(struct soap *soap, TT1__CIntegerField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CIntegerField * SOAP_FMAC4 soap_instantiate_TT1__CIntegerField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CIntegerField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CIntegerField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CIntegerField;
		if (size)
			*size = sizeof(TT1__CIntegerField);
		((TT1__CIntegerField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CIntegerField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CIntegerField);
		for (int i = 0; i < n; i++)
			((TT1__CIntegerField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CIntegerField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CIntegerField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CIntegerField %p -> %p\n", q, p));
	*(TT1__CIntegerField*)p = *(TT1__CIntegerField*)q;
}

void TT1__CStringField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CStringField::value);
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CStringField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CStringField::value);
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CStringField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CStringField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CStringField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CStringField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CStringField(struct soap *soap, const char *tag, int id, const TT1__CStringField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CStringField), "TT1:CStringField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->TT1__CStringField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CStringField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CStringField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CStringField * SOAP_FMAC4 soap_get_TT1__CStringField(struct soap *soap, TT1__CStringField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CStringField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CStringField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CStringField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CStringField * SOAP_FMAC4 soap_in_TT1__CStringField(struct soap *soap, const char *tag, TT1__CStringField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CStringField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CStringField, sizeof(TT1__CStringField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CStringField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CStringField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_name2 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->TT1__CStringField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CStringField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CStringField, 0, sizeof(TT1__CStringField), 0, soap_copy_TT1__CStringField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_name2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CStringField * SOAP_FMAC6 soap_new_TT1__CStringField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CStringField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CStringField(struct soap *soap, TT1__CStringField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CStringField * SOAP_FMAC4 soap_instantiate_TT1__CStringField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CStringField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CStringField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CStringField;
		if (size)
			*size = sizeof(TT1__CStringField);
		((TT1__CStringField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CStringField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CStringField);
		for (int i = 0; i < n; i++)
			((TT1__CStringField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CStringField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CStringField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CStringField %p -> %p\n", q, p));
	*(TT1__CStringField*)p = *(TT1__CStringField*)q;
}

void TT1__CField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CField::name);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CField::name);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CField(struct soap *soap, const char *tag, int id, const TT1__CField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CField), "TT1:CField"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "name", -1, &(a->TT1__CField::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CField * SOAP_FMAC4 soap_get_TT1__CField(struct soap *soap, TT1__CField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CField * SOAP_FMAC4 soap_in_TT1__CField(struct soap *soap, const char *tag, TT1__CField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CField, sizeof(TT1__CField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CField, 0, sizeof(TT1__CField), 0, soap_copy_TT1__CField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CField * SOAP_FMAC6 soap_new_TT1__CField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CField(struct soap *soap, TT1__CField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CField * SOAP_FMAC4 soap_instantiate_TT1__CField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CStringField"))
	{	cp->type = SOAP_TYPE_TT1__CStringField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CStringField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CStringField);
			((TT1__CStringField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CStringField[n];
			if (size)
				*size = n * sizeof(TT1__CStringField);
			for (int i = 0; i < n; i++)
				((TT1__CStringField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CStringField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CIntegerField"))
	{	cp->type = SOAP_TYPE_TT1__CIntegerField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CIntegerField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CIntegerField);
			((TT1__CIntegerField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CIntegerField[n];
			if (size)
				*size = n * sizeof(TT1__CIntegerField);
			for (int i = 0; i < n; i++)
				((TT1__CIntegerField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CIntegerField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDecimalField"))
	{	cp->type = SOAP_TYPE_TT1__CDecimalField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDecimalField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDecimalField);
			((TT1__CDecimalField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDecimalField[n];
			if (size)
				*size = n * sizeof(TT1__CDecimalField);
			for (int i = 0; i < n; i++)
				((TT1__CDecimalField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDecimalField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CBooleanField"))
	{	cp->type = SOAP_TYPE_TT1__CBooleanField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CBooleanField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CBooleanField);
			((TT1__CBooleanField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CBooleanField[n];
			if (size)
				*size = n * sizeof(TT1__CBooleanField);
			for (int i = 0; i < n; i++)
				((TT1__CBooleanField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CBooleanField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDateField"))
	{	cp->type = SOAP_TYPE_TT1__CDateField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDateField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDateField);
			((TT1__CDateField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDateField[n];
			if (size)
				*size = n * sizeof(TT1__CDateField);
			for (int i = 0; i < n; i++)
				((TT1__CDateField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDateField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDateTimeField"))
	{	cp->type = SOAP_TYPE_TT1__CDateTimeField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDateTimeField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDateTimeField);
			((TT1__CDateTimeField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDateTimeField[n];
			if (size)
				*size = n * sizeof(TT1__CDateTimeField);
			for (int i = 0; i < n; i++)
				((TT1__CDateTimeField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDateTimeField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDropdownField"))
	{	cp->type = SOAP_TYPE_TT1__CDropdownField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDropdownField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDropdownField);
			((TT1__CDropdownField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDropdownField[n];
			if (size)
				*size = n * sizeof(TT1__CDropdownField);
			for (int i = 0; i < n; i++)
				((TT1__CDropdownField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDropdownField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CMultiSelectDropdownField"))
	{	cp->type = SOAP_TYPE_TT1__CMultiSelectDropdownField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CMultiSelectDropdownField);
			((TT1__CMultiSelectDropdownField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField[n];
			if (size)
				*size = n * sizeof(TT1__CMultiSelectDropdownField);
			for (int i = 0; i < n; i++)
				((TT1__CMultiSelectDropdownField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CMultiSelectDropdownField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CVersionField"))
	{	cp->type = SOAP_TYPE_TT1__CVersionField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CVersionField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CVersionField);
			((TT1__CVersionField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CVersionField[n];
			if (size)
				*size = n * sizeof(TT1__CVersionField);
			for (int i = 0; i < n; i++)
				((TT1__CVersionField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CVersionField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestRunVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestRunVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestRunVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestRunVariantField);
			((TT1__CTestRunVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestRunVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestRunVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestRunVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestRunVariantField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestCaseVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestCaseVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCaseVariantField);
			((TT1__CTestCaseVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestCaseVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestCaseVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCaseVariantField*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CField;
		if (size)
			*size = sizeof(TT1__CField);
		((TT1__CField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CField);
		for (int i = 0; i < n; i++)
			((TT1__CField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CField %p -> %p\n", q, p));
	*(TT1__CField*)p = *(TT1__CField*)q;
}

void TT1ArrayOfCReportedByRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCReportedByRecord::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCReportedByRecord))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CReportedByRecord(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCReportedByRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCReportedByRecord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCReportedByRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCReportedByRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCReportedByRecord(struct soap *soap, const char *tag, int id, const TT1ArrayOfCReportedByRecord *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CReportedByRecord", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCReportedByRecord);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CReportedByRecord(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCReportedByRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCReportedByRecord(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCReportedByRecord * SOAP_FMAC4 soap_get_TT1ArrayOfCReportedByRecord(struct soap *soap, TT1ArrayOfCReportedByRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCReportedByRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCReportedByRecord(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCReportedByRecord * SOAP_FMAC4 soap_in_TT1ArrayOfCReportedByRecord(struct soap *soap, const char *tag, TT1ArrayOfCReportedByRecord *a, const char *type)
{	int i, j;
	TT1__CReportedByRecord **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCReportedByRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCReportedByRecord, sizeof(TT1ArrayOfCReportedByRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CReportedByRecord **)soap_malloc(soap, sizeof(TT1__CReportedByRecord *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CReportedByRecord(soap, NULL, a->__ptritem + i, "TT1:CReportedByRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CReportedByRecord **)soap_push_block(soap, sizeof(TT1__CReportedByRecord *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CReportedByRecord(soap, NULL, p, "TT1:CReportedByRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CReportedByRecord **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCReportedByRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCReportedByRecord, 0, sizeof(TT1ArrayOfCReportedByRecord), 0, soap_copy_TT1ArrayOfCReportedByRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCReportedByRecord * SOAP_FMAC6 soap_new_TT1ArrayOfCReportedByRecord(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCReportedByRecord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCReportedByRecord(struct soap *soap, TT1ArrayOfCReportedByRecord *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCReportedByRecord * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCReportedByRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCReportedByRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCReportedByRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCReportedByRecord;
		if (size)
			*size = sizeof(TT1ArrayOfCReportedByRecord);
		((TT1ArrayOfCReportedByRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCReportedByRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCReportedByRecord);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCReportedByRecord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCReportedByRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCReportedByRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCReportedByRecord %p -> %p\n", q, p));
	*(TT1ArrayOfCReportedByRecord*)p = *(TT1ArrayOfCReportedByRecord*)q;
}

void TT1__CReportedByRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CReportedByRecord::foundby);
	soap_default_xsd__date(soap, &this->TT1__CReportedByRecord::datefound);
	soap_default_string(soap, &this->TT1__CReportedByRecord::contactinfo);
	soap_default_string(soap, &this->TT1__CReportedByRecord::foundinversion);
	soap_default_string(soap, &this->TT1__CReportedByRecord::comments);
	soap_default_string(soap, &this->TT1__CReportedByRecord::reproduced);
	soap_default_string(soap, &this->TT1__CReportedByRecord::reproducedsteps);
	this->TT1__CReportedByRecord::standardtestconfig = NULL;
	soap_default_string(soap, &this->TT1__CReportedByRecord::otherhardwaresoftware);
	this->TT1__CReportedByRecord::testconfigtype = NULL;
	this->TT1__CReportedByRecord::attachmentlist = NULL;
	soap_default_short(soap, &this->TT1__CReportedByRecord::showorder);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CReportedByRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::foundby);
	soap_serialize_xsd__date(soap, &this->TT1__CReportedByRecord::datefound);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::contactinfo);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::foundinversion);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::comments);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::reproduced);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::reproducedsteps);
	soap_serialize_PointerToTT1__CSystem(soap, &this->TT1__CReportedByRecord::standardtestconfig);
	soap_serialize_string(soap, &this->TT1__CReportedByRecord::otherhardwaresoftware);
	soap_serialize_PointerToshort(soap, &this->TT1__CReportedByRecord::testconfigtype);
	soap_serialize_PointerToTT1ArrayOfCFileAttachment(soap, &this->TT1__CReportedByRecord::attachmentlist);
	soap_embedded(soap, &this->TT1__CReportedByRecord::showorder, SOAP_TYPE_short);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CReportedByRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CReportedByRecord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CReportedByRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CReportedByRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CReportedByRecord(struct soap *soap, const char *tag, int id, const TT1__CReportedByRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CReportedByRecord), "TT1:CReportedByRecord"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "foundby", -1, &(a->TT1__CReportedByRecord::foundby), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "datefound", -1, &(a->TT1__CReportedByRecord::datefound), ""))
		return soap->error;
	if (soap_out_string(soap, "contactinfo", -1, &(a->TT1__CReportedByRecord::contactinfo), ""))
		return soap->error;
	if (soap_out_string(soap, "foundinversion", -1, &(a->TT1__CReportedByRecord::foundinversion), ""))
		return soap->error;
	if (soap_out_string(soap, "comments", -1, &(a->TT1__CReportedByRecord::comments), ""))
		return soap->error;
	if (soap_out_string(soap, "reproduced", -1, &(a->TT1__CReportedByRecord::reproduced), ""))
		return soap->error;
	if (soap_out_string(soap, "reproducedsteps", -1, &(a->TT1__CReportedByRecord::reproducedsteps), ""))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "standardtestconfig", -1, &(a->TT1__CReportedByRecord::standardtestconfig), ""))
		return soap->error;
	if (soap_out_string(soap, "otherhardwaresoftware", -1, &(a->TT1__CReportedByRecord::otherhardwaresoftware), ""))
		return soap->error;
	if (soap_out_PointerToshort(soap, "testconfigtype", -1, &(a->TT1__CReportedByRecord::testconfigtype), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->TT1__CReportedByRecord::attachmentlist), ""))
		return soap->error;
	if (soap_out_short(soap, "showorder", -1, &(a->TT1__CReportedByRecord::showorder), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CReportedByRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CReportedByRecord(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CReportedByRecord * SOAP_FMAC4 soap_get_TT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CReportedByRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CReportedByRecord(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CReportedByRecord * SOAP_FMAC4 soap_in_TT1__CReportedByRecord(struct soap *soap, const char *tag, TT1__CReportedByRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CReportedByRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CReportedByRecord, sizeof(TT1__CReportedByRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CReportedByRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CReportedByRecord *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_foundby1 = 1, soap_flag_datefound1 = 1, soap_flag_contactinfo1 = 1, soap_flag_foundinversion1 = 1, soap_flag_comments1 = 1, soap_flag_reproduced1 = 1, soap_flag_reproducedsteps1 = 1, soap_flag_standardtestconfig1 = 1, soap_flag_otherhardwaresoftware1 = 1, soap_flag_testconfigtype1 = 1, soap_flag_attachmentlist1 = 1, soap_flag_showorder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_foundby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "foundby", &(a->TT1__CReportedByRecord::foundby), "xsd:string"))
				{	soap_flag_foundby1--;
					continue;
				}
			if (soap_flag_datefound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "datefound", &(a->TT1__CReportedByRecord::datefound), "xsd:date"))
				{	soap_flag_datefound1--;
					continue;
				}
			if (soap_flag_contactinfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "contactinfo", &(a->TT1__CReportedByRecord::contactinfo), "xsd:string"))
				{	soap_flag_contactinfo1--;
					continue;
				}
			if (soap_flag_foundinversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "foundinversion", &(a->TT1__CReportedByRecord::foundinversion), "xsd:string"))
				{	soap_flag_foundinversion1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comments", &(a->TT1__CReportedByRecord::comments), "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_reproduced1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reproduced", &(a->TT1__CReportedByRecord::reproduced), "xsd:string"))
				{	soap_flag_reproduced1--;
					continue;
				}
			if (soap_flag_reproducedsteps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reproducedsteps", &(a->TT1__CReportedByRecord::reproducedsteps), "xsd:string"))
				{	soap_flag_reproducedsteps1--;
					continue;
				}
			if (soap_flag_standardtestconfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "standardtestconfig", &(a->TT1__CReportedByRecord::standardtestconfig), "TT1:CSystem"))
				{	soap_flag_standardtestconfig1--;
					continue;
				}
			if (soap_flag_otherhardwaresoftware1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "otherhardwaresoftware", &(a->TT1__CReportedByRecord::otherhardwaresoftware), "xsd:string"))
				{	soap_flag_otherhardwaresoftware1--;
					continue;
				}
			if (soap_flag_testconfigtype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "testconfigtype", &(a->TT1__CReportedByRecord::testconfigtype), "xsd:short"))
				{	soap_flag_testconfigtype1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFileAttachment(soap, "attachmentlist", &(a->TT1__CReportedByRecord::attachmentlist), "TT1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_showorder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "showorder", &(a->TT1__CReportedByRecord::showorder), "xsd:short"))
				{	soap_flag_showorder1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CReportedByRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CReportedByRecord, 0, sizeof(TT1__CReportedByRecord), 0, soap_copy_TT1__CReportedByRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_showorder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CReportedByRecord * SOAP_FMAC6 soap_new_TT1__CReportedByRecord(struct soap *soap, int n)
{	return soap_instantiate_TT1__CReportedByRecord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CReportedByRecord * SOAP_FMAC4 soap_instantiate_TT1__CReportedByRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CReportedByRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CReportedByRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CReportedByRecord;
		if (size)
			*size = sizeof(TT1__CReportedByRecord);
		((TT1__CReportedByRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CReportedByRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CReportedByRecord);
		for (int i = 0; i < n; i++)
			((TT1__CReportedByRecord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CReportedByRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CReportedByRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CReportedByRecord %p -> %p\n", q, p));
	*(TT1__CReportedByRecord*)p = *(TT1__CReportedByRecord*)q;
}

void TT1ArrayOfCFileAttachment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCFileAttachment::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCFileAttachment))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CFileAttachment(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCFileAttachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCFileAttachment);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCFileAttachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCFileAttachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCFileAttachment(struct soap *soap, const char *tag, int id, const TT1ArrayOfCFileAttachment *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CFileAttachment", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFileAttachment);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CFileAttachment(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCFileAttachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCFileAttachment(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCFileAttachment * SOAP_FMAC4 soap_get_TT1ArrayOfCFileAttachment(struct soap *soap, TT1ArrayOfCFileAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCFileAttachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCFileAttachment(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCFileAttachment * SOAP_FMAC4 soap_in_TT1ArrayOfCFileAttachment(struct soap *soap, const char *tag, TT1ArrayOfCFileAttachment *a, const char *type)
{	int i, j;
	TT1__CFileAttachment **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCFileAttachment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCFileAttachment, sizeof(TT1ArrayOfCFileAttachment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CFileAttachment **)soap_malloc(soap, sizeof(TT1__CFileAttachment *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CFileAttachment(soap, NULL, a->__ptritem + i, "TT1:CFileAttachment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CFileAttachment **)soap_push_block(soap, sizeof(TT1__CFileAttachment *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CFileAttachment(soap, NULL, p, "TT1:CFileAttachment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CFileAttachment **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCFileAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCFileAttachment, 0, sizeof(TT1ArrayOfCFileAttachment), 0, soap_copy_TT1ArrayOfCFileAttachment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCFileAttachment * SOAP_FMAC6 soap_new_TT1ArrayOfCFileAttachment(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCFileAttachment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCFileAttachment(struct soap *soap, TT1ArrayOfCFileAttachment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCFileAttachment * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCFileAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCFileAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCFileAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCFileAttachment;
		if (size)
			*size = sizeof(TT1ArrayOfCFileAttachment);
		((TT1ArrayOfCFileAttachment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCFileAttachment[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCFileAttachment);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCFileAttachment*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCFileAttachment*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCFileAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCFileAttachment %p -> %p\n", q, p));
	*(TT1ArrayOfCFileAttachment*)p = *(TT1ArrayOfCFileAttachment*)q;
}

void TT1__CFileAttachment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CFileAttachment::m_pFileData = NULL;
	soap_default_string(soap, &this->TT1__CFileAttachment::m_strFileName);
	soap_default_string(soap, &this->TT1__CFileAttachment::m_strArchiveName);
	soap_default_string(soap, &this->TT1__CFileAttachment::m_strType);
	this->TT1__CFileAttachment::m_scriptOrder = NULL;
	soap_default_string(soap, &this->TT1__CFileAttachment::m_strScriptState);
	/* transient soap skipped */
}

void TT1__CFileAttachment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->TT1__CFileAttachment::m_pFileData);
	soap_serialize_string(soap, &this->TT1__CFileAttachment::m_strFileName);
	soap_serialize_string(soap, &this->TT1__CFileAttachment::m_strArchiveName);
	soap_serialize_string(soap, &this->TT1__CFileAttachment::m_strType);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CFileAttachment::m_scriptOrder);
	soap_serialize_string(soap, &this->TT1__CFileAttachment::m_strScriptState);
	/* transient soap skipped */
}

int TT1__CFileAttachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CFileAttachment);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CFileAttachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CFileAttachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CFileAttachment(struct soap *soap, const char *tag, int id, const TT1__CFileAttachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CFileAttachment), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "m-pFileData", -1, &(a->TT1__CFileAttachment::m_pFileData), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strFileName", -1, &(a->TT1__CFileAttachment::m_strFileName), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strArchiveName", -1, &(a->TT1__CFileAttachment::m_strArchiveName), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strType", -1, &(a->TT1__CFileAttachment::m_strType), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "m-scriptOrder", -1, &(a->TT1__CFileAttachment::m_scriptOrder), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strScriptState", -1, &(a->TT1__CFileAttachment::m_strScriptState), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CFileAttachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CFileAttachment(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CFileAttachment * SOAP_FMAC4 soap_get_TT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CFileAttachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CFileAttachment(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CFileAttachment * SOAP_FMAC4 soap_in_TT1__CFileAttachment(struct soap *soap, const char *tag, TT1__CFileAttachment *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CFileAttachment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CFileAttachment, sizeof(TT1__CFileAttachment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CFileAttachment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CFileAttachment *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_m_pFileData1 = 1, soap_flag_m_strFileName1 = 1, soap_flag_m_strArchiveName1 = 1, soap_flag_m_strType1 = 1, soap_flag_m_scriptOrder1 = 1, soap_flag_m_strScriptState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_pFileData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "m-pFileData", &(a->TT1__CFileAttachment::m_pFileData), "xsd:base64Binary"))
				{	soap_flag_m_pFileData1--;
					continue;
				}
			if (soap_flag_m_strFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFileName", &(a->TT1__CFileAttachment::m_strFileName), "xsd:string"))
				{	soap_flag_m_strFileName1--;
					continue;
				}
			if (soap_flag_m_strArchiveName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strArchiveName", &(a->TT1__CFileAttachment::m_strArchiveName), "xsd:string"))
				{	soap_flag_m_strArchiveName1--;
					continue;
				}
			if (soap_flag_m_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strType", &(a->TT1__CFileAttachment::m_strType), "xsd:string"))
				{	soap_flag_m_strType1--;
					continue;
				}
			if (soap_flag_m_scriptOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "m-scriptOrder", &(a->TT1__CFileAttachment::m_scriptOrder), "xsd:long"))
				{	soap_flag_m_scriptOrder1--;
					continue;
				}
			if (soap_flag_m_strScriptState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strScriptState", &(a->TT1__CFileAttachment::m_strScriptState), "xsd:string"))
				{	soap_flag_m_strScriptState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CFileAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CFileAttachment, 0, sizeof(TT1__CFileAttachment), 0, soap_copy_TT1__CFileAttachment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CFileAttachment * SOAP_FMAC6 soap_new_TT1__CFileAttachment(struct soap *soap, int n)
{	return soap_instantiate_TT1__CFileAttachment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CFileAttachment * SOAP_FMAC4 soap_instantiate_TT1__CFileAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CFileAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CFileAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CFileAttachment;
		if (size)
			*size = sizeof(TT1__CFileAttachment);
		((TT1__CFileAttachment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CFileAttachment[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CFileAttachment);
		for (int i = 0; i < n; i++)
			((TT1__CFileAttachment*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CFileAttachment*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CFileAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CFileAttachment %p -> %p\n", q, p));
	*(TT1__CFileAttachment*)p = *(TT1__CFileAttachment*)q;
}

void TT1ArrayOfCSCCFileRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCSCCFileRecord::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCSCCFileRecord))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CSCCFileRecord(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCSCCFileRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCSCCFileRecord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCSCCFileRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCSCCFileRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, int id, const TT1ArrayOfCSCCFileRecord *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CSCCFileRecord", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCSCCFileRecord);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CSCCFileRecord(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCSCCFileRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCSCCFileRecord(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCSCCFileRecord * SOAP_FMAC4 soap_get_TT1ArrayOfCSCCFileRecord(struct soap *soap, TT1ArrayOfCSCCFileRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCSCCFileRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCSCCFileRecord(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCSCCFileRecord * SOAP_FMAC4 soap_in_TT1ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, TT1ArrayOfCSCCFileRecord *a, const char *type)
{	int i, j;
	TT1__CSCCFileRecord **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCSCCFileRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCSCCFileRecord, sizeof(TT1ArrayOfCSCCFileRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CSCCFileRecord **)soap_malloc(soap, sizeof(TT1__CSCCFileRecord *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CSCCFileRecord(soap, NULL, a->__ptritem + i, "TT1:CSCCFileRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CSCCFileRecord **)soap_push_block(soap, sizeof(TT1__CSCCFileRecord *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CSCCFileRecord(soap, NULL, p, "TT1:CSCCFileRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CSCCFileRecord **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCSCCFileRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCSCCFileRecord, 0, sizeof(TT1ArrayOfCSCCFileRecord), 0, soap_copy_TT1ArrayOfCSCCFileRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCSCCFileRecord * SOAP_FMAC6 soap_new_TT1ArrayOfCSCCFileRecord(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCSCCFileRecord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCSCCFileRecord(struct soap *soap, TT1ArrayOfCSCCFileRecord *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCSCCFileRecord * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCSCCFileRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCSCCFileRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCSCCFileRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCSCCFileRecord;
		if (size)
			*size = sizeof(TT1ArrayOfCSCCFileRecord);
		((TT1ArrayOfCSCCFileRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCSCCFileRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCSCCFileRecord);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCSCCFileRecord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCSCCFileRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCSCCFileRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCSCCFileRecord %p -> %p\n", q, p));
	*(TT1ArrayOfCSCCFileRecord*)p = *(TT1ArrayOfCSCCFileRecord*)q;
}

void TT1__CSCCFileRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CSCCFileRecord::m_strFileName);
	soap_default_string(soap, &this->TT1__CSCCFileRecord::m_strFixedRevision);
	this->TT1__CSCCFileRecord::m_dateFixedTimestamp = NULL;
	soap_default_string(soap, &this->TT1__CSCCFileRecord::m_strType);
	this->TT1__CSCCFileRecord::m_scriptOrder = NULL;
	soap_default_string(soap, &this->TT1__CSCCFileRecord::m_strScriptState);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CSCCFileRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CSCCFileRecord::m_strFileName);
	soap_serialize_string(soap, &this->TT1__CSCCFileRecord::m_strFixedRevision);
	soap_serialize_PointerTotime(soap, &this->TT1__CSCCFileRecord::m_dateFixedTimestamp);
	soap_serialize_string(soap, &this->TT1__CSCCFileRecord::m_strType);
	soap_serialize_PointerToLONG64(soap, &this->TT1__CSCCFileRecord::m_scriptOrder);
	soap_serialize_string(soap, &this->TT1__CSCCFileRecord::m_strScriptState);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CSCCFileRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CSCCFileRecord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CSCCFileRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CSCCFileRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CSCCFileRecord(struct soap *soap, const char *tag, int id, const TT1__CSCCFileRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CSCCFileRecord), "TT1:CSCCFileRecord"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "m-strFileName", -1, &(a->TT1__CSCCFileRecord::m_strFileName), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strFixedRevision", -1, &(a->TT1__CSCCFileRecord::m_strFixedRevision), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "m-dateFixedTimestamp", -1, &(a->TT1__CSCCFileRecord::m_dateFixedTimestamp), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strType", -1, &(a->TT1__CSCCFileRecord::m_strType), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "m-scriptOrder", -1, &(a->TT1__CSCCFileRecord::m_scriptOrder), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strScriptState", -1, &(a->TT1__CSCCFileRecord::m_strScriptState), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CSCCFileRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CSCCFileRecord(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CSCCFileRecord * SOAP_FMAC4 soap_get_TT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CSCCFileRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CSCCFileRecord(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CSCCFileRecord * SOAP_FMAC4 soap_in_TT1__CSCCFileRecord(struct soap *soap, const char *tag, TT1__CSCCFileRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CSCCFileRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CSCCFileRecord, sizeof(TT1__CSCCFileRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CSCCFileRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CSCCFileRecord *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_m_strFileName1 = 1, soap_flag_m_strFixedRevision1 = 1, soap_flag_m_dateFixedTimestamp1 = 1, soap_flag_m_strType1 = 1, soap_flag_m_scriptOrder1 = 1, soap_flag_m_strScriptState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_m_strFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFileName", &(a->TT1__CSCCFileRecord::m_strFileName), "xsd:string"))
				{	soap_flag_m_strFileName1--;
					continue;
				}
			if (soap_flag_m_strFixedRevision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFixedRevision", &(a->TT1__CSCCFileRecord::m_strFixedRevision), "xsd:string"))
				{	soap_flag_m_strFixedRevision1--;
					continue;
				}
			if (soap_flag_m_dateFixedTimestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "m-dateFixedTimestamp", &(a->TT1__CSCCFileRecord::m_dateFixedTimestamp), "xsd:dateTime"))
				{	soap_flag_m_dateFixedTimestamp1--;
					continue;
				}
			if (soap_flag_m_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strType", &(a->TT1__CSCCFileRecord::m_strType), "xsd:string"))
				{	soap_flag_m_strType1--;
					continue;
				}
			if (soap_flag_m_scriptOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "m-scriptOrder", &(a->TT1__CSCCFileRecord::m_scriptOrder), "xsd:long"))
				{	soap_flag_m_scriptOrder1--;
					continue;
				}
			if (soap_flag_m_strScriptState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strScriptState", &(a->TT1__CSCCFileRecord::m_strScriptState), "xsd:string"))
				{	soap_flag_m_strScriptState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CSCCFileRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CSCCFileRecord, 0, sizeof(TT1__CSCCFileRecord), 0, soap_copy_TT1__CSCCFileRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_m_strFileName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CSCCFileRecord * SOAP_FMAC6 soap_new_TT1__CSCCFileRecord(struct soap *soap, int n)
{	return soap_instantiate_TT1__CSCCFileRecord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CSCCFileRecord * SOAP_FMAC4 soap_instantiate_TT1__CSCCFileRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CSCCFileRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CSCCFileRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CSCCFileRecord;
		if (size)
			*size = sizeof(TT1__CSCCFileRecord);
		((TT1__CSCCFileRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CSCCFileRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CSCCFileRecord);
		for (int i = 0; i < n; i++)
			((TT1__CSCCFileRecord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CSCCFileRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CSCCFileRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CSCCFileRecord %p -> %p\n", q, p));
	*(TT1__CSCCFileRecord*)p = *(TT1__CSCCFileRecord*)q;
}

void TT1__CSystem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CSystem::location);
	soap_default_string(soap, &this->TT1__CSystem::computermodel);
	soap_default_string(soap, &this->TT1__CSystem::computerbrand);
	soap_default_string(soap, &this->TT1__CSystem::cputype);
	soap_default_string(soap, &this->TT1__CSystem::cpuspeed);
	soap_default_string(soap, &this->TT1__CSystem::harddisktype);
	soap_default_string(soap, &this->TT1__CSystem::harddisksize);
	soap_default_string(soap, &this->TT1__CSystem::ramsize);
	soap_default_string(soap, &this->TT1__CSystem::romsize);
	soap_default_string(soap, &this->TT1__CSystem::osname);
	soap_default_string(soap, &this->TT1__CSystem::osversion);
	soap_default_string(soap, &this->TT1__CSystem::videoname);
	this->TT1__CSystem::hascdrom = NULL;
	soap_default_string(soap, &this->TT1__CSystem::cdrommodel);
	this->TT1__CSystem::hasscanner = NULL;
	soap_default_string(soap, &this->TT1__CSystem::scannermodel);
	this->TT1__CSystem::hasmodem = NULL;
	soap_default_string(soap, &this->TT1__CSystem::modemmodel);
	this->TT1__CSystem::hasprinter = NULL;
	soap_default_string(soap, &this->TT1__CSystem::printermodel);
	soap_default_string(soap, &this->TT1__CSystem::otherhardware);
	this->TT1__CSystem::hasmultiplemonitors = NULL;
	soap_default_string(soap, &this->TT1__CSystemBase::systemname);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CSystem::location);
	soap_serialize_string(soap, &this->TT1__CSystem::computermodel);
	soap_serialize_string(soap, &this->TT1__CSystem::computerbrand);
	soap_serialize_string(soap, &this->TT1__CSystem::cputype);
	soap_serialize_string(soap, &this->TT1__CSystem::cpuspeed);
	soap_serialize_string(soap, &this->TT1__CSystem::harddisktype);
	soap_serialize_string(soap, &this->TT1__CSystem::harddisksize);
	soap_serialize_string(soap, &this->TT1__CSystem::ramsize);
	soap_serialize_string(soap, &this->TT1__CSystem::romsize);
	soap_serialize_string(soap, &this->TT1__CSystem::osname);
	soap_serialize_string(soap, &this->TT1__CSystem::osversion);
	soap_serialize_string(soap, &this->TT1__CSystem::videoname);
	soap_serialize_PointerTobool(soap, &this->TT1__CSystem::hascdrom);
	soap_serialize_string(soap, &this->TT1__CSystem::cdrommodel);
	soap_serialize_PointerTobool(soap, &this->TT1__CSystem::hasscanner);
	soap_serialize_string(soap, &this->TT1__CSystem::scannermodel);
	soap_serialize_PointerTobool(soap, &this->TT1__CSystem::hasmodem);
	soap_serialize_string(soap, &this->TT1__CSystem::modemmodel);
	soap_serialize_PointerTobool(soap, &this->TT1__CSystem::hasprinter);
	soap_serialize_string(soap, &this->TT1__CSystem::printermodel);
	soap_serialize_string(soap, &this->TT1__CSystem::otherhardware);
	soap_serialize_PointerTobool(soap, &this->TT1__CSystem::hasmultiplemonitors);
	soap_serialize_string(soap, &this->TT1__CSystemBase::systemname);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CSystem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CSystem(struct soap *soap, const char *tag, int id, const TT1__CSystem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CSystem), "TT1:CSystem"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "systemname", -1, &(a->TT1__CSystemBase::systemname), ""))
		return soap->error;
	if (soap_out_string(soap, "location", -1, &(a->TT1__CSystem::location), ""))
		return soap->error;
	if (soap_out_string(soap, "computermodel", -1, &(a->TT1__CSystem::computermodel), ""))
		return soap->error;
	if (soap_out_string(soap, "computerbrand", -1, &(a->TT1__CSystem::computerbrand), ""))
		return soap->error;
	if (soap_out_string(soap, "cputype", -1, &(a->TT1__CSystem::cputype), ""))
		return soap->error;
	if (soap_out_string(soap, "cpuspeed", -1, &(a->TT1__CSystem::cpuspeed), ""))
		return soap->error;
	if (soap_out_string(soap, "harddisktype", -1, &(a->TT1__CSystem::harddisktype), ""))
		return soap->error;
	if (soap_out_string(soap, "harddisksize", -1, &(a->TT1__CSystem::harddisksize), ""))
		return soap->error;
	if (soap_out_string(soap, "ramsize", -1, &(a->TT1__CSystem::ramsize), ""))
		return soap->error;
	if (soap_out_string(soap, "romsize", -1, &(a->TT1__CSystem::romsize), ""))
		return soap->error;
	if (soap_out_string(soap, "osname", -1, &(a->TT1__CSystem::osname), ""))
		return soap->error;
	if (soap_out_string(soap, "osversion", -1, &(a->TT1__CSystem::osversion), ""))
		return soap->error;
	if (soap_out_string(soap, "videoname", -1, &(a->TT1__CSystem::videoname), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hascdrom", -1, &(a->TT1__CSystem::hascdrom), ""))
		return soap->error;
	if (soap_out_string(soap, "cdrommodel", -1, &(a->TT1__CSystem::cdrommodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasscanner", -1, &(a->TT1__CSystem::hasscanner), ""))
		return soap->error;
	if (soap_out_string(soap, "scannermodel", -1, &(a->TT1__CSystem::scannermodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasmodem", -1, &(a->TT1__CSystem::hasmodem), ""))
		return soap->error;
	if (soap_out_string(soap, "modemmodel", -1, &(a->TT1__CSystem::modemmodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasprinter", -1, &(a->TT1__CSystem::hasprinter), ""))
		return soap->error;
	if (soap_out_string(soap, "printermodel", -1, &(a->TT1__CSystem::printermodel), ""))
		return soap->error;
	if (soap_out_string(soap, "otherhardware", -1, &(a->TT1__CSystem::otherhardware), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasmultiplemonitors", -1, &(a->TT1__CSystem::hasmultiplemonitors), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CSystem(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CSystem * SOAP_FMAC4 soap_get_TT1__CSystem(struct soap *soap, TT1__CSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CSystem(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CSystem * SOAP_FMAC4 soap_in_TT1__CSystem(struct soap *soap, const char *tag, TT1__CSystem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CSystem, sizeof(TT1__CSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CSystem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CSystem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid4 = 1, soap_flag_systemname2 = 1, soap_flag_location1 = 1, soap_flag_computermodel1 = 1, soap_flag_computerbrand1 = 1, soap_flag_cputype1 = 1, soap_flag_cpuspeed1 = 1, soap_flag_harddisktype1 = 1, soap_flag_harddisksize1 = 1, soap_flag_ramsize1 = 1, soap_flag_romsize1 = 1, soap_flag_osname1 = 1, soap_flag_osversion1 = 1, soap_flag_videoname1 = 1, soap_flag_hascdrom1 = 1, soap_flag_cdrommodel1 = 1, soap_flag_hasscanner1 = 1, soap_flag_scannermodel1 = 1, soap_flag_hasmodem1 = 1, soap_flag_modemmodel1 = 1, soap_flag_hasprinter1 = 1, soap_flag_printermodel1 = 1, soap_flag_otherhardware1 = 1, soap_flag_hasmultiplemonitors1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_systemname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "systemname", &(a->TT1__CSystemBase::systemname), "xsd:string"))
				{	soap_flag_systemname2--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "location", &(a->TT1__CSystem::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_computermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "computermodel", &(a->TT1__CSystem::computermodel), "xsd:string"))
				{	soap_flag_computermodel1--;
					continue;
				}
			if (soap_flag_computerbrand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "computerbrand", &(a->TT1__CSystem::computerbrand), "xsd:string"))
				{	soap_flag_computerbrand1--;
					continue;
				}
			if (soap_flag_cputype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cputype", &(a->TT1__CSystem::cputype), "xsd:string"))
				{	soap_flag_cputype1--;
					continue;
				}
			if (soap_flag_cpuspeed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cpuspeed", &(a->TT1__CSystem::cpuspeed), "xsd:string"))
				{	soap_flag_cpuspeed1--;
					continue;
				}
			if (soap_flag_harddisktype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "harddisktype", &(a->TT1__CSystem::harddisktype), "xsd:string"))
				{	soap_flag_harddisktype1--;
					continue;
				}
			if (soap_flag_harddisksize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "harddisksize", &(a->TT1__CSystem::harddisksize), "xsd:string"))
				{	soap_flag_harddisksize1--;
					continue;
				}
			if (soap_flag_ramsize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ramsize", &(a->TT1__CSystem::ramsize), "xsd:string"))
				{	soap_flag_ramsize1--;
					continue;
				}
			if (soap_flag_romsize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "romsize", &(a->TT1__CSystem::romsize), "xsd:string"))
				{	soap_flag_romsize1--;
					continue;
				}
			if (soap_flag_osname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "osname", &(a->TT1__CSystem::osname), "xsd:string"))
				{	soap_flag_osname1--;
					continue;
				}
			if (soap_flag_osversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "osversion", &(a->TT1__CSystem::osversion), "xsd:string"))
				{	soap_flag_osversion1--;
					continue;
				}
			if (soap_flag_videoname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "videoname", &(a->TT1__CSystem::videoname), "xsd:string"))
				{	soap_flag_videoname1--;
					continue;
				}
			if (soap_flag_hascdrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hascdrom", &(a->TT1__CSystem::hascdrom), "xsd:boolean"))
				{	soap_flag_hascdrom1--;
					continue;
				}
			if (soap_flag_cdrommodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cdrommodel", &(a->TT1__CSystem::cdrommodel), "xsd:string"))
				{	soap_flag_cdrommodel1--;
					continue;
				}
			if (soap_flag_hasscanner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasscanner", &(a->TT1__CSystem::hasscanner), "xsd:boolean"))
				{	soap_flag_hasscanner1--;
					continue;
				}
			if (soap_flag_scannermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "scannermodel", &(a->TT1__CSystem::scannermodel), "xsd:string"))
				{	soap_flag_scannermodel1--;
					continue;
				}
			if (soap_flag_hasmodem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasmodem", &(a->TT1__CSystem::hasmodem), "xsd:boolean"))
				{	soap_flag_hasmodem1--;
					continue;
				}
			if (soap_flag_modemmodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modemmodel", &(a->TT1__CSystem::modemmodel), "xsd:string"))
				{	soap_flag_modemmodel1--;
					continue;
				}
			if (soap_flag_hasprinter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasprinter", &(a->TT1__CSystem::hasprinter), "xsd:boolean"))
				{	soap_flag_hasprinter1--;
					continue;
				}
			if (soap_flag_printermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "printermodel", &(a->TT1__CSystem::printermodel), "xsd:string"))
				{	soap_flag_printermodel1--;
					continue;
				}
			if (soap_flag_otherhardware1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "otherhardware", &(a->TT1__CSystem::otherhardware), "xsd:string"))
				{	soap_flag_otherhardware1--;
					continue;
				}
			if (soap_flag_hasmultiplemonitors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasmultiplemonitors", &(a->TT1__CSystem::hasmultiplemonitors), "xsd:boolean"))
				{	soap_flag_hasmultiplemonitors1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CSystem, 0, sizeof(TT1__CSystem), 0, soap_copy_TT1__CSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid4 > 0 || soap_flag_systemname2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CSystem * SOAP_FMAC6 soap_new_TT1__CSystem(struct soap *soap, int n)
{	return soap_instantiate_TT1__CSystem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CSystem(struct soap *soap, TT1__CSystem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CSystem * SOAP_FMAC4 soap_instantiate_TT1__CSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CSystem;
		if (size)
			*size = sizeof(TT1__CSystem);
		((TT1__CSystem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CSystem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CSystem);
		for (int i = 0; i < n; i++)
			((TT1__CSystem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CSystem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CSystem %p -> %p\n", q, p));
	*(TT1__CSystem*)p = *(TT1__CSystem*)q;
}

void TT1__CSystemBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CSystemBase::systemname);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CSystemBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CSystemBase::systemname);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CSystemBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CSystemBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CSystemBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CSystemBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CSystemBase(struct soap *soap, const char *tag, int id, const TT1__CSystemBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CSystemBase), "TT1:CSystemBase"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_string(soap, "systemname", -1, &(a->TT1__CSystemBase::systemname), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__CSystemBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CSystemBase(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CSystemBase * SOAP_FMAC4 soap_get_TT1__CSystemBase(struct soap *soap, TT1__CSystemBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CSystemBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CSystemBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CSystemBase(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CSystemBase * SOAP_FMAC4 soap_in_TT1__CSystemBase(struct soap *soap, const char *tag, TT1__CSystemBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CSystemBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CSystemBase, sizeof(TT1__CSystemBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CSystemBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CSystemBase *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid3 = 1, soap_flag_systemname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_systemname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "systemname", &(a->TT1__CSystemBase::systemname), "xsd:string"))
				{	soap_flag_systemname1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CSystemBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CSystemBase, 0, sizeof(TT1__CSystemBase), 0, soap_copy_TT1__CSystemBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid3 > 0 || soap_flag_systemname1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CSystemBase * SOAP_FMAC6 soap_new_TT1__CSystemBase(struct soap *soap, int n)
{	return soap_instantiate_TT1__CSystemBase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CSystemBase(struct soap *soap, TT1__CSystemBase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CSystemBase * SOAP_FMAC4 soap_instantiate_TT1__CSystemBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CSystemBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CSystemBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CSystem"))
	{	cp->type = SOAP_TYPE_TT1__CSystem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSystem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSystem);
			((TT1__CSystem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSystem[n];
			if (size)
				*size = n * sizeof(TT1__CSystem);
			for (int i = 0; i < n; i++)
				((TT1__CSystem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSystem*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CSystemBase;
		if (size)
			*size = sizeof(TT1__CSystemBase);
		((TT1__CSystemBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CSystemBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CSystemBase);
		for (int i = 0; i < n; i++)
			((TT1__CSystemBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CSystemBase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CSystemBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CSystemBase %p -> %p\n", q, p));
	*(TT1__CSystemBase*)p = *(TT1__CSystemBase*)q;
}

void TT1__COrderedItemWithDBRecordId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->TT1__COrderedItemWithDBRecordId::order);
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__COrderedItemWithDBRecordId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__COrderedItemWithDBRecordId::order, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__COrderedItemWithDBRecordId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__COrderedItemWithDBRecordId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__COrderedItemWithDBRecordId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__COrderedItemWithDBRecordId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__COrderedItemWithDBRecordId(struct soap *soap, const char *tag, int id, const TT1__COrderedItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__COrderedItemWithDBRecordId), "TT1:COrderedItemWithDBRecordId"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_LONG64(soap, "order", -1, &(a->TT1__COrderedItemWithDBRecordId::order), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *TT1__COrderedItemWithDBRecordId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__COrderedItemWithDBRecordId(soap, this, tag, type);
}

SOAP_FMAC3 TT1__COrderedItemWithDBRecordId * SOAP_FMAC4 soap_get_TT1__COrderedItemWithDBRecordId(struct soap *soap, TT1__COrderedItemWithDBRecordId *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__COrderedItemWithDBRecordId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__COrderedItemWithDBRecordId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__COrderedItemWithDBRecordId(soap, tag, this, type);
}

SOAP_FMAC3 TT1__COrderedItemWithDBRecordId * SOAP_FMAC4 soap_in_TT1__COrderedItemWithDBRecordId(struct soap *soap, const char *tag, TT1__COrderedItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__COrderedItemWithDBRecordId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__COrderedItemWithDBRecordId, sizeof(TT1__COrderedItemWithDBRecordId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__COrderedItemWithDBRecordId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__COrderedItemWithDBRecordId *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1, soap_flag_order1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->TT1__COrderedItemWithDBRecordId::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__COrderedItemWithDBRecordId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__COrderedItemWithDBRecordId, 0, sizeof(TT1__COrderedItemWithDBRecordId), 0, soap_copy_TT1__COrderedItemWithDBRecordId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0 || soap_flag_order1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__COrderedItemWithDBRecordId * SOAP_FMAC6 soap_new_TT1__COrderedItemWithDBRecordId(struct soap *soap, int n)
{	return soap_instantiate_TT1__COrderedItemWithDBRecordId(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__COrderedItemWithDBRecordId(struct soap *soap, TT1__COrderedItemWithDBRecordId *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__COrderedItemWithDBRecordId * SOAP_FMAC4 soap_instantiate_TT1__COrderedItemWithDBRecordId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__COrderedItemWithDBRecordId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__COrderedItemWithDBRecordId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CLinkedItem"))
	{	cp->type = SOAP_TYPE_TT1__CLinkedItem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLinkedItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLinkedItem);
			((TT1__CLinkedItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLinkedItem[n];
			if (size)
				*size = n * sizeof(TT1__CLinkedItem);
			for (int i = 0; i < n; i++)
				((TT1__CLinkedItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLinkedItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CLinkHistoryItem"))
	{	cp->type = SOAP_TYPE_TT1__CLinkHistoryItem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLinkHistoryItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLinkHistoryItem);
			((TT1__CLinkHistoryItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLinkHistoryItem[n];
			if (size)
				*size = n * sizeof(TT1__CLinkHistoryItem);
			for (int i = 0; i < n; i++)
				((TT1__CLinkHistoryItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLinkHistoryItem*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__COrderedItemWithDBRecordId;
		if (size)
			*size = sizeof(TT1__COrderedItemWithDBRecordId);
		((TT1__COrderedItemWithDBRecordId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__COrderedItemWithDBRecordId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__COrderedItemWithDBRecordId);
		for (int i = 0; i < n; i++)
			((TT1__COrderedItemWithDBRecordId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__COrderedItemWithDBRecordId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__COrderedItemWithDBRecordId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__COrderedItemWithDBRecordId %p -> %p\n", q, p));
	*(TT1__COrderedItemWithDBRecordId*)p = *(TT1__COrderedItemWithDBRecordId*)q;
}

void TT1__CItemToTrack::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CItemToTrack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CItemToTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CItemToTrack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CItemToTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CItemToTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CItemToTrack(struct soap *soap, const char *tag, int id, const TT1__CItemToTrack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CItemToTrack), "TT1:CItemToTrack"))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CItemToTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CItemToTrack(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CItemToTrack * SOAP_FMAC4 soap_get_TT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CItemToTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CItemToTrack(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CItemToTrack * SOAP_FMAC4 soap_in_TT1__CItemToTrack(struct soap *soap, const char *tag, TT1__CItemToTrack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CItemToTrack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CItemToTrack, sizeof(TT1__CItemToTrack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CItemToTrack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CItemToTrack *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CItemToTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CItemToTrack, 0, sizeof(TT1__CItemToTrack), 0, soap_copy_TT1__CItemToTrack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CItemToTrack * SOAP_FMAC6 soap_new_TT1__CItemToTrack(struct soap *soap, int n)
{	return soap_instantiate_TT1__CItemToTrack(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CItemToTrack * SOAP_FMAC4 soap_instantiate_TT1__CItemToTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CItemToTrack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CItemToTrack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CSystemBase"))
	{	cp->type = SOAP_TYPE_TT1__CSystemBase;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSystemBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSystemBase);
			((TT1__CSystemBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSystemBase[n];
			if (size)
				*size = n * sizeof(TT1__CSystemBase);
			for (int i = 0; i < n; i++)
				((TT1__CSystemBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSystemBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDefect"))
	{	cp->type = SOAP_TYPE_TT1__CDefect;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDefect;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDefect);
			((TT1__CDefect*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDefect[n];
			if (size)
				*size = n * sizeof(TT1__CDefect);
			for (int i = 0; i < n; i++)
				((TT1__CDefect*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDefect*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTask"))
	{	cp->type = SOAP_TYPE_TT1__CTask;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTask;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTask);
			((TT1__CTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTask[n];
			if (size)
				*size = n * sizeof(TT1__CTask);
			for (int i = 0; i < n; i++)
				((TT1__CTask*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CUser"))
	{	cp->type = SOAP_TYPE_TT1__CUser;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CUser;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CUser);
			((TT1__CUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CUser[n];
			if (size)
				*size = n * sizeof(TT1__CUser);
			for (int i = 0; i < n; i++)
				((TT1__CUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CLink"))
	{	cp->type = SOAP_TYPE_TT1__CLink;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLink;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLink);
			((TT1__CLink*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLink[n];
			if (size)
				*size = n * sizeof(TT1__CLink);
			for (int i = 0; i < n; i++)
				((TT1__CLink*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLink*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestCase"))
	{	cp->type = SOAP_TYPE_TT1__CTestCase;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCase);
			((TT1__CTestCase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCase[n];
			if (size)
				*size = n * sizeof(TT1__CTestCase);
			for (int i = 0; i < n; i++)
				((TT1__CTestCase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestRun"))
	{	cp->type = SOAP_TYPE_TT1__CTestRun;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestRun;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestRun);
			((TT1__CTestRun*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestRun[n];
			if (size)
				*size = n * sizeof(TT1__CTestRun);
			for (int i = 0; i < n; i++)
				((TT1__CTestRun*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestRun*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CFolder"))
	{	cp->type = SOAP_TYPE_TT1__CFolder;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CFolder;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CFolder);
			((TT1__CFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CFolder[n];
			if (size)
				*size = n * sizeof(TT1__CFolder);
			for (int i = 0; i < n; i++)
				((TT1__CFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CSystem"))
	{	cp->type = SOAP_TYPE_TT1__CSystem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSystem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSystem);
			((TT1__CSystem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSystem[n];
			if (size)
				*size = n * sizeof(TT1__CSystem);
			for (int i = 0; i < n; i++)
				((TT1__CSystem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSystem*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CItemToTrack;
		if (size)
			*size = sizeof(TT1__CItemToTrack);
		((TT1__CItemToTrack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CItemToTrack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CItemToTrack);
		for (int i = 0; i < n; i++)
			((TT1__CItemToTrack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CItemToTrack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CItemToTrack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CItemToTrack %p -> %p\n", q, p));
	*(TT1__CItemToTrack*)p = *(TT1__CItemToTrack*)q;
}

void TT1__CItemWithDBRecordId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->TT1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void TT1__CItemWithDBRecordId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->TT1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

int TT1__CItemWithDBRecordId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CItemWithDBRecordId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CItemWithDBRecordId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CItemWithDBRecordId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CItemWithDBRecordId(struct soap *soap, const char *tag, int id, const TT1__CItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CItemWithDBRecordId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->TT1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CItemWithDBRecordId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CItemWithDBRecordId(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CItemWithDBRecordId * SOAP_FMAC4 soap_get_TT1__CItemWithDBRecordId(struct soap *soap, TT1__CItemWithDBRecordId *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CItemWithDBRecordId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CItemWithDBRecordId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CItemWithDBRecordId(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CItemWithDBRecordId * SOAP_FMAC4 soap_in_TT1__CItemWithDBRecordId(struct soap *soap, const char *tag, TT1__CItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CItemWithDBRecordId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CItemWithDBRecordId, sizeof(TT1__CItemWithDBRecordId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CItemWithDBRecordId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CItemWithDBRecordId *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_recordid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->TT1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CItemWithDBRecordId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CItemWithDBRecordId, 0, sizeof(TT1__CItemWithDBRecordId), 0, soap_copy_TT1__CItemWithDBRecordId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CItemWithDBRecordId * SOAP_FMAC6 soap_new_TT1__CItemWithDBRecordId(struct soap *soap, int n)
{	return soap_instantiate_TT1__CItemWithDBRecordId(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CItemWithDBRecordId(struct soap *soap, TT1__CItemWithDBRecordId *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CItemWithDBRecordId * SOAP_FMAC4 soap_instantiate_TT1__CItemWithDBRecordId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CItemWithDBRecordId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CItemWithDBRecordId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "TT1:CItemToTrack"))
	{	cp->type = SOAP_TYPE_TT1__CItemToTrack;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CItemToTrack;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CItemToTrack);
			((TT1__CItemToTrack*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CItemToTrack[n];
			if (size)
				*size = n * sizeof(TT1__CItemToTrack);
			for (int i = 0; i < n; i++)
				((TT1__CItemToTrack*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CItemToTrack*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:COrderedItemWithDBRecordId"))
	{	cp->type = SOAP_TYPE_TT1__COrderedItemWithDBRecordId;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__COrderedItemWithDBRecordId;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__COrderedItemWithDBRecordId);
			((TT1__COrderedItemWithDBRecordId*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__COrderedItemWithDBRecordId[n];
			if (size)
				*size = n * sizeof(TT1__COrderedItemWithDBRecordId);
			for (int i = 0; i < n; i++)
				((TT1__COrderedItemWithDBRecordId*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__COrderedItemWithDBRecordId*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CSCCFileRecord"))
	{	cp->type = SOAP_TYPE_TT1__CSCCFileRecord;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSCCFileRecord;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSCCFileRecord);
			((TT1__CSCCFileRecord*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSCCFileRecord[n];
			if (size)
				*size = n * sizeof(TT1__CSCCFileRecord);
			for (int i = 0; i < n; i++)
				((TT1__CSCCFileRecord*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSCCFileRecord*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CReportedByRecord"))
	{	cp->type = SOAP_TYPE_TT1__CReportedByRecord;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CReportedByRecord;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CReportedByRecord);
			((TT1__CReportedByRecord*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CReportedByRecord[n];
			if (size)
				*size = n * sizeof(TT1__CReportedByRecord);
			for (int i = 0; i < n; i++)
				((TT1__CReportedByRecord*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CReportedByRecord*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CField"))
	{	cp->type = SOAP_TYPE_TT1__CField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CField);
			((TT1__CField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CField[n];
			if (size)
				*size = n * sizeof(TT1__CField);
			for (int i = 0; i < n; i++)
				((TT1__CField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CEvent"))
	{	cp->type = SOAP_TYPE_TT1__CEvent;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CEvent;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CEvent);
			((TT1__CEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CEvent[n];
			if (size)
				*size = n * sizeof(TT1__CEvent);
			for (int i = 0; i < n; i++)
				((TT1__CEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CEvent*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CFolderItem"))
	{	cp->type = SOAP_TYPE_TT1__CFolderItem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CFolderItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CFolderItem);
			((TT1__CFolderItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CFolderItem[n];
			if (size)
				*size = n * sizeof(TT1__CFolderItem);
			for (int i = 0; i < n; i++)
				((TT1__CFolderItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CFolderItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CSystemBase"))
	{	cp->type = SOAP_TYPE_TT1__CSystemBase;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSystemBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSystemBase);
			((TT1__CSystemBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSystemBase[n];
			if (size)
				*size = n * sizeof(TT1__CSystemBase);
			for (int i = 0; i < n; i++)
				((TT1__CSystemBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSystemBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CStringField"))
	{	cp->type = SOAP_TYPE_TT1__CStringField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CStringField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CStringField);
			((TT1__CStringField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CStringField[n];
			if (size)
				*size = n * sizeof(TT1__CStringField);
			for (int i = 0; i < n; i++)
				((TT1__CStringField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CStringField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CIntegerField"))
	{	cp->type = SOAP_TYPE_TT1__CIntegerField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CIntegerField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CIntegerField);
			((TT1__CIntegerField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CIntegerField[n];
			if (size)
				*size = n * sizeof(TT1__CIntegerField);
			for (int i = 0; i < n; i++)
				((TT1__CIntegerField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CIntegerField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDecimalField"))
	{	cp->type = SOAP_TYPE_TT1__CDecimalField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDecimalField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDecimalField);
			((TT1__CDecimalField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDecimalField[n];
			if (size)
				*size = n * sizeof(TT1__CDecimalField);
			for (int i = 0; i < n; i++)
				((TT1__CDecimalField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDecimalField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CBooleanField"))
	{	cp->type = SOAP_TYPE_TT1__CBooleanField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CBooleanField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CBooleanField);
			((TT1__CBooleanField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CBooleanField[n];
			if (size)
				*size = n * sizeof(TT1__CBooleanField);
			for (int i = 0; i < n; i++)
				((TT1__CBooleanField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CBooleanField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDateField"))
	{	cp->type = SOAP_TYPE_TT1__CDateField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDateField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDateField);
			((TT1__CDateField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDateField[n];
			if (size)
				*size = n * sizeof(TT1__CDateField);
			for (int i = 0; i < n; i++)
				((TT1__CDateField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDateField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDateTimeField"))
	{	cp->type = SOAP_TYPE_TT1__CDateTimeField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDateTimeField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDateTimeField);
			((TT1__CDateTimeField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDateTimeField[n];
			if (size)
				*size = n * sizeof(TT1__CDateTimeField);
			for (int i = 0; i < n; i++)
				((TT1__CDateTimeField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDateTimeField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDropdownField"))
	{	cp->type = SOAP_TYPE_TT1__CDropdownField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDropdownField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDropdownField);
			((TT1__CDropdownField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDropdownField[n];
			if (size)
				*size = n * sizeof(TT1__CDropdownField);
			for (int i = 0; i < n; i++)
				((TT1__CDropdownField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDropdownField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CMultiSelectDropdownField"))
	{	cp->type = SOAP_TYPE_TT1__CMultiSelectDropdownField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CMultiSelectDropdownField);
			((TT1__CMultiSelectDropdownField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CMultiSelectDropdownField[n];
			if (size)
				*size = n * sizeof(TT1__CMultiSelectDropdownField);
			for (int i = 0; i < n; i++)
				((TT1__CMultiSelectDropdownField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CMultiSelectDropdownField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CVersionField"))
	{	cp->type = SOAP_TYPE_TT1__CVersionField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CVersionField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CVersionField);
			((TT1__CVersionField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CVersionField[n];
			if (size)
				*size = n * sizeof(TT1__CVersionField);
			for (int i = 0; i < n; i++)
				((TT1__CVersionField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CVersionField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDefectEvent"))
	{	cp->type = SOAP_TYPE_TT1__CDefectEvent;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDefectEvent;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDefectEvent);
			((TT1__CDefectEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDefectEvent[n];
			if (size)
				*size = n * sizeof(TT1__CDefectEvent);
			for (int i = 0; i < n; i++)
				((TT1__CDefectEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDefectEvent*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CDefect"))
	{	cp->type = SOAP_TYPE_TT1__CDefect;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CDefect;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CDefect);
			((TT1__CDefect*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CDefect[n];
			if (size)
				*size = n * sizeof(TT1__CDefect);
			for (int i = 0; i < n; i++)
				((TT1__CDefect*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CDefect*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTask"))
	{	cp->type = SOAP_TYPE_TT1__CTask;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTask;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTask);
			((TT1__CTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTask[n];
			if (size)
				*size = n * sizeof(TT1__CTask);
			for (int i = 0; i < n; i++)
				((TT1__CTask*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CUser"))
	{	cp->type = SOAP_TYPE_TT1__CUser;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CUser;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CUser);
			((TT1__CUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CUser[n];
			if (size)
				*size = n * sizeof(TT1__CUser);
			for (int i = 0; i < n; i++)
				((TT1__CUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CLinkedItem"))
	{	cp->type = SOAP_TYPE_TT1__CLinkedItem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLinkedItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLinkedItem);
			((TT1__CLinkedItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLinkedItem[n];
			if (size)
				*size = n * sizeof(TT1__CLinkedItem);
			for (int i = 0; i < n; i++)
				((TT1__CLinkedItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLinkedItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CLinkHistoryItem"))
	{	cp->type = SOAP_TYPE_TT1__CLinkHistoryItem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLinkHistoryItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLinkHistoryItem);
			((TT1__CLinkHistoryItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLinkHistoryItem[n];
			if (size)
				*size = n * sizeof(TT1__CLinkHistoryItem);
			for (int i = 0; i < n; i++)
				((TT1__CLinkHistoryItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLinkHistoryItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CLink"))
	{	cp->type = SOAP_TYPE_TT1__CLink;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CLink;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CLink);
			((TT1__CLink*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CLink[n];
			if (size)
				*size = n * sizeof(TT1__CLink);
			for (int i = 0; i < n; i++)
				((TT1__CLink*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CLink*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestCase"))
	{	cp->type = SOAP_TYPE_TT1__CTestCase;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCase);
			((TT1__CTestCase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCase[n];
			if (size)
				*size = n * sizeof(TT1__CTestCase);
			for (int i = 0; i < n; i++)
				((TT1__CTestCase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestRun"))
	{	cp->type = SOAP_TYPE_TT1__CTestRun;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestRun;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestRun);
			((TT1__CTestRun*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestRun[n];
			if (size)
				*size = n * sizeof(TT1__CTestRun);
			for (int i = 0; i < n; i++)
				((TT1__CTestRun*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestRun*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CFolder"))
	{	cp->type = SOAP_TYPE_TT1__CFolder;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CFolder;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CFolder);
			((TT1__CFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CFolder[n];
			if (size)
				*size = n * sizeof(TT1__CFolder);
			for (int i = 0; i < n; i++)
				((TT1__CFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CSystem"))
	{	cp->type = SOAP_TYPE_TT1__CSystem;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CSystem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CSystem);
			((TT1__CSystem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CSystem[n];
			if (size)
				*size = n * sizeof(TT1__CSystem);
			for (int i = 0; i < n; i++)
				((TT1__CSystem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CSystem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestRunVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestRunVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestRunVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestRunVariantField);
			((TT1__CTestRunVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestRunVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestRunVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestRunVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestRunVariantField*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "TT1:CTestCaseVariantField"))
	{	cp->type = SOAP_TYPE_TT1__CTestCaseVariantField;
		if (n < 0)
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(TT1__CTestCaseVariantField);
			((TT1__CTestCaseVariantField*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new TT1__CTestCaseVariantField[n];
			if (size)
				*size = n * sizeof(TT1__CTestCaseVariantField);
			for (int i = 0; i < n; i++)
				((TT1__CTestCaseVariantField*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (TT1__CTestCaseVariantField*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CItemWithDBRecordId;
		if (size)
			*size = sizeof(TT1__CItemWithDBRecordId);
		((TT1__CItemWithDBRecordId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CItemWithDBRecordId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CItemWithDBRecordId);
		for (int i = 0; i < n; i++)
			((TT1__CItemWithDBRecordId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CItemWithDBRecordId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CItemWithDBRecordId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CItemWithDBRecordId %p -> %p\n", q, p));
	*(TT1__CItemWithDBRecordId*)p = *(TT1__CItemWithDBRecordId*)q;
}

void TT1__CRecordListSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CRecordListSoap::columnlist = NULL;
	this->TT1__CRecordListSoap::records = NULL;
	/* transient soap skipped */
}

void TT1__CRecordListSoap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCTableColumn(soap, &this->TT1__CRecordListSoap::columnlist);
	soap_serialize_PointerToTT1ArrayOfCRecordRowSoap(soap, &this->TT1__CRecordListSoap::records);
	/* transient soap skipped */
}

int TT1__CRecordListSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CRecordListSoap);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CRecordListSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CRecordListSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CRecordListSoap(struct soap *soap, const char *tag, int id, const TT1__CRecordListSoap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CRecordListSoap), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTableColumn(soap, "columnlist", -1, &(a->TT1__CRecordListSoap::columnlist), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCRecordRowSoap(soap, "records", -1, &(a->TT1__CRecordListSoap::records), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CRecordListSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CRecordListSoap(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CRecordListSoap * SOAP_FMAC4 soap_get_TT1__CRecordListSoap(struct soap *soap, TT1__CRecordListSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CRecordListSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CRecordListSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CRecordListSoap(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CRecordListSoap * SOAP_FMAC4 soap_in_TT1__CRecordListSoap(struct soap *soap, const char *tag, TT1__CRecordListSoap *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CRecordListSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CRecordListSoap, sizeof(TT1__CRecordListSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CRecordListSoap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CRecordListSoap *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_columnlist1 = 1, soap_flag_records1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_columnlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTableColumn(soap, "columnlist", &(a->TT1__CRecordListSoap::columnlist), "TT1:CTableColumn"))
				{	soap_flag_columnlist1--;
					continue;
				}
			if (soap_flag_records1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCRecordRowSoap(soap, "records", &(a->TT1__CRecordListSoap::records), "TT1:CRecordRowSoap"))
				{	soap_flag_records1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CRecordListSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CRecordListSoap, 0, sizeof(TT1__CRecordListSoap), 0, soap_copy_TT1__CRecordListSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CRecordListSoap * SOAP_FMAC6 soap_new_TT1__CRecordListSoap(struct soap *soap, int n)
{	return soap_instantiate_TT1__CRecordListSoap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CRecordListSoap(struct soap *soap, TT1__CRecordListSoap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CRecordListSoap * SOAP_FMAC4 soap_instantiate_TT1__CRecordListSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CRecordListSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CRecordListSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CRecordListSoap;
		if (size)
			*size = sizeof(TT1__CRecordListSoap);
		((TT1__CRecordListSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CRecordListSoap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CRecordListSoap);
		for (int i = 0; i < n; i++)
			((TT1__CRecordListSoap*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CRecordListSoap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CRecordListSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CRecordListSoap %p -> %p\n", q, p));
	*(TT1__CRecordListSoap*)p = *(TT1__CRecordListSoap*)q;
}

void TT1ArrayOfCRecordRowSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCRecordRowSoap::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCRecordRowSoap))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CRecordRowSoap(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCRecordRowSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCRecordRowSoap);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCRecordRowSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCRecordRowSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, int id, const TT1ArrayOfCRecordRowSoap *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CRecordRowSoap", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCRecordRowSoap);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CRecordRowSoap(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCRecordRowSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCRecordRowSoap(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordRowSoap * SOAP_FMAC4 soap_get_TT1ArrayOfCRecordRowSoap(struct soap *soap, TT1ArrayOfCRecordRowSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCRecordRowSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCRecordRowSoap(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordRowSoap * SOAP_FMAC4 soap_in_TT1ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, TT1ArrayOfCRecordRowSoap *a, const char *type)
{	int i, j;
	TT1__CRecordRowSoap **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCRecordRowSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCRecordRowSoap, sizeof(TT1ArrayOfCRecordRowSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CRecordRowSoap **)soap_malloc(soap, sizeof(TT1__CRecordRowSoap *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CRecordRowSoap(soap, NULL, a->__ptritem + i, "TT1:CRecordRowSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CRecordRowSoap **)soap_push_block(soap, sizeof(TT1__CRecordRowSoap *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CRecordRowSoap(soap, NULL, p, "TT1:CRecordRowSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CRecordRowSoap **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCRecordRowSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCRecordRowSoap, 0, sizeof(TT1ArrayOfCRecordRowSoap), 0, soap_copy_TT1ArrayOfCRecordRowSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCRecordRowSoap * SOAP_FMAC6 soap_new_TT1ArrayOfCRecordRowSoap(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCRecordRowSoap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCRecordRowSoap(struct soap *soap, TT1ArrayOfCRecordRowSoap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCRecordRowSoap * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCRecordRowSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCRecordRowSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCRecordRowSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCRecordRowSoap;
		if (size)
			*size = sizeof(TT1ArrayOfCRecordRowSoap);
		((TT1ArrayOfCRecordRowSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCRecordRowSoap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCRecordRowSoap);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCRecordRowSoap*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCRecordRowSoap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCRecordRowSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCRecordRowSoap %p -> %p\n", q, p));
	*(TT1ArrayOfCRecordRowSoap*)p = *(TT1ArrayOfCRecordRowSoap*)q;
}

void TT1__CRecordRowSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CRecordRowSoap::row = NULL;
	/* transient soap skipped */
}

void TT1__CRecordRowSoap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCRecordData(soap, &this->TT1__CRecordRowSoap::row);
	/* transient soap skipped */
}

int TT1__CRecordRowSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CRecordRowSoap);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CRecordRowSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CRecordRowSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CRecordRowSoap(struct soap *soap, const char *tag, int id, const TT1__CRecordRowSoap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CRecordRowSoap), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCRecordData(soap, "row", -1, &(a->TT1__CRecordRowSoap::row), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CRecordRowSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CRecordRowSoap(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CRecordRowSoap * SOAP_FMAC4 soap_get_TT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CRecordRowSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CRecordRowSoap(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CRecordRowSoap * SOAP_FMAC4 soap_in_TT1__CRecordRowSoap(struct soap *soap, const char *tag, TT1__CRecordRowSoap *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CRecordRowSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CRecordRowSoap, sizeof(TT1__CRecordRowSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CRecordRowSoap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CRecordRowSoap *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_row1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_row1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCRecordData(soap, "row", &(a->TT1__CRecordRowSoap::row), "TT1:CRecordData"))
				{	soap_flag_row1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CRecordRowSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CRecordRowSoap, 0, sizeof(TT1__CRecordRowSoap), 0, soap_copy_TT1__CRecordRowSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_row1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CRecordRowSoap * SOAP_FMAC6 soap_new_TT1__CRecordRowSoap(struct soap *soap, int n)
{	return soap_instantiate_TT1__CRecordRowSoap(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CRecordRowSoap * SOAP_FMAC4 soap_instantiate_TT1__CRecordRowSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CRecordRowSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CRecordRowSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CRecordRowSoap;
		if (size)
			*size = sizeof(TT1__CRecordRowSoap);
		((TT1__CRecordRowSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CRecordRowSoap[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CRecordRowSoap);
		for (int i = 0; i < n; i++)
			((TT1__CRecordRowSoap*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CRecordRowSoap*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CRecordRowSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CRecordRowSoap %p -> %p\n", q, p));
	*(TT1__CRecordRowSoap*)p = *(TT1__CRecordRowSoap*)q;
}

void TT1ArrayOfCRecordData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCRecordData::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCRecordData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CRecordData(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCRecordData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCRecordData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCRecordData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCRecordData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCRecordData(struct soap *soap, const char *tag, int id, const TT1ArrayOfCRecordData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CRecordData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCRecordData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CRecordData(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCRecordData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCRecordData(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordData * SOAP_FMAC4 soap_get_TT1ArrayOfCRecordData(struct soap *soap, TT1ArrayOfCRecordData *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCRecordData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCRecordData(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordData * SOAP_FMAC4 soap_in_TT1ArrayOfCRecordData(struct soap *soap, const char *tag, TT1ArrayOfCRecordData *a, const char *type)
{	int i, j;
	TT1__CRecordData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCRecordData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCRecordData, sizeof(TT1ArrayOfCRecordData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CRecordData **)soap_malloc(soap, sizeof(TT1__CRecordData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CRecordData(soap, NULL, a->__ptritem + i, "TT1:CRecordData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CRecordData **)soap_push_block(soap, sizeof(TT1__CRecordData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CRecordData(soap, NULL, p, "TT1:CRecordData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CRecordData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCRecordData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCRecordData, 0, sizeof(TT1ArrayOfCRecordData), 0, soap_copy_TT1ArrayOfCRecordData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCRecordData * SOAP_FMAC6 soap_new_TT1ArrayOfCRecordData(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCRecordData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCRecordData(struct soap *soap, TT1ArrayOfCRecordData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCRecordData * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCRecordData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCRecordData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCRecordData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCRecordData;
		if (size)
			*size = sizeof(TT1ArrayOfCRecordData);
		((TT1ArrayOfCRecordData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCRecordData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCRecordData);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCRecordData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCRecordData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCRecordData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCRecordData %p -> %p\n", q, p));
	*(TT1ArrayOfCRecordData*)p = *(TT1ArrayOfCRecordData*)q;
}

void TT1__CRecordData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CRecordData::value);
	/* transient soap skipped */
}

void TT1__CRecordData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CRecordData::value);
	/* transient soap skipped */
}

int TT1__CRecordData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CRecordData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CRecordData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CRecordData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CRecordData(struct soap *soap, const char *tag, int id, const TT1__CRecordData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CRecordData), type))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->TT1__CRecordData::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CRecordData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CRecordData(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CRecordData * SOAP_FMAC4 soap_get_TT1__CRecordData(struct soap *soap, TT1__CRecordData *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CRecordData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CRecordData(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CRecordData * SOAP_FMAC4 soap_in_TT1__CRecordData(struct soap *soap, const char *tag, TT1__CRecordData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CRecordData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CRecordData, sizeof(TT1__CRecordData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CRecordData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CRecordData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->TT1__CRecordData::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CRecordData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CRecordData, 0, sizeof(TT1__CRecordData), 0, soap_copy_TT1__CRecordData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CRecordData * SOAP_FMAC6 soap_new_TT1__CRecordData(struct soap *soap, int n)
{	return soap_instantiate_TT1__CRecordData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CRecordData(struct soap *soap, TT1__CRecordData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CRecordData * SOAP_FMAC4 soap_instantiate_TT1__CRecordData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CRecordData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CRecordData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CRecordData;
		if (size)
			*size = sizeof(TT1__CRecordData);
		((TT1__CRecordData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CRecordData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CRecordData);
		for (int i = 0; i < n; i++)
			((TT1__CRecordData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CRecordData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CRecordData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CRecordData %p -> %p\n", q, p));
	*(TT1__CRecordData*)p = *(TT1__CRecordData*)q;
}

void TT1ArrayOfCFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCFilter::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCFilter))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CFilter(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCFilter(struct soap *soap, const char *tag, int id, const TT1ArrayOfCFilter *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CFilter", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFilter);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CFilter(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCFilter(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCFilter * SOAP_FMAC4 soap_get_TT1ArrayOfCFilter(struct soap *soap, TT1ArrayOfCFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCFilter(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCFilter * SOAP_FMAC4 soap_in_TT1ArrayOfCFilter(struct soap *soap, const char *tag, TT1ArrayOfCFilter *a, const char *type)
{	int i, j;
	TT1__CFilter **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCFilter, sizeof(TT1ArrayOfCFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CFilter **)soap_malloc(soap, sizeof(TT1__CFilter *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CFilter(soap, NULL, a->__ptritem + i, "TT1:CFilter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CFilter **)soap_push_block(soap, sizeof(TT1__CFilter *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CFilter(soap, NULL, p, "TT1:CFilter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CFilter **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCFilter, 0, sizeof(TT1ArrayOfCFilter), 0, soap_copy_TT1ArrayOfCFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCFilter * SOAP_FMAC6 soap_new_TT1ArrayOfCFilter(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCFilter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCFilter(struct soap *soap, TT1ArrayOfCFilter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCFilter * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCFilter;
		if (size)
			*size = sizeof(TT1ArrayOfCFilter);
		((TT1ArrayOfCFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCFilter);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCFilter %p -> %p\n", q, p));
	*(TT1ArrayOfCFilter*)p = *(TT1ArrayOfCFilter*)q;
}

void TT1__CFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CFilter::name);
	/* transient soap skipped */
}

void TT1__CFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CFilter::name);
	/* transient soap skipped */
}

int TT1__CFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CFilter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CFilter(struct soap *soap, const char *tag, int id, const TT1__CFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CFilter), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CFilter::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CFilter(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CFilter * SOAP_FMAC4 soap_get_TT1__CFilter(struct soap *soap, TT1__CFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CFilter(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CFilter * SOAP_FMAC4 soap_in_TT1__CFilter(struct soap *soap, const char *tag, TT1__CFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CFilter, sizeof(TT1__CFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CFilter *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CFilter::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CFilter, 0, sizeof(TT1__CFilter), 0, soap_copy_TT1__CFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CFilter * SOAP_FMAC6 soap_new_TT1__CFilter(struct soap *soap, int n)
{	return soap_instantiate_TT1__CFilter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CFilter(struct soap *soap, TT1__CFilter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CFilter * SOAP_FMAC4 soap_instantiate_TT1__CFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CFilter;
		if (size)
			*size = sizeof(TT1__CFilter);
		((TT1__CFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CFilter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CFilter);
		for (int i = 0; i < n; i++)
			((TT1__CFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CFilter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CFilter %p -> %p\n", q, p));
	*(TT1__CFilter*)p = *(TT1__CFilter*)q;
}

void TT1ArrayOfCTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCTableColumn::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCTableColumn))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CTableColumn(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCTableColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCTableColumn(struct soap *soap, const char *tag, int id, const TT1ArrayOfCTableColumn *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CTableColumn", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTableColumn);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CTableColumn(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCTableColumn * SOAP_FMAC4 soap_get_TT1ArrayOfCTableColumn(struct soap *soap, TT1ArrayOfCTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCTableColumn * SOAP_FMAC4 soap_in_TT1ArrayOfCTableColumn(struct soap *soap, const char *tag, TT1ArrayOfCTableColumn *a, const char *type)
{	int i, j;
	TT1__CTableColumn **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCTableColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCTableColumn, sizeof(TT1ArrayOfCTableColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CTableColumn **)soap_malloc(soap, sizeof(TT1__CTableColumn *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CTableColumn(soap, NULL, a->__ptritem + i, "TT1:CTableColumn"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CTableColumn **)soap_push_block(soap, sizeof(TT1__CTableColumn *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CTableColumn(soap, NULL, p, "TT1:CTableColumn"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CTableColumn **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCTableColumn, 0, sizeof(TT1ArrayOfCTableColumn), 0, soap_copy_TT1ArrayOfCTableColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCTableColumn * SOAP_FMAC6 soap_new_TT1ArrayOfCTableColumn(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCTableColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCTableColumn(struct soap *soap, TT1ArrayOfCTableColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCTableColumn * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCTableColumn;
		if (size)
			*size = sizeof(TT1ArrayOfCTableColumn);
		((TT1ArrayOfCTableColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCTableColumn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCTableColumn);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCTableColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCTableColumn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCTableColumn %p -> %p\n", q, p));
	*(TT1ArrayOfCTableColumn*)p = *(TT1ArrayOfCTableColumn*)q;
}

void TT1__CTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CTableColumn::name);
	/* transient soap skipped */
}

void TT1__CTableColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CTableColumn::name);
	/* transient soap skipped */
}

int TT1__CTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTableColumn);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTableColumn(struct soap *soap, const char *tag, int id, const TT1__CTableColumn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTableColumn), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CTableColumn::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTableColumn * SOAP_FMAC4 soap_get_TT1__CTableColumn(struct soap *soap, TT1__CTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTableColumn * SOAP_FMAC4 soap_in_TT1__CTableColumn(struct soap *soap, const char *tag, TT1__CTableColumn *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTableColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTableColumn, sizeof(TT1__CTableColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTableColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTableColumn *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CTableColumn::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTableColumn, 0, sizeof(TT1__CTableColumn), 0, soap_copy_TT1__CTableColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTableColumn * SOAP_FMAC6 soap_new_TT1__CTableColumn(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTableColumn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTableColumn(struct soap *soap, TT1__CTableColumn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTableColumn * SOAP_FMAC4 soap_instantiate_TT1__CTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTableColumn;
		if (size)
			*size = sizeof(TT1__CTableColumn);
		((TT1__CTableColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTableColumn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTableColumn);
		for (int i = 0; i < n; i++)
			((TT1__CTableColumn*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTableColumn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTableColumn %p -> %p\n", q, p));
	*(TT1__CTableColumn*)p = *(TT1__CTableColumn*)q;
}

void TT1ArrayOfCFieldValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCFieldValue::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCFieldValue))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CFieldValue(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCFieldValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCFieldValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCFieldValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCFieldValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCFieldValue(struct soap *soap, const char *tag, int id, const TT1ArrayOfCFieldValue *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CFieldValue", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFieldValue);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CFieldValue(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCFieldValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCFieldValue(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCFieldValue * SOAP_FMAC4 soap_get_TT1ArrayOfCFieldValue(struct soap *soap, TT1ArrayOfCFieldValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCFieldValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCFieldValue(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCFieldValue * SOAP_FMAC4 soap_in_TT1ArrayOfCFieldValue(struct soap *soap, const char *tag, TT1ArrayOfCFieldValue *a, const char *type)
{	int i, j;
	TT1__CFieldValue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCFieldValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCFieldValue, sizeof(TT1ArrayOfCFieldValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CFieldValue **)soap_malloc(soap, sizeof(TT1__CFieldValue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CFieldValue(soap, NULL, a->__ptritem + i, "TT1:CFieldValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CFieldValue **)soap_push_block(soap, sizeof(TT1__CFieldValue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CFieldValue(soap, NULL, p, "TT1:CFieldValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CFieldValue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCFieldValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCFieldValue, 0, sizeof(TT1ArrayOfCFieldValue), 0, soap_copy_TT1ArrayOfCFieldValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCFieldValue * SOAP_FMAC6 soap_new_TT1ArrayOfCFieldValue(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCFieldValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCFieldValue(struct soap *soap, TT1ArrayOfCFieldValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCFieldValue * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCFieldValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCFieldValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCFieldValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCFieldValue;
		if (size)
			*size = sizeof(TT1ArrayOfCFieldValue);
		((TT1ArrayOfCFieldValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCFieldValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCFieldValue);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCFieldValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCFieldValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCFieldValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCFieldValue %p -> %p\n", q, p));
	*(TT1ArrayOfCFieldValue*)p = *(TT1ArrayOfCFieldValue*)q;
}

void TT1__CFieldValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CFieldValue::value);
	/* transient soap skipped */
}

void TT1__CFieldValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CFieldValue::value);
	/* transient soap skipped */
}

int TT1__CFieldValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CFieldValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CFieldValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CFieldValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CFieldValue(struct soap *soap, const char *tag, int id, const TT1__CFieldValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CFieldValue), type))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->TT1__CFieldValue::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CFieldValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CFieldValue(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CFieldValue * SOAP_FMAC4 soap_get_TT1__CFieldValue(struct soap *soap, TT1__CFieldValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CFieldValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CFieldValue(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CFieldValue * SOAP_FMAC4 soap_in_TT1__CFieldValue(struct soap *soap, const char *tag, TT1__CFieldValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CFieldValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CFieldValue, sizeof(TT1__CFieldValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CFieldValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CFieldValue *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->TT1__CFieldValue::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CFieldValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CFieldValue, 0, sizeof(TT1__CFieldValue), 0, soap_copy_TT1__CFieldValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CFieldValue * SOAP_FMAC6 soap_new_TT1__CFieldValue(struct soap *soap, int n)
{	return soap_instantiate_TT1__CFieldValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CFieldValue(struct soap *soap, TT1__CFieldValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CFieldValue * SOAP_FMAC4 soap_instantiate_TT1__CFieldValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CFieldValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CFieldValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CFieldValue;
		if (size)
			*size = sizeof(TT1__CFieldValue);
		((TT1__CFieldValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CFieldValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CFieldValue);
		for (int i = 0; i < n; i++)
			((TT1__CFieldValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CFieldValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CFieldValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CFieldValue %p -> %p\n", q, p));
	*(TT1__CFieldValue*)p = *(TT1__CFieldValue*)q;
}

void TT1ArrayOfCTableField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCTableField::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCTableField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CTableField(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCTableField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCTableField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCTableField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCTableField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCTableField(struct soap *soap, const char *tag, int id, const TT1ArrayOfCTableField *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CTableField", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTableField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CTableField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCTableField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCTableField(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCTableField * SOAP_FMAC4 soap_get_TT1ArrayOfCTableField(struct soap *soap, TT1ArrayOfCTableField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCTableField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCTableField(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCTableField * SOAP_FMAC4 soap_in_TT1ArrayOfCTableField(struct soap *soap, const char *tag, TT1ArrayOfCTableField *a, const char *type)
{	int i, j;
	TT1__CTableField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCTableField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCTableField, sizeof(TT1ArrayOfCTableField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CTableField **)soap_malloc(soap, sizeof(TT1__CTableField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CTableField(soap, NULL, a->__ptritem + i, "TT1:CTableField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CTableField **)soap_push_block(soap, sizeof(TT1__CTableField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CTableField(soap, NULL, p, "TT1:CTableField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CTableField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCTableField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCTableField, 0, sizeof(TT1ArrayOfCTableField), 0, soap_copy_TT1ArrayOfCTableField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCTableField * SOAP_FMAC6 soap_new_TT1ArrayOfCTableField(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCTableField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCTableField(struct soap *soap, TT1ArrayOfCTableField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCTableField * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCTableField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCTableField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCTableField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCTableField;
		if (size)
			*size = sizeof(TT1ArrayOfCTableField);
		((TT1ArrayOfCTableField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCTableField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCTableField);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCTableField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCTableField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCTableField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCTableField %p -> %p\n", q, p));
	*(TT1ArrayOfCTableField*)p = *(TT1ArrayOfCTableField*)q;
}

void TT1__CTableField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CTableField::name);
	/* transient soap skipped */
}

void TT1__CTableField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CTableField::name);
	/* transient soap skipped */
}

int TT1__CTableField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CTableField);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CTableField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CTableField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CTableField(struct soap *soap, const char *tag, int id, const TT1__CTableField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CTableField), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CTableField::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CTableField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CTableField(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CTableField * SOAP_FMAC4 soap_get_TT1__CTableField(struct soap *soap, TT1__CTableField *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CTableField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CTableField(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CTableField * SOAP_FMAC4 soap_in_TT1__CTableField(struct soap *soap, const char *tag, TT1__CTableField *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CTableField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CTableField, sizeof(TT1__CTableField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CTableField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CTableField *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CTableField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CTableField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CTableField, 0, sizeof(TT1__CTableField), 0, soap_copy_TT1__CTableField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CTableField * SOAP_FMAC6 soap_new_TT1__CTableField(struct soap *soap, int n)
{	return soap_instantiate_TT1__CTableField(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CTableField(struct soap *soap, TT1__CTableField *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CTableField * SOAP_FMAC4 soap_instantiate_TT1__CTableField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CTableField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CTableField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CTableField;
		if (size)
			*size = sizeof(TT1__CTableField);
		((TT1__CTableField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CTableField[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CTableField);
		for (int i = 0; i < n; i++)
			((TT1__CTableField*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CTableField*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CTableField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CTableField %p -> %p\n", q, p));
	*(TT1__CTableField*)p = *(TT1__CTableField*)q;
}

void TT1ArrayOfCDatabaseTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCDatabaseTable::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCDatabaseTable))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CDatabaseTable(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCDatabaseTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCDatabaseTable);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCDatabaseTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCDatabaseTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCDatabaseTable(struct soap *soap, const char *tag, int id, const TT1ArrayOfCDatabaseTable *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CDatabaseTable", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDatabaseTable);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CDatabaseTable(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCDatabaseTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCDatabaseTable(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabaseTable * SOAP_FMAC4 soap_get_TT1ArrayOfCDatabaseTable(struct soap *soap, TT1ArrayOfCDatabaseTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCDatabaseTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCDatabaseTable(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabaseTable * SOAP_FMAC4 soap_in_TT1ArrayOfCDatabaseTable(struct soap *soap, const char *tag, TT1ArrayOfCDatabaseTable *a, const char *type)
{	int i, j;
	TT1__CDatabaseTable **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCDatabaseTable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCDatabaseTable, sizeof(TT1ArrayOfCDatabaseTable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CDatabaseTable **)soap_malloc(soap, sizeof(TT1__CDatabaseTable *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CDatabaseTable(soap, NULL, a->__ptritem + i, "TT1:CDatabaseTable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CDatabaseTable **)soap_push_block(soap, sizeof(TT1__CDatabaseTable *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CDatabaseTable(soap, NULL, p, "TT1:CDatabaseTable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CDatabaseTable **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCDatabaseTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCDatabaseTable, 0, sizeof(TT1ArrayOfCDatabaseTable), 0, soap_copy_TT1ArrayOfCDatabaseTable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCDatabaseTable * SOAP_FMAC6 soap_new_TT1ArrayOfCDatabaseTable(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCDatabaseTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCDatabaseTable(struct soap *soap, TT1ArrayOfCDatabaseTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCDatabaseTable * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCDatabaseTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCDatabaseTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCDatabaseTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCDatabaseTable;
		if (size)
			*size = sizeof(TT1ArrayOfCDatabaseTable);
		((TT1ArrayOfCDatabaseTable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCDatabaseTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCDatabaseTable);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCDatabaseTable*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCDatabaseTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCDatabaseTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCDatabaseTable %p -> %p\n", q, p));
	*(TT1ArrayOfCDatabaseTable*)p = *(TT1ArrayOfCDatabaseTable*)q;
}

void TT1__CDatabaseTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CDatabaseTable::name);
	/* transient soap skipped */
}

void TT1__CDatabaseTable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CDatabaseTable::name);
	/* transient soap skipped */
}

int TT1__CDatabaseTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDatabaseTable);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDatabaseTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDatabaseTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDatabaseTable(struct soap *soap, const char *tag, int id, const TT1__CDatabaseTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDatabaseTable), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CDatabaseTable::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CDatabaseTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDatabaseTable(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDatabaseTable * SOAP_FMAC4 soap_get_TT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDatabaseTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDatabaseTable(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDatabaseTable * SOAP_FMAC4 soap_in_TT1__CDatabaseTable(struct soap *soap, const char *tag, TT1__CDatabaseTable *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDatabaseTable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDatabaseTable, sizeof(TT1__CDatabaseTable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDatabaseTable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDatabaseTable *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CDatabaseTable::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDatabaseTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDatabaseTable, 0, sizeof(TT1__CDatabaseTable), 0, soap_copy_TT1__CDatabaseTable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDatabaseTable * SOAP_FMAC6 soap_new_TT1__CDatabaseTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDatabaseTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDatabaseTable * SOAP_FMAC4 soap_instantiate_TT1__CDatabaseTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDatabaseTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDatabaseTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDatabaseTable;
		if (size)
			*size = sizeof(TT1__CDatabaseTable);
		((TT1__CDatabaseTable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDatabaseTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDatabaseTable);
		for (int i = 0; i < n; i++)
			((TT1__CDatabaseTable*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDatabaseTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDatabaseTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDatabaseTable %p -> %p\n", q, p));
	*(TT1__CDatabaseTable*)p = *(TT1__CDatabaseTable*)q;
}

void TT1ArrayOfCProject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCProject::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCProject))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CProject(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCProject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCProject);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCProject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCProject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCProject(struct soap *soap, const char *tag, int id, const TT1ArrayOfCProject *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CProject", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCProject);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CProject(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCProject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCProject(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCProject * SOAP_FMAC4 soap_get_TT1ArrayOfCProject(struct soap *soap, TT1ArrayOfCProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCProject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCProject(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCProject * SOAP_FMAC4 soap_in_TT1ArrayOfCProject(struct soap *soap, const char *tag, TT1ArrayOfCProject *a, const char *type)
{	int i, j;
	TT1__CProject **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCProject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCProject, sizeof(TT1ArrayOfCProject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CProject **)soap_malloc(soap, sizeof(TT1__CProject *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CProject(soap, NULL, a->__ptritem + i, "TT1:CProject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CProject **)soap_push_block(soap, sizeof(TT1__CProject *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CProject(soap, NULL, p, "TT1:CProject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CProject **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCProject, 0, sizeof(TT1ArrayOfCProject), 0, soap_copy_TT1ArrayOfCProject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCProject * SOAP_FMAC6 soap_new_TT1ArrayOfCProject(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCProject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCProject(struct soap *soap, TT1ArrayOfCProject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCProject * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCProject;
		if (size)
			*size = sizeof(TT1ArrayOfCProject);
		((TT1ArrayOfCProject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCProject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCProject);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCProject*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCProject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCProject %p -> %p\n", q, p));
	*(TT1ArrayOfCProject*)p = *(TT1ArrayOfCProject*)q;
}

void TT1__CProject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->TT1__CProject::database = NULL;
	this->TT1__CProject::options = NULL;
	/* transient soap skipped */
}

void TT1__CProject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDatabase(soap, &this->TT1__CProject::database);
	soap_serialize_PointerToTT1ArrayOfCProjectDataOption(soap, &this->TT1__CProject::options);
	/* transient soap skipped */
}

int TT1__CProject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CProject);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CProject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CProject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CProject(struct soap *soap, const char *tag, int id, const TT1__CProject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CProject), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDatabase(soap, "database", -1, &(a->TT1__CProject::database), ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCProjectDataOption(soap, "options", -1, &(a->TT1__CProject::options), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CProject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CProject(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CProject * SOAP_FMAC4 soap_get_TT1__CProject(struct soap *soap, TT1__CProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CProject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CProject(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CProject * SOAP_FMAC4 soap_in_TT1__CProject(struct soap *soap, const char *tag, TT1__CProject *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CProject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CProject, sizeof(TT1__CProject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CProject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CProject *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_database1 = 1, soap_flag_options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_database1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDatabase(soap, "database", &(a->TT1__CProject::database), "TT1:CDatabase"))
				{	soap_flag_database1--;
					continue;
				}
			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCProjectDataOption(soap, "options", &(a->TT1__CProject::options), "TT1:CProjectDataOption"))
				{	soap_flag_options1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CProject, 0, sizeof(TT1__CProject), 0, soap_copy_TT1__CProject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_database1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CProject * SOAP_FMAC6 soap_new_TT1__CProject(struct soap *soap, int n)
{	return soap_instantiate_TT1__CProject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CProject(struct soap *soap, TT1__CProject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CProject * SOAP_FMAC4 soap_instantiate_TT1__CProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CProject;
		if (size)
			*size = sizeof(TT1__CProject);
		((TT1__CProject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CProject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CProject);
		for (int i = 0; i < n; i++)
			((TT1__CProject*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CProject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CProject %p -> %p\n", q, p));
	*(TT1__CProject*)p = *(TT1__CProject*)q;
}

void TT1ArrayOfCProjectDataOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCProjectDataOption::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCProjectDataOption))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CProjectDataOption(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCProjectDataOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCProjectDataOption);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCProjectDataOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCProjectDataOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCProjectDataOption(struct soap *soap, const char *tag, int id, const TT1ArrayOfCProjectDataOption *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CProjectDataOption", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCProjectDataOption);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CProjectDataOption(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCProjectDataOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCProjectDataOption(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCProjectDataOption * SOAP_FMAC4 soap_get_TT1ArrayOfCProjectDataOption(struct soap *soap, TT1ArrayOfCProjectDataOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCProjectDataOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCProjectDataOption(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCProjectDataOption * SOAP_FMAC4 soap_in_TT1ArrayOfCProjectDataOption(struct soap *soap, const char *tag, TT1ArrayOfCProjectDataOption *a, const char *type)
{	int i, j;
	TT1__CProjectDataOption **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCProjectDataOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCProjectDataOption, sizeof(TT1ArrayOfCProjectDataOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CProjectDataOption **)soap_malloc(soap, sizeof(TT1__CProjectDataOption *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CProjectDataOption(soap, NULL, a->__ptritem + i, "TT1:CProjectDataOption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CProjectDataOption **)soap_push_block(soap, sizeof(TT1__CProjectDataOption *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CProjectDataOption(soap, NULL, p, "TT1:CProjectDataOption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CProjectDataOption **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCProjectDataOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCProjectDataOption, 0, sizeof(TT1ArrayOfCProjectDataOption), 0, soap_copy_TT1ArrayOfCProjectDataOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCProjectDataOption * SOAP_FMAC6 soap_new_TT1ArrayOfCProjectDataOption(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCProjectDataOption(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCProjectDataOption(struct soap *soap, TT1ArrayOfCProjectDataOption *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCProjectDataOption * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCProjectDataOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCProjectDataOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCProjectDataOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCProjectDataOption;
		if (size)
			*size = sizeof(TT1ArrayOfCProjectDataOption);
		((TT1ArrayOfCProjectDataOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCProjectDataOption[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCProjectDataOption);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCProjectDataOption*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCProjectDataOption*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCProjectDataOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCProjectDataOption %p -> %p\n", q, p));
	*(TT1ArrayOfCProjectDataOption*)p = *(TT1ArrayOfCProjectDataOption*)q;
}

void TT1__CProjectDataOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CProjectDataOption::name);
	/* transient soap skipped */
}

void TT1__CProjectDataOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CProjectDataOption::name);
	/* transient soap skipped */
}

int TT1__CProjectDataOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CProjectDataOption);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CProjectDataOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CProjectDataOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CProjectDataOption(struct soap *soap, const char *tag, int id, const TT1__CProjectDataOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CProjectDataOption), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CProjectDataOption::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CProjectDataOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CProjectDataOption(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CProjectDataOption * SOAP_FMAC4 soap_get_TT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CProjectDataOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CProjectDataOption(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CProjectDataOption * SOAP_FMAC4 soap_in_TT1__CProjectDataOption(struct soap *soap, const char *tag, TT1__CProjectDataOption *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CProjectDataOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CProjectDataOption, sizeof(TT1__CProjectDataOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CProjectDataOption)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CProjectDataOption *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CProjectDataOption::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CProjectDataOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CProjectDataOption, 0, sizeof(TT1__CProjectDataOption), 0, soap_copy_TT1__CProjectDataOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CProjectDataOption * SOAP_FMAC6 soap_new_TT1__CProjectDataOption(struct soap *soap, int n)
{	return soap_instantiate_TT1__CProjectDataOption(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CProjectDataOption * SOAP_FMAC4 soap_instantiate_TT1__CProjectDataOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CProjectDataOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CProjectDataOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CProjectDataOption;
		if (size)
			*size = sizeof(TT1__CProjectDataOption);
		((TT1__CProjectDataOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CProjectDataOption[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CProjectDataOption);
		for (int i = 0; i < n; i++)
			((TT1__CProjectDataOption*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CProjectDataOption*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CProjectDataOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CProjectDataOption %p -> %p\n", q, p));
	*(TT1__CProjectDataOption*)p = *(TT1__CProjectDataOption*)q;
}

void TT1ArrayOfCDatabase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfCDatabase::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfCDatabase))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToTT1__CDatabase(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfCDatabase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfCDatabase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfCDatabase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfCDatabase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfCDatabase(struct soap *soap, const char *tag, int id, const TT1ArrayOfCDatabase *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "TT1:CDatabase", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDatabase);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToTT1__CDatabase(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfCDatabase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfCDatabase(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabase * SOAP_FMAC4 soap_get_TT1ArrayOfCDatabase(struct soap *soap, TT1ArrayOfCDatabase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfCDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfCDatabase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfCDatabase(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabase * SOAP_FMAC4 soap_in_TT1ArrayOfCDatabase(struct soap *soap, const char *tag, TT1ArrayOfCDatabase *a, const char *type)
{	int i, j;
	TT1__CDatabase **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfCDatabase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfCDatabase, sizeof(TT1ArrayOfCDatabase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (TT1__CDatabase **)soap_malloc(soap, sizeof(TT1__CDatabase *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToTT1__CDatabase(soap, NULL, a->__ptritem + i, "TT1:CDatabase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (TT1__CDatabase **)soap_push_block(soap, sizeof(TT1__CDatabase *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToTT1__CDatabase(soap, NULL, p, "TT1:CDatabase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (TT1__CDatabase **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfCDatabase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfCDatabase, 0, sizeof(TT1ArrayOfCDatabase), 0, soap_copy_TT1ArrayOfCDatabase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfCDatabase * SOAP_FMAC6 soap_new_TT1ArrayOfCDatabase(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfCDatabase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfCDatabase(struct soap *soap, TT1ArrayOfCDatabase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfCDatabase * SOAP_FMAC4 soap_instantiate_TT1ArrayOfCDatabase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfCDatabase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfCDatabase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfCDatabase;
		if (size)
			*size = sizeof(TT1ArrayOfCDatabase);
		((TT1ArrayOfCDatabase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfCDatabase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfCDatabase);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfCDatabase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfCDatabase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfCDatabase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfCDatabase %p -> %p\n", q, p));
	*(TT1ArrayOfCDatabase*)p = *(TT1ArrayOfCDatabase*)q;
}

void TT1__CDatabase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->TT1__CDatabase::name);
	/* transient soap skipped */
}

void TT1__CDatabase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->TT1__CDatabase::name);
	/* transient soap skipped */
}

int TT1__CDatabase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_TT1__CDatabase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1__CDatabase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TT1__CDatabase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__CDatabase(struct soap *soap, const char *tag, int id, const TT1__CDatabase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__CDatabase), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->TT1__CDatabase::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *TT1__CDatabase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1__CDatabase(soap, this, tag, type);
}

SOAP_FMAC3 TT1__CDatabase * SOAP_FMAC4 soap_get_TT1__CDatabase(struct soap *soap, TT1__CDatabase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1__CDatabase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1__CDatabase(soap, tag, this, type);
}

SOAP_FMAC3 TT1__CDatabase * SOAP_FMAC4 soap_in_TT1__CDatabase(struct soap *soap, const char *tag, TT1__CDatabase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (TT1__CDatabase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__CDatabase, sizeof(TT1__CDatabase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_TT1__CDatabase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (TT1__CDatabase *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->TT1__CDatabase::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1__CDatabase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__CDatabase, 0, sizeof(TT1__CDatabase), 0, soap_copy_TT1__CDatabase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1__CDatabase * SOAP_FMAC6 soap_new_TT1__CDatabase(struct soap *soap, int n)
{	return soap_instantiate_TT1__CDatabase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__CDatabase(struct soap *soap, TT1__CDatabase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1__CDatabase * SOAP_FMAC4 soap_instantiate_TT1__CDatabase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__CDatabase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__CDatabase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1__CDatabase;
		if (size)
			*size = sizeof(TT1__CDatabase);
		((TT1__CDatabase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1__CDatabase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1__CDatabase);
		for (int i = 0; i < n; i++)
			((TT1__CDatabase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1__CDatabase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__CDatabase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1__CDatabase %p -> %p\n", q, p));
	*(TT1__CDatabase*)p = *(TT1__CDatabase*)q;
}

void TT1ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void TT1ArrayOfstring::soap_serialize(struct soap *soap) const
{
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_TT1ArrayOfstring))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_string(soap, this->__ptritem + i);
		}
}

int TT1ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_TT1ArrayOfstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int TT1ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_TT1ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1ArrayOfstring(struct soap *soap, const char *tag, int id, const TT1ArrayOfstring *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfstring);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TT1ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TT1ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 TT1ArrayOfstring * SOAP_FMAC4 soap_get_TT1ArrayOfstring(struct soap *soap, TT1ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *TT1ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_TT1ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 TT1ArrayOfstring * SOAP_FMAC4 soap_in_TT1ArrayOfstring(struct soap *soap, const char *tag, TT1ArrayOfstring *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TT1ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_TT1ArrayOfstring, sizeof(TT1ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptritem + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptritem = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TT1ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1ArrayOfstring, 0, sizeof(TT1ArrayOfstring), 0, soap_copy_TT1ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 TT1ArrayOfstring * SOAP_FMAC6 soap_new_TT1ArrayOfstring(struct soap *soap, int n)
{	return soap_instantiate_TT1ArrayOfstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1ArrayOfstring(struct soap *soap, TT1ArrayOfstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 TT1ArrayOfstring * SOAP_FMAC4 soap_instantiate_TT1ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1ArrayOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new TT1ArrayOfstring;
		if (size)
			*size = sizeof(TT1ArrayOfstring);
		((TT1ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new TT1ArrayOfstring[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(TT1ArrayOfstring);
		for (int i = 0; i < n; i++)
			((TT1ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (TT1ArrayOfstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying TT1ArrayOfstring %p -> %p\n", q, p));
	*(TT1ArrayOfstring*)p = *(TT1ArrayOfstring*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRootPrivateFolderPath(struct soap *soap, struct TT1__getRootPrivateFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRootPrivateFolderPath(struct soap *soap, const struct TT1__getRootPrivateFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRootPrivateFolderPath(struct soap *soap, const struct TT1__getRootPrivateFolderPath *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRootPrivateFolderPath);
	if (soap_out_TT1__getRootPrivateFolderPath(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRootPrivateFolderPath(struct soap *soap, const char *tag, int id, const struct TT1__getRootPrivateFolderPath *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRootPrivateFolderPath), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPath * SOAP_FMAC4 soap_get_TT1__getRootPrivateFolderPath(struct soap *soap, struct TT1__getRootPrivateFolderPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRootPrivateFolderPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPath * SOAP_FMAC4 soap_in_TT1__getRootPrivateFolderPath(struct soap *soap, const char *tag, struct TT1__getRootPrivateFolderPath *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRootPrivateFolderPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRootPrivateFolderPath, sizeof(struct TT1__getRootPrivateFolderPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRootPrivateFolderPath(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRootPrivateFolderPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRootPrivateFolderPath, 0, sizeof(struct TT1__getRootPrivateFolderPath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRootPrivateFolderPath * SOAP_FMAC6 soap_new_TT1__getRootPrivateFolderPath(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRootPrivateFolderPath(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRootPrivateFolderPath(struct soap *soap, struct TT1__getRootPrivateFolderPath *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPath * SOAP_FMAC4 soap_instantiate_TT1__getRootPrivateFolderPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRootPrivateFolderPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRootPrivateFolderPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRootPrivateFolderPath;
		if (size)
			*size = sizeof(struct TT1__getRootPrivateFolderPath);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRootPrivateFolderPath[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRootPrivateFolderPath);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRootPrivateFolderPath*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRootPrivateFolderPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRootPrivateFolderPath %p -> %p\n", q, p));
	*(struct TT1__getRootPrivateFolderPath*)p = *(struct TT1__getRootPrivateFolderPath*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRootPrivateFolderPathResponse(struct soap *soap, struct TT1__getRootPrivateFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->strPrivatePath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRootPrivateFolderPathResponse(struct soap *soap, const struct TT1__getRootPrivateFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->strPrivatePath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRootPrivateFolderPathResponse(struct soap *soap, const struct TT1__getRootPrivateFolderPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRootPrivateFolderPathResponse);
	if (soap_out_TT1__getRootPrivateFolderPathResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRootPrivateFolderPathResponse(struct soap *soap, const char *tag, int id, const struct TT1__getRootPrivateFolderPathResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRootPrivateFolderPathResponse), type))
		return soap->error;
	if (soap_out_string(soap, "strPrivatePath", -1, &a->strPrivatePath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPathResponse * SOAP_FMAC4 soap_get_TT1__getRootPrivateFolderPathResponse(struct soap *soap, struct TT1__getRootPrivateFolderPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRootPrivateFolderPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPathResponse * SOAP_FMAC4 soap_in_TT1__getRootPrivateFolderPathResponse(struct soap *soap, const char *tag, struct TT1__getRootPrivateFolderPathResponse *a, const char *type)
{
	short soap_flag_strPrivatePath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRootPrivateFolderPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRootPrivateFolderPathResponse, sizeof(struct TT1__getRootPrivateFolderPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRootPrivateFolderPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strPrivatePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "strPrivatePath", &a->strPrivatePath, "xsd:string"))
				{	soap_flag_strPrivatePath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRootPrivateFolderPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRootPrivateFolderPathResponse, 0, sizeof(struct TT1__getRootPrivateFolderPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strPrivatePath > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRootPrivateFolderPathResponse * SOAP_FMAC6 soap_new_TT1__getRootPrivateFolderPathResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRootPrivateFolderPathResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRootPrivateFolderPathResponse(struct soap *soap, struct TT1__getRootPrivateFolderPathResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRootPrivateFolderPathResponse * SOAP_FMAC4 soap_instantiate_TT1__getRootPrivateFolderPathResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRootPrivateFolderPathResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRootPrivateFolderPathResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRootPrivateFolderPathResponse;
		if (size)
			*size = sizeof(struct TT1__getRootPrivateFolderPathResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRootPrivateFolderPathResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRootPrivateFolderPathResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRootPrivateFolderPathResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRootPrivateFolderPathResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRootPrivateFolderPathResponse %p -> %p\n", q, p));
	*(struct TT1__getRootPrivateFolderPathResponse*)p = *(struct TT1__getRootPrivateFolderPathResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRootPublicFolderPath(struct soap *soap, struct TT1__getRootPublicFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRootPublicFolderPath(struct soap *soap, const struct TT1__getRootPublicFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRootPublicFolderPath(struct soap *soap, const struct TT1__getRootPublicFolderPath *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRootPublicFolderPath);
	if (soap_out_TT1__getRootPublicFolderPath(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRootPublicFolderPath(struct soap *soap, const char *tag, int id, const struct TT1__getRootPublicFolderPath *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRootPublicFolderPath), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPath * SOAP_FMAC4 soap_get_TT1__getRootPublicFolderPath(struct soap *soap, struct TT1__getRootPublicFolderPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRootPublicFolderPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPath * SOAP_FMAC4 soap_in_TT1__getRootPublicFolderPath(struct soap *soap, const char *tag, struct TT1__getRootPublicFolderPath *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRootPublicFolderPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRootPublicFolderPath, sizeof(struct TT1__getRootPublicFolderPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRootPublicFolderPath(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRootPublicFolderPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRootPublicFolderPath, 0, sizeof(struct TT1__getRootPublicFolderPath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRootPublicFolderPath * SOAP_FMAC6 soap_new_TT1__getRootPublicFolderPath(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRootPublicFolderPath(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRootPublicFolderPath(struct soap *soap, struct TT1__getRootPublicFolderPath *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPath * SOAP_FMAC4 soap_instantiate_TT1__getRootPublicFolderPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRootPublicFolderPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRootPublicFolderPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRootPublicFolderPath;
		if (size)
			*size = sizeof(struct TT1__getRootPublicFolderPath);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRootPublicFolderPath[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRootPublicFolderPath);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRootPublicFolderPath*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRootPublicFolderPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRootPublicFolderPath %p -> %p\n", q, p));
	*(struct TT1__getRootPublicFolderPath*)p = *(struct TT1__getRootPublicFolderPath*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRootPublicFolderPathResponse(struct soap *soap, struct TT1__getRootPublicFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->strPublicPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRootPublicFolderPathResponse(struct soap *soap, const struct TT1__getRootPublicFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->strPublicPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRootPublicFolderPathResponse(struct soap *soap, const struct TT1__getRootPublicFolderPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRootPublicFolderPathResponse);
	if (soap_out_TT1__getRootPublicFolderPathResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRootPublicFolderPathResponse(struct soap *soap, const char *tag, int id, const struct TT1__getRootPublicFolderPathResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRootPublicFolderPathResponse), type))
		return soap->error;
	if (soap_out_string(soap, "strPublicPath", -1, &a->strPublicPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPathResponse * SOAP_FMAC4 soap_get_TT1__getRootPublicFolderPathResponse(struct soap *soap, struct TT1__getRootPublicFolderPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRootPublicFolderPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPathResponse * SOAP_FMAC4 soap_in_TT1__getRootPublicFolderPathResponse(struct soap *soap, const char *tag, struct TT1__getRootPublicFolderPathResponse *a, const char *type)
{
	short soap_flag_strPublicPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRootPublicFolderPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRootPublicFolderPathResponse, sizeof(struct TT1__getRootPublicFolderPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRootPublicFolderPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strPublicPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "strPublicPath", &a->strPublicPath, "xsd:string"))
				{	soap_flag_strPublicPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRootPublicFolderPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRootPublicFolderPathResponse, 0, sizeof(struct TT1__getRootPublicFolderPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strPublicPath > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRootPublicFolderPathResponse * SOAP_FMAC6 soap_new_TT1__getRootPublicFolderPathResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRootPublicFolderPathResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRootPublicFolderPathResponse(struct soap *soap, struct TT1__getRootPublicFolderPathResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRootPublicFolderPathResponse * SOAP_FMAC4 soap_instantiate_TT1__getRootPublicFolderPathResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRootPublicFolderPathResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRootPublicFolderPathResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRootPublicFolderPathResponse;
		if (size)
			*size = sizeof(struct TT1__getRootPublicFolderPathResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRootPublicFolderPathResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRootPublicFolderPathResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRootPublicFolderPathResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRootPublicFolderPathResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRootPublicFolderPathResponse %p -> %p\n", q, p));
	*(struct TT1__getRootPublicFolderPathResponse*)p = *(struct TT1__getRootPublicFolderPathResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolderPathSeparator(struct soap *soap, struct TT1__getFolderPathSeparator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolderPathSeparator(struct soap *soap, const struct TT1__getFolderPathSeparator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolderPathSeparator(struct soap *soap, const struct TT1__getFolderPathSeparator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolderPathSeparator);
	if (soap_out_TT1__getFolderPathSeparator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolderPathSeparator(struct soap *soap, const char *tag, int id, const struct TT1__getFolderPathSeparator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolderPathSeparator), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolderPathSeparator * SOAP_FMAC4 soap_get_TT1__getFolderPathSeparator(struct soap *soap, struct TT1__getFolderPathSeparator *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolderPathSeparator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolderPathSeparator * SOAP_FMAC4 soap_in_TT1__getFolderPathSeparator(struct soap *soap, const char *tag, struct TT1__getFolderPathSeparator *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolderPathSeparator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolderPathSeparator, sizeof(struct TT1__getFolderPathSeparator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolderPathSeparator(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolderPathSeparator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolderPathSeparator, 0, sizeof(struct TT1__getFolderPathSeparator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolderPathSeparator * SOAP_FMAC6 soap_new_TT1__getFolderPathSeparator(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolderPathSeparator(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolderPathSeparator(struct soap *soap, struct TT1__getFolderPathSeparator *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolderPathSeparator * SOAP_FMAC4 soap_instantiate_TT1__getFolderPathSeparator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolderPathSeparator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolderPathSeparator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolderPathSeparator;
		if (size)
			*size = sizeof(struct TT1__getFolderPathSeparator);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolderPathSeparator[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolderPathSeparator);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolderPathSeparator*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolderPathSeparator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolderPathSeparator %p -> %p\n", q, p));
	*(struct TT1__getFolderPathSeparator*)p = *(struct TT1__getFolderPathSeparator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolderPathSeparatorResponse(struct soap *soap, struct TT1__getFolderPathSeparatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__byte(soap, &a->separator);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolderPathSeparatorResponse(struct soap *soap, const struct TT1__getFolderPathSeparatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolderPathSeparatorResponse(struct soap *soap, const struct TT1__getFolderPathSeparatorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolderPathSeparatorResponse);
	if (soap_out_TT1__getFolderPathSeparatorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolderPathSeparatorResponse(struct soap *soap, const char *tag, int id, const struct TT1__getFolderPathSeparatorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolderPathSeparatorResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "separator", -1, &a->separator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolderPathSeparatorResponse * SOAP_FMAC4 soap_get_TT1__getFolderPathSeparatorResponse(struct soap *soap, struct TT1__getFolderPathSeparatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolderPathSeparatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolderPathSeparatorResponse * SOAP_FMAC4 soap_in_TT1__getFolderPathSeparatorResponse(struct soap *soap, const char *tag, struct TT1__getFolderPathSeparatorResponse *a, const char *type)
{
	short soap_flag_separator = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolderPathSeparatorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolderPathSeparatorResponse, sizeof(struct TT1__getFolderPathSeparatorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolderPathSeparatorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_separator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "separator", &a->separator, "xsd:byte"))
				{	soap_flag_separator--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolderPathSeparatorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolderPathSeparatorResponse, 0, sizeof(struct TT1__getFolderPathSeparatorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_separator > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolderPathSeparatorResponse * SOAP_FMAC6 soap_new_TT1__getFolderPathSeparatorResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolderPathSeparatorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolderPathSeparatorResponse(struct soap *soap, struct TT1__getFolderPathSeparatorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolderPathSeparatorResponse * SOAP_FMAC4 soap_instantiate_TT1__getFolderPathSeparatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolderPathSeparatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolderPathSeparatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolderPathSeparatorResponse;
		if (size)
			*size = sizeof(struct TT1__getFolderPathSeparatorResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolderPathSeparatorResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolderPathSeparatorResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolderPathSeparatorResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolderPathSeparatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolderPathSeparatorResponse %p -> %p\n", q, p));
	*(struct TT1__getFolderPathSeparatorResponse*)p = *(struct TT1__getFolderPathSeparatorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getEntityListForFolderByRecordID(struct soap *soap, struct TT1__getEntityListForFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getEntityListForFolderByRecordID(struct soap *soap, const struct TT1__getEntityListForFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getEntityListForFolderByRecordID(struct soap *soap, const struct TT1__getEntityListForFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getEntityListForFolderByRecordID);
	if (soap_out_TT1__getEntityListForFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getEntityListForFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getEntityListForFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getEntityListForFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordID * SOAP_FMAC4 soap_get_TT1__getEntityListForFolderByRecordID(struct soap *soap, struct TT1__getEntityListForFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getEntityListForFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordID * SOAP_FMAC4 soap_in_TT1__getEntityListForFolderByRecordID(struct soap *soap, const char *tag, struct TT1__getEntityListForFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getEntityListForFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getEntityListForFolderByRecordID, sizeof(struct TT1__getEntityListForFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getEntityListForFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getEntityListForFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getEntityListForFolderByRecordID, 0, sizeof(struct TT1__getEntityListForFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getEntityListForFolderByRecordID * SOAP_FMAC6 soap_new_TT1__getEntityListForFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getEntityListForFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getEntityListForFolderByRecordID(struct soap *soap, struct TT1__getEntityListForFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getEntityListForFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getEntityListForFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getEntityListForFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getEntityListForFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__getEntityListForFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getEntityListForFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getEntityListForFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getEntityListForFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getEntityListForFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getEntityListForFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__getEntityListForFolderByRecordID*)p = *(struct TT1__getEntityListForFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, struct TT1__getEntityListForFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pEntityList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const struct TT1__getEntityListForFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFolderItem(soap, &a->pEntityList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const struct TT1__getEntityListForFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse);
	if (soap_out_TT1__getEntityListForFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getEntityListForFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFolderItem(soap, "pEntityList", -1, &a->pEntityList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, struct TT1__getEntityListForFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getEntityListForFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getEntityListForFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_pEntityList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getEntityListForFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse, sizeof(struct TT1__getEntityListForFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getEntityListForFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pEntityList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFolderItem(soap, "pEntityList", &a->pEntityList, "TT1:CFolderItem"))
				{	soap_flag_pEntityList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getEntityListForFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse, 0, sizeof(struct TT1__getEntityListForFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getEntityListForFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, struct TT1__getEntityListForFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getEntityListForFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getEntityListForFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getEntityListForFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getEntityListForFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getEntityListForFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getEntityListForFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getEntityListForFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getEntityListForFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getEntityListForFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getEntityListForFolderByRecordIDResponse*)p = *(struct TT1__getEntityListForFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__removeEntityFromFolderByRecordID(struct soap *soap, struct TT1__removeEntityFromFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
	a->entity = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__removeEntityFromFolderByRecordID(struct soap *soap, const struct TT1__removeEntityFromFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
	soap_serialize_PointerToTT1__CFolderItem(soap, &a->entity);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__removeEntityFromFolderByRecordID(struct soap *soap, const struct TT1__removeEntityFromFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__removeEntityFromFolderByRecordID);
	if (soap_out_TT1__removeEntityFromFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__removeEntityFromFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__removeEntityFromFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__removeEntityFromFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CFolderItem(soap, "entity", -1, &a->entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordID * SOAP_FMAC4 soap_get_TT1__removeEntityFromFolderByRecordID(struct soap *soap, struct TT1__removeEntityFromFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__removeEntityFromFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordID * SOAP_FMAC4 soap_in_TT1__removeEntityFromFolderByRecordID(struct soap *soap, const char *tag, struct TT1__removeEntityFromFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1, soap_flag_entity = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__removeEntityFromFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__removeEntityFromFolderByRecordID, sizeof(struct TT1__removeEntityFromFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__removeEntityFromFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap_flag_entity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolderItem(soap, "entity", &a->entity, "TT1:CFolderItem"))
				{	soap_flag_entity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__removeEntityFromFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__removeEntityFromFolderByRecordID, 0, sizeof(struct TT1__removeEntityFromFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__removeEntityFromFolderByRecordID * SOAP_FMAC6 soap_new_TT1__removeEntityFromFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__removeEntityFromFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__removeEntityFromFolderByRecordID(struct soap *soap, struct TT1__removeEntityFromFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__removeEntityFromFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__removeEntityFromFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__removeEntityFromFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__removeEntityFromFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__removeEntityFromFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__removeEntityFromFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__removeEntityFromFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__removeEntityFromFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__removeEntityFromFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__removeEntityFromFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__removeEntityFromFolderByRecordID*)p = *(struct TT1__removeEntityFromFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, struct TT1__removeEntityFromFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const struct TT1__removeEntityFromFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const struct TT1__removeEntityFromFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse);
	if (soap_out_TT1__removeEntityFromFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__removeEntityFromFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, struct TT1__removeEntityFromFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__removeEntityFromFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__removeEntityFromFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__removeEntityFromFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse, sizeof(struct TT1__removeEntityFromFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__removeEntityFromFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__removeEntityFromFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse, 0, sizeof(struct TT1__removeEntityFromFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__removeEntityFromFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, struct TT1__removeEntityFromFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__removeEntityFromFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__removeEntityFromFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__removeEntityFromFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__removeEntityFromFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__removeEntityFromFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__removeEntityFromFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__removeEntityFromFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__removeEntityFromFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__removeEntityFromFolderByRecordIDResponse*)p = *(struct TT1__removeEntityFromFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addEntityToFolderByRecordID(struct soap *soap, struct TT1__addEntityToFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
	soap_default_LONG64(soap, &a->entityRecordID);
	soap_default_string(soap, &a->entityTableName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addEntityToFolderByRecordID(struct soap *soap, const struct TT1__addEntityToFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
	soap_embedded(soap, &a->entityRecordID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->entityTableName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addEntityToFolderByRecordID(struct soap *soap, const struct TT1__addEntityToFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addEntityToFolderByRecordID);
	if (soap_out_TT1__addEntityToFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addEntityToFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__addEntityToFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addEntityToFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityRecordID", -1, &a->entityRecordID, ""))
		return soap->error;
	if (soap_out_string(soap, "entityTableName", -1, &a->entityTableName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordID * SOAP_FMAC4 soap_get_TT1__addEntityToFolderByRecordID(struct soap *soap, struct TT1__addEntityToFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addEntityToFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordID * SOAP_FMAC4 soap_in_TT1__addEntityToFolderByRecordID(struct soap *soap, const char *tag, struct TT1__addEntityToFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1, soap_flag_entityRecordID = 1, soap_flag_entityTableName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addEntityToFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addEntityToFolderByRecordID, sizeof(struct TT1__addEntityToFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addEntityToFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap_flag_entityRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityRecordID", &a->entityRecordID, "xsd:long"))
				{	soap_flag_entityRecordID--;
					continue;
				}
			if (soap_flag_entityTableName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entityTableName", &a->entityTableName, "xsd:string"))
				{	soap_flag_entityTableName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addEntityToFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addEntityToFolderByRecordID, 0, sizeof(struct TT1__addEntityToFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0 || soap_flag_entityRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addEntityToFolderByRecordID * SOAP_FMAC6 soap_new_TT1__addEntityToFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__addEntityToFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addEntityToFolderByRecordID(struct soap *soap, struct TT1__addEntityToFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__addEntityToFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addEntityToFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addEntityToFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addEntityToFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__addEntityToFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addEntityToFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addEntityToFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addEntityToFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addEntityToFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addEntityToFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__addEntityToFolderByRecordID*)p = *(struct TT1__addEntityToFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, struct TT1__addEntityToFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->itemRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, const struct TT1__addEntityToFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->itemRecordID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, const struct TT1__addEntityToFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse);
	if (soap_out_TT1__addEntityToFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__addEntityToFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "itemRecordID", -1, &a->itemRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, struct TT1__addEntityToFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addEntityToFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__addEntityToFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_itemRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addEntityToFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse, sizeof(struct TT1__addEntityToFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addEntityToFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "itemRecordID", &a->itemRecordID, "xsd:int"))
				{	soap_flag_itemRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addEntityToFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse, 0, sizeof(struct TT1__addEntityToFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_itemRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addEntityToFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addEntityToFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, struct TT1__addEntityToFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addEntityToFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addEntityToFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addEntityToFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addEntityToFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__addEntityToFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addEntityToFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addEntityToFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addEntityToFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addEntityToFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addEntityToFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__addEntityToFolderByRecordIDResponse*)p = *(struct TT1__addEntityToFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteFolderByRecordID(struct soap *soap, struct TT1__deleteFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteFolderByRecordID(struct soap *soap, const struct TT1__deleteFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteFolderByRecordID(struct soap *soap, const struct TT1__deleteFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteFolderByRecordID);
	if (soap_out_TT1__deleteFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordID * SOAP_FMAC4 soap_get_TT1__deleteFolderByRecordID(struct soap *soap, struct TT1__deleteFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordID * SOAP_FMAC4 soap_in_TT1__deleteFolderByRecordID(struct soap *soap, const char *tag, struct TT1__deleteFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteFolderByRecordID, sizeof(struct TT1__deleteFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteFolderByRecordID, 0, sizeof(struct TT1__deleteFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteFolderByRecordID * SOAP_FMAC6 soap_new_TT1__deleteFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteFolderByRecordID(struct soap *soap, struct TT1__deleteFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteFolderByRecordID*)p = *(struct TT1__deleteFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteFolderByRecordIDResponse(struct soap *soap, struct TT1__deleteFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteFolderByRecordIDResponse(struct soap *soap, const struct TT1__deleteFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteFolderByRecordIDResponse(struct soap *soap, const struct TT1__deleteFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteFolderByRecordIDResponse);
	if (soap_out_TT1__deleteFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteFolderByRecordIDResponse(struct soap *soap, struct TT1__deleteFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteFolderByRecordIDResponse, sizeof(struct TT1__deleteFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteFolderByRecordIDResponse, 0, sizeof(struct TT1__deleteFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteFolderByRecordIDResponse(struct soap *soap, struct TT1__deleteFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteFolderByRecordIDResponse*)p = *(struct TT1__deleteFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteFolder(struct soap *soap, struct TT1__deleteFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->folderPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteFolder(struct soap *soap, const struct TT1__deleteFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->folderPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteFolder(struct soap *soap, const struct TT1__deleteFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteFolder);
	if (soap_out_TT1__deleteFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteFolder(struct soap *soap, const char *tag, int id, const struct TT1__deleteFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "folderPath", -1, &a->folderPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteFolder * SOAP_FMAC4 soap_get_TT1__deleteFolder(struct soap *soap, struct TT1__deleteFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteFolder * SOAP_FMAC4 soap_in_TT1__deleteFolder(struct soap *soap, const char *tag, struct TT1__deleteFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_folderPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteFolder, sizeof(struct TT1__deleteFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_folderPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "folderPath", &a->folderPath, "xsd:string"))
				{	soap_flag_folderPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteFolder, 0, sizeof(struct TT1__deleteFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteFolder * SOAP_FMAC6 soap_new_TT1__deleteFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteFolder(struct soap *soap, struct TT1__deleteFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteFolder * SOAP_FMAC4 soap_instantiate_TT1__deleteFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteFolder;
		if (size)
			*size = sizeof(struct TT1__deleteFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteFolder %p -> %p\n", q, p));
	*(struct TT1__deleteFolder*)p = *(struct TT1__deleteFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteFolderResponse(struct soap *soap, struct TT1__deleteFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteFolderResponse(struct soap *soap, const struct TT1__deleteFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteFolderResponse(struct soap *soap, const struct TT1__deleteFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteFolderResponse);
	if (soap_out_TT1__deleteFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteFolderResponse * SOAP_FMAC4 soap_get_TT1__deleteFolderResponse(struct soap *soap, struct TT1__deleteFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteFolderResponse * SOAP_FMAC4 soap_in_TT1__deleteFolderResponse(struct soap *soap, const char *tag, struct TT1__deleteFolderResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteFolderResponse, sizeof(struct TT1__deleteFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteFolderResponse, 0, sizeof(struct TT1__deleteFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteFolderResponse * SOAP_FMAC6 soap_new_TT1__deleteFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteFolderResponse(struct soap *soap, struct TT1__deleteFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteFolderResponse;
		if (size)
			*size = sizeof(struct TT1__deleteFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteFolderResponse %p -> %p\n", q, p));
	*(struct TT1__deleteFolderResponse*)p = *(struct TT1__deleteFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolderByRecordID(struct soap *soap, struct TT1__getFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolderByRecordID(struct soap *soap, const struct TT1__getFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolderByRecordID(struct soap *soap, const struct TT1__getFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolderByRecordID);
	if (soap_out_TT1__getFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolderByRecordID * SOAP_FMAC4 soap_get_TT1__getFolderByRecordID(struct soap *soap, struct TT1__getFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolderByRecordID * SOAP_FMAC4 soap_in_TT1__getFolderByRecordID(struct soap *soap, const char *tag, struct TT1__getFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolderByRecordID, sizeof(struct TT1__getFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolderByRecordID, 0, sizeof(struct TT1__getFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolderByRecordID * SOAP_FMAC6 soap_new_TT1__getFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolderByRecordID(struct soap *soap, struct TT1__getFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__getFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__getFolderByRecordID*)p = *(struct TT1__getFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolderByRecordIDResponse(struct soap *soap, struct TT1__getFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolderByRecordIDResponse(struct soap *soap, const struct TT1__getFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolderByRecordIDResponse(struct soap *soap, const struct TT1__getFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolderByRecordIDResponse);
	if (soap_out_TT1__getFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getFolderByRecordIDResponse(struct soap *soap, struct TT1__getFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolderByRecordIDResponse, sizeof(struct TT1__getFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolderByRecordIDResponse, 0, sizeof(struct TT1__getFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolderByRecordIDResponse(struct soap *soap, struct TT1__getFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getFolderByRecordIDResponse*)p = *(struct TT1__getFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolder(struct soap *soap, struct TT1__getFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->path);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolder(struct soap *soap, const struct TT1__getFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->path);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolder(struct soap *soap, const struct TT1__getFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolder);
	if (soap_out_TT1__getFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolder(struct soap *soap, const char *tag, int id, const struct TT1__getFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "path", -1, &a->path, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolder * SOAP_FMAC4 soap_get_TT1__getFolder(struct soap *soap, struct TT1__getFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolder * SOAP_FMAC4 soap_in_TT1__getFolder(struct soap *soap, const char *tag, struct TT1__getFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_path = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolder, sizeof(struct TT1__getFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_path && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &a->path, "xsd:string"))
				{	soap_flag_path--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolder, 0, sizeof(struct TT1__getFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolder * SOAP_FMAC6 soap_new_TT1__getFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolder(struct soap *soap, struct TT1__getFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolder * SOAP_FMAC4 soap_instantiate_TT1__getFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolder;
		if (size)
			*size = sizeof(struct TT1__getFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolder %p -> %p\n", q, p));
	*(struct TT1__getFolder*)p = *(struct TT1__getFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFolderResponse(struct soap *soap, struct TT1__getFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFolderResponse(struct soap *soap, const struct TT1__getFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFolderResponse(struct soap *soap, const struct TT1__getFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFolderResponse);
	if (soap_out_TT1__getFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__getFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFolderResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFolderResponse * SOAP_FMAC4 soap_get_TT1__getFolderResponse(struct soap *soap, struct TT1__getFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFolderResponse * SOAP_FMAC4 soap_in_TT1__getFolderResponse(struct soap *soap, const char *tag, struct TT1__getFolderResponse *a, const char *type)
{
	short soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFolderResponse, sizeof(struct TT1__getFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFolderResponse, 0, sizeof(struct TT1__getFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFolderResponse * SOAP_FMAC6 soap_new_TT1__getFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFolderResponse(struct soap *soap, struct TT1__getFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__getFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFolderResponse;
		if (size)
			*size = sizeof(struct TT1__getFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFolderResponse %p -> %p\n", q, p));
	*(struct TT1__getFolderResponse*)p = *(struct TT1__getFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveFolder(struct soap *soap, struct TT1__cancelSaveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveFolder(struct soap *soap, const struct TT1__cancelSaveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveFolder(struct soap *soap, const struct TT1__cancelSaveFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveFolder);
	if (soap_out_TT1__cancelSaveFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveFolder(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveFolder * SOAP_FMAC4 soap_get_TT1__cancelSaveFolder(struct soap *soap, struct TT1__cancelSaveFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveFolder * SOAP_FMAC4 soap_in_TT1__cancelSaveFolder(struct soap *soap, const char *tag, struct TT1__cancelSaveFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveFolder, sizeof(struct TT1__cancelSaveFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveFolder, 0, sizeof(struct TT1__cancelSaveFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveFolder * SOAP_FMAC6 soap_new_TT1__cancelSaveFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveFolder(struct soap *soap, struct TT1__cancelSaveFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveFolder * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveFolder;
		if (size)
			*size = sizeof(struct TT1__cancelSaveFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveFolder %p -> %p\n", q, p));
	*(struct TT1__cancelSaveFolder*)p = *(struct TT1__cancelSaveFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveFolderResponse(struct soap *soap, struct TT1__cancelSaveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveFolderResponse(struct soap *soap, const struct TT1__cancelSaveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveFolderResponse(struct soap *soap, const struct TT1__cancelSaveFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveFolderResponse);
	if (soap_out_TT1__cancelSaveFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveFolderResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveFolderResponse(struct soap *soap, struct TT1__cancelSaveFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveFolderResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveFolderResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveFolderResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveFolderResponse, sizeof(struct TT1__cancelSaveFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveFolderResponse, 0, sizeof(struct TT1__cancelSaveFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveFolderResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveFolderResponse(struct soap *soap, struct TT1__cancelSaveFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveFolderResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveFolderResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveFolderResponse*)p = *(struct TT1__cancelSaveFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveFolder(struct soap *soap, struct TT1__saveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveFolder(struct soap *soap, const struct TT1__saveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveFolder(struct soap *soap, const struct TT1__saveFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveFolder);
	if (soap_out_TT1__saveFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveFolder(struct soap *soap, const char *tag, int id, const struct TT1__saveFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveFolder * SOAP_FMAC4 soap_get_TT1__saveFolder(struct soap *soap, struct TT1__saveFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveFolder * SOAP_FMAC4 soap_in_TT1__saveFolder(struct soap *soap, const char *tag, struct TT1__saveFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveFolder, sizeof(struct TT1__saveFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveFolder, 0, sizeof(struct TT1__saveFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveFolder * SOAP_FMAC6 soap_new_TT1__saveFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveFolder(struct soap *soap, struct TT1__saveFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveFolder * SOAP_FMAC4 soap_instantiate_TT1__saveFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveFolder;
		if (size)
			*size = sizeof(struct TT1__saveFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveFolder %p -> %p\n", q, p));
	*(struct TT1__saveFolder*)p = *(struct TT1__saveFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveFolderResponse(struct soap *soap, struct TT1__saveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveFolderResponse(struct soap *soap, const struct TT1__saveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveFolderResponse(struct soap *soap, const struct TT1__saveFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveFolderResponse);
	if (soap_out_TT1__saveFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveFolderResponse * SOAP_FMAC4 soap_get_TT1__saveFolderResponse(struct soap *soap, struct TT1__saveFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveFolderResponse * SOAP_FMAC4 soap_in_TT1__saveFolderResponse(struct soap *soap, const char *tag, struct TT1__saveFolderResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveFolderResponse, sizeof(struct TT1__saveFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveFolderResponse, 0, sizeof(struct TT1__saveFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveFolderResponse * SOAP_FMAC6 soap_new_TT1__saveFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveFolderResponse(struct soap *soap, struct TT1__saveFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__saveFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveFolderResponse;
		if (size)
			*size = sizeof(struct TT1__saveFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveFolderResponse %p -> %p\n", q, p));
	*(struct TT1__saveFolderResponse*)p = *(struct TT1__saveFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editFolderByRecordID(struct soap *soap, struct TT1__editFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editFolderByRecordID(struct soap *soap, const struct TT1__editFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editFolderByRecordID(struct soap *soap, const struct TT1__editFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editFolderByRecordID);
	if (soap_out_TT1__editFolderByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editFolderByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editFolderByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editFolderByRecordID * SOAP_FMAC4 soap_get_TT1__editFolderByRecordID(struct soap *soap, struct TT1__editFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editFolderByRecordID * SOAP_FMAC4 soap_in_TT1__editFolderByRecordID(struct soap *soap, const char *tag, struct TT1__editFolderByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editFolderByRecordID, sizeof(struct TT1__editFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editFolderByRecordID, 0, sizeof(struct TT1__editFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editFolderByRecordID * SOAP_FMAC6 soap_new_TT1__editFolderByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editFolderByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editFolderByRecordID(struct soap *soap, struct TT1__editFolderByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editFolderByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editFolderByRecordID;
		if (size)
			*size = sizeof(struct TT1__editFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editFolderByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editFolderByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editFolderByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editFolderByRecordID %p -> %p\n", q, p));
	*(struct TT1__editFolderByRecordID*)p = *(struct TT1__editFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editFolderByRecordIDResponse(struct soap *soap, struct TT1__editFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editFolderByRecordIDResponse(struct soap *soap, const struct TT1__editFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editFolderByRecordIDResponse(struct soap *soap, const struct TT1__editFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editFolderByRecordIDResponse);
	if (soap_out_TT1__editFolderByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editFolderByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editFolderByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editFolderByRecordIDResponse(struct soap *soap, struct TT1__editFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editFolderByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editFolderByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editFolderByRecordIDResponse *a, const char *type)
{
	short soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editFolderByRecordIDResponse, sizeof(struct TT1__editFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editFolderByRecordIDResponse, 0, sizeof(struct TT1__editFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editFolderByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editFolderByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editFolderByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editFolderByRecordIDResponse(struct soap *soap, struct TT1__editFolderByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editFolderByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editFolderByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editFolderByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editFolderByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editFolderByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editFolderByRecordIDResponse*)p = *(struct TT1__editFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editFolder(struct soap *soap, struct TT1__editFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->folderPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editFolder(struct soap *soap, const struct TT1__editFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->folderPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editFolder(struct soap *soap, const struct TT1__editFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editFolder);
	if (soap_out_TT1__editFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editFolder(struct soap *soap, const char *tag, int id, const struct TT1__editFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "folderPath", -1, &a->folderPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editFolder * SOAP_FMAC4 soap_get_TT1__editFolder(struct soap *soap, struct TT1__editFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editFolder * SOAP_FMAC4 soap_in_TT1__editFolder(struct soap *soap, const char *tag, struct TT1__editFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_folderPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editFolder, sizeof(struct TT1__editFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_folderPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "folderPath", &a->folderPath, "xsd:string"))
				{	soap_flag_folderPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editFolder, 0, sizeof(struct TT1__editFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editFolder * SOAP_FMAC6 soap_new_TT1__editFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__editFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editFolder(struct soap *soap, struct TT1__editFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editFolder * SOAP_FMAC4 soap_instantiate_TT1__editFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editFolder;
		if (size)
			*size = sizeof(struct TT1__editFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editFolder %p -> %p\n", q, p));
	*(struct TT1__editFolder*)p = *(struct TT1__editFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editFolderResponse(struct soap *soap, struct TT1__editFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editFolderResponse(struct soap *soap, const struct TT1__editFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editFolderResponse(struct soap *soap, const struct TT1__editFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editFolderResponse);
	if (soap_out_TT1__editFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__editFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editFolderResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editFolderResponse * SOAP_FMAC4 soap_get_TT1__editFolderResponse(struct soap *soap, struct TT1__editFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editFolderResponse * SOAP_FMAC4 soap_in_TT1__editFolderResponse(struct soap *soap, const char *tag, struct TT1__editFolderResponse *a, const char *type)
{
	short soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editFolderResponse, sizeof(struct TT1__editFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editFolderResponse, 0, sizeof(struct TT1__editFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editFolderResponse * SOAP_FMAC6 soap_new_TT1__editFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editFolderResponse(struct soap *soap, struct TT1__editFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__editFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editFolderResponse;
		if (size)
			*size = sizeof(struct TT1__editFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editFolderResponse %p -> %p\n", q, p));
	*(struct TT1__editFolderResponse*)p = *(struct TT1__editFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addFolder(struct soap *soap, struct TT1__addFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addFolder(struct soap *soap, const struct TT1__addFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CFolder(soap, &a->pFolder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addFolder(struct soap *soap, const struct TT1__addFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addFolder);
	if (soap_out_TT1__addFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addFolder(struct soap *soap, const char *tag, int id, const struct TT1__addFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addFolder * SOAP_FMAC4 soap_get_TT1__addFolder(struct soap *soap, struct TT1__addFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addFolder * SOAP_FMAC4 soap_in_TT1__addFolder(struct soap *soap, const char *tag, struct TT1__addFolder *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addFolder, sizeof(struct TT1__addFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFolder(soap, "pFolder", &a->pFolder, "TT1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addFolder, 0, sizeof(struct TT1__addFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addFolder * SOAP_FMAC6 soap_new_TT1__addFolder(struct soap *soap, int n)
{	return soap_instantiate_TT1__addFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addFolder(struct soap *soap, struct TT1__addFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addFolder * SOAP_FMAC4 soap_instantiate_TT1__addFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addFolder;
		if (size)
			*size = sizeof(struct TT1__addFolder);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addFolder[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addFolder);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addFolder*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addFolder %p -> %p\n", q, p));
	*(struct TT1__addFolder*)p = *(struct TT1__addFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addFolderResponse(struct soap *soap, struct TT1__addFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addFolderResponse(struct soap *soap, const struct TT1__addFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addFolderResponse(struct soap *soap, const struct TT1__addFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addFolderResponse);
	if (soap_out_TT1__addFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addFolderResponse(struct soap *soap, const char *tag, int id, const struct TT1__addFolderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addFolderResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addFolderResponse * SOAP_FMAC4 soap_get_TT1__addFolderResponse(struct soap *soap, struct TT1__addFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addFolderResponse * SOAP_FMAC4 soap_in_TT1__addFolderResponse(struct soap *soap, const char *tag, struct TT1__addFolderResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addFolderResponse, sizeof(struct TT1__addFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addFolderResponse, 0, sizeof(struct TT1__addFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addFolderResponse * SOAP_FMAC6 soap_new_TT1__addFolderResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addFolderResponse(struct soap *soap, struct TT1__addFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addFolderResponse * SOAP_FMAC4 soap_instantiate_TT1__addFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addFolderResponse;
		if (size)
			*size = sizeof(struct TT1__addFolderResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addFolderResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addFolderResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addFolderResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addFolderResponse %p -> %p\n", q, p));
	*(struct TT1__addFolderResponse*)p = *(struct TT1__addFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__generateTestRuns(struct soap *soap, struct TT1__generateTestRuns *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	a->testVariants = NULL;
	soap_default_string(soap, &a->testRunSet);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__generateTestRuns(struct soap *soap, const struct TT1__generateTestRuns *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1ArrayOfCTestRunVariantField(soap, &a->testVariants);
	soap_serialize_string(soap, &a->testRunSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__generateTestRuns(struct soap *soap, const struct TT1__generateTestRuns *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__generateTestRuns);
	if (soap_out_TT1__generateTestRuns(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__generateTestRuns(struct soap *soap, const char *tag, int id, const struct TT1__generateTestRuns *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__generateTestRuns), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTestRunVariantField(soap, "testVariants", -1, &a->testVariants, ""))
		return soap->error;
	if (soap_out_string(soap, "testRunSet", -1, &a->testRunSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__generateTestRuns * SOAP_FMAC4 soap_get_TT1__generateTestRuns(struct soap *soap, struct TT1__generateTestRuns *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__generateTestRuns(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__generateTestRuns * SOAP_FMAC4 soap_in_TT1__generateTestRuns(struct soap *soap, const char *tag, struct TT1__generateTestRuns *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_testVariants = 1, soap_flag_testRunSet = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__generateTestRuns *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__generateTestRuns, sizeof(struct TT1__generateTestRuns), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__generateTestRuns(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_testVariants && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTestRunVariantField(soap, "testVariants", &a->testVariants, "TT1:CTestRunVariantField"))
				{	soap_flag_testVariants--;
					continue;
				}
			if (soap_flag_testRunSet && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testRunSet", &a->testRunSet, "xsd:string"))
				{	soap_flag_testRunSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__generateTestRuns *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__generateTestRuns, 0, sizeof(struct TT1__generateTestRuns), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__generateTestRuns * SOAP_FMAC6 soap_new_TT1__generateTestRuns(struct soap *soap, int n)
{	return soap_instantiate_TT1__generateTestRuns(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__generateTestRuns(struct soap *soap, struct TT1__generateTestRuns *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__generateTestRuns * SOAP_FMAC4 soap_instantiate_TT1__generateTestRuns(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__generateTestRuns(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__generateTestRuns, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__generateTestRuns;
		if (size)
			*size = sizeof(struct TT1__generateTestRuns);
	}
	else
	{	cp->ptr = (void*)new struct TT1__generateTestRuns[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__generateTestRuns);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__generateTestRuns*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__generateTestRuns(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__generateTestRuns %p -> %p\n", q, p));
	*(struct TT1__generateTestRuns*)p = *(struct TT1__generateTestRuns*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__generateTestRunsResponse(struct soap *soap, struct TT1__generateTestRunsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__generateTestRunsResponse(struct soap *soap, const struct TT1__generateTestRunsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCItemToTrack(soap, &a->pResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__generateTestRunsResponse(struct soap *soap, const struct TT1__generateTestRunsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__generateTestRunsResponse);
	if (soap_out_TT1__generateTestRunsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__generateTestRunsResponse(struct soap *soap, const char *tag, int id, const struct TT1__generateTestRunsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__generateTestRunsResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCItemToTrack(soap, "pResults", -1, &a->pResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__generateTestRunsResponse * SOAP_FMAC4 soap_get_TT1__generateTestRunsResponse(struct soap *soap, struct TT1__generateTestRunsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__generateTestRunsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__generateTestRunsResponse * SOAP_FMAC4 soap_in_TT1__generateTestRunsResponse(struct soap *soap, const char *tag, struct TT1__generateTestRunsResponse *a, const char *type)
{
	short soap_flag_pResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__generateTestRunsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__generateTestRunsResponse, sizeof(struct TT1__generateTestRunsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__generateTestRunsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCItemToTrack(soap, "pResults", &a->pResults, "TT1:CItemToTrack"))
				{	soap_flag_pResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__generateTestRunsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__generateTestRunsResponse, 0, sizeof(struct TT1__generateTestRunsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__generateTestRunsResponse * SOAP_FMAC6 soap_new_TT1__generateTestRunsResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__generateTestRunsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__generateTestRunsResponse(struct soap *soap, struct TT1__generateTestRunsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__generateTestRunsResponse * SOAP_FMAC4 soap_instantiate_TT1__generateTestRunsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__generateTestRunsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__generateTestRunsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__generateTestRunsResponse;
		if (size)
			*size = sizeof(struct TT1__generateTestRunsResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__generateTestRunsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__generateTestRunsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__generateTestRunsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__generateTestRunsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__generateTestRunsResponse %p -> %p\n", q, p));
	*(struct TT1__generateTestRunsResponse*)p = *(struct TT1__generateTestRunsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__createDefectForTestRun(struct soap *soap, struct TT1__createDefectForTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__createDefectForTestRun(struct soap *soap, const struct TT1__createDefectForTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__createDefectForTestRun(struct soap *soap, const struct TT1__createDefectForTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__createDefectForTestRun);
	if (soap_out_TT1__createDefectForTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__createDefectForTestRun(struct soap *soap, const char *tag, int id, const struct TT1__createDefectForTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__createDefectForTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__createDefectForTestRun * SOAP_FMAC4 soap_get_TT1__createDefectForTestRun(struct soap *soap, struct TT1__createDefectForTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__createDefectForTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__createDefectForTestRun * SOAP_FMAC4 soap_in_TT1__createDefectForTestRun(struct soap *soap, const char *tag, struct TT1__createDefectForTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__createDefectForTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__createDefectForTestRun, sizeof(struct TT1__createDefectForTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__createDefectForTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__createDefectForTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__createDefectForTestRun, 0, sizeof(struct TT1__createDefectForTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__createDefectForTestRun * SOAP_FMAC6 soap_new_TT1__createDefectForTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__createDefectForTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__createDefectForTestRun(struct soap *soap, struct TT1__createDefectForTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__createDefectForTestRun * SOAP_FMAC4 soap_instantiate_TT1__createDefectForTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__createDefectForTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__createDefectForTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__createDefectForTestRun;
		if (size)
			*size = sizeof(struct TT1__createDefectForTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__createDefectForTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__createDefectForTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__createDefectForTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__createDefectForTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__createDefectForTestRun %p -> %p\n", q, p));
	*(struct TT1__createDefectForTestRun*)p = *(struct TT1__createDefectForTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__createDefectForTestRunResponse(struct soap *soap, struct TT1__createDefectForTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__createDefectForTestRunResponse(struct soap *soap, const struct TT1__createDefectForTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__createDefectForTestRunResponse(struct soap *soap, const struct TT1__createDefectForTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__createDefectForTestRunResponse);
	if (soap_out_TT1__createDefectForTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__createDefectForTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__createDefectForTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__createDefectForTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__createDefectForTestRunResponse * SOAP_FMAC4 soap_get_TT1__createDefectForTestRunResponse(struct soap *soap, struct TT1__createDefectForTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__createDefectForTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__createDefectForTestRunResponse * SOAP_FMAC4 soap_in_TT1__createDefectForTestRunResponse(struct soap *soap, const char *tag, struct TT1__createDefectForTestRunResponse *a, const char *type)
{
	short soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__createDefectForTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__createDefectForTestRunResponse, sizeof(struct TT1__createDefectForTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__createDefectForTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__createDefectForTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__createDefectForTestRunResponse, 0, sizeof(struct TT1__createDefectForTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__createDefectForTestRunResponse * SOAP_FMAC6 soap_new_TT1__createDefectForTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__createDefectForTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__createDefectForTestRunResponse(struct soap *soap, struct TT1__createDefectForTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__createDefectForTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__createDefectForTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__createDefectForTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__createDefectForTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__createDefectForTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__createDefectForTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__createDefectForTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__createDefectForTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__createDefectForTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__createDefectForTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__createDefectForTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__createDefectForTestRunResponse*)p = *(struct TT1__createDefectForTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestRun(struct soap *soap, struct TT1__cancelSaveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestRun(struct soap *soap, const struct TT1__cancelSaveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestRun(struct soap *soap, const struct TT1__cancelSaveTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestRun);
	if (soap_out_TT1__cancelSaveTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestRun(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestRun * SOAP_FMAC4 soap_get_TT1__cancelSaveTestRun(struct soap *soap, struct TT1__cancelSaveTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestRun * SOAP_FMAC4 soap_in_TT1__cancelSaveTestRun(struct soap *soap, const char *tag, struct TT1__cancelSaveTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestRun, sizeof(struct TT1__cancelSaveTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestRun, 0, sizeof(struct TT1__cancelSaveTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestRun * SOAP_FMAC6 soap_new_TT1__cancelSaveTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestRun(struct soap *soap, struct TT1__cancelSaveTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestRun * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestRun;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestRun %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestRun*)p = *(struct TT1__cancelSaveTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestRunResponse(struct soap *soap, struct TT1__cancelSaveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestRunResponse(struct soap *soap, const struct TT1__cancelSaveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestRunResponse(struct soap *soap, const struct TT1__cancelSaveTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestRunResponse);
	if (soap_out_TT1__cancelSaveTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestRunResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveTestRunResponse(struct soap *soap, struct TT1__cancelSaveTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestRunResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveTestRunResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveTestRunResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestRunResponse, sizeof(struct TT1__cancelSaveTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestRunResponse, 0, sizeof(struct TT1__cancelSaveTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestRunResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestRunResponse(struct soap *soap, struct TT1__cancelSaveTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestRunResponse*)p = *(struct TT1__cancelSaveTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestRun(struct soap *soap, struct TT1__saveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestRun(struct soap *soap, const struct TT1__saveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CTestRun(soap, &a->pTestRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestRun(struct soap *soap, const struct TT1__saveTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestRun);
	if (soap_out_TT1__saveTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestRun(struct soap *soap, const char *tag, int id, const struct TT1__saveTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestRun * SOAP_FMAC4 soap_get_TT1__saveTestRun(struct soap *soap, struct TT1__saveTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestRun * SOAP_FMAC4 soap_in_TT1__saveTestRun(struct soap *soap, const char *tag, struct TT1__saveTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestRun, sizeof(struct TT1__saveTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestRun(soap, "pTestRun", &a->pTestRun, "TT1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestRun, 0, sizeof(struct TT1__saveTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestRun * SOAP_FMAC6 soap_new_TT1__saveTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestRun(struct soap *soap, struct TT1__saveTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestRun * SOAP_FMAC4 soap_instantiate_TT1__saveTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestRun;
		if (size)
			*size = sizeof(struct TT1__saveTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestRun %p -> %p\n", q, p));
	*(struct TT1__saveTestRun*)p = *(struct TT1__saveTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestRunResponse(struct soap *soap, struct TT1__saveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestRunResponse(struct soap *soap, const struct TT1__saveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestRunResponse(struct soap *soap, const struct TT1__saveTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestRunResponse);
	if (soap_out_TT1__saveTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestRunResponse * SOAP_FMAC4 soap_get_TT1__saveTestRunResponse(struct soap *soap, struct TT1__saveTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestRunResponse * SOAP_FMAC4 soap_in_TT1__saveTestRunResponse(struct soap *soap, const char *tag, struct TT1__saveTestRunResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestRunResponse, sizeof(struct TT1__saveTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestRunResponse, 0, sizeof(struct TT1__saveTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestRunResponse * SOAP_FMAC6 soap_new_TT1__saveTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestRunResponse(struct soap *soap, struct TT1__saveTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__saveTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__saveTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__saveTestRunResponse*)p = *(struct TT1__saveTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestRunByRecordID(struct soap *soap, struct TT1__editTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestRunByRecordID(struct soap *soap, const struct TT1__editTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestRunByRecordID(struct soap *soap, const struct TT1__editTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestRunByRecordID);
	if (soap_out_TT1__editTestRunByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editTestRunByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestRunByRecordID * SOAP_FMAC4 soap_get_TT1__editTestRunByRecordID(struct soap *soap, struct TT1__editTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestRunByRecordID * SOAP_FMAC4 soap_in_TT1__editTestRunByRecordID(struct soap *soap, const char *tag, struct TT1__editTestRunByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestRunByRecordID, sizeof(struct TT1__editTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestRunByRecordID, 0, sizeof(struct TT1__editTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestRunByRecordID * SOAP_FMAC6 soap_new_TT1__editTestRunByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestRunByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestRunByRecordID(struct soap *soap, struct TT1__editTestRunByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestRunByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestRunByRecordID;
		if (size)
			*size = sizeof(struct TT1__editTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestRunByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestRunByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestRunByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestRunByRecordID %p -> %p\n", q, p));
	*(struct TT1__editTestRunByRecordID*)p = *(struct TT1__editTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestRunByRecordIDResponse(struct soap *soap, struct TT1__editTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestRunByRecordIDResponse(struct soap *soap, const struct TT1__editTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestRun(soap, &a->pTestRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestRunByRecordIDResponse(struct soap *soap, const struct TT1__editTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestRunByRecordIDResponse);
	if (soap_out_TT1__editTestRunByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestRunByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editTestRunByRecordIDResponse(struct soap *soap, struct TT1__editTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editTestRunByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestRunByRecordIDResponse, sizeof(struct TT1__editTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestRun(soap, "pTestRun", &a->pTestRun, "TT1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestRunByRecordIDResponse, 0, sizeof(struct TT1__editTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestRunByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editTestRunByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestRunByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestRunByRecordIDResponse(struct soap *soap, struct TT1__editTestRunByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestRunByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestRunByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestRunByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestRunByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestRunByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editTestRunByRecordIDResponse*)p = *(struct TT1__editTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestRun(struct soap *soap, struct TT1__editTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestRun(struct soap *soap, const struct TT1__editTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestRun(struct soap *soap, const struct TT1__editTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestRun);
	if (soap_out_TT1__editTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestRun(struct soap *soap, const char *tag, int id, const struct TT1__editTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestRun * SOAP_FMAC4 soap_get_TT1__editTestRun(struct soap *soap, struct TT1__editTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestRun * SOAP_FMAC4 soap_in_TT1__editTestRun(struct soap *soap, const char *tag, struct TT1__editTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testRunNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestRun, sizeof(struct TT1__editTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestRun, 0, sizeof(struct TT1__editTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestRun * SOAP_FMAC6 soap_new_TT1__editTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestRun(struct soap *soap, struct TT1__editTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestRun * SOAP_FMAC4 soap_instantiate_TT1__editTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestRun;
		if (size)
			*size = sizeof(struct TT1__editTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestRun %p -> %p\n", q, p));
	*(struct TT1__editTestRun*)p = *(struct TT1__editTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestRunResponse(struct soap *soap, struct TT1__editTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestRunResponse(struct soap *soap, const struct TT1__editTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestRun(soap, &a->pTestRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestRunResponse(struct soap *soap, const struct TT1__editTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestRunResponse);
	if (soap_out_TT1__editTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestRunResponse * SOAP_FMAC4 soap_get_TT1__editTestRunResponse(struct soap *soap, struct TT1__editTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestRunResponse * SOAP_FMAC4 soap_in_TT1__editTestRunResponse(struct soap *soap, const char *tag, struct TT1__editTestRunResponse *a, const char *type)
{
	short soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestRunResponse, sizeof(struct TT1__editTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestRun(soap, "pTestRun", &a->pTestRun, "TT1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestRunResponse, 0, sizeof(struct TT1__editTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestRunResponse * SOAP_FMAC6 soap_new_TT1__editTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestRunResponse(struct soap *soap, struct TT1__editTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__editTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__editTestRunResponse*)p = *(struct TT1__editTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestRunByRecordID(struct soap *soap, struct TT1__deleteTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestRunByRecordID(struct soap *soap, const struct TT1__deleteTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestRunByRecordID(struct soap *soap, const struct TT1__deleteTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestRunByRecordID);
	if (soap_out_TT1__deleteTestRunByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestRunByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordID * SOAP_FMAC4 soap_get_TT1__deleteTestRunByRecordID(struct soap *soap, struct TT1__deleteTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordID * SOAP_FMAC4 soap_in_TT1__deleteTestRunByRecordID(struct soap *soap, const char *tag, struct TT1__deleteTestRunByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestRunByRecordID, sizeof(struct TT1__deleteTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestRunByRecordID, 0, sizeof(struct TT1__deleteTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestRunByRecordID * SOAP_FMAC6 soap_new_TT1__deleteTestRunByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestRunByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestRunByRecordID(struct soap *soap, struct TT1__deleteTestRunByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestRunByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestRunByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestRunByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestRunByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestRunByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteTestRunByRecordID*)p = *(struct TT1__deleteTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, struct TT1__deleteTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse);
	if (soap_out_TT1__deleteTestRunByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestRunByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, struct TT1__deleteTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteTestRunByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse, sizeof(struct TT1__deleteTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse, 0, sizeof(struct TT1__deleteTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestRunByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestRunByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, struct TT1__deleteTestRunByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestRunByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestRunByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestRunByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestRunByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestRunByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestRunByRecordIDResponse*)p = *(struct TT1__deleteTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestRun(struct soap *soap, struct TT1__deleteTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestRun(struct soap *soap, const struct TT1__deleteTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestRun(struct soap *soap, const struct TT1__deleteTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestRun);
	if (soap_out_TT1__deleteTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestRun(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestRun * SOAP_FMAC4 soap_get_TT1__deleteTestRun(struct soap *soap, struct TT1__deleteTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestRun * SOAP_FMAC4 soap_in_TT1__deleteTestRun(struct soap *soap, const char *tag, struct TT1__deleteTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testRunNumber = 1, soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestRun, sizeof(struct TT1__deleteTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestRun, 0, sizeof(struct TT1__deleteTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestRun * SOAP_FMAC6 soap_new_TT1__deleteTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestRun(struct soap *soap, struct TT1__deleteTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestRun * SOAP_FMAC4 soap_instantiate_TT1__deleteTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestRun;
		if (size)
			*size = sizeof(struct TT1__deleteTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestRun %p -> %p\n", q, p));
	*(struct TT1__deleteTestRun*)p = *(struct TT1__deleteTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestRunResponse(struct soap *soap, struct TT1__deleteTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestRunResponse(struct soap *soap, const struct TT1__deleteTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestRunResponse(struct soap *soap, const struct TT1__deleteTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestRunResponse);
	if (soap_out_TT1__deleteTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestRunResponse * SOAP_FMAC4 soap_get_TT1__deleteTestRunResponse(struct soap *soap, struct TT1__deleteTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestRunResponse * SOAP_FMAC4 soap_in_TT1__deleteTestRunResponse(struct soap *soap, const char *tag, struct TT1__deleteTestRunResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestRunResponse, sizeof(struct TT1__deleteTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestRunResponse, 0, sizeof(struct TT1__deleteTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestRunResponse * SOAP_FMAC6 soap_new_TT1__deleteTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestRunResponse(struct soap *soap, struct TT1__deleteTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestRunResponse*)p = *(struct TT1__deleteTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRunByRecordID(struct soap *soap, struct TT1__getTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRunByRecordID(struct soap *soap, const struct TT1__getTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRunByRecordID(struct soap *soap, const struct TT1__getTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRunByRecordID);
	if (soap_out_TT1__getTestRunByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getTestRunByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRunByRecordID * SOAP_FMAC4 soap_get_TT1__getTestRunByRecordID(struct soap *soap, struct TT1__getTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRunByRecordID * SOAP_FMAC4 soap_in_TT1__getTestRunByRecordID(struct soap *soap, const char *tag, struct TT1__getTestRunByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRunByRecordID, sizeof(struct TT1__getTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRunByRecordID, 0, sizeof(struct TT1__getTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRunByRecordID * SOAP_FMAC6 soap_new_TT1__getTestRunByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRunByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRunByRecordID(struct soap *soap, struct TT1__getTestRunByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRunByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRunByRecordID;
		if (size)
			*size = sizeof(struct TT1__getTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRunByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRunByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRunByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRunByRecordID %p -> %p\n", q, p));
	*(struct TT1__getTestRunByRecordID*)p = *(struct TT1__getTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRunByRecordIDResponse(struct soap *soap, struct TT1__getTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRunByRecordIDResponse(struct soap *soap, const struct TT1__getTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestRun(soap, &a->pTestRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRunByRecordIDResponse(struct soap *soap, const struct TT1__getTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRunByRecordIDResponse);
	if (soap_out_TT1__getTestRunByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestRunByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getTestRunByRecordIDResponse(struct soap *soap, struct TT1__getTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getTestRunByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRunByRecordIDResponse, sizeof(struct TT1__getTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestRun(soap, "pTestRun", &a->pTestRun, "TT1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRunByRecordIDResponse, 0, sizeof(struct TT1__getTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRunByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getTestRunByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRunByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRunByRecordIDResponse(struct soap *soap, struct TT1__getTestRunByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRunByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRunByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRunByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRunByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRunByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getTestRunByRecordIDResponse*)p = *(struct TT1__getTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRun(struct soap *soap, struct TT1__getTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRun(struct soap *soap, const struct TT1__getTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRun(struct soap *soap, const struct TT1__getTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRun);
	if (soap_out_TT1__getTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRun(struct soap *soap, const char *tag, int id, const struct TT1__getTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRun * SOAP_FMAC4 soap_get_TT1__getTestRun(struct soap *soap, struct TT1__getTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRun * SOAP_FMAC4 soap_in_TT1__getTestRun(struct soap *soap, const char *tag, struct TT1__getTestRun *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testRunNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRun, sizeof(struct TT1__getTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRun, 0, sizeof(struct TT1__getTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRun * SOAP_FMAC6 soap_new_TT1__getTestRun(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRun(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRun(struct soap *soap, struct TT1__getTestRun *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRun * SOAP_FMAC4 soap_instantiate_TT1__getTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRun;
		if (size)
			*size = sizeof(struct TT1__getTestRun);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRun[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRun);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRun*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRun %p -> %p\n", q, p));
	*(struct TT1__getTestRun*)p = *(struct TT1__getTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRunResponse(struct soap *soap, struct TT1__getTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRunResponse(struct soap *soap, const struct TT1__getTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestRun(soap, &a->pTestRun);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRunResponse(struct soap *soap, const struct TT1__getTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRunResponse);
	if (soap_out_TT1__getTestRunResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRunResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestRunResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRunResponse * SOAP_FMAC4 soap_get_TT1__getTestRunResponse(struct soap *soap, struct TT1__getTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRunResponse * SOAP_FMAC4 soap_in_TT1__getTestRunResponse(struct soap *soap, const char *tag, struct TT1__getTestRunResponse *a, const char *type)
{
	short soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRunResponse, sizeof(struct TT1__getTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestRun(soap, "pTestRun", &a->pTestRun, "TT1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRunResponse, 0, sizeof(struct TT1__getTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRunResponse * SOAP_FMAC6 soap_new_TT1__getTestRunResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRunResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRunResponse(struct soap *soap, struct TT1__getTestRunResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRunResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRunResponse;
		if (size)
			*size = sizeof(struct TT1__getTestRunResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRunResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRunResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRunResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRunResponse %p -> %p\n", q, p));
	*(struct TT1__getTestRunResponse*)p = *(struct TT1__getTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestCase(struct soap *soap, struct TT1__cancelSaveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestCase(struct soap *soap, const struct TT1__cancelSaveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestCase(struct soap *soap, const struct TT1__cancelSaveTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestCase);
	if (soap_out_TT1__cancelSaveTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestCase(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestCase * SOAP_FMAC4 soap_get_TT1__cancelSaveTestCase(struct soap *soap, struct TT1__cancelSaveTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestCase * SOAP_FMAC4 soap_in_TT1__cancelSaveTestCase(struct soap *soap, const char *tag, struct TT1__cancelSaveTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestCase, sizeof(struct TT1__cancelSaveTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestCase, 0, sizeof(struct TT1__cancelSaveTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestCase * SOAP_FMAC6 soap_new_TT1__cancelSaveTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestCase(struct soap *soap, struct TT1__cancelSaveTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestCase * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestCase;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestCase %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestCase*)p = *(struct TT1__cancelSaveTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestCaseResponse(struct soap *soap, struct TT1__cancelSaveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestCaseResponse(struct soap *soap, const struct TT1__cancelSaveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestCaseResponse(struct soap *soap, const struct TT1__cancelSaveTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestCaseResponse);
	if (soap_out_TT1__cancelSaveTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestCaseResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveTestCaseResponse(struct soap *soap, struct TT1__cancelSaveTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestCaseResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveTestCaseResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveTestCaseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestCaseResponse, sizeof(struct TT1__cancelSaveTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestCaseResponse, 0, sizeof(struct TT1__cancelSaveTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestCaseResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestCaseResponse(struct soap *soap, struct TT1__cancelSaveTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestCaseResponse*)p = *(struct TT1__cancelSaveTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestCase(struct soap *soap, struct TT1__saveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestCase(struct soap *soap, const struct TT1__saveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestCase(struct soap *soap, const struct TT1__saveTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestCase);
	if (soap_out_TT1__saveTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestCase(struct soap *soap, const char *tag, int id, const struct TT1__saveTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestCase * SOAP_FMAC4 soap_get_TT1__saveTestCase(struct soap *soap, struct TT1__saveTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestCase * SOAP_FMAC4 soap_in_TT1__saveTestCase(struct soap *soap, const char *tag, struct TT1__saveTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestCase, sizeof(struct TT1__saveTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestCase, 0, sizeof(struct TT1__saveTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestCase * SOAP_FMAC6 soap_new_TT1__saveTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestCase(struct soap *soap, struct TT1__saveTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestCase * SOAP_FMAC4 soap_instantiate_TT1__saveTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestCase;
		if (size)
			*size = sizeof(struct TT1__saveTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestCase %p -> %p\n", q, p));
	*(struct TT1__saveTestCase*)p = *(struct TT1__saveTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestCaseResponse(struct soap *soap, struct TT1__saveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestCaseResponse(struct soap *soap, const struct TT1__saveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestCaseResponse(struct soap *soap, const struct TT1__saveTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestCaseResponse);
	if (soap_out_TT1__saveTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestCaseResponse * SOAP_FMAC4 soap_get_TT1__saveTestCaseResponse(struct soap *soap, struct TT1__saveTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestCaseResponse * SOAP_FMAC4 soap_in_TT1__saveTestCaseResponse(struct soap *soap, const char *tag, struct TT1__saveTestCaseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestCaseResponse, sizeof(struct TT1__saveTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestCaseResponse, 0, sizeof(struct TT1__saveTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestCaseResponse * SOAP_FMAC6 soap_new_TT1__saveTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestCaseResponse(struct soap *soap, struct TT1__saveTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__saveTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__saveTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__saveTestCaseResponse*)p = *(struct TT1__saveTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestCaseByRecordID(struct soap *soap, struct TT1__editTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestCaseByRecordID(struct soap *soap, const struct TT1__editTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestCaseByRecordID(struct soap *soap, const struct TT1__editTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestCaseByRecordID);
	if (soap_out_TT1__editTestCaseByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editTestCaseByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordID * SOAP_FMAC4 soap_get_TT1__editTestCaseByRecordID(struct soap *soap, struct TT1__editTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordID * SOAP_FMAC4 soap_in_TT1__editTestCaseByRecordID(struct soap *soap, const char *tag, struct TT1__editTestCaseByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestCaseByRecordID, sizeof(struct TT1__editTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestCaseByRecordID, 0, sizeof(struct TT1__editTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestCaseByRecordID * SOAP_FMAC6 soap_new_TT1__editTestCaseByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestCaseByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestCaseByRecordID(struct soap *soap, struct TT1__editTestCaseByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestCaseByRecordID;
		if (size)
			*size = sizeof(struct TT1__editTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestCaseByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestCaseByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestCaseByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestCaseByRecordID %p -> %p\n", q, p));
	*(struct TT1__editTestCaseByRecordID*)p = *(struct TT1__editTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestCaseByRecordIDResponse(struct soap *soap, struct TT1__editTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__editTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__editTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestCaseByRecordIDResponse);
	if (soap_out_TT1__editTestCaseByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestCaseByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editTestCaseByRecordIDResponse(struct soap *soap, struct TT1__editTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editTestCaseByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestCaseByRecordIDResponse, sizeof(struct TT1__editTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestCaseByRecordIDResponse, 0, sizeof(struct TT1__editTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestCaseByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editTestCaseByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestCaseByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestCaseByRecordIDResponse(struct soap *soap, struct TT1__editTestCaseByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestCaseByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestCaseByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestCaseByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestCaseByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestCaseByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editTestCaseByRecordIDResponse*)p = *(struct TT1__editTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestCase(struct soap *soap, struct TT1__editTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestCase(struct soap *soap, const struct TT1__editTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestCase(struct soap *soap, const struct TT1__editTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestCase);
	if (soap_out_TT1__editTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestCase(struct soap *soap, const char *tag, int id, const struct TT1__editTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestCase * SOAP_FMAC4 soap_get_TT1__editTestCase(struct soap *soap, struct TT1__editTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestCase * SOAP_FMAC4 soap_in_TT1__editTestCase(struct soap *soap, const char *tag, struct TT1__editTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testCaseNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestCase, sizeof(struct TT1__editTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestCase, 0, sizeof(struct TT1__editTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestCase * SOAP_FMAC6 soap_new_TT1__editTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestCase(struct soap *soap, struct TT1__editTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestCase * SOAP_FMAC4 soap_instantiate_TT1__editTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestCase;
		if (size)
			*size = sizeof(struct TT1__editTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestCase %p -> %p\n", q, p));
	*(struct TT1__editTestCase*)p = *(struct TT1__editTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestCaseResponse(struct soap *soap, struct TT1__editTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestCaseResponse(struct soap *soap, const struct TT1__editTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestCaseResponse(struct soap *soap, const struct TT1__editTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestCaseResponse);
	if (soap_out_TT1__editTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestCaseResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestCaseResponse * SOAP_FMAC4 soap_get_TT1__editTestCaseResponse(struct soap *soap, struct TT1__editTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestCaseResponse * SOAP_FMAC4 soap_in_TT1__editTestCaseResponse(struct soap *soap, const char *tag, struct TT1__editTestCaseResponse *a, const char *type)
{
	short soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestCaseResponse, sizeof(struct TT1__editTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestCaseResponse, 0, sizeof(struct TT1__editTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestCaseResponse * SOAP_FMAC6 soap_new_TT1__editTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestCaseResponse(struct soap *soap, struct TT1__editTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__editTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__editTestCaseResponse*)p = *(struct TT1__editTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestCaseByRecordID(struct soap *soap, struct TT1__deleteTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDeleteAssociatedTestRun);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestCaseByRecordID(struct soap *soap, const struct TT1__deleteTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDeleteAssociatedTestRun, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestCaseByRecordID(struct soap *soap, const struct TT1__deleteTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestCaseByRecordID);
	if (soap_out_TT1__deleteTestCaseByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestCaseByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedTestRun", -1, &a->bDeleteAssociatedTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordID * SOAP_FMAC4 soap_get_TT1__deleteTestCaseByRecordID(struct soap *soap, struct TT1__deleteTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordID * SOAP_FMAC4 soap_in_TT1__deleteTestCaseByRecordID(struct soap *soap, const char *tag, struct TT1__deleteTestCaseByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDeleteAssociatedTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestCaseByRecordID, sizeof(struct TT1__deleteTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedTestRun", &a->bDeleteAssociatedTestRun, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestCaseByRecordID, 0, sizeof(struct TT1__deleteTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDeleteAssociatedTestRun > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestCaseByRecordID * SOAP_FMAC6 soap_new_TT1__deleteTestCaseByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestCaseByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestCaseByRecordID(struct soap *soap, struct TT1__deleteTestCaseByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestCaseByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestCaseByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestCaseByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteTestCaseByRecordID*)p = *(struct TT1__deleteTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, struct TT1__deleteTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse);
	if (soap_out_TT1__deleteTestCaseByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestCaseByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, struct TT1__deleteTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteTestCaseByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse, sizeof(struct TT1__deleteTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse, 0, sizeof(struct TT1__deleteTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestCaseByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestCaseByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, struct TT1__deleteTestCaseByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestCaseByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestCaseByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestCaseByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestCaseByRecordIDResponse*)p = *(struct TT1__deleteTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestCase(struct soap *soap, struct TT1__deleteTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDeleteAssociatedTestRuns);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestCase(struct soap *soap, const struct TT1__deleteTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDeleteAssociatedTestRuns, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestCase(struct soap *soap, const struct TT1__deleteTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestCase);
	if (soap_out_TT1__deleteTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestCase(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedTestRuns", -1, &a->bDeleteAssociatedTestRuns, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestCase * SOAP_FMAC4 soap_get_TT1__deleteTestCase(struct soap *soap, struct TT1__deleteTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestCase * SOAP_FMAC4 soap_in_TT1__deleteTestCase(struct soap *soap, const char *tag, struct TT1__deleteTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testCaseNumber = 1, soap_flag_summary = 1, soap_flag_bDeleteAssociatedTestRuns = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestCase, sizeof(struct TT1__deleteTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedTestRuns && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedTestRuns", &a->bDeleteAssociatedTestRuns, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedTestRuns--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestCase, 0, sizeof(struct TT1__deleteTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDeleteAssociatedTestRuns > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestCase * SOAP_FMAC6 soap_new_TT1__deleteTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestCase(struct soap *soap, struct TT1__deleteTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestCase * SOAP_FMAC4 soap_instantiate_TT1__deleteTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestCase;
		if (size)
			*size = sizeof(struct TT1__deleteTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestCase %p -> %p\n", q, p));
	*(struct TT1__deleteTestCase*)p = *(struct TT1__deleteTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestCaseResponse(struct soap *soap, struct TT1__deleteTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestCaseResponse(struct soap *soap, const struct TT1__deleteTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestCaseResponse(struct soap *soap, const struct TT1__deleteTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestCaseResponse);
	if (soap_out_TT1__deleteTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestCaseResponse * SOAP_FMAC4 soap_get_TT1__deleteTestCaseResponse(struct soap *soap, struct TT1__deleteTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestCaseResponse * SOAP_FMAC4 soap_in_TT1__deleteTestCaseResponse(struct soap *soap, const char *tag, struct TT1__deleteTestCaseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestCaseResponse, sizeof(struct TT1__deleteTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestCaseResponse, 0, sizeof(struct TT1__deleteTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestCaseResponse * SOAP_FMAC6 soap_new_TT1__deleteTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestCaseResponse(struct soap *soap, struct TT1__deleteTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestCaseResponse*)p = *(struct TT1__deleteTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTestCase(struct soap *soap, struct TT1__addTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTestCase(struct soap *soap, const struct TT1__addTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTestCase(struct soap *soap, const struct TT1__addTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTestCase);
	if (soap_out_TT1__addTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTestCase(struct soap *soap, const char *tag, int id, const struct TT1__addTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTestCase * SOAP_FMAC4 soap_get_TT1__addTestCase(struct soap *soap, struct TT1__addTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTestCase * SOAP_FMAC4 soap_in_TT1__addTestCase(struct soap *soap, const char *tag, struct TT1__addTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTestCase, sizeof(struct TT1__addTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTestCase, 0, sizeof(struct TT1__addTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTestCase * SOAP_FMAC6 soap_new_TT1__addTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTestCase(struct soap *soap, struct TT1__addTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTestCase * SOAP_FMAC4 soap_instantiate_TT1__addTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTestCase;
		if (size)
			*size = sizeof(struct TT1__addTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTestCase %p -> %p\n", q, p));
	*(struct TT1__addTestCase*)p = *(struct TT1__addTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTestCaseResponse(struct soap *soap, struct TT1__addTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTestCaseResponse(struct soap *soap, const struct TT1__addTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTestCaseResponse(struct soap *soap, const struct TT1__addTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTestCaseResponse);
	if (soap_out_TT1__addTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__addTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTestCaseResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTestCaseResponse * SOAP_FMAC4 soap_get_TT1__addTestCaseResponse(struct soap *soap, struct TT1__addTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTestCaseResponse * SOAP_FMAC4 soap_in_TT1__addTestCaseResponse(struct soap *soap, const char *tag, struct TT1__addTestCaseResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTestCaseResponse, sizeof(struct TT1__addTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTestCaseResponse, 0, sizeof(struct TT1__addTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTestCaseResponse * SOAP_FMAC6 soap_new_TT1__addTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTestCaseResponse(struct soap *soap, struct TT1__addTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__addTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__addTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__addTestCaseResponse*)p = *(struct TT1__addTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestCaseByRecordID(struct soap *soap, struct TT1__getTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestCaseByRecordID(struct soap *soap, const struct TT1__getTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestCaseByRecordID(struct soap *soap, const struct TT1__getTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestCaseByRecordID);
	if (soap_out_TT1__getTestCaseByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getTestCaseByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordID * SOAP_FMAC4 soap_get_TT1__getTestCaseByRecordID(struct soap *soap, struct TT1__getTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordID * SOAP_FMAC4 soap_in_TT1__getTestCaseByRecordID(struct soap *soap, const char *tag, struct TT1__getTestCaseByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestCaseByRecordID, sizeof(struct TT1__getTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestCaseByRecordID, 0, sizeof(struct TT1__getTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestCaseByRecordID * SOAP_FMAC6 soap_new_TT1__getTestCaseByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestCaseByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestCaseByRecordID(struct soap *soap, struct TT1__getTestCaseByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestCaseByRecordID;
		if (size)
			*size = sizeof(struct TT1__getTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestCaseByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestCaseByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestCaseByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestCaseByRecordID %p -> %p\n", q, p));
	*(struct TT1__getTestCaseByRecordID*)p = *(struct TT1__getTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestCaseByRecordIDResponse(struct soap *soap, struct TT1__getTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__getTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestCaseByRecordIDResponse(struct soap *soap, const struct TT1__getTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestCaseByRecordIDResponse);
	if (soap_out_TT1__getTestCaseByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestCaseByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getTestCaseByRecordIDResponse(struct soap *soap, struct TT1__getTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getTestCaseByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestCaseByRecordIDResponse, sizeof(struct TT1__getTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestCaseByRecordIDResponse, 0, sizeof(struct TT1__getTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestCaseByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getTestCaseByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestCaseByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestCaseByRecordIDResponse(struct soap *soap, struct TT1__getTestCaseByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestCaseByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestCaseByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestCaseByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestCaseByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestCaseByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getTestCaseByRecordIDResponse*)p = *(struct TT1__getTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestCase(struct soap *soap, struct TT1__getTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestCase(struct soap *soap, const struct TT1__getTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestCase(struct soap *soap, const struct TT1__getTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestCase);
	if (soap_out_TT1__getTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestCase(struct soap *soap, const char *tag, int id, const struct TT1__getTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestCase * SOAP_FMAC4 soap_get_TT1__getTestCase(struct soap *soap, struct TT1__getTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestCase * SOAP_FMAC4 soap_in_TT1__getTestCase(struct soap *soap, const char *tag, struct TT1__getTestCase *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_testCaseNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestCase, sizeof(struct TT1__getTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestCase, 0, sizeof(struct TT1__getTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestCase * SOAP_FMAC6 soap_new_TT1__getTestCase(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestCase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestCase(struct soap *soap, struct TT1__getTestCase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestCase * SOAP_FMAC4 soap_instantiate_TT1__getTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestCase;
		if (size)
			*size = sizeof(struct TT1__getTestCase);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestCase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestCase);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestCase*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestCase %p -> %p\n", q, p));
	*(struct TT1__getTestCase*)p = *(struct TT1__getTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestCaseResponse(struct soap *soap, struct TT1__getTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestCaseResponse(struct soap *soap, const struct TT1__getTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTestCase(soap, &a->pTestCase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestCaseResponse(struct soap *soap, const struct TT1__getTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestCaseResponse);
	if (soap_out_TT1__getTestCaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestCaseResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestCaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestCaseResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestCaseResponse * SOAP_FMAC4 soap_get_TT1__getTestCaseResponse(struct soap *soap, struct TT1__getTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestCaseResponse * SOAP_FMAC4 soap_in_TT1__getTestCaseResponse(struct soap *soap, const char *tag, struct TT1__getTestCaseResponse *a, const char *type)
{
	short soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestCaseResponse, sizeof(struct TT1__getTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTestCase(soap, "pTestCase", &a->pTestCase, "TT1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestCaseResponse, 0, sizeof(struct TT1__getTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestCaseResponse * SOAP_FMAC6 soap_new_TT1__getTestCaseResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestCaseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestCaseResponse(struct soap *soap, struct TT1__getTestCaseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestCaseResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestCaseResponse;
		if (size)
			*size = sizeof(struct TT1__getTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestCaseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestCaseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestCaseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestCaseResponse %p -> %p\n", q, p));
	*(struct TT1__getTestCaseResponse*)p = *(struct TT1__getTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRunStepsModes(struct soap *soap, struct TT1__getTestRunStepsModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRunStepsModes(struct soap *soap, const struct TT1__getTestRunStepsModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRunStepsModes(struct soap *soap, const struct TT1__getTestRunStepsModes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRunStepsModes);
	if (soap_out_TT1__getTestRunStepsModes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRunStepsModes(struct soap *soap, const char *tag, int id, const struct TT1__getTestRunStepsModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRunStepsModes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRunStepsModes * SOAP_FMAC4 soap_get_TT1__getTestRunStepsModes(struct soap *soap, struct TT1__getTestRunStepsModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRunStepsModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRunStepsModes * SOAP_FMAC4 soap_in_TT1__getTestRunStepsModes(struct soap *soap, const char *tag, struct TT1__getTestRunStepsModes *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRunStepsModes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRunStepsModes, sizeof(struct TT1__getTestRunStepsModes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRunStepsModes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRunStepsModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRunStepsModes, 0, sizeof(struct TT1__getTestRunStepsModes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRunStepsModes * SOAP_FMAC6 soap_new_TT1__getTestRunStepsModes(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRunStepsModes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRunStepsModes(struct soap *soap, struct TT1__getTestRunStepsModes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRunStepsModes * SOAP_FMAC4 soap_instantiate_TT1__getTestRunStepsModes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRunStepsModes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRunStepsModes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRunStepsModes;
		if (size)
			*size = sizeof(struct TT1__getTestRunStepsModes);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRunStepsModes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRunStepsModes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRunStepsModes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRunStepsModes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRunStepsModes %p -> %p\n", q, p));
	*(struct TT1__getTestRunStepsModes*)p = *(struct TT1__getTestRunStepsModes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestRunStepsModesResponse(struct soap *soap, struct TT1__getTestRunStepsModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pModeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestRunStepsModesResponse(struct soap *soap, const struct TT1__getTestRunStepsModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfstring(soap, &a->pModeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestRunStepsModesResponse(struct soap *soap, const struct TT1__getTestRunStepsModesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestRunStepsModesResponse);
	if (soap_out_TT1__getTestRunStepsModesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestRunStepsModesResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestRunStepsModesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestRunStepsModesResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfstring(soap, "pModeList", -1, &a->pModeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestRunStepsModesResponse * SOAP_FMAC4 soap_get_TT1__getTestRunStepsModesResponse(struct soap *soap, struct TT1__getTestRunStepsModesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestRunStepsModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestRunStepsModesResponse * SOAP_FMAC4 soap_in_TT1__getTestRunStepsModesResponse(struct soap *soap, const char *tag, struct TT1__getTestRunStepsModesResponse *a, const char *type)
{
	short soap_flag_pModeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestRunStepsModesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestRunStepsModesResponse, sizeof(struct TT1__getTestRunStepsModesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestRunStepsModesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pModeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfstring(soap, "pModeList", &a->pModeList, "xsd:string"))
				{	soap_flag_pModeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestRunStepsModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestRunStepsModesResponse, 0, sizeof(struct TT1__getTestRunStepsModesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestRunStepsModesResponse * SOAP_FMAC6 soap_new_TT1__getTestRunStepsModesResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestRunStepsModesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestRunStepsModesResponse(struct soap *soap, struct TT1__getTestRunStepsModesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestRunStepsModesResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestRunStepsModesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestRunStepsModesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestRunStepsModesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestRunStepsModesResponse;
		if (size)
			*size = sizeof(struct TT1__getTestRunStepsModesResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestRunStepsModesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestRunStepsModesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestRunStepsModesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestRunStepsModesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestRunStepsModesResponse %p -> %p\n", q, p));
	*(struct TT1__getTestRunStepsModesResponse*)p = *(struct TT1__getTestRunStepsModesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestVariantTypes(struct soap *soap, struct TT1__getTestVariantTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestVariantTypes(struct soap *soap, const struct TT1__getTestVariantTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestVariantTypes(struct soap *soap, const struct TT1__getTestVariantTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestVariantTypes);
	if (soap_out_TT1__getTestVariantTypes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestVariantTypes(struct soap *soap, const char *tag, int id, const struct TT1__getTestVariantTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestVariantTypes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestVariantTypes * SOAP_FMAC4 soap_get_TT1__getTestVariantTypes(struct soap *soap, struct TT1__getTestVariantTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestVariantTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestVariantTypes * SOAP_FMAC4 soap_in_TT1__getTestVariantTypes(struct soap *soap, const char *tag, struct TT1__getTestVariantTypes *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestVariantTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestVariantTypes, sizeof(struct TT1__getTestVariantTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestVariantTypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestVariantTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestVariantTypes, 0, sizeof(struct TT1__getTestVariantTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestVariantTypes * SOAP_FMAC6 soap_new_TT1__getTestVariantTypes(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestVariantTypes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestVariantTypes(struct soap *soap, struct TT1__getTestVariantTypes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestVariantTypes * SOAP_FMAC4 soap_instantiate_TT1__getTestVariantTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestVariantTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestVariantTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestVariantTypes;
		if (size)
			*size = sizeof(struct TT1__getTestVariantTypes);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestVariantTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestVariantTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestVariantTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestVariantTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestVariantTypes %p -> %p\n", q, p));
	*(struct TT1__getTestVariantTypes*)p = *(struct TT1__getTestVariantTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestVariantTypesResponse(struct soap *soap, struct TT1__getTestVariantTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestVariantTypesResponse(struct soap *soap, const struct TT1__getTestVariantTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfstring(soap, &a->pTypeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestVariantTypesResponse(struct soap *soap, const struct TT1__getTestVariantTypesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestVariantTypesResponse);
	if (soap_out_TT1__getTestVariantTypesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestVariantTypesResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestVariantTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestVariantTypesResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfstring(soap, "pTypeList", -1, &a->pTypeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestVariantTypesResponse * SOAP_FMAC4 soap_get_TT1__getTestVariantTypesResponse(struct soap *soap, struct TT1__getTestVariantTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestVariantTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestVariantTypesResponse * SOAP_FMAC4 soap_in_TT1__getTestVariantTypesResponse(struct soap *soap, const char *tag, struct TT1__getTestVariantTypesResponse *a, const char *type)
{
	short soap_flag_pTypeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestVariantTypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestVariantTypesResponse, sizeof(struct TT1__getTestVariantTypesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestVariantTypesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTypeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfstring(soap, "pTypeList", &a->pTypeList, "xsd:string"))
				{	soap_flag_pTypeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestVariantTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestVariantTypesResponse, 0, sizeof(struct TT1__getTestVariantTypesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestVariantTypesResponse * SOAP_FMAC6 soap_new_TT1__getTestVariantTypesResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestVariantTypesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestVariantTypesResponse(struct soap *soap, struct TT1__getTestVariantTypesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestVariantTypesResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestVariantTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestVariantTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestVariantTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestVariantTypesResponse;
		if (size)
			*size = sizeof(struct TT1__getTestVariantTypesResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestVariantTypesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestVariantTypesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestVariantTypesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestVariantTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestVariantTypesResponse %p -> %p\n", q, p));
	*(struct TT1__getTestVariantTypesResponse*)p = *(struct TT1__getTestVariantTypesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveLink(struct soap *soap, struct TT1__cancelSaveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveLink(struct soap *soap, const struct TT1__cancelSaveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveLink(struct soap *soap, const struct TT1__cancelSaveLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveLink);
	if (soap_out_TT1__cancelSaveLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveLink(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveLink * SOAP_FMAC4 soap_get_TT1__cancelSaveLink(struct soap *soap, struct TT1__cancelSaveLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveLink * SOAP_FMAC4 soap_in_TT1__cancelSaveLink(struct soap *soap, const char *tag, struct TT1__cancelSaveLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveLink, sizeof(struct TT1__cancelSaveLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveLink, 0, sizeof(struct TT1__cancelSaveLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveLink * SOAP_FMAC6 soap_new_TT1__cancelSaveLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveLink(struct soap *soap, struct TT1__cancelSaveLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveLink * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveLink;
		if (size)
			*size = sizeof(struct TT1__cancelSaveLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveLink %p -> %p\n", q, p));
	*(struct TT1__cancelSaveLink*)p = *(struct TT1__cancelSaveLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveLinkResponse(struct soap *soap, struct TT1__cancelSaveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveLinkResponse(struct soap *soap, const struct TT1__cancelSaveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveLinkResponse(struct soap *soap, const struct TT1__cancelSaveLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveLinkResponse);
	if (soap_out_TT1__cancelSaveLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveLinkResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveLinkResponse(struct soap *soap, struct TT1__cancelSaveLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveLinkResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveLinkResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveLinkResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveLinkResponse, sizeof(struct TT1__cancelSaveLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveLinkResponse, 0, sizeof(struct TT1__cancelSaveLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveLinkResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveLinkResponse(struct soap *soap, struct TT1__cancelSaveLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveLinkResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveLinkResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveLinkResponse*)p = *(struct TT1__cancelSaveLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveLink(struct soap *soap, struct TT1__saveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveLink(struct soap *soap, const struct TT1__saveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CLink(soap, &a->pLink);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveLink(struct soap *soap, const struct TT1__saveLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveLink);
	if (soap_out_TT1__saveLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveLink(struct soap *soap, const char *tag, int id, const struct TT1__saveLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveLink * SOAP_FMAC4 soap_get_TT1__saveLink(struct soap *soap, struct TT1__saveLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveLink * SOAP_FMAC4 soap_in_TT1__saveLink(struct soap *soap, const char *tag, struct TT1__saveLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveLink, sizeof(struct TT1__saveLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CLink(soap, "pLink", &a->pLink, "TT1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveLink, 0, sizeof(struct TT1__saveLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveLink * SOAP_FMAC6 soap_new_TT1__saveLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveLink(struct soap *soap, struct TT1__saveLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveLink * SOAP_FMAC4 soap_instantiate_TT1__saveLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveLink;
		if (size)
			*size = sizeof(struct TT1__saveLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveLink %p -> %p\n", q, p));
	*(struct TT1__saveLink*)p = *(struct TT1__saveLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveLinkResponse(struct soap *soap, struct TT1__saveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveLinkResponse(struct soap *soap, const struct TT1__saveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveLinkResponse(struct soap *soap, const struct TT1__saveLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveLinkResponse);
	if (soap_out_TT1__saveLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveLinkResponse * SOAP_FMAC4 soap_get_TT1__saveLinkResponse(struct soap *soap, struct TT1__saveLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveLinkResponse * SOAP_FMAC4 soap_in_TT1__saveLinkResponse(struct soap *soap, const char *tag, struct TT1__saveLinkResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveLinkResponse, sizeof(struct TT1__saveLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveLinkResponse, 0, sizeof(struct TT1__saveLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveLinkResponse * SOAP_FMAC6 soap_new_TT1__saveLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveLinkResponse(struct soap *soap, struct TT1__saveLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__saveLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveLinkResponse;
		if (size)
			*size = sizeof(struct TT1__saveLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveLinkResponse %p -> %p\n", q, p));
	*(struct TT1__saveLinkResponse*)p = *(struct TT1__saveLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editLink(struct soap *soap, struct TT1__editLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editLink(struct soap *soap, const struct TT1__editLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editLink(struct soap *soap, const struct TT1__editLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editLink);
	if (soap_out_TT1__editLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editLink(struct soap *soap, const char *tag, int id, const struct TT1__editLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editLink * SOAP_FMAC4 soap_get_TT1__editLink(struct soap *soap, struct TT1__editLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editLink * SOAP_FMAC4 soap_in_TT1__editLink(struct soap *soap, const char *tag, struct TT1__editLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editLink, sizeof(struct TT1__editLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editLink, 0, sizeof(struct TT1__editLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editLink * SOAP_FMAC6 soap_new_TT1__editLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__editLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editLink(struct soap *soap, struct TT1__editLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editLink * SOAP_FMAC4 soap_instantiate_TT1__editLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editLink;
		if (size)
			*size = sizeof(struct TT1__editLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editLink %p -> %p\n", q, p));
	*(struct TT1__editLink*)p = *(struct TT1__editLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editLinkResponse(struct soap *soap, struct TT1__editLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editLinkResponse(struct soap *soap, const struct TT1__editLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CLink(soap, &a->pLink);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editLinkResponse(struct soap *soap, const struct TT1__editLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editLinkResponse);
	if (soap_out_TT1__editLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__editLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editLinkResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editLinkResponse * SOAP_FMAC4 soap_get_TT1__editLinkResponse(struct soap *soap, struct TT1__editLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editLinkResponse * SOAP_FMAC4 soap_in_TT1__editLinkResponse(struct soap *soap, const char *tag, struct TT1__editLinkResponse *a, const char *type)
{
	short soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editLinkResponse, sizeof(struct TT1__editLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CLink(soap, "pLink", &a->pLink, "TT1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editLinkResponse, 0, sizeof(struct TT1__editLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editLinkResponse * SOAP_FMAC6 soap_new_TT1__editLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editLinkResponse(struct soap *soap, struct TT1__editLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__editLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editLinkResponse;
		if (size)
			*size = sizeof(struct TT1__editLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editLinkResponse %p -> %p\n", q, p));
	*(struct TT1__editLinkResponse*)p = *(struct TT1__editLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteLink(struct soap *soap, struct TT1__deleteLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteLink(struct soap *soap, const struct TT1__deleteLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteLink(struct soap *soap, const struct TT1__deleteLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteLink);
	if (soap_out_TT1__deleteLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteLink(struct soap *soap, const char *tag, int id, const struct TT1__deleteLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteLink * SOAP_FMAC4 soap_get_TT1__deleteLink(struct soap *soap, struct TT1__deleteLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteLink * SOAP_FMAC4 soap_in_TT1__deleteLink(struct soap *soap, const char *tag, struct TT1__deleteLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteLink, sizeof(struct TT1__deleteLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteLink, 0, sizeof(struct TT1__deleteLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteLink * SOAP_FMAC6 soap_new_TT1__deleteLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteLink(struct soap *soap, struct TT1__deleteLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteLink * SOAP_FMAC4 soap_instantiate_TT1__deleteLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteLink;
		if (size)
			*size = sizeof(struct TT1__deleteLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteLink %p -> %p\n", q, p));
	*(struct TT1__deleteLink*)p = *(struct TT1__deleteLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteLinkResponse(struct soap *soap, struct TT1__deleteLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteLinkResponse(struct soap *soap, const struct TT1__deleteLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteLinkResponse(struct soap *soap, const struct TT1__deleteLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteLinkResponse);
	if (soap_out_TT1__deleteLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteLinkResponse * SOAP_FMAC4 soap_get_TT1__deleteLinkResponse(struct soap *soap, struct TT1__deleteLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteLinkResponse * SOAP_FMAC4 soap_in_TT1__deleteLinkResponse(struct soap *soap, const char *tag, struct TT1__deleteLinkResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteLinkResponse, sizeof(struct TT1__deleteLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteLinkResponse, 0, sizeof(struct TT1__deleteLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteLinkResponse * SOAP_FMAC6 soap_new_TT1__deleteLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteLinkResponse(struct soap *soap, struct TT1__deleteLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteLinkResponse;
		if (size)
			*size = sizeof(struct TT1__deleteLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteLinkResponse %p -> %p\n", q, p));
	*(struct TT1__deleteLinkResponse*)p = *(struct TT1__deleteLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addLink(struct soap *soap, struct TT1__addLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addLink(struct soap *soap, const struct TT1__addLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CLink(soap, &a->pLink);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addLink(struct soap *soap, const struct TT1__addLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addLink);
	if (soap_out_TT1__addLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addLink(struct soap *soap, const char *tag, int id, const struct TT1__addLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addLink * SOAP_FMAC4 soap_get_TT1__addLink(struct soap *soap, struct TT1__addLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addLink * SOAP_FMAC4 soap_in_TT1__addLink(struct soap *soap, const char *tag, struct TT1__addLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addLink, sizeof(struct TT1__addLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CLink(soap, "pLink", &a->pLink, "TT1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addLink, 0, sizeof(struct TT1__addLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addLink * SOAP_FMAC6 soap_new_TT1__addLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__addLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addLink(struct soap *soap, struct TT1__addLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addLink * SOAP_FMAC4 soap_instantiate_TT1__addLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addLink;
		if (size)
			*size = sizeof(struct TT1__addLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addLink %p -> %p\n", q, p));
	*(struct TT1__addLink*)p = *(struct TT1__addLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addLinkResponse(struct soap *soap, struct TT1__addLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addLinkResponse(struct soap *soap, const struct TT1__addLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addLinkResponse(struct soap *soap, const struct TT1__addLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addLinkResponse);
	if (soap_out_TT1__addLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__addLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addLinkResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addLinkResponse * SOAP_FMAC4 soap_get_TT1__addLinkResponse(struct soap *soap, struct TT1__addLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addLinkResponse * SOAP_FMAC4 soap_in_TT1__addLinkResponse(struct soap *soap, const char *tag, struct TT1__addLinkResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addLinkResponse, sizeof(struct TT1__addLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addLinkResponse, 0, sizeof(struct TT1__addLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addLinkResponse * SOAP_FMAC6 soap_new_TT1__addLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addLinkResponse(struct soap *soap, struct TT1__addLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__addLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addLinkResponse;
		if (size)
			*size = sizeof(struct TT1__addLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addLinkResponse %p -> %p\n", q, p));
	*(struct TT1__addLinkResponse*)p = *(struct TT1__addLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLink(struct soap *soap, struct TT1__getLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLink(struct soap *soap, const struct TT1__getLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLink(struct soap *soap, const struct TT1__getLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLink);
	if (soap_out_TT1__getLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLink(struct soap *soap, const char *tag, int id, const struct TT1__getLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLink * SOAP_FMAC4 soap_get_TT1__getLink(struct soap *soap, struct TT1__getLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLink * SOAP_FMAC4 soap_in_TT1__getLink(struct soap *soap, const char *tag, struct TT1__getLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLink, sizeof(struct TT1__getLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLink, 0, sizeof(struct TT1__getLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLink * SOAP_FMAC6 soap_new_TT1__getLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLink(struct soap *soap, struct TT1__getLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLink * SOAP_FMAC4 soap_instantiate_TT1__getLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLink;
		if (size)
			*size = sizeof(struct TT1__getLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLink %p -> %p\n", q, p));
	*(struct TT1__getLink*)p = *(struct TT1__getLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLinkResponse(struct soap *soap, struct TT1__getLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLinkResponse(struct soap *soap, const struct TT1__getLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CLink(soap, &a->pLink);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLinkResponse(struct soap *soap, const struct TT1__getLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLinkResponse);
	if (soap_out_TT1__getLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__getLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLinkResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLinkResponse * SOAP_FMAC4 soap_get_TT1__getLinkResponse(struct soap *soap, struct TT1__getLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLinkResponse * SOAP_FMAC4 soap_in_TT1__getLinkResponse(struct soap *soap, const char *tag, struct TT1__getLinkResponse *a, const char *type)
{
	short soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLinkResponse, sizeof(struct TT1__getLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CLink(soap, "pLink", &a->pLink, "TT1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLinkResponse, 0, sizeof(struct TT1__getLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLinkResponse * SOAP_FMAC6 soap_new_TT1__getLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLinkResponse(struct soap *soap, struct TT1__getLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__getLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLinkResponse;
		if (size)
			*size = sizeof(struct TT1__getLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLinkResponse %p -> %p\n", q, p));
	*(struct TT1__getLinkResponse*)p = *(struct TT1__getLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLinksForDefect(struct soap *soap, struct TT1__getLinksForDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLinksForDefect(struct soap *soap, const struct TT1__getLinksForDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectRecordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLinksForDefect(struct soap *soap, const struct TT1__getLinksForDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLinksForDefect);
	if (soap_out_TT1__getLinksForDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLinksForDefect(struct soap *soap, const char *tag, int id, const struct TT1__getLinksForDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLinksForDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectRecordID", -1, &a->defectRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLinksForDefect * SOAP_FMAC4 soap_get_TT1__getLinksForDefect(struct soap *soap, struct TT1__getLinksForDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLinksForDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLinksForDefect * SOAP_FMAC4 soap_in_TT1__getLinksForDefect(struct soap *soap, const char *tag, struct TT1__getLinksForDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_defectRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLinksForDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLinksForDefect, sizeof(struct TT1__getLinksForDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLinksForDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectRecordID", &a->defectRecordID, "xsd:long"))
				{	soap_flag_defectRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLinksForDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLinksForDefect, 0, sizeof(struct TT1__getLinksForDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLinksForDefect * SOAP_FMAC6 soap_new_TT1__getLinksForDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLinksForDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLinksForDefect(struct soap *soap, struct TT1__getLinksForDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLinksForDefect * SOAP_FMAC4 soap_instantiate_TT1__getLinksForDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLinksForDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLinksForDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLinksForDefect;
		if (size)
			*size = sizeof(struct TT1__getLinksForDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLinksForDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLinksForDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLinksForDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLinksForDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLinksForDefect %p -> %p\n", q, p));
	*(struct TT1__getLinksForDefect*)p = *(struct TT1__getLinksForDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLinksForDefectResponse(struct soap *soap, struct TT1__getLinksForDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLinkList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLinksForDefectResponse(struct soap *soap, const struct TT1__getLinksForDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCLink(soap, &a->pLinkList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLinksForDefectResponse(struct soap *soap, const struct TT1__getLinksForDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLinksForDefectResponse);
	if (soap_out_TT1__getLinksForDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLinksForDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__getLinksForDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLinksForDefectResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCLink(soap, "pLinkList", -1, &a->pLinkList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLinksForDefectResponse * SOAP_FMAC4 soap_get_TT1__getLinksForDefectResponse(struct soap *soap, struct TT1__getLinksForDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLinksForDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLinksForDefectResponse * SOAP_FMAC4 soap_in_TT1__getLinksForDefectResponse(struct soap *soap, const char *tag, struct TT1__getLinksForDefectResponse *a, const char *type)
{
	short soap_flag_pLinkList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLinksForDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLinksForDefectResponse, sizeof(struct TT1__getLinksForDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLinksForDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLinkList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCLink(soap, "pLinkList", &a->pLinkList, "TT1:CLink"))
				{	soap_flag_pLinkList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLinksForDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLinksForDefectResponse, 0, sizeof(struct TT1__getLinksForDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLinksForDefectResponse * SOAP_FMAC6 soap_new_TT1__getLinksForDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLinksForDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLinksForDefectResponse(struct soap *soap, struct TT1__getLinksForDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLinksForDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__getLinksForDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLinksForDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLinksForDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLinksForDefectResponse;
		if (size)
			*size = sizeof(struct TT1__getLinksForDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLinksForDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLinksForDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLinksForDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLinksForDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLinksForDefectResponse %p -> %p\n", q, p));
	*(struct TT1__getLinksForDefectResponse*)p = *(struct TT1__getLinksForDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLinksForItem(struct soap *soap, struct TT1__getLinksForItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_LONG64(soap, &a->itemRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLinksForItem(struct soap *soap, const struct TT1__getLinksForItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_embedded(soap, &a->itemRecordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLinksForItem(struct soap *soap, const struct TT1__getLinksForItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLinksForItem);
	if (soap_out_TT1__getLinksForItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLinksForItem(struct soap *soap, const char *tag, int id, const struct TT1__getLinksForItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLinksForItem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "itemRecordID", -1, &a->itemRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLinksForItem * SOAP_FMAC4 soap_get_TT1__getLinksForItem(struct soap *soap, struct TT1__getLinksForItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLinksForItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLinksForItem * SOAP_FMAC4 soap_in_TT1__getLinksForItem(struct soap *soap, const char *tag, struct TT1__getLinksForItem *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1, soap_flag_itemRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLinksForItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLinksForItem, sizeof(struct TT1__getLinksForItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLinksForItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_itemRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "itemRecordID", &a->itemRecordID, "xsd:long"))
				{	soap_flag_itemRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLinksForItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLinksForItem, 0, sizeof(struct TT1__getLinksForItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_itemRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLinksForItem * SOAP_FMAC6 soap_new_TT1__getLinksForItem(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLinksForItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLinksForItem(struct soap *soap, struct TT1__getLinksForItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLinksForItem * SOAP_FMAC4 soap_instantiate_TT1__getLinksForItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLinksForItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLinksForItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLinksForItem;
		if (size)
			*size = sizeof(struct TT1__getLinksForItem);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLinksForItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLinksForItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLinksForItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLinksForItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLinksForItem %p -> %p\n", q, p));
	*(struct TT1__getLinksForItem*)p = *(struct TT1__getLinksForItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getLinksForItemResponse(struct soap *soap, struct TT1__getLinksForItemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLinkList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getLinksForItemResponse(struct soap *soap, const struct TT1__getLinksForItemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCLink(soap, &a->pLinkList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getLinksForItemResponse(struct soap *soap, const struct TT1__getLinksForItemResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getLinksForItemResponse);
	if (soap_out_TT1__getLinksForItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getLinksForItemResponse(struct soap *soap, const char *tag, int id, const struct TT1__getLinksForItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getLinksForItemResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCLink(soap, "pLinkList", -1, &a->pLinkList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getLinksForItemResponse * SOAP_FMAC4 soap_get_TT1__getLinksForItemResponse(struct soap *soap, struct TT1__getLinksForItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getLinksForItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getLinksForItemResponse * SOAP_FMAC4 soap_in_TT1__getLinksForItemResponse(struct soap *soap, const char *tag, struct TT1__getLinksForItemResponse *a, const char *type)
{
	short soap_flag_pLinkList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getLinksForItemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getLinksForItemResponse, sizeof(struct TT1__getLinksForItemResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getLinksForItemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLinkList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCLink(soap, "pLinkList", &a->pLinkList, "TT1:CLink"))
				{	soap_flag_pLinkList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getLinksForItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getLinksForItemResponse, 0, sizeof(struct TT1__getLinksForItemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getLinksForItemResponse * SOAP_FMAC6 soap_new_TT1__getLinksForItemResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getLinksForItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getLinksForItemResponse(struct soap *soap, struct TT1__getLinksForItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getLinksForItemResponse * SOAP_FMAC4 soap_instantiate_TT1__getLinksForItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getLinksForItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getLinksForItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getLinksForItemResponse;
		if (size)
			*size = sizeof(struct TT1__getLinksForItemResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getLinksForItemResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getLinksForItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getLinksForItemResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getLinksForItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getLinksForItemResponse %p -> %p\n", q, p));
	*(struct TT1__getLinksForItemResponse*)p = *(struct TT1__getLinksForItemResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addGlobalCustomer(struct soap *soap, struct TT1__addGlobalCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addGlobalCustomer(struct soap *soap, const struct TT1__addGlobalCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CGlobalUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addGlobalCustomer(struct soap *soap, const struct TT1__addGlobalCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addGlobalCustomer);
	if (soap_out_TT1__addGlobalCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addGlobalCustomer(struct soap *soap, const char *tag, int id, const struct TT1__addGlobalCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addGlobalCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CGlobalUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addGlobalCustomer * SOAP_FMAC4 soap_get_TT1__addGlobalCustomer(struct soap *soap, struct TT1__addGlobalCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addGlobalCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addGlobalCustomer * SOAP_FMAC4 soap_in_TT1__addGlobalCustomer(struct soap *soap, const char *tag, struct TT1__addGlobalCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addGlobalCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addGlobalCustomer, sizeof(struct TT1__addGlobalCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addGlobalCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CGlobalUser(soap, "pUser", &a->pUser, "TT1:CGlobalUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addGlobalCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addGlobalCustomer, 0, sizeof(struct TT1__addGlobalCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addGlobalCustomer * SOAP_FMAC6 soap_new_TT1__addGlobalCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__addGlobalCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addGlobalCustomer(struct soap *soap, struct TT1__addGlobalCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addGlobalCustomer * SOAP_FMAC4 soap_instantiate_TT1__addGlobalCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addGlobalCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addGlobalCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addGlobalCustomer;
		if (size)
			*size = sizeof(struct TT1__addGlobalCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addGlobalCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addGlobalCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addGlobalCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addGlobalCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addGlobalCustomer %p -> %p\n", q, p));
	*(struct TT1__addGlobalCustomer*)p = *(struct TT1__addGlobalCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addGlobalCustomerResponse(struct soap *soap, struct TT1__addGlobalCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addGlobalCustomerResponse(struct soap *soap, const struct TT1__addGlobalCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addGlobalCustomerResponse(struct soap *soap, const struct TT1__addGlobalCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addGlobalCustomerResponse);
	if (soap_out_TT1__addGlobalCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addGlobalCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__addGlobalCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addGlobalCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addGlobalCustomerResponse * SOAP_FMAC4 soap_get_TT1__addGlobalCustomerResponse(struct soap *soap, struct TT1__addGlobalCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addGlobalCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addGlobalCustomerResponse * SOAP_FMAC4 soap_in_TT1__addGlobalCustomerResponse(struct soap *soap, const char *tag, struct TT1__addGlobalCustomerResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addGlobalCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addGlobalCustomerResponse, sizeof(struct TT1__addGlobalCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addGlobalCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addGlobalCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addGlobalCustomerResponse, 0, sizeof(struct TT1__addGlobalCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addGlobalCustomerResponse * SOAP_FMAC6 soap_new_TT1__addGlobalCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addGlobalCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addGlobalCustomerResponse(struct soap *soap, struct TT1__addGlobalCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addGlobalCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__addGlobalCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addGlobalCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addGlobalCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addGlobalCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__addGlobalCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addGlobalCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addGlobalCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addGlobalCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addGlobalCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addGlobalCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__addGlobalCustomerResponse*)p = *(struct TT1__addGlobalCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__promoteCustomer(struct soap *soap, struct TT1__promoteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->localCustomer);
	soap_default_string(soap, &a->globalUser);
	soap_default_string(soap, &a->loginname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__promoteCustomer(struct soap *soap, const struct TT1__promoteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->localCustomer);
	soap_serialize_string(soap, &a->globalUser);
	soap_serialize_string(soap, &a->loginname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__promoteCustomer(struct soap *soap, const struct TT1__promoteCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__promoteCustomer);
	if (soap_out_TT1__promoteCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__promoteCustomer(struct soap *soap, const char *tag, int id, const struct TT1__promoteCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__promoteCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "localCustomer", -1, &a->localCustomer, ""))
		return soap->error;
	if (soap_out_string(soap, "globalUser", -1, &a->globalUser, ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &a->loginname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__promoteCustomer * SOAP_FMAC4 soap_get_TT1__promoteCustomer(struct soap *soap, struct TT1__promoteCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__promoteCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__promoteCustomer * SOAP_FMAC4 soap_in_TT1__promoteCustomer(struct soap *soap, const char *tag, struct TT1__promoteCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_localCustomer = 1, soap_flag_globalUser = 1, soap_flag_loginname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__promoteCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__promoteCustomer, sizeof(struct TT1__promoteCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__promoteCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_localCustomer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "localCustomer", &a->localCustomer, "xsd:string"))
				{	soap_flag_localCustomer--;
					continue;
				}
			if (soap_flag_globalUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "globalUser", &a->globalUser, "xsd:string"))
				{	soap_flag_globalUser--;
					continue;
				}
			if (soap_flag_loginname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &a->loginname, "xsd:string"))
				{	soap_flag_loginname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__promoteCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__promoteCustomer, 0, sizeof(struct TT1__promoteCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__promoteCustomer * SOAP_FMAC6 soap_new_TT1__promoteCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__promoteCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__promoteCustomer(struct soap *soap, struct TT1__promoteCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__promoteCustomer * SOAP_FMAC4 soap_instantiate_TT1__promoteCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__promoteCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__promoteCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__promoteCustomer;
		if (size)
			*size = sizeof(struct TT1__promoteCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__promoteCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__promoteCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__promoteCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__promoteCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__promoteCustomer %p -> %p\n", q, p));
	*(struct TT1__promoteCustomer*)p = *(struct TT1__promoteCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__promoteCustomerResponse(struct soap *soap, struct TT1__promoteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__promoteCustomerResponse(struct soap *soap, const struct TT1__promoteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__promoteCustomerResponse(struct soap *soap, const struct TT1__promoteCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__promoteCustomerResponse);
	if (soap_out_TT1__promoteCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__promoteCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__promoteCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__promoteCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__promoteCustomerResponse * SOAP_FMAC4 soap_get_TT1__promoteCustomerResponse(struct soap *soap, struct TT1__promoteCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__promoteCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__promoteCustomerResponse * SOAP_FMAC4 soap_in_TT1__promoteCustomerResponse(struct soap *soap, const char *tag, struct TT1__promoteCustomerResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__promoteCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__promoteCustomerResponse, sizeof(struct TT1__promoteCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__promoteCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__promoteCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__promoteCustomerResponse, 0, sizeof(struct TT1__promoteCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__promoteCustomerResponse * SOAP_FMAC6 soap_new_TT1__promoteCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__promoteCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__promoteCustomerResponse(struct soap *soap, struct TT1__promoteCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__promoteCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__promoteCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__promoteCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__promoteCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__promoteCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__promoteCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__promoteCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__promoteCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__promoteCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__promoteCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__promoteCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__promoteCustomerResponse*)p = *(struct TT1__promoteCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveCustomer(struct soap *soap, struct TT1__cancelSaveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveCustomer(struct soap *soap, const struct TT1__cancelSaveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveCustomer(struct soap *soap, const struct TT1__cancelSaveCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveCustomer);
	if (soap_out_TT1__cancelSaveCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveCustomer(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveCustomer * SOAP_FMAC4 soap_get_TT1__cancelSaveCustomer(struct soap *soap, struct TT1__cancelSaveCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveCustomer * SOAP_FMAC4 soap_in_TT1__cancelSaveCustomer(struct soap *soap, const char *tag, struct TT1__cancelSaveCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveCustomer, sizeof(struct TT1__cancelSaveCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveCustomer, 0, sizeof(struct TT1__cancelSaveCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveCustomer * SOAP_FMAC6 soap_new_TT1__cancelSaveCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveCustomer(struct soap *soap, struct TT1__cancelSaveCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveCustomer * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveCustomer;
		if (size)
			*size = sizeof(struct TT1__cancelSaveCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveCustomer %p -> %p\n", q, p));
	*(struct TT1__cancelSaveCustomer*)p = *(struct TT1__cancelSaveCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveCustomerResponse(struct soap *soap, struct TT1__cancelSaveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveCustomerResponse(struct soap *soap, const struct TT1__cancelSaveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveCustomerResponse(struct soap *soap, const struct TT1__cancelSaveCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveCustomerResponse);
	if (soap_out_TT1__cancelSaveCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveCustomerResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveCustomerResponse(struct soap *soap, struct TT1__cancelSaveCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveCustomerResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveCustomerResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveCustomerResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveCustomerResponse, sizeof(struct TT1__cancelSaveCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveCustomerResponse, 0, sizeof(struct TT1__cancelSaveCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveCustomerResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveCustomerResponse(struct soap *soap, struct TT1__cancelSaveCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveCustomerResponse*)p = *(struct TT1__cancelSaveCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteCustomerByRecordID(struct soap *soap, struct TT1__deleteCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteCustomerByRecordID(struct soap *soap, const struct TT1__deleteCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteCustomerByRecordID(struct soap *soap, const struct TT1__deleteCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteCustomerByRecordID);
	if (soap_out_TT1__deleteCustomerByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteCustomerByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordID * SOAP_FMAC4 soap_get_TT1__deleteCustomerByRecordID(struct soap *soap, struct TT1__deleteCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordID * SOAP_FMAC4 soap_in_TT1__deleteCustomerByRecordID(struct soap *soap, const char *tag, struct TT1__deleteCustomerByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteCustomerByRecordID, sizeof(struct TT1__deleteCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteCustomerByRecordID, 0, sizeof(struct TT1__deleteCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteCustomerByRecordID * SOAP_FMAC6 soap_new_TT1__deleteCustomerByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteCustomerByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteCustomerByRecordID(struct soap *soap, struct TT1__deleteCustomerByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteCustomerByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteCustomerByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteCustomerByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteCustomerByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteCustomerByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteCustomerByRecordID*)p = *(struct TT1__deleteCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, struct TT1__deleteCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, const struct TT1__deleteCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, const struct TT1__deleteCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse);
	if (soap_out_TT1__deleteCustomerByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteCustomerByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, struct TT1__deleteCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteCustomerByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse, sizeof(struct TT1__deleteCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse, 0, sizeof(struct TT1__deleteCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteCustomerByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteCustomerByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, struct TT1__deleteCustomerByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteCustomerByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteCustomerByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteCustomerByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteCustomerByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteCustomerByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteCustomerByRecordIDResponse*)p = *(struct TT1__deleteCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteCustomer(struct soap *soap, struct TT1__deleteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteCustomer(struct soap *soap, const struct TT1__deleteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteCustomer(struct soap *soap, const struct TT1__deleteCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteCustomer);
	if (soap_out_TT1__deleteCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteCustomer(struct soap *soap, const char *tag, int id, const struct TT1__deleteCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteCustomer * SOAP_FMAC4 soap_get_TT1__deleteCustomer(struct soap *soap, struct TT1__deleteCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteCustomer * SOAP_FMAC4 soap_in_TT1__deleteCustomer(struct soap *soap, const char *tag, struct TT1__deleteCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteCustomer, sizeof(struct TT1__deleteCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteCustomer, 0, sizeof(struct TT1__deleteCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteCustomer * SOAP_FMAC6 soap_new_TT1__deleteCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteCustomer(struct soap *soap, struct TT1__deleteCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteCustomer * SOAP_FMAC4 soap_instantiate_TT1__deleteCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteCustomer;
		if (size)
			*size = sizeof(struct TT1__deleteCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteCustomer %p -> %p\n", q, p));
	*(struct TT1__deleteCustomer*)p = *(struct TT1__deleteCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteCustomerResponse(struct soap *soap, struct TT1__deleteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteCustomerResponse(struct soap *soap, const struct TT1__deleteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteCustomerResponse(struct soap *soap, const struct TT1__deleteCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteCustomerResponse);
	if (soap_out_TT1__deleteCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteCustomerResponse * SOAP_FMAC4 soap_get_TT1__deleteCustomerResponse(struct soap *soap, struct TT1__deleteCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteCustomerResponse * SOAP_FMAC4 soap_in_TT1__deleteCustomerResponse(struct soap *soap, const char *tag, struct TT1__deleteCustomerResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteCustomerResponse, sizeof(struct TT1__deleteCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteCustomerResponse, 0, sizeof(struct TT1__deleteCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteCustomerResponse * SOAP_FMAC6 soap_new_TT1__deleteCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteCustomerResponse(struct soap *soap, struct TT1__deleteCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__deleteCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__deleteCustomerResponse*)p = *(struct TT1__deleteCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveCustomer(struct soap *soap, struct TT1__saveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveCustomer(struct soap *soap, const struct TT1__saveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveCustomer(struct soap *soap, const struct TT1__saveCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveCustomer);
	if (soap_out_TT1__saveCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveCustomer(struct soap *soap, const char *tag, int id, const struct TT1__saveCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveCustomer * SOAP_FMAC4 soap_get_TT1__saveCustomer(struct soap *soap, struct TT1__saveCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveCustomer * SOAP_FMAC4 soap_in_TT1__saveCustomer(struct soap *soap, const char *tag, struct TT1__saveCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1, soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveCustomer, sizeof(struct TT1__saveCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveCustomer, 0, sizeof(struct TT1__saveCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveCustomer * SOAP_FMAC6 soap_new_TT1__saveCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveCustomer(struct soap *soap, struct TT1__saveCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveCustomer * SOAP_FMAC4 soap_instantiate_TT1__saveCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveCustomer;
		if (size)
			*size = sizeof(struct TT1__saveCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveCustomer %p -> %p\n", q, p));
	*(struct TT1__saveCustomer*)p = *(struct TT1__saveCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveCustomerResponse(struct soap *soap, struct TT1__saveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveCustomerResponse(struct soap *soap, const struct TT1__saveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveCustomerResponse(struct soap *soap, const struct TT1__saveCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveCustomerResponse);
	if (soap_out_TT1__saveCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveCustomerResponse * SOAP_FMAC4 soap_get_TT1__saveCustomerResponse(struct soap *soap, struct TT1__saveCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveCustomerResponse * SOAP_FMAC4 soap_in_TT1__saveCustomerResponse(struct soap *soap, const char *tag, struct TT1__saveCustomerResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveCustomerResponse, sizeof(struct TT1__saveCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveCustomerResponse, 0, sizeof(struct TT1__saveCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveCustomerResponse * SOAP_FMAC6 soap_new_TT1__saveCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveCustomerResponse(struct soap *soap, struct TT1__saveCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__saveCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__saveCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__saveCustomerResponse*)p = *(struct TT1__saveCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editCustomerByRecordID(struct soap *soap, struct TT1__editCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editCustomerByRecordID(struct soap *soap, const struct TT1__editCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editCustomerByRecordID(struct soap *soap, const struct TT1__editCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editCustomerByRecordID);
	if (soap_out_TT1__editCustomerByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editCustomerByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editCustomerByRecordID * SOAP_FMAC4 soap_get_TT1__editCustomerByRecordID(struct soap *soap, struct TT1__editCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editCustomerByRecordID * SOAP_FMAC4 soap_in_TT1__editCustomerByRecordID(struct soap *soap, const char *tag, struct TT1__editCustomerByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editCustomerByRecordID, sizeof(struct TT1__editCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editCustomerByRecordID, 0, sizeof(struct TT1__editCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editCustomerByRecordID * SOAP_FMAC6 soap_new_TT1__editCustomerByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editCustomerByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editCustomerByRecordID(struct soap *soap, struct TT1__editCustomerByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editCustomerByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editCustomerByRecordID;
		if (size)
			*size = sizeof(struct TT1__editCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editCustomerByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editCustomerByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editCustomerByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editCustomerByRecordID %p -> %p\n", q, p));
	*(struct TT1__editCustomerByRecordID*)p = *(struct TT1__editCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editCustomerByRecordIDResponse(struct soap *soap, struct TT1__editCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editCustomerByRecordIDResponse(struct soap *soap, const struct TT1__editCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editCustomerByRecordIDResponse(struct soap *soap, const struct TT1__editCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editCustomerByRecordIDResponse);
	if (soap_out_TT1__editCustomerByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editCustomerByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editCustomerByRecordIDResponse(struct soap *soap, struct TT1__editCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editCustomerByRecordIDResponse *a, const char *type)
{
	short soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editCustomerByRecordIDResponse, sizeof(struct TT1__editCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editCustomerByRecordIDResponse, 0, sizeof(struct TT1__editCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editCustomerByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editCustomerByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editCustomerByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editCustomerByRecordIDResponse(struct soap *soap, struct TT1__editCustomerByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editCustomerByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editCustomerByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editCustomerByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editCustomerByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editCustomerByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editCustomerByRecordIDResponse*)p = *(struct TT1__editCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editCustomer(struct soap *soap, struct TT1__editCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editCustomer(struct soap *soap, const struct TT1__editCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editCustomer(struct soap *soap, const struct TT1__editCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editCustomer);
	if (soap_out_TT1__editCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editCustomer(struct soap *soap, const char *tag, int id, const struct TT1__editCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editCustomer * SOAP_FMAC4 soap_get_TT1__editCustomer(struct soap *soap, struct TT1__editCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editCustomer * SOAP_FMAC4 soap_in_TT1__editCustomer(struct soap *soap, const char *tag, struct TT1__editCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editCustomer, sizeof(struct TT1__editCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editCustomer, 0, sizeof(struct TT1__editCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editCustomer * SOAP_FMAC6 soap_new_TT1__editCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__editCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editCustomer(struct soap *soap, struct TT1__editCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editCustomer * SOAP_FMAC4 soap_instantiate_TT1__editCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editCustomer;
		if (size)
			*size = sizeof(struct TT1__editCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editCustomer %p -> %p\n", q, p));
	*(struct TT1__editCustomer*)p = *(struct TT1__editCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editCustomerResponse(struct soap *soap, struct TT1__editCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editCustomerResponse(struct soap *soap, const struct TT1__editCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editCustomerResponse(struct soap *soap, const struct TT1__editCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editCustomerResponse);
	if (soap_out_TT1__editCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__editCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editCustomerResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editCustomerResponse * SOAP_FMAC4 soap_get_TT1__editCustomerResponse(struct soap *soap, struct TT1__editCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editCustomerResponse * SOAP_FMAC4 soap_in_TT1__editCustomerResponse(struct soap *soap, const char *tag, struct TT1__editCustomerResponse *a, const char *type)
{
	short soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editCustomerResponse, sizeof(struct TT1__editCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editCustomerResponse, 0, sizeof(struct TT1__editCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editCustomerResponse * SOAP_FMAC6 soap_new_TT1__editCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editCustomerResponse(struct soap *soap, struct TT1__editCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__editCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__editCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__editCustomerResponse*)p = *(struct TT1__editCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addCustomer(struct soap *soap, struct TT1__addCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addCustomer(struct soap *soap, const struct TT1__addCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addCustomer(struct soap *soap, const struct TT1__addCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addCustomer);
	if (soap_out_TT1__addCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addCustomer(struct soap *soap, const char *tag, int id, const struct TT1__addCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addCustomer * SOAP_FMAC4 soap_get_TT1__addCustomer(struct soap *soap, struct TT1__addCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addCustomer * SOAP_FMAC4 soap_in_TT1__addCustomer(struct soap *soap, const char *tag, struct TT1__addCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addCustomer, sizeof(struct TT1__addCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addCustomer, 0, sizeof(struct TT1__addCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addCustomer * SOAP_FMAC6 soap_new_TT1__addCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__addCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addCustomer(struct soap *soap, struct TT1__addCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addCustomer * SOAP_FMAC4 soap_instantiate_TT1__addCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addCustomer;
		if (size)
			*size = sizeof(struct TT1__addCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addCustomer %p -> %p\n", q, p));
	*(struct TT1__addCustomer*)p = *(struct TT1__addCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addCustomerResponse(struct soap *soap, struct TT1__addCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addCustomerResponse(struct soap *soap, const struct TT1__addCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addCustomerResponse(struct soap *soap, const struct TT1__addCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addCustomerResponse);
	if (soap_out_TT1__addCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__addCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addCustomerResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addCustomerResponse * SOAP_FMAC4 soap_get_TT1__addCustomerResponse(struct soap *soap, struct TT1__addCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addCustomerResponse * SOAP_FMAC4 soap_in_TT1__addCustomerResponse(struct soap *soap, const char *tag, struct TT1__addCustomerResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addCustomerResponse, sizeof(struct TT1__addCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addCustomerResponse, 0, sizeof(struct TT1__addCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addCustomerResponse * SOAP_FMAC6 soap_new_TT1__addCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addCustomerResponse(struct soap *soap, struct TT1__addCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__addCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__addCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__addCustomerResponse*)p = *(struct TT1__addCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomerByRecordID(struct soap *soap, struct TT1__getCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomerByRecordID(struct soap *soap, const struct TT1__getCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomerByRecordID(struct soap *soap, const struct TT1__getCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomerByRecordID);
	if (soap_out_TT1__getCustomerByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getCustomerByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomerByRecordID * SOAP_FMAC4 soap_get_TT1__getCustomerByRecordID(struct soap *soap, struct TT1__getCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomerByRecordID * SOAP_FMAC4 soap_in_TT1__getCustomerByRecordID(struct soap *soap, const char *tag, struct TT1__getCustomerByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomerByRecordID, sizeof(struct TT1__getCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomerByRecordID, 0, sizeof(struct TT1__getCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomerByRecordID * SOAP_FMAC6 soap_new_TT1__getCustomerByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomerByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomerByRecordID(struct soap *soap, struct TT1__getCustomerByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomerByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomerByRecordID;
		if (size)
			*size = sizeof(struct TT1__getCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomerByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomerByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomerByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomerByRecordID %p -> %p\n", q, p));
	*(struct TT1__getCustomerByRecordID*)p = *(struct TT1__getCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomerByRecordIDResponse(struct soap *soap, struct TT1__getCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomerByRecordIDResponse(struct soap *soap, const struct TT1__getCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomerByRecordIDResponse(struct soap *soap, const struct TT1__getCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomerByRecordIDResponse);
	if (soap_out_TT1__getCustomerByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getCustomerByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getCustomerByRecordIDResponse(struct soap *soap, struct TT1__getCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getCustomerByRecordIDResponse *a, const char *type)
{
	short soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomerByRecordIDResponse, sizeof(struct TT1__getCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomerByRecordIDResponse, 0, sizeof(struct TT1__getCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomerByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getCustomerByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomerByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomerByRecordIDResponse(struct soap *soap, struct TT1__getCustomerByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomerByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomerByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomerByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomerByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomerByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getCustomerByRecordIDResponse*)p = *(struct TT1__getCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomer(struct soap *soap, struct TT1__getCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomer(struct soap *soap, const struct TT1__getCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomer(struct soap *soap, const struct TT1__getCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomer);
	if (soap_out_TT1__getCustomer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomer(struct soap *soap, const char *tag, int id, const struct TT1__getCustomer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomer * SOAP_FMAC4 soap_get_TT1__getCustomer(struct soap *soap, struct TT1__getCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomer * SOAP_FMAC4 soap_in_TT1__getCustomer(struct soap *soap, const char *tag, struct TT1__getCustomer *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomer, sizeof(struct TT1__getCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomer, 0, sizeof(struct TT1__getCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomer * SOAP_FMAC6 soap_new_TT1__getCustomer(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomer(struct soap *soap, struct TT1__getCustomer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomer * SOAP_FMAC4 soap_instantiate_TT1__getCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomer;
		if (size)
			*size = sizeof(struct TT1__getCustomer);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomer %p -> %p\n", q, p));
	*(struct TT1__getCustomer*)p = *(struct TT1__getCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomerResponse(struct soap *soap, struct TT1__getCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomerResponse(struct soap *soap, const struct TT1__getCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pCustomer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomerResponse(struct soap *soap, const struct TT1__getCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomerResponse);
	if (soap_out_TT1__getCustomerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomerResponse(struct soap *soap, const char *tag, int id, const struct TT1__getCustomerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomerResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomerResponse * SOAP_FMAC4 soap_get_TT1__getCustomerResponse(struct soap *soap, struct TT1__getCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomerResponse * SOAP_FMAC4 soap_in_TT1__getCustomerResponse(struct soap *soap, const char *tag, struct TT1__getCustomerResponse *a, const char *type)
{
	short soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomerResponse, sizeof(struct TT1__getCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pCustomer", &a->pCustomer, "TT1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomerResponse, 0, sizeof(struct TT1__getCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomerResponse * SOAP_FMAC6 soap_new_TT1__getCustomerResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomerResponse(struct soap *soap, struct TT1__getCustomerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomerResponse * SOAP_FMAC4 soap_instantiate_TT1__getCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomerResponse;
		if (size)
			*size = sizeof(struct TT1__getCustomerResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomerResponse %p -> %p\n", q, p));
	*(struct TT1__getCustomerResponse*)p = *(struct TT1__getCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addGlobalUser(struct soap *soap, struct TT1__addGlobalUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addGlobalUser(struct soap *soap, const struct TT1__addGlobalUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CGlobalUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addGlobalUser(struct soap *soap, const struct TT1__addGlobalUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addGlobalUser);
	if (soap_out_TT1__addGlobalUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addGlobalUser(struct soap *soap, const char *tag, int id, const struct TT1__addGlobalUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addGlobalUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CGlobalUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addGlobalUser * SOAP_FMAC4 soap_get_TT1__addGlobalUser(struct soap *soap, struct TT1__addGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addGlobalUser * SOAP_FMAC4 soap_in_TT1__addGlobalUser(struct soap *soap, const char *tag, struct TT1__addGlobalUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addGlobalUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addGlobalUser, sizeof(struct TT1__addGlobalUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addGlobalUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CGlobalUser(soap, "pUser", &a->pUser, "TT1:CGlobalUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addGlobalUser, 0, sizeof(struct TT1__addGlobalUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addGlobalUser * SOAP_FMAC6 soap_new_TT1__addGlobalUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__addGlobalUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addGlobalUser(struct soap *soap, struct TT1__addGlobalUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addGlobalUser * SOAP_FMAC4 soap_instantiate_TT1__addGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addGlobalUser;
		if (size)
			*size = sizeof(struct TT1__addGlobalUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addGlobalUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addGlobalUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addGlobalUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addGlobalUser %p -> %p\n", q, p));
	*(struct TT1__addGlobalUser*)p = *(struct TT1__addGlobalUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addGlobalUserResponse(struct soap *soap, struct TT1__addGlobalUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addGlobalUserResponse(struct soap *soap, const struct TT1__addGlobalUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addGlobalUserResponse(struct soap *soap, const struct TT1__addGlobalUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addGlobalUserResponse);
	if (soap_out_TT1__addGlobalUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addGlobalUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__addGlobalUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addGlobalUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addGlobalUserResponse * SOAP_FMAC4 soap_get_TT1__addGlobalUserResponse(struct soap *soap, struct TT1__addGlobalUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addGlobalUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addGlobalUserResponse * SOAP_FMAC4 soap_in_TT1__addGlobalUserResponse(struct soap *soap, const char *tag, struct TT1__addGlobalUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addGlobalUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addGlobalUserResponse, sizeof(struct TT1__addGlobalUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addGlobalUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addGlobalUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addGlobalUserResponse, 0, sizeof(struct TT1__addGlobalUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addGlobalUserResponse * SOAP_FMAC6 soap_new_TT1__addGlobalUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addGlobalUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addGlobalUserResponse(struct soap *soap, struct TT1__addGlobalUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addGlobalUserResponse * SOAP_FMAC4 soap_instantiate_TT1__addGlobalUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addGlobalUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addGlobalUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addGlobalUserResponse;
		if (size)
			*size = sizeof(struct TT1__addGlobalUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addGlobalUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addGlobalUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addGlobalUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addGlobalUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addGlobalUserResponse %p -> %p\n", q, p));
	*(struct TT1__addGlobalUserResponse*)p = *(struct TT1__addGlobalUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__promoteUser(struct soap *soap, struct TT1__promoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->localUser);
	soap_default_string(soap, &a->globalUser);
	soap_default_string(soap, &a->loginname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__promoteUser(struct soap *soap, const struct TT1__promoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->localUser);
	soap_serialize_string(soap, &a->globalUser);
	soap_serialize_string(soap, &a->loginname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__promoteUser(struct soap *soap, const struct TT1__promoteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__promoteUser);
	if (soap_out_TT1__promoteUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__promoteUser(struct soap *soap, const char *tag, int id, const struct TT1__promoteUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__promoteUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "localUser", -1, &a->localUser, ""))
		return soap->error;
	if (soap_out_string(soap, "globalUser", -1, &a->globalUser, ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &a->loginname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__promoteUser * SOAP_FMAC4 soap_get_TT1__promoteUser(struct soap *soap, struct TT1__promoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__promoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__promoteUser * SOAP_FMAC4 soap_in_TT1__promoteUser(struct soap *soap, const char *tag, struct TT1__promoteUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_localUser = 1, soap_flag_globalUser = 1, soap_flag_loginname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__promoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__promoteUser, sizeof(struct TT1__promoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__promoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_localUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "localUser", &a->localUser, "xsd:string"))
				{	soap_flag_localUser--;
					continue;
				}
			if (soap_flag_globalUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "globalUser", &a->globalUser, "xsd:string"))
				{	soap_flag_globalUser--;
					continue;
				}
			if (soap_flag_loginname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &a->loginname, "xsd:string"))
				{	soap_flag_loginname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__promoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__promoteUser, 0, sizeof(struct TT1__promoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__promoteUser * SOAP_FMAC6 soap_new_TT1__promoteUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__promoteUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__promoteUser(struct soap *soap, struct TT1__promoteUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__promoteUser * SOAP_FMAC4 soap_instantiate_TT1__promoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__promoteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__promoteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__promoteUser;
		if (size)
			*size = sizeof(struct TT1__promoteUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__promoteUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__promoteUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__promoteUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__promoteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__promoteUser %p -> %p\n", q, p));
	*(struct TT1__promoteUser*)p = *(struct TT1__promoteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__promoteUserResponse(struct soap *soap, struct TT1__promoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__promoteUserResponse(struct soap *soap, const struct TT1__promoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__promoteUserResponse(struct soap *soap, const struct TT1__promoteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__promoteUserResponse);
	if (soap_out_TT1__promoteUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__promoteUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__promoteUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__promoteUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__promoteUserResponse * SOAP_FMAC4 soap_get_TT1__promoteUserResponse(struct soap *soap, struct TT1__promoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__promoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__promoteUserResponse * SOAP_FMAC4 soap_in_TT1__promoteUserResponse(struct soap *soap, const char *tag, struct TT1__promoteUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__promoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__promoteUserResponse, sizeof(struct TT1__promoteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__promoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__promoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__promoteUserResponse, 0, sizeof(struct TT1__promoteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__promoteUserResponse * SOAP_FMAC6 soap_new_TT1__promoteUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__promoteUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__promoteUserResponse(struct soap *soap, struct TT1__promoteUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__promoteUserResponse * SOAP_FMAC4 soap_instantiate_TT1__promoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__promoteUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__promoteUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__promoteUserResponse;
		if (size)
			*size = sizeof(struct TT1__promoteUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__promoteUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__promoteUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__promoteUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__promoteUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__promoteUserResponse %p -> %p\n", q, p));
	*(struct TT1__promoteUserResponse*)p = *(struct TT1__promoteUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveUser(struct soap *soap, struct TT1__cancelSaveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveUser(struct soap *soap, const struct TT1__cancelSaveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveUser(struct soap *soap, const struct TT1__cancelSaveUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveUser);
	if (soap_out_TT1__cancelSaveUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveUser(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveUser * SOAP_FMAC4 soap_get_TT1__cancelSaveUser(struct soap *soap, struct TT1__cancelSaveUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveUser * SOAP_FMAC4 soap_in_TT1__cancelSaveUser(struct soap *soap, const char *tag, struct TT1__cancelSaveUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveUser, sizeof(struct TT1__cancelSaveUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveUser, 0, sizeof(struct TT1__cancelSaveUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveUser * SOAP_FMAC6 soap_new_TT1__cancelSaveUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveUser(struct soap *soap, struct TT1__cancelSaveUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveUser * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveUser;
		if (size)
			*size = sizeof(struct TT1__cancelSaveUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveUser %p -> %p\n", q, p));
	*(struct TT1__cancelSaveUser*)p = *(struct TT1__cancelSaveUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveUserResponse(struct soap *soap, struct TT1__cancelSaveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveUserResponse(struct soap *soap, const struct TT1__cancelSaveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveUserResponse(struct soap *soap, const struct TT1__cancelSaveUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveUserResponse);
	if (soap_out_TT1__cancelSaveUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveUserResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveUserResponse(struct soap *soap, struct TT1__cancelSaveUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveUserResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveUserResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveUserResponse, sizeof(struct TT1__cancelSaveUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveUserResponse, 0, sizeof(struct TT1__cancelSaveUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveUserResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveUserResponse(struct soap *soap, struct TT1__cancelSaveUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveUserResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveUserResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveUserResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveUserResponse*)p = *(struct TT1__cancelSaveUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteUserByRecordID(struct soap *soap, struct TT1__deleteUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteUserByRecordID(struct soap *soap, const struct TT1__deleteUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteUserByRecordID(struct soap *soap, const struct TT1__deleteUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteUserByRecordID);
	if (soap_out_TT1__deleteUserByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteUserByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteUserByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteUserByRecordID * SOAP_FMAC4 soap_get_TT1__deleteUserByRecordID(struct soap *soap, struct TT1__deleteUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteUserByRecordID * SOAP_FMAC4 soap_in_TT1__deleteUserByRecordID(struct soap *soap, const char *tag, struct TT1__deleteUserByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteUserByRecordID, sizeof(struct TT1__deleteUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteUserByRecordID, 0, sizeof(struct TT1__deleteUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteUserByRecordID * SOAP_FMAC6 soap_new_TT1__deleteUserByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteUserByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteUserByRecordID(struct soap *soap, struct TT1__deleteUserByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteUserByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteUserByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteUserByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteUserByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteUserByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteUserByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteUserByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteUserByRecordID*)p = *(struct TT1__deleteUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteUserByRecordIDResponse(struct soap *soap, struct TT1__deleteUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteUserByRecordIDResponse(struct soap *soap, const struct TT1__deleteUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteUserByRecordIDResponse(struct soap *soap, const struct TT1__deleteUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteUserByRecordIDResponse);
	if (soap_out_TT1__deleteUserByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteUserByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteUserByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteUserByRecordIDResponse(struct soap *soap, struct TT1__deleteUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteUserByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteUserByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteUserByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteUserByRecordIDResponse, sizeof(struct TT1__deleteUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteUserByRecordIDResponse, 0, sizeof(struct TT1__deleteUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteUserByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteUserByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteUserByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteUserByRecordIDResponse(struct soap *soap, struct TT1__deleteUserByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteUserByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteUserByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteUserByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteUserByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteUserByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteUserByRecordIDResponse*)p = *(struct TT1__deleteUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteUser(struct soap *soap, struct TT1__deleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteUser(struct soap *soap, const struct TT1__deleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteUser(struct soap *soap, const struct TT1__deleteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteUser);
	if (soap_out_TT1__deleteUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteUser(struct soap *soap, const char *tag, int id, const struct TT1__deleteUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteUser * SOAP_FMAC4 soap_get_TT1__deleteUser(struct soap *soap, struct TT1__deleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteUser * SOAP_FMAC4 soap_in_TT1__deleteUser(struct soap *soap, const char *tag, struct TT1__deleteUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteUser, sizeof(struct TT1__deleteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteUser, 0, sizeof(struct TT1__deleteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteUser * SOAP_FMAC6 soap_new_TT1__deleteUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteUser(struct soap *soap, struct TT1__deleteUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteUser * SOAP_FMAC4 soap_instantiate_TT1__deleteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteUser;
		if (size)
			*size = sizeof(struct TT1__deleteUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteUser %p -> %p\n", q, p));
	*(struct TT1__deleteUser*)p = *(struct TT1__deleteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteUserResponse(struct soap *soap, struct TT1__deleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteUserResponse(struct soap *soap, const struct TT1__deleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteUserResponse(struct soap *soap, const struct TT1__deleteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteUserResponse);
	if (soap_out_TT1__deleteUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteUserResponse * SOAP_FMAC4 soap_get_TT1__deleteUserResponse(struct soap *soap, struct TT1__deleteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteUserResponse * SOAP_FMAC4 soap_in_TT1__deleteUserResponse(struct soap *soap, const char *tag, struct TT1__deleteUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteUserResponse, sizeof(struct TT1__deleteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteUserResponse, 0, sizeof(struct TT1__deleteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteUserResponse * SOAP_FMAC6 soap_new_TT1__deleteUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteUserResponse(struct soap *soap, struct TT1__deleteUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteUserResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteUserResponse;
		if (size)
			*size = sizeof(struct TT1__deleteUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteUserResponse %p -> %p\n", q, p));
	*(struct TT1__deleteUserResponse*)p = *(struct TT1__deleteUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveUser(struct soap *soap, struct TT1__saveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveUser(struct soap *soap, const struct TT1__saveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveUser(struct soap *soap, const struct TT1__saveUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveUser);
	if (soap_out_TT1__saveUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveUser(struct soap *soap, const char *tag, int id, const struct TT1__saveUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveUser * SOAP_FMAC4 soap_get_TT1__saveUser(struct soap *soap, struct TT1__saveUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveUser * SOAP_FMAC4 soap_in_TT1__saveUser(struct soap *soap, const char *tag, struct TT1__saveUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1, soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveUser, sizeof(struct TT1__saveUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveUser, 0, sizeof(struct TT1__saveUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveUser * SOAP_FMAC6 soap_new_TT1__saveUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveUser(struct soap *soap, struct TT1__saveUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveUser * SOAP_FMAC4 soap_instantiate_TT1__saveUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveUser;
		if (size)
			*size = sizeof(struct TT1__saveUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveUser %p -> %p\n", q, p));
	*(struct TT1__saveUser*)p = *(struct TT1__saveUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveUserResponse(struct soap *soap, struct TT1__saveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveUserResponse(struct soap *soap, const struct TT1__saveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveUserResponse(struct soap *soap, const struct TT1__saveUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveUserResponse);
	if (soap_out_TT1__saveUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveUserResponse * SOAP_FMAC4 soap_get_TT1__saveUserResponse(struct soap *soap, struct TT1__saveUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveUserResponse * SOAP_FMAC4 soap_in_TT1__saveUserResponse(struct soap *soap, const char *tag, struct TT1__saveUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveUserResponse, sizeof(struct TT1__saveUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveUserResponse, 0, sizeof(struct TT1__saveUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveUserResponse * SOAP_FMAC6 soap_new_TT1__saveUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveUserResponse(struct soap *soap, struct TT1__saveUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveUserResponse * SOAP_FMAC4 soap_instantiate_TT1__saveUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveUserResponse;
		if (size)
			*size = sizeof(struct TT1__saveUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveUserResponse %p -> %p\n", q, p));
	*(struct TT1__saveUserResponse*)p = *(struct TT1__saveUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editUserByRecordID(struct soap *soap, struct TT1__editUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editUserByRecordID(struct soap *soap, const struct TT1__editUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editUserByRecordID(struct soap *soap, const struct TT1__editUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editUserByRecordID);
	if (soap_out_TT1__editUserByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editUserByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editUserByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editUserByRecordID * SOAP_FMAC4 soap_get_TT1__editUserByRecordID(struct soap *soap, struct TT1__editUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editUserByRecordID * SOAP_FMAC4 soap_in_TT1__editUserByRecordID(struct soap *soap, const char *tag, struct TT1__editUserByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editUserByRecordID, sizeof(struct TT1__editUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editUserByRecordID, 0, sizeof(struct TT1__editUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editUserByRecordID * SOAP_FMAC6 soap_new_TT1__editUserByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editUserByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editUserByRecordID(struct soap *soap, struct TT1__editUserByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editUserByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editUserByRecordID;
		if (size)
			*size = sizeof(struct TT1__editUserByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editUserByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editUserByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editUserByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editUserByRecordID %p -> %p\n", q, p));
	*(struct TT1__editUserByRecordID*)p = *(struct TT1__editUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editUserByRecordIDResponse(struct soap *soap, struct TT1__editUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editUserByRecordIDResponse(struct soap *soap, const struct TT1__editUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editUserByRecordIDResponse(struct soap *soap, const struct TT1__editUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editUserByRecordIDResponse);
	if (soap_out_TT1__editUserByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editUserByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editUserByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editUserByRecordIDResponse(struct soap *soap, struct TT1__editUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editUserByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editUserByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editUserByRecordIDResponse *a, const char *type)
{
	short soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editUserByRecordIDResponse, sizeof(struct TT1__editUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editUserByRecordIDResponse, 0, sizeof(struct TT1__editUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editUserByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editUserByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editUserByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editUserByRecordIDResponse(struct soap *soap, struct TT1__editUserByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editUserByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editUserByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editUserByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editUserByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editUserByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editUserByRecordIDResponse*)p = *(struct TT1__editUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editUser(struct soap *soap, struct TT1__editUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editUser(struct soap *soap, const struct TT1__editUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editUser(struct soap *soap, const struct TT1__editUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editUser);
	if (soap_out_TT1__editUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editUser(struct soap *soap, const char *tag, int id, const struct TT1__editUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editUser * SOAP_FMAC4 soap_get_TT1__editUser(struct soap *soap, struct TT1__editUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editUser * SOAP_FMAC4 soap_in_TT1__editUser(struct soap *soap, const char *tag, struct TT1__editUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editUser, sizeof(struct TT1__editUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editUser, 0, sizeof(struct TT1__editUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editUser * SOAP_FMAC6 soap_new_TT1__editUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__editUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editUser(struct soap *soap, struct TT1__editUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editUser * SOAP_FMAC4 soap_instantiate_TT1__editUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editUser;
		if (size)
			*size = sizeof(struct TT1__editUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editUser %p -> %p\n", q, p));
	*(struct TT1__editUser*)p = *(struct TT1__editUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editUserResponse(struct soap *soap, struct TT1__editUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editUserResponse(struct soap *soap, const struct TT1__editUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editUserResponse(struct soap *soap, const struct TT1__editUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editUserResponse);
	if (soap_out_TT1__editUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__editUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editUserResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editUserResponse * SOAP_FMAC4 soap_get_TT1__editUserResponse(struct soap *soap, struct TT1__editUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editUserResponse * SOAP_FMAC4 soap_in_TT1__editUserResponse(struct soap *soap, const char *tag, struct TT1__editUserResponse *a, const char *type)
{
	short soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editUserResponse, sizeof(struct TT1__editUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editUserResponse, 0, sizeof(struct TT1__editUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editUserResponse * SOAP_FMAC6 soap_new_TT1__editUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editUserResponse(struct soap *soap, struct TT1__editUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editUserResponse * SOAP_FMAC4 soap_instantiate_TT1__editUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editUserResponse;
		if (size)
			*size = sizeof(struct TT1__editUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editUserResponse %p -> %p\n", q, p));
	*(struct TT1__editUserResponse*)p = *(struct TT1__editUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addUser(struct soap *soap, struct TT1__addUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addUser(struct soap *soap, const struct TT1__addUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addUser(struct soap *soap, const struct TT1__addUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addUser);
	if (soap_out_TT1__addUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addUser(struct soap *soap, const char *tag, int id, const struct TT1__addUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addUser * SOAP_FMAC4 soap_get_TT1__addUser(struct soap *soap, struct TT1__addUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addUser * SOAP_FMAC4 soap_in_TT1__addUser(struct soap *soap, const char *tag, struct TT1__addUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addUser, sizeof(struct TT1__addUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addUser, 0, sizeof(struct TT1__addUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addUser * SOAP_FMAC6 soap_new_TT1__addUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__addUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addUser(struct soap *soap, struct TT1__addUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addUser * SOAP_FMAC4 soap_instantiate_TT1__addUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addUser;
		if (size)
			*size = sizeof(struct TT1__addUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addUser %p -> %p\n", q, p));
	*(struct TT1__addUser*)p = *(struct TT1__addUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addUserResponse(struct soap *soap, struct TT1__addUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addUserResponse(struct soap *soap, const struct TT1__addUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addUserResponse(struct soap *soap, const struct TT1__addUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addUserResponse);
	if (soap_out_TT1__addUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__addUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addUserResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addUserResponse * SOAP_FMAC4 soap_get_TT1__addUserResponse(struct soap *soap, struct TT1__addUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addUserResponse * SOAP_FMAC4 soap_in_TT1__addUserResponse(struct soap *soap, const char *tag, struct TT1__addUserResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addUserResponse, sizeof(struct TT1__addUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addUserResponse, 0, sizeof(struct TT1__addUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addUserResponse * SOAP_FMAC6 soap_new_TT1__addUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addUserResponse(struct soap *soap, struct TT1__addUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addUserResponse * SOAP_FMAC4 soap_instantiate_TT1__addUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addUserResponse;
		if (size)
			*size = sizeof(struct TT1__addUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addUserResponse %p -> %p\n", q, p));
	*(struct TT1__addUserResponse*)p = *(struct TT1__addUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUserByRecordID(struct soap *soap, struct TT1__getUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUserByRecordID(struct soap *soap, const struct TT1__getUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUserByRecordID(struct soap *soap, const struct TT1__getUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUserByRecordID);
	if (soap_out_TT1__getUserByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUserByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getUserByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUserByRecordID * SOAP_FMAC4 soap_get_TT1__getUserByRecordID(struct soap *soap, struct TT1__getUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUserByRecordID * SOAP_FMAC4 soap_in_TT1__getUserByRecordID(struct soap *soap, const char *tag, struct TT1__getUserByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUserByRecordID, sizeof(struct TT1__getUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUserByRecordID, 0, sizeof(struct TT1__getUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUserByRecordID * SOAP_FMAC6 soap_new_TT1__getUserByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUserByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUserByRecordID(struct soap *soap, struct TT1__getUserByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUserByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUserByRecordID;
		if (size)
			*size = sizeof(struct TT1__getUserByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUserByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUserByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUserByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUserByRecordID %p -> %p\n", q, p));
	*(struct TT1__getUserByRecordID*)p = *(struct TT1__getUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUserByRecordIDResponse(struct soap *soap, struct TT1__getUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUserByRecordIDResponse(struct soap *soap, const struct TT1__getUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUserByRecordIDResponse(struct soap *soap, const struct TT1__getUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUserByRecordIDResponse);
	if (soap_out_TT1__getUserByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getUserByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUserByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getUserByRecordIDResponse(struct soap *soap, struct TT1__getUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUserByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getUserByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getUserByRecordIDResponse *a, const char *type)
{
	short soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUserByRecordIDResponse, sizeof(struct TT1__getUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUserByRecordIDResponse, 0, sizeof(struct TT1__getUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUserByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getUserByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUserByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUserByRecordIDResponse(struct soap *soap, struct TT1__getUserByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUserByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUserByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUserByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUserByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUserByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getUserByRecordIDResponse*)p = *(struct TT1__getUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUser(struct soap *soap, struct TT1__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUser(struct soap *soap, const struct TT1__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUser(struct soap *soap, const struct TT1__getUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUser);
	if (soap_out_TT1__getUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUser(struct soap *soap, const char *tag, int id, const struct TT1__getUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUser * SOAP_FMAC4 soap_get_TT1__getUser(struct soap *soap, struct TT1__getUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUser * SOAP_FMAC4 soap_in_TT1__getUser(struct soap *soap, const char *tag, struct TT1__getUser *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_firstName = 1, soap_flag_middleInitials = 1, soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUser, sizeof(struct TT1__getUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUser, 0, sizeof(struct TT1__getUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUser * SOAP_FMAC6 soap_new_TT1__getUser(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUser(struct soap *soap, struct TT1__getUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUser * SOAP_FMAC4 soap_instantiate_TT1__getUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUser;
		if (size)
			*size = sizeof(struct TT1__getUser);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUser %p -> %p\n", q, p));
	*(struct TT1__getUser*)p = *(struct TT1__getUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUserResponse(struct soap *soap, struct TT1__getUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUserResponse(struct soap *soap, const struct TT1__getUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CUser(soap, &a->pUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUserResponse(struct soap *soap, const struct TT1__getUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUserResponse);
	if (soap_out_TT1__getUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUserResponse(struct soap *soap, const char *tag, int id, const struct TT1__getUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUserResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUserResponse * SOAP_FMAC4 soap_get_TT1__getUserResponse(struct soap *soap, struct TT1__getUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUserResponse * SOAP_FMAC4 soap_in_TT1__getUserResponse(struct soap *soap, const char *tag, struct TT1__getUserResponse *a, const char *type)
{
	short soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUserResponse, sizeof(struct TT1__getUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CUser(soap, "pUser", &a->pUser, "TT1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUserResponse, 0, sizeof(struct TT1__getUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUserResponse * SOAP_FMAC6 soap_new_TT1__getUserResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUserResponse(struct soap *soap, struct TT1__getUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUserResponse * SOAP_FMAC4 soap_instantiate_TT1__getUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUserResponse;
		if (size)
			*size = sizeof(struct TT1__getUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUserResponse %p -> %p\n", q, p));
	*(struct TT1__getUserResponse*)p = *(struct TT1__getUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUserLicenseList(struct soap *soap, struct TT1__getUserLicenseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUserLicenseList(struct soap *soap, const struct TT1__getUserLicenseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUserLicenseList(struct soap *soap, const struct TT1__getUserLicenseList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUserLicenseList);
	if (soap_out_TT1__getUserLicenseList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUserLicenseList(struct soap *soap, const char *tag, int id, const struct TT1__getUserLicenseList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUserLicenseList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUserLicenseList * SOAP_FMAC4 soap_get_TT1__getUserLicenseList(struct soap *soap, struct TT1__getUserLicenseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUserLicenseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUserLicenseList * SOAP_FMAC4 soap_in_TT1__getUserLicenseList(struct soap *soap, const char *tag, struct TT1__getUserLicenseList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUserLicenseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUserLicenseList, sizeof(struct TT1__getUserLicenseList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUserLicenseList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUserLicenseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUserLicenseList, 0, sizeof(struct TT1__getUserLicenseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUserLicenseList * SOAP_FMAC6 soap_new_TT1__getUserLicenseList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUserLicenseList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUserLicenseList(struct soap *soap, struct TT1__getUserLicenseList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUserLicenseList * SOAP_FMAC4 soap_instantiate_TT1__getUserLicenseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUserLicenseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUserLicenseList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUserLicenseList;
		if (size)
			*size = sizeof(struct TT1__getUserLicenseList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUserLicenseList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUserLicenseList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUserLicenseList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUserLicenseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUserLicenseList %p -> %p\n", q, p));
	*(struct TT1__getUserLicenseList*)p = *(struct TT1__getUserLicenseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getUserLicenseListResponse(struct soap *soap, struct TT1__getUserLicenseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UserLicenseList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getUserLicenseListResponse(struct soap *soap, const struct TT1__getUserLicenseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCUserLicense(soap, &a->UserLicenseList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getUserLicenseListResponse(struct soap *soap, const struct TT1__getUserLicenseListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getUserLicenseListResponse);
	if (soap_out_TT1__getUserLicenseListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getUserLicenseListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getUserLicenseListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getUserLicenseListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCUserLicense(soap, "UserLicenseList", -1, &a->UserLicenseList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getUserLicenseListResponse * SOAP_FMAC4 soap_get_TT1__getUserLicenseListResponse(struct soap *soap, struct TT1__getUserLicenseListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getUserLicenseListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getUserLicenseListResponse * SOAP_FMAC4 soap_in_TT1__getUserLicenseListResponse(struct soap *soap, const char *tag, struct TT1__getUserLicenseListResponse *a, const char *type)
{
	short soap_flag_UserLicenseList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getUserLicenseListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getUserLicenseListResponse, sizeof(struct TT1__getUserLicenseListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getUserLicenseListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserLicenseList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCUserLicense(soap, "UserLicenseList", &a->UserLicenseList, "TT1:CUserLicense"))
				{	soap_flag_UserLicenseList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getUserLicenseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getUserLicenseListResponse, 0, sizeof(struct TT1__getUserLicenseListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getUserLicenseListResponse * SOAP_FMAC6 soap_new_TT1__getUserLicenseListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getUserLicenseListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getUserLicenseListResponse(struct soap *soap, struct TT1__getUserLicenseListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getUserLicenseListResponse * SOAP_FMAC4 soap_instantiate_TT1__getUserLicenseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getUserLicenseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getUserLicenseListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getUserLicenseListResponse;
		if (size)
			*size = sizeof(struct TT1__getUserLicenseListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getUserLicenseListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getUserLicenseListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getUserLicenseListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getUserLicenseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getUserLicenseListResponse %p -> %p\n", q, p));
	*(struct TT1__getUserLicenseListResponse*)p = *(struct TT1__getUserLicenseListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getGlobalCustomerList(struct soap *soap, struct TT1__getGlobalCustomerList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getGlobalCustomerList(struct soap *soap, const struct TT1__getGlobalCustomerList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getGlobalCustomerList(struct soap *soap, const struct TT1__getGlobalCustomerList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getGlobalCustomerList);
	if (soap_out_TT1__getGlobalCustomerList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getGlobalCustomerList(struct soap *soap, const char *tag, int id, const struct TT1__getGlobalCustomerList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getGlobalCustomerList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getGlobalCustomerList * SOAP_FMAC4 soap_get_TT1__getGlobalCustomerList(struct soap *soap, struct TT1__getGlobalCustomerList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getGlobalCustomerList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getGlobalCustomerList * SOAP_FMAC4 soap_in_TT1__getGlobalCustomerList(struct soap *soap, const char *tag, struct TT1__getGlobalCustomerList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getGlobalCustomerList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getGlobalCustomerList, sizeof(struct TT1__getGlobalCustomerList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getGlobalCustomerList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getGlobalCustomerList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getGlobalCustomerList, 0, sizeof(struct TT1__getGlobalCustomerList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getGlobalCustomerList * SOAP_FMAC6 soap_new_TT1__getGlobalCustomerList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getGlobalCustomerList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getGlobalCustomerList(struct soap *soap, struct TT1__getGlobalCustomerList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getGlobalCustomerList * SOAP_FMAC4 soap_instantiate_TT1__getGlobalCustomerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getGlobalCustomerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getGlobalCustomerList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getGlobalCustomerList;
		if (size)
			*size = sizeof(struct TT1__getGlobalCustomerList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getGlobalCustomerList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getGlobalCustomerList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getGlobalCustomerList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getGlobalCustomerList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getGlobalCustomerList %p -> %p\n", q, p));
	*(struct TT1__getGlobalCustomerList*)p = *(struct TT1__getGlobalCustomerList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getGlobalCustomerListResponse(struct soap *soap, struct TT1__getGlobalCustomerListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GlobalCustomerList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getGlobalCustomerListResponse(struct soap *soap, const struct TT1__getGlobalCustomerListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCGlobalUser(soap, &a->GlobalCustomerList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getGlobalCustomerListResponse(struct soap *soap, const struct TT1__getGlobalCustomerListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getGlobalCustomerListResponse);
	if (soap_out_TT1__getGlobalCustomerListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getGlobalCustomerListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getGlobalCustomerListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getGlobalCustomerListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCGlobalUser(soap, "GlobalCustomerList", -1, &a->GlobalCustomerList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getGlobalCustomerListResponse * SOAP_FMAC4 soap_get_TT1__getGlobalCustomerListResponse(struct soap *soap, struct TT1__getGlobalCustomerListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getGlobalCustomerListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getGlobalCustomerListResponse * SOAP_FMAC4 soap_in_TT1__getGlobalCustomerListResponse(struct soap *soap, const char *tag, struct TT1__getGlobalCustomerListResponse *a, const char *type)
{
	short soap_flag_GlobalCustomerList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getGlobalCustomerListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getGlobalCustomerListResponse, sizeof(struct TT1__getGlobalCustomerListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getGlobalCustomerListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GlobalCustomerList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCGlobalUser(soap, "GlobalCustomerList", &a->GlobalCustomerList, "TT1:CGlobalUser"))
				{	soap_flag_GlobalCustomerList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getGlobalCustomerListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getGlobalCustomerListResponse, 0, sizeof(struct TT1__getGlobalCustomerListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getGlobalCustomerListResponse * SOAP_FMAC6 soap_new_TT1__getGlobalCustomerListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getGlobalCustomerListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getGlobalCustomerListResponse(struct soap *soap, struct TT1__getGlobalCustomerListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getGlobalCustomerListResponse * SOAP_FMAC4 soap_instantiate_TT1__getGlobalCustomerListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getGlobalCustomerListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getGlobalCustomerListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getGlobalCustomerListResponse;
		if (size)
			*size = sizeof(struct TT1__getGlobalCustomerListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getGlobalCustomerListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getGlobalCustomerListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getGlobalCustomerListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getGlobalCustomerListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getGlobalCustomerListResponse %p -> %p\n", q, p));
	*(struct TT1__getGlobalCustomerListResponse*)p = *(struct TT1__getGlobalCustomerListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getGlobalUserList(struct soap *soap, struct TT1__getGlobalUserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getGlobalUserList(struct soap *soap, const struct TT1__getGlobalUserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getGlobalUserList(struct soap *soap, const struct TT1__getGlobalUserList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getGlobalUserList);
	if (soap_out_TT1__getGlobalUserList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getGlobalUserList(struct soap *soap, const char *tag, int id, const struct TT1__getGlobalUserList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getGlobalUserList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getGlobalUserList * SOAP_FMAC4 soap_get_TT1__getGlobalUserList(struct soap *soap, struct TT1__getGlobalUserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getGlobalUserList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getGlobalUserList * SOAP_FMAC4 soap_in_TT1__getGlobalUserList(struct soap *soap, const char *tag, struct TT1__getGlobalUserList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getGlobalUserList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getGlobalUserList, sizeof(struct TT1__getGlobalUserList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getGlobalUserList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getGlobalUserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getGlobalUserList, 0, sizeof(struct TT1__getGlobalUserList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getGlobalUserList * SOAP_FMAC6 soap_new_TT1__getGlobalUserList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getGlobalUserList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getGlobalUserList(struct soap *soap, struct TT1__getGlobalUserList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getGlobalUserList * SOAP_FMAC4 soap_instantiate_TT1__getGlobalUserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getGlobalUserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getGlobalUserList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getGlobalUserList;
		if (size)
			*size = sizeof(struct TT1__getGlobalUserList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getGlobalUserList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getGlobalUserList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getGlobalUserList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getGlobalUserList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getGlobalUserList %p -> %p\n", q, p));
	*(struct TT1__getGlobalUserList*)p = *(struct TT1__getGlobalUserList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getGlobalUserListResponse(struct soap *soap, struct TT1__getGlobalUserListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GlobalUserList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getGlobalUserListResponse(struct soap *soap, const struct TT1__getGlobalUserListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCGlobalUser(soap, &a->GlobalUserList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getGlobalUserListResponse(struct soap *soap, const struct TT1__getGlobalUserListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getGlobalUserListResponse);
	if (soap_out_TT1__getGlobalUserListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getGlobalUserListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getGlobalUserListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getGlobalUserListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCGlobalUser(soap, "GlobalUserList", -1, &a->GlobalUserList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getGlobalUserListResponse * SOAP_FMAC4 soap_get_TT1__getGlobalUserListResponse(struct soap *soap, struct TT1__getGlobalUserListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getGlobalUserListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getGlobalUserListResponse * SOAP_FMAC4 soap_in_TT1__getGlobalUserListResponse(struct soap *soap, const char *tag, struct TT1__getGlobalUserListResponse *a, const char *type)
{
	short soap_flag_GlobalUserList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getGlobalUserListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getGlobalUserListResponse, sizeof(struct TT1__getGlobalUserListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getGlobalUserListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GlobalUserList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCGlobalUser(soap, "GlobalUserList", &a->GlobalUserList, "TT1:CGlobalUser"))
				{	soap_flag_GlobalUserList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getGlobalUserListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getGlobalUserListResponse, 0, sizeof(struct TT1__getGlobalUserListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getGlobalUserListResponse * SOAP_FMAC6 soap_new_TT1__getGlobalUserListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getGlobalUserListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getGlobalUserListResponse(struct soap *soap, struct TT1__getGlobalUserListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getGlobalUserListResponse * SOAP_FMAC4 soap_instantiate_TT1__getGlobalUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getGlobalUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getGlobalUserListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getGlobalUserListResponse;
		if (size)
			*size = sizeof(struct TT1__getGlobalUserListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getGlobalUserListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getGlobalUserListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getGlobalUserListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getGlobalUserListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getGlobalUserListResponse %p -> %p\n", q, p));
	*(struct TT1__getGlobalUserListResponse*)p = *(struct TT1__getGlobalUserListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTask(struct soap *soap, struct TT1__cancelSaveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTask(struct soap *soap, const struct TT1__cancelSaveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTask(struct soap *soap, const struct TT1__cancelSaveTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTask);
	if (soap_out_TT1__cancelSaveTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTask(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTask * SOAP_FMAC4 soap_get_TT1__cancelSaveTask(struct soap *soap, struct TT1__cancelSaveTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTask * SOAP_FMAC4 soap_in_TT1__cancelSaveTask(struct soap *soap, const char *tag, struct TT1__cancelSaveTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTask, sizeof(struct TT1__cancelSaveTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTask, 0, sizeof(struct TT1__cancelSaveTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTask * SOAP_FMAC6 soap_new_TT1__cancelSaveTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTask(struct soap *soap, struct TT1__cancelSaveTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTask * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTask;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTask %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTask*)p = *(struct TT1__cancelSaveTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTaskResponse(struct soap *soap, struct TT1__cancelSaveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTaskResponse(struct soap *soap, const struct TT1__cancelSaveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTaskResponse(struct soap *soap, const struct TT1__cancelSaveTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTaskResponse);
	if (soap_out_TT1__cancelSaveTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTaskResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveTaskResponse(struct soap *soap, struct TT1__cancelSaveTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTaskResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveTaskResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveTaskResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTaskResponse, sizeof(struct TT1__cancelSaveTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTaskResponse, 0, sizeof(struct TT1__cancelSaveTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTaskResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTaskResponse(struct soap *soap, struct TT1__cancelSaveTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTaskResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTaskResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTaskResponse*)p = *(struct TT1__cancelSaveTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTask(struct soap *soap, struct TT1__saveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTask(struct soap *soap, const struct TT1__saveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTask(struct soap *soap, const struct TT1__saveTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTask);
	if (soap_out_TT1__saveTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTask(struct soap *soap, const char *tag, int id, const struct TT1__saveTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTask * SOAP_FMAC4 soap_get_TT1__saveTask(struct soap *soap, struct TT1__saveTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTask * SOAP_FMAC4 soap_in_TT1__saveTask(struct soap *soap, const char *tag, struct TT1__saveTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTask, sizeof(struct TT1__saveTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTask, 0, sizeof(struct TT1__saveTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTask * SOAP_FMAC6 soap_new_TT1__saveTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTask(struct soap *soap, struct TT1__saveTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTask * SOAP_FMAC4 soap_instantiate_TT1__saveTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTask;
		if (size)
			*size = sizeof(struct TT1__saveTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTask %p -> %p\n", q, p));
	*(struct TT1__saveTask*)p = *(struct TT1__saveTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTaskResponse(struct soap *soap, struct TT1__saveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTaskResponse(struct soap *soap, const struct TT1__saveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTaskResponse(struct soap *soap, const struct TT1__saveTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTaskResponse);
	if (soap_out_TT1__saveTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTaskResponse * SOAP_FMAC4 soap_get_TT1__saveTaskResponse(struct soap *soap, struct TT1__saveTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTaskResponse * SOAP_FMAC4 soap_in_TT1__saveTaskResponse(struct soap *soap, const char *tag, struct TT1__saveTaskResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTaskResponse, sizeof(struct TT1__saveTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTaskResponse, 0, sizeof(struct TT1__saveTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTaskResponse * SOAP_FMAC6 soap_new_TT1__saveTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTaskResponse(struct soap *soap, struct TT1__saveTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__saveTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTaskResponse;
		if (size)
			*size = sizeof(struct TT1__saveTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTaskResponse %p -> %p\n", q, p));
	*(struct TT1__saveTaskResponse*)p = *(struct TT1__saveTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTaskByRecordID(struct soap *soap, struct TT1__editTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTaskByRecordID(struct soap *soap, const struct TT1__editTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTaskByRecordID(struct soap *soap, const struct TT1__editTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTaskByRecordID);
	if (soap_out_TT1__editTaskByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTaskByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editTaskByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTaskByRecordID * SOAP_FMAC4 soap_get_TT1__editTaskByRecordID(struct soap *soap, struct TT1__editTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTaskByRecordID * SOAP_FMAC4 soap_in_TT1__editTaskByRecordID(struct soap *soap, const char *tag, struct TT1__editTaskByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTaskByRecordID, sizeof(struct TT1__editTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTaskByRecordID, 0, sizeof(struct TT1__editTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTaskByRecordID * SOAP_FMAC6 soap_new_TT1__editTaskByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTaskByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTaskByRecordID(struct soap *soap, struct TT1__editTaskByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTaskByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTaskByRecordID;
		if (size)
			*size = sizeof(struct TT1__editTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTaskByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTaskByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTaskByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTaskByRecordID %p -> %p\n", q, p));
	*(struct TT1__editTaskByRecordID*)p = *(struct TT1__editTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTaskByRecordIDResponse(struct soap *soap, struct TT1__editTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTaskByRecordIDResponse(struct soap *soap, const struct TT1__editTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTaskByRecordIDResponse(struct soap *soap, const struct TT1__editTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTaskByRecordIDResponse);
	if (soap_out_TT1__editTaskByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTaskByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTaskByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editTaskByRecordIDResponse(struct soap *soap, struct TT1__editTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTaskByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editTaskByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editTaskByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTaskByRecordIDResponse, sizeof(struct TT1__editTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTaskByRecordIDResponse, 0, sizeof(struct TT1__editTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTaskByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editTaskByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTaskByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTaskByRecordIDResponse(struct soap *soap, struct TT1__editTaskByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTaskByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTaskByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTaskByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTaskByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTaskByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editTaskByRecordIDResponse*)p = *(struct TT1__editTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTask(struct soap *soap, struct TT1__editTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTask(struct soap *soap, const struct TT1__editTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTask(struct soap *soap, const struct TT1__editTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTask);
	if (soap_out_TT1__editTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTask(struct soap *soap, const char *tag, int id, const struct TT1__editTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTask * SOAP_FMAC4 soap_get_TT1__editTask(struct soap *soap, struct TT1__editTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTask * SOAP_FMAC4 soap_in_TT1__editTask(struct soap *soap, const char *tag, struct TT1__editTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTask, sizeof(struct TT1__editTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTask, 0, sizeof(struct TT1__editTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTask * SOAP_FMAC6 soap_new_TT1__editTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTask(struct soap *soap, struct TT1__editTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTask * SOAP_FMAC4 soap_instantiate_TT1__editTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTask;
		if (size)
			*size = sizeof(struct TT1__editTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTask %p -> %p\n", q, p));
	*(struct TT1__editTask*)p = *(struct TT1__editTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTaskResponse(struct soap *soap, struct TT1__editTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTaskResponse(struct soap *soap, const struct TT1__editTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTaskResponse(struct soap *soap, const struct TT1__editTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTaskResponse);
	if (soap_out_TT1__editTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTaskResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTaskResponse * SOAP_FMAC4 soap_get_TT1__editTaskResponse(struct soap *soap, struct TT1__editTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTaskResponse * SOAP_FMAC4 soap_in_TT1__editTaskResponse(struct soap *soap, const char *tag, struct TT1__editTaskResponse *a, const char *type)
{
	short soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTaskResponse, sizeof(struct TT1__editTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTaskResponse, 0, sizeof(struct TT1__editTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTaskResponse * SOAP_FMAC6 soap_new_TT1__editTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTaskResponse(struct soap *soap, struct TT1__editTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__editTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTaskResponse;
		if (size)
			*size = sizeof(struct TT1__editTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTaskResponse %p -> %p\n", q, p));
	*(struct TT1__editTaskResponse*)p = *(struct TT1__editTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTaskByRecordID(struct soap *soap, struct TT1__deleteTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTaskByRecordID(struct soap *soap, const struct TT1__deleteTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTaskByRecordID(struct soap *soap, const struct TT1__deleteTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTaskByRecordID);
	if (soap_out_TT1__deleteTaskByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTaskByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteTaskByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordID * SOAP_FMAC4 soap_get_TT1__deleteTaskByRecordID(struct soap *soap, struct TT1__deleteTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordID * SOAP_FMAC4 soap_in_TT1__deleteTaskByRecordID(struct soap *soap, const char *tag, struct TT1__deleteTaskByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTaskByRecordID, sizeof(struct TT1__deleteTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTaskByRecordID, 0, sizeof(struct TT1__deleteTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTaskByRecordID * SOAP_FMAC6 soap_new_TT1__deleteTaskByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTaskByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTaskByRecordID(struct soap *soap, struct TT1__deleteTaskByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTaskByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTaskByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTaskByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTaskByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTaskByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteTaskByRecordID*)p = *(struct TT1__deleteTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTaskByRecordIDResponse(struct soap *soap, struct TT1__deleteTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTaskByRecordIDResponse(struct soap *soap, const struct TT1__deleteTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTaskByRecordIDResponse(struct soap *soap, const struct TT1__deleteTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTaskByRecordIDResponse);
	if (soap_out_TT1__deleteTaskByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTaskByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteTaskByRecordIDResponse(struct soap *soap, struct TT1__deleteTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteTaskByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteTaskByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTaskByRecordIDResponse, sizeof(struct TT1__deleteTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTaskByRecordIDResponse, 0, sizeof(struct TT1__deleteTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTaskByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteTaskByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTaskByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTaskByRecordIDResponse(struct soap *soap, struct TT1__deleteTaskByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTaskByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTaskByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTaskByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTaskByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTaskByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTaskByRecordIDResponse*)p = *(struct TT1__deleteTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTask(struct soap *soap, struct TT1__deleteTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTask(struct soap *soap, const struct TT1__deleteTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTask(struct soap *soap, const struct TT1__deleteTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTask);
	if (soap_out_TT1__deleteTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTask(struct soap *soap, const char *tag, int id, const struct TT1__deleteTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTask * SOAP_FMAC4 soap_get_TT1__deleteTask(struct soap *soap, struct TT1__deleteTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTask * SOAP_FMAC4 soap_in_TT1__deleteTask(struct soap *soap, const char *tag, struct TT1__deleteTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTask, sizeof(struct TT1__deleteTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTask, 0, sizeof(struct TT1__deleteTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTask * SOAP_FMAC6 soap_new_TT1__deleteTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTask(struct soap *soap, struct TT1__deleteTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTask * SOAP_FMAC4 soap_instantiate_TT1__deleteTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTask;
		if (size)
			*size = sizeof(struct TT1__deleteTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTask %p -> %p\n", q, p));
	*(struct TT1__deleteTask*)p = *(struct TT1__deleteTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTaskResponse(struct soap *soap, struct TT1__deleteTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTaskResponse(struct soap *soap, const struct TT1__deleteTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTaskResponse(struct soap *soap, const struct TT1__deleteTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTaskResponse);
	if (soap_out_TT1__deleteTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTaskResponse * SOAP_FMAC4 soap_get_TT1__deleteTaskResponse(struct soap *soap, struct TT1__deleteTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTaskResponse * SOAP_FMAC4 soap_in_TT1__deleteTaskResponse(struct soap *soap, const char *tag, struct TT1__deleteTaskResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTaskResponse, sizeof(struct TT1__deleteTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTaskResponse, 0, sizeof(struct TT1__deleteTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTaskResponse * SOAP_FMAC6 soap_new_TT1__deleteTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTaskResponse(struct soap *soap, struct TT1__deleteTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTaskResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTaskResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTaskResponse*)p = *(struct TT1__deleteTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTask(struct soap *soap, struct TT1__addTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTask(struct soap *soap, const struct TT1__addTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTask(struct soap *soap, const struct TT1__addTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTask);
	if (soap_out_TT1__addTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTask(struct soap *soap, const char *tag, int id, const struct TT1__addTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTask * SOAP_FMAC4 soap_get_TT1__addTask(struct soap *soap, struct TT1__addTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTask * SOAP_FMAC4 soap_in_TT1__addTask(struct soap *soap, const char *tag, struct TT1__addTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTask, sizeof(struct TT1__addTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTask, 0, sizeof(struct TT1__addTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTask * SOAP_FMAC6 soap_new_TT1__addTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTask(struct soap *soap, struct TT1__addTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTask * SOAP_FMAC4 soap_instantiate_TT1__addTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTask;
		if (size)
			*size = sizeof(struct TT1__addTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTask %p -> %p\n", q, p));
	*(struct TT1__addTask*)p = *(struct TT1__addTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTaskResponse(struct soap *soap, struct TT1__addTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTaskResponse(struct soap *soap, const struct TT1__addTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTaskResponse(struct soap *soap, const struct TT1__addTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTaskResponse);
	if (soap_out_TT1__addTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__addTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTaskResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTaskResponse * SOAP_FMAC4 soap_get_TT1__addTaskResponse(struct soap *soap, struct TT1__addTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTaskResponse * SOAP_FMAC4 soap_in_TT1__addTaskResponse(struct soap *soap, const char *tag, struct TT1__addTaskResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTaskResponse, sizeof(struct TT1__addTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTaskResponse, 0, sizeof(struct TT1__addTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTaskResponse * SOAP_FMAC6 soap_new_TT1__addTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTaskResponse(struct soap *soap, struct TT1__addTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__addTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTaskResponse;
		if (size)
			*size = sizeof(struct TT1__addTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTaskResponse %p -> %p\n", q, p));
	*(struct TT1__addTaskResponse*)p = *(struct TT1__addTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTaskByRecordID(struct soap *soap, struct TT1__getTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTaskByRecordID(struct soap *soap, const struct TT1__getTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTaskByRecordID(struct soap *soap, const struct TT1__getTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTaskByRecordID);
	if (soap_out_TT1__getTaskByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTaskByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getTaskByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTaskByRecordID * SOAP_FMAC4 soap_get_TT1__getTaskByRecordID(struct soap *soap, struct TT1__getTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTaskByRecordID * SOAP_FMAC4 soap_in_TT1__getTaskByRecordID(struct soap *soap, const char *tag, struct TT1__getTaskByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTaskByRecordID, sizeof(struct TT1__getTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTaskByRecordID, 0, sizeof(struct TT1__getTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTaskByRecordID * SOAP_FMAC6 soap_new_TT1__getTaskByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTaskByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTaskByRecordID(struct soap *soap, struct TT1__getTaskByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTaskByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTaskByRecordID;
		if (size)
			*size = sizeof(struct TT1__getTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTaskByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTaskByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTaskByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTaskByRecordID %p -> %p\n", q, p));
	*(struct TT1__getTaskByRecordID*)p = *(struct TT1__getTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTaskByRecordIDResponse(struct soap *soap, struct TT1__getTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTaskByRecordIDResponse(struct soap *soap, const struct TT1__getTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTaskByRecordIDResponse(struct soap *soap, const struct TT1__getTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTaskByRecordIDResponse);
	if (soap_out_TT1__getTaskByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTaskByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTaskByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getTaskByRecordIDResponse(struct soap *soap, struct TT1__getTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTaskByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getTaskByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getTaskByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTaskByRecordIDResponse, sizeof(struct TT1__getTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTaskByRecordIDResponse, 0, sizeof(struct TT1__getTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTaskByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getTaskByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTaskByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTaskByRecordIDResponse(struct soap *soap, struct TT1__getTaskByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTaskByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTaskByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTaskByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTaskByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTaskByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getTaskByRecordIDResponse*)p = *(struct TT1__getTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTask(struct soap *soap, struct TT1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTask(struct soap *soap, const struct TT1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTask(struct soap *soap, const struct TT1__getTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTask);
	if (soap_out_TT1__getTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTask(struct soap *soap, const char *tag, int id, const struct TT1__getTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTask * SOAP_FMAC4 soap_get_TT1__getTask(struct soap *soap, struct TT1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTask * SOAP_FMAC4 soap_in_TT1__getTask(struct soap *soap, const char *tag, struct TT1__getTask *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTask, sizeof(struct TT1__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTask, 0, sizeof(struct TT1__getTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTask * SOAP_FMAC6 soap_new_TT1__getTask(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTask(struct soap *soap, struct TT1__getTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTask * SOAP_FMAC4 soap_instantiate_TT1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTask;
		if (size)
			*size = sizeof(struct TT1__getTask);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTask %p -> %p\n", q, p));
	*(struct TT1__getTask*)p = *(struct TT1__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTaskResponse(struct soap *soap, struct TT1__getTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTaskResponse(struct soap *soap, const struct TT1__getTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CTask(soap, &a->pTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTaskResponse(struct soap *soap, const struct TT1__getTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTaskResponse);
	if (soap_out_TT1__getTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTaskResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTaskResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTaskResponse * SOAP_FMAC4 soap_get_TT1__getTaskResponse(struct soap *soap, struct TT1__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTaskResponse * SOAP_FMAC4 soap_in_TT1__getTaskResponse(struct soap *soap, const char *tag, struct TT1__getTaskResponse *a, const char *type)
{
	short soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTaskResponse, sizeof(struct TT1__getTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CTask(soap, "pTask", &a->pTask, "TT1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTaskResponse, 0, sizeof(struct TT1__getTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTaskResponse * SOAP_FMAC6 soap_new_TT1__getTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTaskResponse(struct soap *soap, struct TT1__getTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTaskResponse * SOAP_FMAC4 soap_instantiate_TT1__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTaskResponse;
		if (size)
			*size = sizeof(struct TT1__getTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTaskResponse %p -> %p\n", q, p));
	*(struct TT1__getTaskResponse*)p = *(struct TT1__getTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectAttachment(struct soap *soap, struct TT1__getDefectAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectAttachment(struct soap *soap, const struct TT1__getDefectAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectAttachment(struct soap *soap, const struct TT1__getDefectAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectAttachment);
	if (soap_out_TT1__getDefectAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectAttachment(struct soap *soap, const char *tag, int id, const struct TT1__getDefectAttachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectAttachment), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "pszArchiveName", -1, &a->pszArchiveName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectAttachment * SOAP_FMAC4 soap_get_TT1__getDefectAttachment(struct soap *soap, struct TT1__getDefectAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectAttachment * SOAP_FMAC4 soap_in_TT1__getDefectAttachment(struct soap *soap, const char *tag, struct TT1__getDefectAttachment *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pszArchiveName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectAttachment, sizeof(struct TT1__getDefectAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pszArchiveName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pszArchiveName", &a->pszArchiveName, "xsd:string"))
				{	soap_flag_pszArchiveName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectAttachment, 0, sizeof(struct TT1__getDefectAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectAttachment * SOAP_FMAC6 soap_new_TT1__getDefectAttachment(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectAttachment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectAttachment(struct soap *soap, struct TT1__getDefectAttachment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectAttachment * SOAP_FMAC4 soap_instantiate_TT1__getDefectAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectAttachment;
		if (size)
			*size = sizeof(struct TT1__getDefectAttachment);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectAttachment[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectAttachment);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectAttachment*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectAttachment %p -> %p\n", q, p));
	*(struct TT1__getDefectAttachment*)p = *(struct TT1__getDefectAttachment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectAttachmentResponse(struct soap *soap, struct TT1__getDefectAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectAttachmentResponse(struct soap *soap, const struct TT1__getDefectAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFileAttachment(soap, &a->pAttachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectAttachmentResponse(struct soap *soap, const struct TT1__getDefectAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectAttachmentResponse);
	if (soap_out_TT1__getDefectAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectAttachmentResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDefectAttachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectAttachmentResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFileAttachment(soap, "pAttachment", -1, &a->pAttachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectAttachmentResponse * SOAP_FMAC4 soap_get_TT1__getDefectAttachmentResponse(struct soap *soap, struct TT1__getDefectAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectAttachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectAttachmentResponse * SOAP_FMAC4 soap_in_TT1__getDefectAttachmentResponse(struct soap *soap, const char *tag, struct TT1__getDefectAttachmentResponse *a, const char *type)
{
	short soap_flag_pAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectAttachmentResponse, sizeof(struct TT1__getDefectAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFileAttachment(soap, "pAttachment", &a->pAttachment, "TT1:CFileAttachment"))
				{	soap_flag_pAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectAttachmentResponse, 0, sizeof(struct TT1__getDefectAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectAttachmentResponse * SOAP_FMAC6 soap_new_TT1__getDefectAttachmentResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectAttachmentResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectAttachmentResponse(struct soap *soap, struct TT1__getDefectAttachmentResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectAttachmentResponse * SOAP_FMAC4 soap_instantiate_TT1__getDefectAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectAttachmentResponse;
		if (size)
			*size = sizeof(struct TT1__getDefectAttachmentResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectAttachmentResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectAttachmentResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectAttachmentResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectAttachmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectAttachmentResponse %p -> %p\n", q, p));
	*(struct TT1__getDefectAttachmentResponse*)p = *(struct TT1__getDefectAttachmentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getAttachment(struct soap *soap, struct TT1__getAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_LONG64(soap, &a->eventID);
	soap_default_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getAttachment(struct soap *soap, const struct TT1__getAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->eventID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getAttachment(struct soap *soap, const struct TT1__getAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getAttachment);
	if (soap_out_TT1__getAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getAttachment(struct soap *soap, const char *tag, int id, const struct TT1__getAttachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getAttachment), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "eventID", -1, &a->eventID, ""))
		return soap->error;
	if (soap_out_string(soap, "pszArchiveName", -1, &a->pszArchiveName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getAttachment * SOAP_FMAC4 soap_get_TT1__getAttachment(struct soap *soap, struct TT1__getAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getAttachment * SOAP_FMAC4 soap_in_TT1__getAttachment(struct soap *soap, const char *tag, struct TT1__getAttachment *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1, soap_flag_recordID = 1, soap_flag_eventID = 1, soap_flag_pszArchiveName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getAttachment, sizeof(struct TT1__getAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "eventID", &a->eventID, "xsd:long"))
				{	soap_flag_eventID--;
					continue;
				}
			if (soap_flag_pszArchiveName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pszArchiveName", &a->pszArchiveName, "xsd:string"))
				{	soap_flag_pszArchiveName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getAttachment, 0, sizeof(struct TT1__getAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_eventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getAttachment * SOAP_FMAC6 soap_new_TT1__getAttachment(struct soap *soap, int n)
{	return soap_instantiate_TT1__getAttachment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getAttachment(struct soap *soap, struct TT1__getAttachment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getAttachment * SOAP_FMAC4 soap_instantiate_TT1__getAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getAttachment;
		if (size)
			*size = sizeof(struct TT1__getAttachment);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getAttachment[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getAttachment);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getAttachment*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getAttachment %p -> %p\n", q, p));
	*(struct TT1__getAttachment*)p = *(struct TT1__getAttachment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getAttachmentResponse(struct soap *soap, struct TT1__getAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getAttachmentResponse(struct soap *soap, const struct TT1__getAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CFileAttachment(soap, &a->pAttachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getAttachmentResponse(struct soap *soap, const struct TT1__getAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getAttachmentResponse);
	if (soap_out_TT1__getAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getAttachmentResponse(struct soap *soap, const char *tag, int id, const struct TT1__getAttachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getAttachmentResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CFileAttachment(soap, "pAttachment", -1, &a->pAttachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getAttachmentResponse * SOAP_FMAC4 soap_get_TT1__getAttachmentResponse(struct soap *soap, struct TT1__getAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getAttachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getAttachmentResponse * SOAP_FMAC4 soap_in_TT1__getAttachmentResponse(struct soap *soap, const char *tag, struct TT1__getAttachmentResponse *a, const char *type)
{
	short soap_flag_pAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getAttachmentResponse, sizeof(struct TT1__getAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CFileAttachment(soap, "pAttachment", &a->pAttachment, "TT1:CFileAttachment"))
				{	soap_flag_pAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getAttachmentResponse, 0, sizeof(struct TT1__getAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getAttachmentResponse * SOAP_FMAC6 soap_new_TT1__getAttachmentResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getAttachmentResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getAttachmentResponse(struct soap *soap, struct TT1__getAttachmentResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getAttachmentResponse * SOAP_FMAC4 soap_instantiate_TT1__getAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getAttachmentResponse;
		if (size)
			*size = sizeof(struct TT1__getAttachmentResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getAttachmentResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getAttachmentResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getAttachmentResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getAttachmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getAttachmentResponse %p -> %p\n", q, p));
	*(struct TT1__getAttachmentResponse*)p = *(struct TT1__getAttachmentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveDefect(struct soap *soap, struct TT1__cancelSaveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveDefect(struct soap *soap, const struct TT1__cancelSaveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveDefect(struct soap *soap, const struct TT1__cancelSaveDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveDefect);
	if (soap_out_TT1__cancelSaveDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveDefect(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveDefect * SOAP_FMAC4 soap_get_TT1__cancelSaveDefect(struct soap *soap, struct TT1__cancelSaveDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveDefect * SOAP_FMAC4 soap_in_TT1__cancelSaveDefect(struct soap *soap, const char *tag, struct TT1__cancelSaveDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveDefect, sizeof(struct TT1__cancelSaveDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveDefect, 0, sizeof(struct TT1__cancelSaveDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveDefect * SOAP_FMAC6 soap_new_TT1__cancelSaveDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveDefect(struct soap *soap, struct TT1__cancelSaveDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveDefect * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveDefect;
		if (size)
			*size = sizeof(struct TT1__cancelSaveDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveDefect %p -> %p\n", q, p));
	*(struct TT1__cancelSaveDefect*)p = *(struct TT1__cancelSaveDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveDefectResponse(struct soap *soap, struct TT1__cancelSaveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveDefectResponse(struct soap *soap, const struct TT1__cancelSaveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveDefectResponse(struct soap *soap, const struct TT1__cancelSaveDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveDefectResponse);
	if (soap_out_TT1__cancelSaveDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveDefectResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveDefectResponse(struct soap *soap, struct TT1__cancelSaveDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveDefectResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveDefectResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveDefectResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveDefectResponse, sizeof(struct TT1__cancelSaveDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveDefectResponse, 0, sizeof(struct TT1__cancelSaveDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveDefectResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveDefectResponse(struct soap *soap, struct TT1__cancelSaveDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveDefectResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveDefectResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveDefectResponse*)p = *(struct TT1__cancelSaveDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveDefect(struct soap *soap, struct TT1__saveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveDefect(struct soap *soap, const struct TT1__saveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveDefect(struct soap *soap, const struct TT1__saveDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveDefect);
	if (soap_out_TT1__saveDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveDefect(struct soap *soap, const char *tag, int id, const struct TT1__saveDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveDefect * SOAP_FMAC4 soap_get_TT1__saveDefect(struct soap *soap, struct TT1__saveDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveDefect * SOAP_FMAC4 soap_in_TT1__saveDefect(struct soap *soap, const char *tag, struct TT1__saveDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveDefect, sizeof(struct TT1__saveDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveDefect, 0, sizeof(struct TT1__saveDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveDefect * SOAP_FMAC6 soap_new_TT1__saveDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveDefect(struct soap *soap, struct TT1__saveDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveDefect * SOAP_FMAC4 soap_instantiate_TT1__saveDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveDefect;
		if (size)
			*size = sizeof(struct TT1__saveDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveDefect %p -> %p\n", q, p));
	*(struct TT1__saveDefect*)p = *(struct TT1__saveDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveDefectResponse(struct soap *soap, struct TT1__saveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveDefectResponse(struct soap *soap, const struct TT1__saveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveDefectResponse(struct soap *soap, const struct TT1__saveDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveDefectResponse);
	if (soap_out_TT1__saveDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveDefectResponse * SOAP_FMAC4 soap_get_TT1__saveDefectResponse(struct soap *soap, struct TT1__saveDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveDefectResponse * SOAP_FMAC4 soap_in_TT1__saveDefectResponse(struct soap *soap, const char *tag, struct TT1__saveDefectResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveDefectResponse, sizeof(struct TT1__saveDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveDefectResponse, 0, sizeof(struct TT1__saveDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveDefectResponse * SOAP_FMAC6 soap_new_TT1__saveDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveDefectResponse(struct soap *soap, struct TT1__saveDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__saveDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveDefectResponse;
		if (size)
			*size = sizeof(struct TT1__saveDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveDefectResponse %p -> %p\n", q, p));
	*(struct TT1__saveDefectResponse*)p = *(struct TT1__saveDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editDefectByRecordID(struct soap *soap, struct TT1__editDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editDefectByRecordID(struct soap *soap, const struct TT1__editDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editDefectByRecordID(struct soap *soap, const struct TT1__editDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editDefectByRecordID);
	if (soap_out_TT1__editDefectByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editDefectByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editDefectByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editDefectByRecordID * SOAP_FMAC4 soap_get_TT1__editDefectByRecordID(struct soap *soap, struct TT1__editDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editDefectByRecordID * SOAP_FMAC4 soap_in_TT1__editDefectByRecordID(struct soap *soap, const char *tag, struct TT1__editDefectByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editDefectByRecordID, sizeof(struct TT1__editDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editDefectByRecordID, 0, sizeof(struct TT1__editDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editDefectByRecordID * SOAP_FMAC6 soap_new_TT1__editDefectByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editDefectByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editDefectByRecordID(struct soap *soap, struct TT1__editDefectByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editDefectByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editDefectByRecordID;
		if (size)
			*size = sizeof(struct TT1__editDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editDefectByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editDefectByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editDefectByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editDefectByRecordID %p -> %p\n", q, p));
	*(struct TT1__editDefectByRecordID*)p = *(struct TT1__editDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editDefectByRecordIDResponse(struct soap *soap, struct TT1__editDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editDefectByRecordIDResponse(struct soap *soap, const struct TT1__editDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editDefectByRecordIDResponse(struct soap *soap, const struct TT1__editDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editDefectByRecordIDResponse);
	if (soap_out_TT1__editDefectByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editDefectByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editDefectByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editDefectByRecordIDResponse(struct soap *soap, struct TT1__editDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editDefectByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editDefectByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editDefectByRecordIDResponse *a, const char *type)
{
	short soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editDefectByRecordIDResponse, sizeof(struct TT1__editDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editDefectByRecordIDResponse, 0, sizeof(struct TT1__editDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editDefectByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editDefectByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editDefectByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editDefectByRecordIDResponse(struct soap *soap, struct TT1__editDefectByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editDefectByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editDefectByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editDefectByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editDefectByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editDefectByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editDefectByRecordIDResponse*)p = *(struct TT1__editDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editDefect(struct soap *soap, struct TT1__editDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editDefect(struct soap *soap, const struct TT1__editDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editDefect(struct soap *soap, const struct TT1__editDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editDefect);
	if (soap_out_TT1__editDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editDefect(struct soap *soap, const char *tag, int id, const struct TT1__editDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editDefect * SOAP_FMAC4 soap_get_TT1__editDefect(struct soap *soap, struct TT1__editDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editDefect * SOAP_FMAC4 soap_in_TT1__editDefect(struct soap *soap, const char *tag, struct TT1__editDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_defectNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editDefect, sizeof(struct TT1__editDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editDefect, 0, sizeof(struct TT1__editDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editDefect * SOAP_FMAC6 soap_new_TT1__editDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__editDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editDefect(struct soap *soap, struct TT1__editDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editDefect * SOAP_FMAC4 soap_instantiate_TT1__editDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editDefect;
		if (size)
			*size = sizeof(struct TT1__editDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editDefect %p -> %p\n", q, p));
	*(struct TT1__editDefect*)p = *(struct TT1__editDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editDefectResponse(struct soap *soap, struct TT1__editDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editDefectResponse(struct soap *soap, const struct TT1__editDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editDefectResponse(struct soap *soap, const struct TT1__editDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editDefectResponse);
	if (soap_out_TT1__editDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__editDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editDefectResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editDefectResponse * SOAP_FMAC4 soap_get_TT1__editDefectResponse(struct soap *soap, struct TT1__editDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editDefectResponse * SOAP_FMAC4 soap_in_TT1__editDefectResponse(struct soap *soap, const char *tag, struct TT1__editDefectResponse *a, const char *type)
{
	short soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editDefectResponse, sizeof(struct TT1__editDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editDefectResponse, 0, sizeof(struct TT1__editDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editDefectResponse * SOAP_FMAC6 soap_new_TT1__editDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editDefectResponse(struct soap *soap, struct TT1__editDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__editDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editDefectResponse;
		if (size)
			*size = sizeof(struct TT1__editDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editDefectResponse %p -> %p\n", q, p));
	*(struct TT1__editDefectResponse*)p = *(struct TT1__editDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteDefectByRecordID(struct soap *soap, struct TT1__deleteDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteDefectByRecordID(struct soap *soap, const struct TT1__deleteDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteDefectByRecordID(struct soap *soap, const struct TT1__deleteDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteDefectByRecordID);
	if (soap_out_TT1__deleteDefectByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteDefectByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteDefectByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordID * SOAP_FMAC4 soap_get_TT1__deleteDefectByRecordID(struct soap *soap, struct TT1__deleteDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordID * SOAP_FMAC4 soap_in_TT1__deleteDefectByRecordID(struct soap *soap, const char *tag, struct TT1__deleteDefectByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteDefectByRecordID, sizeof(struct TT1__deleteDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteDefectByRecordID, 0, sizeof(struct TT1__deleteDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteDefectByRecordID * SOAP_FMAC6 soap_new_TT1__deleteDefectByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteDefectByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteDefectByRecordID(struct soap *soap, struct TT1__deleteDefectByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteDefectByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteDefectByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteDefectByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteDefectByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteDefectByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteDefectByRecordID*)p = *(struct TT1__deleteDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteDefectByRecordIDResponse(struct soap *soap, struct TT1__deleteDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteDefectByRecordIDResponse(struct soap *soap, const struct TT1__deleteDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteDefectByRecordIDResponse(struct soap *soap, const struct TT1__deleteDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteDefectByRecordIDResponse);
	if (soap_out_TT1__deleteDefectByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteDefectByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteDefectByRecordIDResponse(struct soap *soap, struct TT1__deleteDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteDefectByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteDefectByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteDefectByRecordIDResponse, sizeof(struct TT1__deleteDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteDefectByRecordIDResponse, 0, sizeof(struct TT1__deleteDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteDefectByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteDefectByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteDefectByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteDefectByRecordIDResponse(struct soap *soap, struct TT1__deleteDefectByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteDefectByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteDefectByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteDefectByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteDefectByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteDefectByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteDefectByRecordIDResponse*)p = *(struct TT1__deleteDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteDefect(struct soap *soap, struct TT1__deleteDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteDefect(struct soap *soap, const struct TT1__deleteDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteDefect(struct soap *soap, const struct TT1__deleteDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteDefect);
	if (soap_out_TT1__deleteDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteDefect(struct soap *soap, const char *tag, int id, const struct TT1__deleteDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteDefect * SOAP_FMAC4 soap_get_TT1__deleteDefect(struct soap *soap, struct TT1__deleteDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteDefect * SOAP_FMAC4 soap_in_TT1__deleteDefect(struct soap *soap, const char *tag, struct TT1__deleteDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_defectNumber = 1, soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteDefect, sizeof(struct TT1__deleteDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteDefect, 0, sizeof(struct TT1__deleteDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteDefect * SOAP_FMAC6 soap_new_TT1__deleteDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteDefect(struct soap *soap, struct TT1__deleteDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteDefect * SOAP_FMAC4 soap_instantiate_TT1__deleteDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteDefect;
		if (size)
			*size = sizeof(struct TT1__deleteDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteDefect %p -> %p\n", q, p));
	*(struct TT1__deleteDefect*)p = *(struct TT1__deleteDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteDefectResponse(struct soap *soap, struct TT1__deleteDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteDefectResponse(struct soap *soap, const struct TT1__deleteDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteDefectResponse(struct soap *soap, const struct TT1__deleteDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteDefectResponse);
	if (soap_out_TT1__deleteDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteDefectResponse * SOAP_FMAC4 soap_get_TT1__deleteDefectResponse(struct soap *soap, struct TT1__deleteDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteDefectResponse * SOAP_FMAC4 soap_in_TT1__deleteDefectResponse(struct soap *soap, const char *tag, struct TT1__deleteDefectResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteDefectResponse, sizeof(struct TT1__deleteDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteDefectResponse, 0, sizeof(struct TT1__deleteDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteDefectResponse * SOAP_FMAC6 soap_new_TT1__deleteDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteDefectResponse(struct soap *soap, struct TT1__deleteDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteDefectResponse;
		if (size)
			*size = sizeof(struct TT1__deleteDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteDefectResponse %p -> %p\n", q, p));
	*(struct TT1__deleteDefectResponse*)p = *(struct TT1__deleteDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDefectWithLink(struct soap *soap, struct TT1__addDefectWithLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
	soap_default_LONG64(soap, &a->testRunRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDefectWithLink(struct soap *soap, const struct TT1__addDefectWithLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
	soap_embedded(soap, &a->testRunRecordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDefectWithLink(struct soap *soap, const struct TT1__addDefectWithLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDefectWithLink);
	if (soap_out_TT1__addDefectWithLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDefectWithLink(struct soap *soap, const char *tag, int id, const struct TT1__addDefectWithLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDefectWithLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunRecordID", -1, &a->testRunRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDefectWithLink * SOAP_FMAC4 soap_get_TT1__addDefectWithLink(struct soap *soap, struct TT1__addDefectWithLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDefectWithLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDefectWithLink * SOAP_FMAC4 soap_in_TT1__addDefectWithLink(struct soap *soap, const char *tag, struct TT1__addDefectWithLink *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pDefect = 1, soap_flag_testRunRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDefectWithLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDefectWithLink, sizeof(struct TT1__addDefectWithLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDefectWithLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap_flag_testRunRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunRecordID", &a->testRunRecordID, "xsd:long"))
				{	soap_flag_testRunRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDefectWithLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDefectWithLink, 0, sizeof(struct TT1__addDefectWithLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDefectWithLink * SOAP_FMAC6 soap_new_TT1__addDefectWithLink(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDefectWithLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDefectWithLink(struct soap *soap, struct TT1__addDefectWithLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDefectWithLink * SOAP_FMAC4 soap_instantiate_TT1__addDefectWithLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDefectWithLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDefectWithLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDefectWithLink;
		if (size)
			*size = sizeof(struct TT1__addDefectWithLink);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDefectWithLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDefectWithLink);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDefectWithLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDefectWithLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDefectWithLink %p -> %p\n", q, p));
	*(struct TT1__addDefectWithLink*)p = *(struct TT1__addDefectWithLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDefectWithLinkResponse(struct soap *soap, struct TT1__addDefectWithLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDefectWithLinkResponse(struct soap *soap, const struct TT1__addDefectWithLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDefectWithLinkResponse(struct soap *soap, const struct TT1__addDefectWithLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDefectWithLinkResponse);
	if (soap_out_TT1__addDefectWithLinkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDefectWithLinkResponse(struct soap *soap, const char *tag, int id, const struct TT1__addDefectWithLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDefectWithLinkResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDefectWithLinkResponse * SOAP_FMAC4 soap_get_TT1__addDefectWithLinkResponse(struct soap *soap, struct TT1__addDefectWithLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDefectWithLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDefectWithLinkResponse * SOAP_FMAC4 soap_in_TT1__addDefectWithLinkResponse(struct soap *soap, const char *tag, struct TT1__addDefectWithLinkResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDefectWithLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDefectWithLinkResponse, sizeof(struct TT1__addDefectWithLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDefectWithLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDefectWithLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDefectWithLinkResponse, 0, sizeof(struct TT1__addDefectWithLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDefectWithLinkResponse * SOAP_FMAC6 soap_new_TT1__addDefectWithLinkResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDefectWithLinkResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDefectWithLinkResponse(struct soap *soap, struct TT1__addDefectWithLinkResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDefectWithLinkResponse * SOAP_FMAC4 soap_instantiate_TT1__addDefectWithLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDefectWithLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDefectWithLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDefectWithLinkResponse;
		if (size)
			*size = sizeof(struct TT1__addDefectWithLinkResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDefectWithLinkResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDefectWithLinkResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDefectWithLinkResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDefectWithLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDefectWithLinkResponse %p -> %p\n", q, p));
	*(struct TT1__addDefectWithLinkResponse*)p = *(struct TT1__addDefectWithLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDefect(struct soap *soap, struct TT1__addDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDefect(struct soap *soap, const struct TT1__addDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDefect(struct soap *soap, const struct TT1__addDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDefect);
	if (soap_out_TT1__addDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDefect(struct soap *soap, const char *tag, int id, const struct TT1__addDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDefect * SOAP_FMAC4 soap_get_TT1__addDefect(struct soap *soap, struct TT1__addDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDefect * SOAP_FMAC4 soap_in_TT1__addDefect(struct soap *soap, const char *tag, struct TT1__addDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDefect, sizeof(struct TT1__addDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDefect, 0, sizeof(struct TT1__addDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDefect * SOAP_FMAC6 soap_new_TT1__addDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDefect(struct soap *soap, struct TT1__addDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDefect * SOAP_FMAC4 soap_instantiate_TT1__addDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDefect;
		if (size)
			*size = sizeof(struct TT1__addDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDefect %p -> %p\n", q, p));
	*(struct TT1__addDefect*)p = *(struct TT1__addDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDefectResponse(struct soap *soap, struct TT1__addDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDefectResponse(struct soap *soap, const struct TT1__addDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDefectResponse(struct soap *soap, const struct TT1__addDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDefectResponse);
	if (soap_out_TT1__addDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__addDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDefectResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDefectResponse * SOAP_FMAC4 soap_get_TT1__addDefectResponse(struct soap *soap, struct TT1__addDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDefectResponse * SOAP_FMAC4 soap_in_TT1__addDefectResponse(struct soap *soap, const char *tag, struct TT1__addDefectResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDefectResponse, sizeof(struct TT1__addDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDefectResponse, 0, sizeof(struct TT1__addDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDefectResponse * SOAP_FMAC6 soap_new_TT1__addDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDefectResponse(struct soap *soap, struct TT1__addDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__addDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDefectResponse;
		if (size)
			*size = sizeof(struct TT1__addDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDefectResponse %p -> %p\n", q, p));
	*(struct TT1__addDefectResponse*)p = *(struct TT1__addDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectByRecordID(struct soap *soap, struct TT1__getDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectByRecordID(struct soap *soap, const struct TT1__getDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectByRecordID(struct soap *soap, const struct TT1__getDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectByRecordID);
	if (soap_out_TT1__getDefectByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getDefectByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectByRecordID * SOAP_FMAC4 soap_get_TT1__getDefectByRecordID(struct soap *soap, struct TT1__getDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectByRecordID * SOAP_FMAC4 soap_in_TT1__getDefectByRecordID(struct soap *soap, const char *tag, struct TT1__getDefectByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectByRecordID, sizeof(struct TT1__getDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectByRecordID, 0, sizeof(struct TT1__getDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectByRecordID * SOAP_FMAC6 soap_new_TT1__getDefectByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectByRecordID(struct soap *soap, struct TT1__getDefectByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectByRecordID;
		if (size)
			*size = sizeof(struct TT1__getDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectByRecordID %p -> %p\n", q, p));
	*(struct TT1__getDefectByRecordID*)p = *(struct TT1__getDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectByRecordIDResponse(struct soap *soap, struct TT1__getDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectByRecordIDResponse(struct soap *soap, const struct TT1__getDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectByRecordIDResponse(struct soap *soap, const struct TT1__getDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectByRecordIDResponse);
	if (soap_out_TT1__getDefectByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDefectByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getDefectByRecordIDResponse(struct soap *soap, struct TT1__getDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getDefectByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getDefectByRecordIDResponse *a, const char *type)
{
	short soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectByRecordIDResponse, sizeof(struct TT1__getDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectByRecordIDResponse, 0, sizeof(struct TT1__getDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getDefectByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectByRecordIDResponse(struct soap *soap, struct TT1__getDefectByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getDefectByRecordIDResponse*)p = *(struct TT1__getDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefect(struct soap *soap, struct TT1__getDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefect(struct soap *soap, const struct TT1__getDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefect(struct soap *soap, const struct TT1__getDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefect);
	if (soap_out_TT1__getDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefect(struct soap *soap, const char *tag, int id, const struct TT1__getDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefect * SOAP_FMAC4 soap_get_TT1__getDefect(struct soap *soap, struct TT1__getDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefect * SOAP_FMAC4 soap_in_TT1__getDefect(struct soap *soap, const char *tag, struct TT1__getDefect *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_defectNumber = 1, soap_flag_summary = 1, soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefect, sizeof(struct TT1__getDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefect, 0, sizeof(struct TT1__getDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefect * SOAP_FMAC6 soap_new_TT1__getDefect(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefect(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefect(struct soap *soap, struct TT1__getDefect *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefect * SOAP_FMAC4 soap_instantiate_TT1__getDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefect;
		if (size)
			*size = sizeof(struct TT1__getDefect);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefect[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefect);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefect*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefect %p -> %p\n", q, p));
	*(struct TT1__getDefect*)p = *(struct TT1__getDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectResponse(struct soap *soap, struct TT1__getDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectResponse(struct soap *soap, const struct TT1__getDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CDefect(soap, &a->pDefect);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectResponse(struct soap *soap, const struct TT1__getDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectResponse);
	if (soap_out_TT1__getDefectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDefectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectResponse * SOAP_FMAC4 soap_get_TT1__getDefectResponse(struct soap *soap, struct TT1__getDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectResponse * SOAP_FMAC4 soap_in_TT1__getDefectResponse(struct soap *soap, const char *tag, struct TT1__getDefectResponse *a, const char *type)
{
	short soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectResponse, sizeof(struct TT1__getDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CDefect(soap, "pDefect", &a->pDefect, "TT1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectResponse, 0, sizeof(struct TT1__getDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectResponse * SOAP_FMAC6 soap_new_TT1__getDefectResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectResponse(struct soap *soap, struct TT1__getDefectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectResponse * SOAP_FMAC4 soap_instantiate_TT1__getDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectResponse;
		if (size)
			*size = sizeof(struct TT1__getDefectResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectResponse %p -> %p\n", q, p));
	*(struct TT1__getDefectResponse*)p = *(struct TT1__getDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, const struct TT1__getDefectCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, const struct TT1__getDefectCustomFieldsDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList);
	if (soap_out_TT1__getDefectCustomFieldsDefinitionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, const char *tag, int id, const struct TT1__getDefectCustomFieldsDefinitionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionList * SOAP_FMAC4 soap_get_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectCustomFieldsDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionList * SOAP_FMAC4 soap_in_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, const char *tag, struct TT1__getDefectCustomFieldsDefinitionList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectCustomFieldsDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList, sizeof(struct TT1__getDefectCustomFieldsDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectCustomFieldsDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectCustomFieldsDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList, 0, sizeof(struct TT1__getDefectCustomFieldsDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectCustomFieldsDefinitionList * SOAP_FMAC6 soap_new_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectCustomFieldsDefinitionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionList * SOAP_FMAC4 soap_instantiate_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectCustomFieldsDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectCustomFieldsDefinitionList;
		if (size)
			*size = sizeof(struct TT1__getDefectCustomFieldsDefinitionList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectCustomFieldsDefinitionList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectCustomFieldsDefinitionList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectCustomFieldsDefinitionList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectCustomFieldsDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectCustomFieldsDefinitionList %p -> %p\n", q, p));
	*(struct TT1__getDefectCustomFieldsDefinitionList*)p = *(struct TT1__getDefectCustomFieldsDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->customFields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const struct TT1__getDefectCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCField(soap, &a->customFields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const struct TT1__getDefectCustomFieldsDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse);
	if (soap_out_TT1__getDefectCustomFieldsDefinitionListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDefectCustomFieldsDefinitionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFields", -1, &a->customFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_get_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectCustomFieldsDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_in_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, struct TT1__getDefectCustomFieldsDefinitionListResponse *a, const char *type)
{
	short soap_flag_customFields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectCustomFieldsDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse, sizeof(struct TT1__getDefectCustomFieldsDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectCustomFieldsDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customFields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFields", &a->customFields, "TT1:CField"))
				{	soap_flag_customFields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectCustomFieldsDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse, 0, sizeof(struct TT1__getDefectCustomFieldsDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC6 soap_new_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectCustomFieldsDefinitionListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getDefectCustomFieldsDefinitionListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_instantiate_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectCustomFieldsDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectCustomFieldsDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectCustomFieldsDefinitionListResponse;
		if (size)
			*size = sizeof(struct TT1__getDefectCustomFieldsDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectCustomFieldsDefinitionListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectCustomFieldsDefinitionListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectCustomFieldsDefinitionListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectCustomFieldsDefinitionListResponse %p -> %p\n", q, p));
	*(struct TT1__getDefectCustomFieldsDefinitionListResponse*)p = *(struct TT1__getDefectCustomFieldsDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomFieldsDefinitionList(struct soap *soap, struct TT1__getCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomFieldsDefinitionList(struct soap *soap, const struct TT1__getCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomFieldsDefinitionList(struct soap *soap, const struct TT1__getCustomFieldsDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomFieldsDefinitionList);
	if (soap_out_TT1__getCustomFieldsDefinitionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomFieldsDefinitionList(struct soap *soap, const char *tag, int id, const struct TT1__getCustomFieldsDefinitionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomFieldsDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionList * SOAP_FMAC4 soap_get_TT1__getCustomFieldsDefinitionList(struct soap *soap, struct TT1__getCustomFieldsDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomFieldsDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionList * SOAP_FMAC4 soap_in_TT1__getCustomFieldsDefinitionList(struct soap *soap, const char *tag, struct TT1__getCustomFieldsDefinitionList *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomFieldsDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomFieldsDefinitionList, sizeof(struct TT1__getCustomFieldsDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomFieldsDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomFieldsDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomFieldsDefinitionList, 0, sizeof(struct TT1__getCustomFieldsDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomFieldsDefinitionList * SOAP_FMAC6 soap_new_TT1__getCustomFieldsDefinitionList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomFieldsDefinitionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomFieldsDefinitionList(struct soap *soap, struct TT1__getCustomFieldsDefinitionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionList * SOAP_FMAC4 soap_instantiate_TT1__getCustomFieldsDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomFieldsDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomFieldsDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomFieldsDefinitionList;
		if (size)
			*size = sizeof(struct TT1__getCustomFieldsDefinitionList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomFieldsDefinitionList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomFieldsDefinitionList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomFieldsDefinitionList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomFieldsDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomFieldsDefinitionList %p -> %p\n", q, p));
	*(struct TT1__getCustomFieldsDefinitionList*)p = *(struct TT1__getCustomFieldsDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->customFields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, const struct TT1__getCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCField(soap, &a->customFields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, const struct TT1__getCustomFieldsDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse);
	if (soap_out_TT1__getCustomFieldsDefinitionListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getCustomFieldsDefinitionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCField(soap, "customFields", -1, &a->customFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_get_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getCustomFieldsDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getCustomFieldsDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_in_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, struct TT1__getCustomFieldsDefinitionListResponse *a, const char *type)
{
	short soap_flag_customFields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getCustomFieldsDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse, sizeof(struct TT1__getCustomFieldsDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getCustomFieldsDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customFields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCField(soap, "customFields", &a->customFields, "TT1:CField"))
				{	soap_flag_customFields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getCustomFieldsDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse, 0, sizeof(struct TT1__getCustomFieldsDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getCustomFieldsDefinitionListResponse * SOAP_FMAC6 soap_new_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getCustomFieldsDefinitionListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, struct TT1__getCustomFieldsDefinitionListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_instantiate_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getCustomFieldsDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getCustomFieldsDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getCustomFieldsDefinitionListResponse;
		if (size)
			*size = sizeof(struct TT1__getCustomFieldsDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getCustomFieldsDefinitionListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getCustomFieldsDefinitionListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getCustomFieldsDefinitionListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getCustomFieldsDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getCustomFieldsDefinitionListResponse %p -> %p\n", q, p));
	*(struct TT1__getCustomFieldsDefinitionListResponse*)p = *(struct TT1__getCustomFieldsDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectEventDefinitionList(struct soap *soap, struct TT1__getDefectEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectEventDefinitionList(struct soap *soap, const struct TT1__getDefectEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectEventDefinitionList(struct soap *soap, const struct TT1__getDefectEventDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectEventDefinitionList);
	if (soap_out_TT1__getDefectEventDefinitionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectEventDefinitionList(struct soap *soap, const char *tag, int id, const struct TT1__getDefectEventDefinitionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectEventDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionList * SOAP_FMAC4 soap_get_TT1__getDefectEventDefinitionList(struct soap *soap, struct TT1__getDefectEventDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectEventDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionList * SOAP_FMAC4 soap_in_TT1__getDefectEventDefinitionList(struct soap *soap, const char *tag, struct TT1__getDefectEventDefinitionList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectEventDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectEventDefinitionList, sizeof(struct TT1__getDefectEventDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectEventDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectEventDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectEventDefinitionList, 0, sizeof(struct TT1__getDefectEventDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectEventDefinitionList * SOAP_FMAC6 soap_new_TT1__getDefectEventDefinitionList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectEventDefinitionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectEventDefinitionList(struct soap *soap, struct TT1__getDefectEventDefinitionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionList * SOAP_FMAC4 soap_instantiate_TT1__getDefectEventDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectEventDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectEventDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectEventDefinitionList;
		if (size)
			*size = sizeof(struct TT1__getDefectEventDefinitionList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectEventDefinitionList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectEventDefinitionList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectEventDefinitionList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectEventDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectEventDefinitionList %p -> %p\n", q, p));
	*(struct TT1__getDefectEventDefinitionList*)p = *(struct TT1__getDefectEventDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDefectEventDefinitionListResponse(struct soap *soap, struct TT1__getDefectEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventDefinitionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDefectEventDefinitionListResponse(struct soap *soap, const struct TT1__getDefectEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCDefectEventDefinition(soap, &a->EventDefinitionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDefectEventDefinitionListResponse(struct soap *soap, const struct TT1__getDefectEventDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDefectEventDefinitionListResponse);
	if (soap_out_TT1__getDefectEventDefinitionListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDefectEventDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDefectEventDefinitionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDefectEventDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCDefectEventDefinition(soap, "EventDefinitionList", -1, &a->EventDefinitionList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionListResponse * SOAP_FMAC4 soap_get_TT1__getDefectEventDefinitionListResponse(struct soap *soap, struct TT1__getDefectEventDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDefectEventDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionListResponse * SOAP_FMAC4 soap_in_TT1__getDefectEventDefinitionListResponse(struct soap *soap, const char *tag, struct TT1__getDefectEventDefinitionListResponse *a, const char *type)
{
	short soap_flag_EventDefinitionList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDefectEventDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDefectEventDefinitionListResponse, sizeof(struct TT1__getDefectEventDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDefectEventDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventDefinitionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCDefectEventDefinition(soap, "EventDefinitionList", &a->EventDefinitionList, "TT1:CDefectEventDefinition"))
				{	soap_flag_EventDefinitionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDefectEventDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDefectEventDefinitionListResponse, 0, sizeof(struct TT1__getDefectEventDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDefectEventDefinitionListResponse * SOAP_FMAC6 soap_new_TT1__getDefectEventDefinitionListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDefectEventDefinitionListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDefectEventDefinitionListResponse(struct soap *soap, struct TT1__getDefectEventDefinitionListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDefectEventDefinitionListResponse * SOAP_FMAC4 soap_instantiate_TT1__getDefectEventDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDefectEventDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDefectEventDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDefectEventDefinitionListResponse;
		if (size)
			*size = sizeof(struct TT1__getDefectEventDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDefectEventDefinitionListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDefectEventDefinitionListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDefectEventDefinitionListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDefectEventDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDefectEventDefinitionListResponse %p -> %p\n", q, p));
	*(struct TT1__getDefectEventDefinitionListResponse*)p = *(struct TT1__getDefectEventDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getEventDefinitionList(struct soap *soap, struct TT1__getEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getEventDefinitionList(struct soap *soap, const struct TT1__getEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getEventDefinitionList(struct soap *soap, const struct TT1__getEventDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getEventDefinitionList);
	if (soap_out_TT1__getEventDefinitionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getEventDefinitionList(struct soap *soap, const char *tag, int id, const struct TT1__getEventDefinitionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getEventDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getEventDefinitionList * SOAP_FMAC4 soap_get_TT1__getEventDefinitionList(struct soap *soap, struct TT1__getEventDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getEventDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getEventDefinitionList * SOAP_FMAC4 soap_in_TT1__getEventDefinitionList(struct soap *soap, const char *tag, struct TT1__getEventDefinitionList *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getEventDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getEventDefinitionList, sizeof(struct TT1__getEventDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getEventDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getEventDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getEventDefinitionList, 0, sizeof(struct TT1__getEventDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getEventDefinitionList * SOAP_FMAC6 soap_new_TT1__getEventDefinitionList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getEventDefinitionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getEventDefinitionList(struct soap *soap, struct TT1__getEventDefinitionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getEventDefinitionList * SOAP_FMAC4 soap_instantiate_TT1__getEventDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getEventDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getEventDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getEventDefinitionList;
		if (size)
			*size = sizeof(struct TT1__getEventDefinitionList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getEventDefinitionList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getEventDefinitionList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getEventDefinitionList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getEventDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getEventDefinitionList %p -> %p\n", q, p));
	*(struct TT1__getEventDefinitionList*)p = *(struct TT1__getEventDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getEventDefinitionListResponse(struct soap *soap, struct TT1__getEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventDefinitionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getEventDefinitionListResponse(struct soap *soap, const struct TT1__getEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCEventDefinition(soap, &a->EventDefinitionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getEventDefinitionListResponse(struct soap *soap, const struct TT1__getEventDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getEventDefinitionListResponse);
	if (soap_out_TT1__getEventDefinitionListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getEventDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getEventDefinitionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getEventDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCEventDefinition(soap, "EventDefinitionList", -1, &a->EventDefinitionList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getEventDefinitionListResponse * SOAP_FMAC4 soap_get_TT1__getEventDefinitionListResponse(struct soap *soap, struct TT1__getEventDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getEventDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getEventDefinitionListResponse * SOAP_FMAC4 soap_in_TT1__getEventDefinitionListResponse(struct soap *soap, const char *tag, struct TT1__getEventDefinitionListResponse *a, const char *type)
{
	short soap_flag_EventDefinitionList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getEventDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getEventDefinitionListResponse, sizeof(struct TT1__getEventDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getEventDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventDefinitionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCEventDefinition(soap, "EventDefinitionList", &a->EventDefinitionList, "TT1:CEventDefinition"))
				{	soap_flag_EventDefinitionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getEventDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getEventDefinitionListResponse, 0, sizeof(struct TT1__getEventDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getEventDefinitionListResponse * SOAP_FMAC6 soap_new_TT1__getEventDefinitionListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getEventDefinitionListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getEventDefinitionListResponse(struct soap *soap, struct TT1__getEventDefinitionListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getEventDefinitionListResponse * SOAP_FMAC4 soap_instantiate_TT1__getEventDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getEventDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getEventDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getEventDefinitionListResponse;
		if (size)
			*size = sizeof(struct TT1__getEventDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getEventDefinitionListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getEventDefinitionListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getEventDefinitionListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getEventDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getEventDefinitionListResponse %p -> %p\n", q, p));
	*(struct TT1__getEventDefinitionListResponse*)p = *(struct TT1__getEventDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getAttachmentTypes(struct soap *soap, struct TT1__getAttachmentTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getAttachmentTypes(struct soap *soap, const struct TT1__getAttachmentTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getAttachmentTypes(struct soap *soap, const struct TT1__getAttachmentTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getAttachmentTypes);
	if (soap_out_TT1__getAttachmentTypes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getAttachmentTypes(struct soap *soap, const char *tag, int id, const struct TT1__getAttachmentTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getAttachmentTypes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getAttachmentTypes * SOAP_FMAC4 soap_get_TT1__getAttachmentTypes(struct soap *soap, struct TT1__getAttachmentTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getAttachmentTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getAttachmentTypes * SOAP_FMAC4 soap_in_TT1__getAttachmentTypes(struct soap *soap, const char *tag, struct TT1__getAttachmentTypes *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getAttachmentTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getAttachmentTypes, sizeof(struct TT1__getAttachmentTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getAttachmentTypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getAttachmentTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getAttachmentTypes, 0, sizeof(struct TT1__getAttachmentTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getAttachmentTypes * SOAP_FMAC6 soap_new_TT1__getAttachmentTypes(struct soap *soap, int n)
{	return soap_instantiate_TT1__getAttachmentTypes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getAttachmentTypes(struct soap *soap, struct TT1__getAttachmentTypes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getAttachmentTypes * SOAP_FMAC4 soap_instantiate_TT1__getAttachmentTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getAttachmentTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getAttachmentTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getAttachmentTypes;
		if (size)
			*size = sizeof(struct TT1__getAttachmentTypes);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getAttachmentTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getAttachmentTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getAttachmentTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getAttachmentTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getAttachmentTypes %p -> %p\n", q, p));
	*(struct TT1__getAttachmentTypes*)p = *(struct TT1__getAttachmentTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getAttachmentTypesResponse(struct soap *soap, struct TT1__getAttachmentTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getAttachmentTypesResponse(struct soap *soap, const struct TT1__getAttachmentTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfstring(soap, &a->pTypeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getAttachmentTypesResponse(struct soap *soap, const struct TT1__getAttachmentTypesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getAttachmentTypesResponse);
	if (soap_out_TT1__getAttachmentTypesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getAttachmentTypesResponse(struct soap *soap, const char *tag, int id, const struct TT1__getAttachmentTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getAttachmentTypesResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfstring(soap, "pTypeList", -1, &a->pTypeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getAttachmentTypesResponse * SOAP_FMAC4 soap_get_TT1__getAttachmentTypesResponse(struct soap *soap, struct TT1__getAttachmentTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getAttachmentTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getAttachmentTypesResponse * SOAP_FMAC4 soap_in_TT1__getAttachmentTypesResponse(struct soap *soap, const char *tag, struct TT1__getAttachmentTypesResponse *a, const char *type)
{
	short soap_flag_pTypeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getAttachmentTypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getAttachmentTypesResponse, sizeof(struct TT1__getAttachmentTypesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getAttachmentTypesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTypeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfstring(soap, "pTypeList", &a->pTypeList, "xsd:string"))
				{	soap_flag_pTypeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getAttachmentTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getAttachmentTypesResponse, 0, sizeof(struct TT1__getAttachmentTypesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getAttachmentTypesResponse * SOAP_FMAC6 soap_new_TT1__getAttachmentTypesResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getAttachmentTypesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getAttachmentTypesResponse(struct soap *soap, struct TT1__getAttachmentTypesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getAttachmentTypesResponse * SOAP_FMAC4 soap_instantiate_TT1__getAttachmentTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getAttachmentTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getAttachmentTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getAttachmentTypesResponse;
		if (size)
			*size = sizeof(struct TT1__getAttachmentTypesResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getAttachmentTypesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getAttachmentTypesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getAttachmentTypesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getAttachmentTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getAttachmentTypesResponse %p -> %p\n", q, p));
	*(struct TT1__getAttachmentTypesResponse*)p = *(struct TT1__getAttachmentTypesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestConfig(struct soap *soap, struct TT1__cancelSaveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestConfig(struct soap *soap, const struct TT1__cancelSaveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestConfig(struct soap *soap, const struct TT1__cancelSaveTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestConfig);
	if (soap_out_TT1__cancelSaveTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfig * SOAP_FMAC4 soap_get_TT1__cancelSaveTestConfig(struct soap *soap, struct TT1__cancelSaveTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfig * SOAP_FMAC4 soap_in_TT1__cancelSaveTestConfig(struct soap *soap, const char *tag, struct TT1__cancelSaveTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestConfig, sizeof(struct TT1__cancelSaveTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestConfig, 0, sizeof(struct TT1__cancelSaveTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestConfig * SOAP_FMAC6 soap_new_TT1__cancelSaveTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestConfig(struct soap *soap, struct TT1__cancelSaveTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfig * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestConfig;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestConfig %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestConfig*)p = *(struct TT1__cancelSaveTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__cancelSaveTestConfigResponse(struct soap *soap, struct TT1__cancelSaveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__cancelSaveTestConfigResponse(struct soap *soap, const struct TT1__cancelSaveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__cancelSaveTestConfigResponse(struct soap *soap, const struct TT1__cancelSaveTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__cancelSaveTestConfigResponse);
	if (soap_out_TT1__cancelSaveTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__cancelSaveTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__cancelSaveTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__cancelSaveTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfigResponse * SOAP_FMAC4 soap_get_TT1__cancelSaveTestConfigResponse(struct soap *soap, struct TT1__cancelSaveTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__cancelSaveTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfigResponse * SOAP_FMAC4 soap_in_TT1__cancelSaveTestConfigResponse(struct soap *soap, const char *tag, struct TT1__cancelSaveTestConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__cancelSaveTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__cancelSaveTestConfigResponse, sizeof(struct TT1__cancelSaveTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__cancelSaveTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__cancelSaveTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__cancelSaveTestConfigResponse, 0, sizeof(struct TT1__cancelSaveTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__cancelSaveTestConfigResponse * SOAP_FMAC6 soap_new_TT1__cancelSaveTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__cancelSaveTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__cancelSaveTestConfigResponse(struct soap *soap, struct TT1__cancelSaveTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__cancelSaveTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__cancelSaveTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__cancelSaveTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__cancelSaveTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__cancelSaveTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__cancelSaveTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__cancelSaveTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__cancelSaveTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__cancelSaveTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__cancelSaveTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__cancelSaveTestConfigResponse*)p = *(struct TT1__cancelSaveTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestConfigByRecordID(struct soap *soap, struct TT1__deleteTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestConfigByRecordID(struct soap *soap, const struct TT1__deleteTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestConfigByRecordID(struct soap *soap, const struct TT1__deleteTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestConfigByRecordID);
	if (soap_out_TT1__deleteTestConfigByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestConfigByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordID * SOAP_FMAC4 soap_get_TT1__deleteTestConfigByRecordID(struct soap *soap, struct TT1__deleteTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordID * SOAP_FMAC4 soap_in_TT1__deleteTestConfigByRecordID(struct soap *soap, const char *tag, struct TT1__deleteTestConfigByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestConfigByRecordID, sizeof(struct TT1__deleteTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestConfigByRecordID, 0, sizeof(struct TT1__deleteTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestConfigByRecordID * SOAP_FMAC6 soap_new_TT1__deleteTestConfigByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestConfigByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestConfigByRecordID(struct soap *soap, struct TT1__deleteTestConfigByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordID * SOAP_FMAC4 soap_instantiate_TT1__deleteTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigByRecordID;
		if (size)
			*size = sizeof(struct TT1__deleteTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestConfigByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestConfigByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestConfigByRecordID %p -> %p\n", q, p));
	*(struct TT1__deleteTestConfigByRecordID*)p = *(struct TT1__deleteTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, struct TT1__deleteTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__deleteTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse);
	if (soap_out_TT1__deleteTestConfigByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestConfigByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, struct TT1__deleteTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__deleteTestConfigByRecordIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse, sizeof(struct TT1__deleteTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse, 0, sizeof(struct TT1__deleteTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestConfigByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestConfigByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, struct TT1__deleteTestConfigByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestConfigByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestConfigByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestConfigByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestConfigByRecordIDResponse*)p = *(struct TT1__deleteTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestConfig(struct soap *soap, struct TT1__deleteTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestConfig(struct soap *soap, const struct TT1__deleteTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestConfig(struct soap *soap, const struct TT1__deleteTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestConfig);
	if (soap_out_TT1__deleteTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestConfig * SOAP_FMAC4 soap_get_TT1__deleteTestConfig(struct soap *soap, struct TT1__deleteTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestConfig * SOAP_FMAC4 soap_in_TT1__deleteTestConfig(struct soap *soap, const char *tag, struct TT1__deleteTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestConfig, sizeof(struct TT1__deleteTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestConfig, 0, sizeof(struct TT1__deleteTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestConfig * SOAP_FMAC6 soap_new_TT1__deleteTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestConfig(struct soap *soap, struct TT1__deleteTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestConfig * SOAP_FMAC4 soap_instantiate_TT1__deleteTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestConfig;
		if (size)
			*size = sizeof(struct TT1__deleteTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestConfig %p -> %p\n", q, p));
	*(struct TT1__deleteTestConfig*)p = *(struct TT1__deleteTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__deleteTestConfigResponse(struct soap *soap, struct TT1__deleteTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__deleteTestConfigResponse(struct soap *soap, const struct TT1__deleteTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__deleteTestConfigResponse(struct soap *soap, const struct TT1__deleteTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__deleteTestConfigResponse);
	if (soap_out_TT1__deleteTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__deleteTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__deleteTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__deleteTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__deleteTestConfigResponse * SOAP_FMAC4 soap_get_TT1__deleteTestConfigResponse(struct soap *soap, struct TT1__deleteTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__deleteTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__deleteTestConfigResponse * SOAP_FMAC4 soap_in_TT1__deleteTestConfigResponse(struct soap *soap, const char *tag, struct TT1__deleteTestConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__deleteTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__deleteTestConfigResponse, sizeof(struct TT1__deleteTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__deleteTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__deleteTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__deleteTestConfigResponse, 0, sizeof(struct TT1__deleteTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__deleteTestConfigResponse * SOAP_FMAC6 soap_new_TT1__deleteTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__deleteTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__deleteTestConfigResponse(struct soap *soap, struct TT1__deleteTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__deleteTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__deleteTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__deleteTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__deleteTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__deleteTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__deleteTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__deleteTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__deleteTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__deleteTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__deleteTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__deleteTestConfigResponse*)p = *(struct TT1__deleteTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestConfig(struct soap *soap, struct TT1__saveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestConfig(struct soap *soap, const struct TT1__saveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestConfig(struct soap *soap, const struct TT1__saveTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestConfig);
	if (soap_out_TT1__saveTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__saveTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestConfig * SOAP_FMAC4 soap_get_TT1__saveTestConfig(struct soap *soap, struct TT1__saveTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestConfig * SOAP_FMAC4 soap_in_TT1__saveTestConfig(struct soap *soap, const char *tag, struct TT1__saveTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestConfig, sizeof(struct TT1__saveTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestConfig, 0, sizeof(struct TT1__saveTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestConfig * SOAP_FMAC6 soap_new_TT1__saveTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestConfig(struct soap *soap, struct TT1__saveTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestConfig * SOAP_FMAC4 soap_instantiate_TT1__saveTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestConfig;
		if (size)
			*size = sizeof(struct TT1__saveTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestConfig %p -> %p\n", q, p));
	*(struct TT1__saveTestConfig*)p = *(struct TT1__saveTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__saveTestConfigResponse(struct soap *soap, struct TT1__saveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__saveTestConfigResponse(struct soap *soap, const struct TT1__saveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__saveTestConfigResponse(struct soap *soap, const struct TT1__saveTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__saveTestConfigResponse);
	if (soap_out_TT1__saveTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__saveTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__saveTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__saveTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__saveTestConfigResponse * SOAP_FMAC4 soap_get_TT1__saveTestConfigResponse(struct soap *soap, struct TT1__saveTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__saveTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__saveTestConfigResponse * SOAP_FMAC4 soap_in_TT1__saveTestConfigResponse(struct soap *soap, const char *tag, struct TT1__saveTestConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__saveTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__saveTestConfigResponse, sizeof(struct TT1__saveTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__saveTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__saveTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__saveTestConfigResponse, 0, sizeof(struct TT1__saveTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__saveTestConfigResponse * SOAP_FMAC6 soap_new_TT1__saveTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__saveTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__saveTestConfigResponse(struct soap *soap, struct TT1__saveTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__saveTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__saveTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__saveTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__saveTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__saveTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__saveTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__saveTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__saveTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__saveTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__saveTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__saveTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__saveTestConfigResponse*)p = *(struct TT1__saveTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestConfigByRecordID(struct soap *soap, struct TT1__editTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestConfigByRecordID(struct soap *soap, const struct TT1__editTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestConfigByRecordID(struct soap *soap, const struct TT1__editTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestConfigByRecordID);
	if (soap_out_TT1__editTestConfigByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__editTestConfigByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordID * SOAP_FMAC4 soap_get_TT1__editTestConfigByRecordID(struct soap *soap, struct TT1__editTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordID * SOAP_FMAC4 soap_in_TT1__editTestConfigByRecordID(struct soap *soap, const char *tag, struct TT1__editTestConfigByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestConfigByRecordID, sizeof(struct TT1__editTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestConfigByRecordID, 0, sizeof(struct TT1__editTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestConfigByRecordID * SOAP_FMAC6 soap_new_TT1__editTestConfigByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestConfigByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestConfigByRecordID(struct soap *soap, struct TT1__editTestConfigByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordID * SOAP_FMAC4 soap_instantiate_TT1__editTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestConfigByRecordID;
		if (size)
			*size = sizeof(struct TT1__editTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestConfigByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestConfigByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestConfigByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestConfigByRecordID %p -> %p\n", q, p));
	*(struct TT1__editTestConfigByRecordID*)p = *(struct TT1__editTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestConfigByRecordIDResponse(struct soap *soap, struct TT1__editTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__editTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__editTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestConfigByRecordIDResponse);
	if (soap_out_TT1__editTestConfigByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestConfigByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__editTestConfigByRecordIDResponse(struct soap *soap, struct TT1__editTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__editTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__editTestConfigByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestConfigByRecordIDResponse, sizeof(struct TT1__editTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestConfigByRecordIDResponse, 0, sizeof(struct TT1__editTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestConfigByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__editTestConfigByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestConfigByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestConfigByRecordIDResponse(struct soap *soap, struct TT1__editTestConfigByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestConfigByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestConfigByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__editTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestConfigByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestConfigByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestConfigByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__editTestConfigByRecordIDResponse*)p = *(struct TT1__editTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestConfig(struct soap *soap, struct TT1__editTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestConfig(struct soap *soap, const struct TT1__editTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestConfig(struct soap *soap, const struct TT1__editTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestConfig);
	if (soap_out_TT1__editTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__editTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestConfig * SOAP_FMAC4 soap_get_TT1__editTestConfig(struct soap *soap, struct TT1__editTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestConfig * SOAP_FMAC4 soap_in_TT1__editTestConfig(struct soap *soap, const char *tag, struct TT1__editTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestConfig, sizeof(struct TT1__editTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestConfig, 0, sizeof(struct TT1__editTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestConfig * SOAP_FMAC6 soap_new_TT1__editTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestConfig(struct soap *soap, struct TT1__editTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestConfig * SOAP_FMAC4 soap_instantiate_TT1__editTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestConfig;
		if (size)
			*size = sizeof(struct TT1__editTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestConfig %p -> %p\n", q, p));
	*(struct TT1__editTestConfig*)p = *(struct TT1__editTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__editTestConfigResponse(struct soap *soap, struct TT1__editTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__editTestConfigResponse(struct soap *soap, const struct TT1__editTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__editTestConfigResponse(struct soap *soap, const struct TT1__editTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__editTestConfigResponse);
	if (soap_out_TT1__editTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__editTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__editTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__editTestConfigResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__editTestConfigResponse * SOAP_FMAC4 soap_get_TT1__editTestConfigResponse(struct soap *soap, struct TT1__editTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__editTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__editTestConfigResponse * SOAP_FMAC4 soap_in_TT1__editTestConfigResponse(struct soap *soap, const char *tag, struct TT1__editTestConfigResponse *a, const char *type)
{
	short soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__editTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__editTestConfigResponse, sizeof(struct TT1__editTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__editTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__editTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__editTestConfigResponse, 0, sizeof(struct TT1__editTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__editTestConfigResponse * SOAP_FMAC6 soap_new_TT1__editTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__editTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__editTestConfigResponse(struct soap *soap, struct TT1__editTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__editTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__editTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__editTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__editTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__editTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__editTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__editTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__editTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__editTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__editTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__editTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__editTestConfigResponse*)p = *(struct TT1__editTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTestConfig(struct soap *soap, struct TT1__addTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTestConfig(struct soap *soap, const struct TT1__addTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTestConfig(struct soap *soap, const struct TT1__addTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTestConfig);
	if (soap_out_TT1__addTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__addTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTestConfig * SOAP_FMAC4 soap_get_TT1__addTestConfig(struct soap *soap, struct TT1__addTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTestConfig * SOAP_FMAC4 soap_in_TT1__addTestConfig(struct soap *soap, const char *tag, struct TT1__addTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTestConfig, sizeof(struct TT1__addTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTestConfig, 0, sizeof(struct TT1__addTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTestConfig * SOAP_FMAC6 soap_new_TT1__addTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTestConfig(struct soap *soap, struct TT1__addTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTestConfig * SOAP_FMAC4 soap_instantiate_TT1__addTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTestConfig;
		if (size)
			*size = sizeof(struct TT1__addTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTestConfig %p -> %p\n", q, p));
	*(struct TT1__addTestConfig*)p = *(struct TT1__addTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addTestConfigResponse(struct soap *soap, struct TT1__addTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addTestConfigResponse(struct soap *soap, const struct TT1__addTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addTestConfigResponse(struct soap *soap, const struct TT1__addTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addTestConfigResponse);
	if (soap_out_TT1__addTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__addTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addTestConfigResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addTestConfigResponse * SOAP_FMAC4 soap_get_TT1__addTestConfigResponse(struct soap *soap, struct TT1__addTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addTestConfigResponse * SOAP_FMAC4 soap_in_TT1__addTestConfigResponse(struct soap *soap, const char *tag, struct TT1__addTestConfigResponse *a, const char *type)
{
	short soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addTestConfigResponse, sizeof(struct TT1__addTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addTestConfigResponse, 0, sizeof(struct TT1__addTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addTestConfigResponse * SOAP_FMAC6 soap_new_TT1__addTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addTestConfigResponse(struct soap *soap, struct TT1__addTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__addTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__addTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__addTestConfigResponse*)p = *(struct TT1__addTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestConfigByRecordID(struct soap *soap, struct TT1__getTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestConfigByRecordID(struct soap *soap, const struct TT1__getTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestConfigByRecordID(struct soap *soap, const struct TT1__getTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestConfigByRecordID);
	if (soap_out_TT1__getTestConfigByRecordID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct TT1__getTestConfigByRecordID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordID * SOAP_FMAC4 soap_get_TT1__getTestConfigByRecordID(struct soap *soap, struct TT1__getTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordID * SOAP_FMAC4 soap_in_TT1__getTestConfigByRecordID(struct soap *soap, const char *tag, struct TT1__getTestConfigByRecordID *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestConfigByRecordID, sizeof(struct TT1__getTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestConfigByRecordID, 0, sizeof(struct TT1__getTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestConfigByRecordID * SOAP_FMAC6 soap_new_TT1__getTestConfigByRecordID(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestConfigByRecordID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestConfigByRecordID(struct soap *soap, struct TT1__getTestConfigByRecordID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordID * SOAP_FMAC4 soap_instantiate_TT1__getTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestConfigByRecordID;
		if (size)
			*size = sizeof(struct TT1__getTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestConfigByRecordID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestConfigByRecordID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestConfigByRecordID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestConfigByRecordID %p -> %p\n", q, p));
	*(struct TT1__getTestConfigByRecordID*)p = *(struct TT1__getTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestConfigByRecordIDResponse(struct soap *soap, struct TT1__getTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__getTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestConfigByRecordIDResponse(struct soap *soap, const struct TT1__getTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestConfigByRecordIDResponse);
	if (soap_out_TT1__getTestConfigByRecordIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestConfigByRecordIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_TT1__getTestConfigByRecordIDResponse(struct soap *soap, struct TT1__getTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_TT1__getTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct TT1__getTestConfigByRecordIDResponse *a, const char *type)
{
	short soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestConfigByRecordIDResponse, sizeof(struct TT1__getTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestConfigByRecordIDResponse, 0, sizeof(struct TT1__getTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestConfigByRecordIDResponse * SOAP_FMAC6 soap_new_TT1__getTestConfigByRecordIDResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestConfigByRecordIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestConfigByRecordIDResponse(struct soap *soap, struct TT1__getTestConfigByRecordIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestConfigByRecordIDResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestConfigByRecordIDResponse;
		if (size)
			*size = sizeof(struct TT1__getTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestConfigByRecordIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestConfigByRecordIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestConfigByRecordIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct TT1__getTestConfigByRecordIDResponse*)p = *(struct TT1__getTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestConfig(struct soap *soap, struct TT1__getTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestConfig(struct soap *soap, const struct TT1__getTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestConfig(struct soap *soap, const struct TT1__getTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestConfig);
	if (soap_out_TT1__getTestConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestConfig(struct soap *soap, const char *tag, int id, const struct TT1__getTestConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestConfig * SOAP_FMAC4 soap_get_TT1__getTestConfig(struct soap *soap, struct TT1__getTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestConfig * SOAP_FMAC4 soap_in_TT1__getTestConfig(struct soap *soap, const char *tag, struct TT1__getTestConfig *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestConfig, sizeof(struct TT1__getTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestConfig, 0, sizeof(struct TT1__getTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestConfig * SOAP_FMAC6 soap_new_TT1__getTestConfig(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestConfig(struct soap *soap, struct TT1__getTestConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestConfig * SOAP_FMAC4 soap_instantiate_TT1__getTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestConfig;
		if (size)
			*size = sizeof(struct TT1__getTestConfig);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestConfig %p -> %p\n", q, p));
	*(struct TT1__getTestConfig*)p = *(struct TT1__getTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTestConfigResponse(struct soap *soap, struct TT1__getTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTestConfigResponse(struct soap *soap, const struct TT1__getTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CSystem(soap, &a->pTestConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTestConfigResponse(struct soap *soap, const struct TT1__getTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTestConfigResponse);
	if (soap_out_TT1__getTestConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTestConfigResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTestConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTestConfigResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTestConfigResponse * SOAP_FMAC4 soap_get_TT1__getTestConfigResponse(struct soap *soap, struct TT1__getTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTestConfigResponse * SOAP_FMAC4 soap_in_TT1__getTestConfigResponse(struct soap *soap, const char *tag, struct TT1__getTestConfigResponse *a, const char *type)
{
	short soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTestConfigResponse, sizeof(struct TT1__getTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CSystem(soap, "pTestConfig", &a->pTestConfig, "TT1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTestConfigResponse, 0, sizeof(struct TT1__getTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTestConfigResponse * SOAP_FMAC6 soap_new_TT1__getTestConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTestConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTestConfigResponse(struct soap *soap, struct TT1__getTestConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTestConfigResponse * SOAP_FMAC4 soap_instantiate_TT1__getTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTestConfigResponse;
		if (size)
			*size = sizeof(struct TT1__getTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTestConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTestConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTestConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTestConfigResponse %p -> %p\n", q, p));
	*(struct TT1__getTestConfigResponse*)p = *(struct TT1__getTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRecordListForTable(struct soap *soap, struct TT1__getRecordListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->filtername);
	a->columnlist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRecordListForTable(struct soap *soap, const struct TT1__getRecordListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->filtername);
	soap_serialize_PointerToTT1ArrayOfCTableColumn(soap, &a->columnlist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRecordListForTable(struct soap *soap, const struct TT1__getRecordListForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRecordListForTable);
	if (soap_out_TT1__getRecordListForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRecordListForTable(struct soap *soap, const char *tag, int id, const struct TT1__getRecordListForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRecordListForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "filtername", -1, &a->filtername, ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTableColumn(soap, "columnlist", -1, &a->columnlist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRecordListForTable * SOAP_FMAC4 soap_get_TT1__getRecordListForTable(struct soap *soap, struct TT1__getRecordListForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRecordListForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRecordListForTable * SOAP_FMAC4 soap_in_TT1__getRecordListForTable(struct soap *soap, const char *tag, struct TT1__getRecordListForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1, soap_flag_filtername = 1, soap_flag_columnlist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRecordListForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRecordListForTable, sizeof(struct TT1__getRecordListForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRecordListForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_filtername && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filtername", &a->filtername, "xsd:string"))
				{	soap_flag_filtername--;
					continue;
				}
			if (soap_flag_columnlist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTableColumn(soap, "columnlist", &a->columnlist, "TT1:CTableColumn"))
				{	soap_flag_columnlist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRecordListForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRecordListForTable, 0, sizeof(struct TT1__getRecordListForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRecordListForTable * SOAP_FMAC6 soap_new_TT1__getRecordListForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRecordListForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRecordListForTable(struct soap *soap, struct TT1__getRecordListForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRecordListForTable * SOAP_FMAC4 soap_instantiate_TT1__getRecordListForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRecordListForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRecordListForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRecordListForTable;
		if (size)
			*size = sizeof(struct TT1__getRecordListForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRecordListForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRecordListForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRecordListForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRecordListForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRecordListForTable %p -> %p\n", q, p));
	*(struct TT1__getRecordListForTable*)p = *(struct TT1__getRecordListForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getRecordListForTableResponse(struct soap *soap, struct TT1__getRecordListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->recordlist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getRecordListForTableResponse(struct soap *soap, const struct TT1__getRecordListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CRecordListSoap(soap, &a->recordlist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getRecordListForTableResponse(struct soap *soap, const struct TT1__getRecordListForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getRecordListForTableResponse);
	if (soap_out_TT1__getRecordListForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getRecordListForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__getRecordListForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getRecordListForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1__CRecordListSoap(soap, "recordlist", -1, &a->recordlist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getRecordListForTableResponse * SOAP_FMAC4 soap_get_TT1__getRecordListForTableResponse(struct soap *soap, struct TT1__getRecordListForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getRecordListForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getRecordListForTableResponse * SOAP_FMAC4 soap_in_TT1__getRecordListForTableResponse(struct soap *soap, const char *tag, struct TT1__getRecordListForTableResponse *a, const char *type)
{
	short soap_flag_recordlist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getRecordListForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getRecordListForTableResponse, sizeof(struct TT1__getRecordListForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getRecordListForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordlist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CRecordListSoap(soap, "recordlist", &a->recordlist, "TT1:CRecordListSoap"))
				{	soap_flag_recordlist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getRecordListForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getRecordListForTableResponse, 0, sizeof(struct TT1__getRecordListForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getRecordListForTableResponse * SOAP_FMAC6 soap_new_TT1__getRecordListForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getRecordListForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getRecordListForTableResponse(struct soap *soap, struct TT1__getRecordListForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getRecordListForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__getRecordListForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getRecordListForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getRecordListForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getRecordListForTableResponse;
		if (size)
			*size = sizeof(struct TT1__getRecordListForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getRecordListForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getRecordListForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getRecordListForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getRecordListForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getRecordListForTableResponse %p -> %p\n", q, p));
	*(struct TT1__getRecordListForTableResponse*)p = *(struct TT1__getRecordListForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFilterListForTable(struct soap *soap, struct TT1__getFilterListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFilterListForTable(struct soap *soap, const struct TT1__getFilterListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFilterListForTable(struct soap *soap, const struct TT1__getFilterListForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFilterListForTable);
	if (soap_out_TT1__getFilterListForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFilterListForTable(struct soap *soap, const char *tag, int id, const struct TT1__getFilterListForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFilterListForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFilterListForTable * SOAP_FMAC4 soap_get_TT1__getFilterListForTable(struct soap *soap, struct TT1__getFilterListForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFilterListForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFilterListForTable * SOAP_FMAC4 soap_in_TT1__getFilterListForTable(struct soap *soap, const char *tag, struct TT1__getFilterListForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFilterListForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFilterListForTable, sizeof(struct TT1__getFilterListForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFilterListForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFilterListForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFilterListForTable, 0, sizeof(struct TT1__getFilterListForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFilterListForTable * SOAP_FMAC6 soap_new_TT1__getFilterListForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFilterListForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFilterListForTable(struct soap *soap, struct TT1__getFilterListForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFilterListForTable * SOAP_FMAC4 soap_instantiate_TT1__getFilterListForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFilterListForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFilterListForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFilterListForTable;
		if (size)
			*size = sizeof(struct TT1__getFilterListForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFilterListForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFilterListForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFilterListForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFilterListForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFilterListForTable %p -> %p\n", q, p));
	*(struct TT1__getFilterListForTable*)p = *(struct TT1__getFilterListForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFilterListForTableResponse(struct soap *soap, struct TT1__getFilterListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFilterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFilterListForTableResponse(struct soap *soap, const struct TT1__getFilterListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFilter(soap, &a->pFilterList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFilterListForTableResponse(struct soap *soap, const struct TT1__getFilterListForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFilterListForTableResponse);
	if (soap_out_TT1__getFilterListForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFilterListForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__getFilterListForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFilterListForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFilter(soap, "pFilterList", -1, &a->pFilterList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFilterListForTableResponse * SOAP_FMAC4 soap_get_TT1__getFilterListForTableResponse(struct soap *soap, struct TT1__getFilterListForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFilterListForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFilterListForTableResponse * SOAP_FMAC4 soap_in_TT1__getFilterListForTableResponse(struct soap *soap, const char *tag, struct TT1__getFilterListForTableResponse *a, const char *type)
{
	short soap_flag_pFilterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFilterListForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFilterListForTableResponse, sizeof(struct TT1__getFilterListForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFilterListForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFilterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFilter(soap, "pFilterList", &a->pFilterList, "TT1:CFilter"))
				{	soap_flag_pFilterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFilterListForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFilterListForTableResponse, 0, sizeof(struct TT1__getFilterListForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFilterListForTableResponse * SOAP_FMAC6 soap_new_TT1__getFilterListForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFilterListForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFilterListForTableResponse(struct soap *soap, struct TT1__getFilterListForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFilterListForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__getFilterListForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFilterListForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFilterListForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFilterListForTableResponse;
		if (size)
			*size = sizeof(struct TT1__getFilterListForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFilterListForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFilterListForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFilterListForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFilterListForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFilterListForTableResponse %p -> %p\n", q, p));
	*(struct TT1__getFilterListForTableResponse*)p = *(struct TT1__getFilterListForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFilterList(struct soap *soap, struct TT1__getFilterList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFilterList(struct soap *soap, const struct TT1__getFilterList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFilterList(struct soap *soap, const struct TT1__getFilterList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFilterList);
	if (soap_out_TT1__getFilterList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFilterList(struct soap *soap, const char *tag, int id, const struct TT1__getFilterList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFilterList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFilterList * SOAP_FMAC4 soap_get_TT1__getFilterList(struct soap *soap, struct TT1__getFilterList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFilterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFilterList * SOAP_FMAC4 soap_in_TT1__getFilterList(struct soap *soap, const char *tag, struct TT1__getFilterList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFilterList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFilterList, sizeof(struct TT1__getFilterList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFilterList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFilterList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFilterList, 0, sizeof(struct TT1__getFilterList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFilterList * SOAP_FMAC6 soap_new_TT1__getFilterList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFilterList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFilterList(struct soap *soap, struct TT1__getFilterList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFilterList * SOAP_FMAC4 soap_instantiate_TT1__getFilterList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFilterList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFilterList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFilterList;
		if (size)
			*size = sizeof(struct TT1__getFilterList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFilterList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFilterList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFilterList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFilterList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFilterList %p -> %p\n", q, p));
	*(struct TT1__getFilterList*)p = *(struct TT1__getFilterList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getFilterListResponse(struct soap *soap, struct TT1__getFilterListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFilterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getFilterListResponse(struct soap *soap, const struct TT1__getFilterListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFilter(soap, &a->pFilterList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getFilterListResponse(struct soap *soap, const struct TT1__getFilterListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getFilterListResponse);
	if (soap_out_TT1__getFilterListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getFilterListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getFilterListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getFilterListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFilter(soap, "pFilterList", -1, &a->pFilterList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getFilterListResponse * SOAP_FMAC4 soap_get_TT1__getFilterListResponse(struct soap *soap, struct TT1__getFilterListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getFilterListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getFilterListResponse * SOAP_FMAC4 soap_in_TT1__getFilterListResponse(struct soap *soap, const char *tag, struct TT1__getFilterListResponse *a, const char *type)
{
	short soap_flag_pFilterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getFilterListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getFilterListResponse, sizeof(struct TT1__getFilterListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getFilterListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFilterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFilter(soap, "pFilterList", &a->pFilterList, "TT1:CFilter"))
				{	soap_flag_pFilterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getFilterListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getFilterListResponse, 0, sizeof(struct TT1__getFilterListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getFilterListResponse * SOAP_FMAC6 soap_new_TT1__getFilterListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getFilterListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getFilterListResponse(struct soap *soap, struct TT1__getFilterListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getFilterListResponse * SOAP_FMAC4 soap_instantiate_TT1__getFilterListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getFilterListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getFilterListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getFilterListResponse;
		if (size)
			*size = sizeof(struct TT1__getFilterListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getFilterListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getFilterListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getFilterListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getFilterListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getFilterListResponse %p -> %p\n", q, p));
	*(struct TT1__getFilterListResponse*)p = *(struct TT1__getFilterListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getColumnsForTable(struct soap *soap, struct TT1__getColumnsForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getColumnsForTable(struct soap *soap, const struct TT1__getColumnsForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getColumnsForTable(struct soap *soap, const struct TT1__getColumnsForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getColumnsForTable);
	if (soap_out_TT1__getColumnsForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getColumnsForTable(struct soap *soap, const char *tag, int id, const struct TT1__getColumnsForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getColumnsForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getColumnsForTable * SOAP_FMAC4 soap_get_TT1__getColumnsForTable(struct soap *soap, struct TT1__getColumnsForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getColumnsForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getColumnsForTable * SOAP_FMAC4 soap_in_TT1__getColumnsForTable(struct soap *soap, const char *tag, struct TT1__getColumnsForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getColumnsForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getColumnsForTable, sizeof(struct TT1__getColumnsForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getColumnsForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getColumnsForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getColumnsForTable, 0, sizeof(struct TT1__getColumnsForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getColumnsForTable * SOAP_FMAC6 soap_new_TT1__getColumnsForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__getColumnsForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getColumnsForTable(struct soap *soap, struct TT1__getColumnsForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getColumnsForTable * SOAP_FMAC4 soap_instantiate_TT1__getColumnsForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getColumnsForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getColumnsForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getColumnsForTable;
		if (size)
			*size = sizeof(struct TT1__getColumnsForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getColumnsForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getColumnsForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getColumnsForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getColumnsForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getColumnsForTable %p -> %p\n", q, p));
	*(struct TT1__getColumnsForTable*)p = *(struct TT1__getColumnsForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getColumnsForTableResponse(struct soap *soap, struct TT1__getColumnsForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pColumnList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getColumnsForTableResponse(struct soap *soap, const struct TT1__getColumnsForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCTableColumn(soap, &a->pColumnList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getColumnsForTableResponse(struct soap *soap, const struct TT1__getColumnsForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getColumnsForTableResponse);
	if (soap_out_TT1__getColumnsForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getColumnsForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__getColumnsForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getColumnsForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTableColumn(soap, "pColumnList", -1, &a->pColumnList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getColumnsForTableResponse * SOAP_FMAC4 soap_get_TT1__getColumnsForTableResponse(struct soap *soap, struct TT1__getColumnsForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getColumnsForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getColumnsForTableResponse * SOAP_FMAC4 soap_in_TT1__getColumnsForTableResponse(struct soap *soap, const char *tag, struct TT1__getColumnsForTableResponse *a, const char *type)
{
	short soap_flag_pColumnList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getColumnsForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getColumnsForTableResponse, sizeof(struct TT1__getColumnsForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getColumnsForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pColumnList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTableColumn(soap, "pColumnList", &a->pColumnList, "TT1:CTableColumn"))
				{	soap_flag_pColumnList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getColumnsForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getColumnsForTableResponse, 0, sizeof(struct TT1__getColumnsForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getColumnsForTableResponse * SOAP_FMAC6 soap_new_TT1__getColumnsForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getColumnsForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getColumnsForTableResponse(struct soap *soap, struct TT1__getColumnsForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getColumnsForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__getColumnsForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getColumnsForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getColumnsForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getColumnsForTableResponse;
		if (size)
			*size = sizeof(struct TT1__getColumnsForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getColumnsForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getColumnsForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getColumnsForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getColumnsForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getColumnsForTableResponse %p -> %p\n", q, p));
	*(struct TT1__getColumnsForTableResponse*)p = *(struct TT1__getColumnsForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__GetLinkDefinitionValues(struct soap *soap, struct TT1__GetLinkDefinitionValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__GetLinkDefinitionValues(struct soap *soap, const struct TT1__GetLinkDefinitionValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__GetLinkDefinitionValues(struct soap *soap, const struct TT1__GetLinkDefinitionValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__GetLinkDefinitionValues);
	if (soap_out_TT1__GetLinkDefinitionValues(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__GetLinkDefinitionValues(struct soap *soap, const char *tag, int id, const struct TT1__GetLinkDefinitionValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__GetLinkDefinitionValues), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValues * SOAP_FMAC4 soap_get_TT1__GetLinkDefinitionValues(struct soap *soap, struct TT1__GetLinkDefinitionValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__GetLinkDefinitionValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValues * SOAP_FMAC4 soap_in_TT1__GetLinkDefinitionValues(struct soap *soap, const char *tag, struct TT1__GetLinkDefinitionValues *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__GetLinkDefinitionValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__GetLinkDefinitionValues, sizeof(struct TT1__GetLinkDefinitionValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__GetLinkDefinitionValues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__GetLinkDefinitionValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__GetLinkDefinitionValues, 0, sizeof(struct TT1__GetLinkDefinitionValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__GetLinkDefinitionValues * SOAP_FMAC6 soap_new_TT1__GetLinkDefinitionValues(struct soap *soap, int n)
{	return soap_instantiate_TT1__GetLinkDefinitionValues(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__GetLinkDefinitionValues(struct soap *soap, struct TT1__GetLinkDefinitionValues *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValues * SOAP_FMAC4 soap_instantiate_TT1__GetLinkDefinitionValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__GetLinkDefinitionValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__GetLinkDefinitionValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__GetLinkDefinitionValues;
		if (size)
			*size = sizeof(struct TT1__GetLinkDefinitionValues);
	}
	else
	{	cp->ptr = (void*)new struct TT1__GetLinkDefinitionValues[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__GetLinkDefinitionValues);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__GetLinkDefinitionValues*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__GetLinkDefinitionValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__GetLinkDefinitionValues %p -> %p\n", q, p));
	*(struct TT1__GetLinkDefinitionValues*)p = *(struct TT1__GetLinkDefinitionValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, struct TT1__GetLinkDefinitionValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, const struct TT1__GetLinkDefinitionValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &a->pValueList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, const struct TT1__GetLinkDefinitionValuesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse);
	if (soap_out_TT1__GetLinkDefinitionValuesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, const char *tag, int id, const struct TT1__GetLinkDefinitionValuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValuesResponse * SOAP_FMAC4 soap_get_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, struct TT1__GetLinkDefinitionValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__GetLinkDefinitionValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValuesResponse * SOAP_FMAC4 soap_in_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, const char *tag, struct TT1__GetLinkDefinitionValuesResponse *a, const char *type)
{
	short soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__GetLinkDefinitionValuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse, sizeof(struct TT1__GetLinkDefinitionValuesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__GetLinkDefinitionValuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "TT1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__GetLinkDefinitionValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse, 0, sizeof(struct TT1__GetLinkDefinitionValuesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__GetLinkDefinitionValuesResponse * SOAP_FMAC6 soap_new_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__GetLinkDefinitionValuesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, struct TT1__GetLinkDefinitionValuesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__GetLinkDefinitionValuesResponse * SOAP_FMAC4 soap_instantiate_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__GetLinkDefinitionValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__GetLinkDefinitionValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__GetLinkDefinitionValuesResponse;
		if (size)
			*size = sizeof(struct TT1__GetLinkDefinitionValuesResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__GetLinkDefinitionValuesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__GetLinkDefinitionValuesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__GetLinkDefinitionValuesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__GetLinkDefinitionValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__GetLinkDefinitionValuesResponse %p -> %p\n", q, p));
	*(struct TT1__GetLinkDefinitionValuesResponse*)p = *(struct TT1__GetLinkDefinitionValuesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDropdownFieldValuesForTable(struct soap *soap, struct TT1__addDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->fieldname);
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDropdownFieldValuesForTable(struct soap *soap, const struct TT1__addDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->fieldname);
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &a->pValueList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDropdownFieldValuesForTable(struct soap *soap, const struct TT1__addDropdownFieldValuesForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDropdownFieldValuesForTable);
	if (soap_out_TT1__addDropdownFieldValuesForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDropdownFieldValuesForTable(struct soap *soap, const char *tag, int id, const struct TT1__addDropdownFieldValuesForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDropdownFieldValuesForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "fieldname", -1, &a->fieldname, ""))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTable * SOAP_FMAC4 soap_get_TT1__addDropdownFieldValuesForTable(struct soap *soap, struct TT1__addDropdownFieldValuesForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDropdownFieldValuesForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTable * SOAP_FMAC4 soap_in_TT1__addDropdownFieldValuesForTable(struct soap *soap, const char *tag, struct TT1__addDropdownFieldValuesForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1, soap_flag_fieldname = 1, soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDropdownFieldValuesForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDropdownFieldValuesForTable, sizeof(struct TT1__addDropdownFieldValuesForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDropdownFieldValuesForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_fieldname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fieldname", &a->fieldname, "xsd:string"))
				{	soap_flag_fieldname--;
					continue;
				}
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "TT1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDropdownFieldValuesForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDropdownFieldValuesForTable, 0, sizeof(struct TT1__addDropdownFieldValuesForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDropdownFieldValuesForTable * SOAP_FMAC6 soap_new_TT1__addDropdownFieldValuesForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDropdownFieldValuesForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDropdownFieldValuesForTable(struct soap *soap, struct TT1__addDropdownFieldValuesForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTable * SOAP_FMAC4 soap_instantiate_TT1__addDropdownFieldValuesForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDropdownFieldValuesForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDropdownFieldValuesForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDropdownFieldValuesForTable;
		if (size)
			*size = sizeof(struct TT1__addDropdownFieldValuesForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDropdownFieldValuesForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDropdownFieldValuesForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDropdownFieldValuesForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDropdownFieldValuesForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDropdownFieldValuesForTable %p -> %p\n", q, p));
	*(struct TT1__addDropdownFieldValuesForTable*)p = *(struct TT1__addDropdownFieldValuesForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__addDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, const struct TT1__addDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, const struct TT1__addDropdownFieldValuesForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse);
	if (soap_out_TT1__addDropdownFieldValuesForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__addDropdownFieldValuesForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_get_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__addDropdownFieldValuesForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__addDropdownFieldValuesForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_in_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, struct TT1__addDropdownFieldValuesForTableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__addDropdownFieldValuesForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse, sizeof(struct TT1__addDropdownFieldValuesForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__addDropdownFieldValuesForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__addDropdownFieldValuesForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse, 0, sizeof(struct TT1__addDropdownFieldValuesForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__addDropdownFieldValuesForTableResponse * SOAP_FMAC6 soap_new_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__addDropdownFieldValuesForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__addDropdownFieldValuesForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__addDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__addDropdownFieldValuesForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__addDropdownFieldValuesForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__addDropdownFieldValuesForTableResponse;
		if (size)
			*size = sizeof(struct TT1__addDropdownFieldValuesForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__addDropdownFieldValuesForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__addDropdownFieldValuesForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__addDropdownFieldValuesForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__addDropdownFieldValuesForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__addDropdownFieldValuesForTableResponse %p -> %p\n", q, p));
	*(struct TT1__addDropdownFieldValuesForTableResponse*)p = *(struct TT1__addDropdownFieldValuesForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDropdownFieldValuesForTable(struct soap *soap, struct TT1__getDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->fieldname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDropdownFieldValuesForTable(struct soap *soap, const struct TT1__getDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->fieldname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDropdownFieldValuesForTable(struct soap *soap, const struct TT1__getDropdownFieldValuesForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDropdownFieldValuesForTable);
	if (soap_out_TT1__getDropdownFieldValuesForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDropdownFieldValuesForTable(struct soap *soap, const char *tag, int id, const struct TT1__getDropdownFieldValuesForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDropdownFieldValuesForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "fieldname", -1, &a->fieldname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTable * SOAP_FMAC4 soap_get_TT1__getDropdownFieldValuesForTable(struct soap *soap, struct TT1__getDropdownFieldValuesForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDropdownFieldValuesForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTable * SOAP_FMAC4 soap_in_TT1__getDropdownFieldValuesForTable(struct soap *soap, const char *tag, struct TT1__getDropdownFieldValuesForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1, soap_flag_fieldname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDropdownFieldValuesForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDropdownFieldValuesForTable, sizeof(struct TT1__getDropdownFieldValuesForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDropdownFieldValuesForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_fieldname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fieldname", &a->fieldname, "xsd:string"))
				{	soap_flag_fieldname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDropdownFieldValuesForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDropdownFieldValuesForTable, 0, sizeof(struct TT1__getDropdownFieldValuesForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDropdownFieldValuesForTable * SOAP_FMAC6 soap_new_TT1__getDropdownFieldValuesForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDropdownFieldValuesForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDropdownFieldValuesForTable(struct soap *soap, struct TT1__getDropdownFieldValuesForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTable * SOAP_FMAC4 soap_instantiate_TT1__getDropdownFieldValuesForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDropdownFieldValuesForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDropdownFieldValuesForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldValuesForTable;
		if (size)
			*size = sizeof(struct TT1__getDropdownFieldValuesForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldValuesForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDropdownFieldValuesForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDropdownFieldValuesForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDropdownFieldValuesForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDropdownFieldValuesForTable %p -> %p\n", q, p));
	*(struct TT1__getDropdownFieldValuesForTable*)p = *(struct TT1__getDropdownFieldValuesForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__getDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, const struct TT1__getDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCFieldValue(soap, &a->pValueList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, const struct TT1__getDropdownFieldValuesForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse);
	if (soap_out_TT1__getDropdownFieldValuesForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDropdownFieldValuesForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_get_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__getDropdownFieldValuesForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDropdownFieldValuesForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_in_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, struct TT1__getDropdownFieldValuesForTableResponse *a, const char *type)
{
	short soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDropdownFieldValuesForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse, sizeof(struct TT1__getDropdownFieldValuesForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDropdownFieldValuesForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "TT1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDropdownFieldValuesForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse, 0, sizeof(struct TT1__getDropdownFieldValuesForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDropdownFieldValuesForTableResponse * SOAP_FMAC6 soap_new_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDropdownFieldValuesForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, struct TT1__getDropdownFieldValuesForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDropdownFieldValuesForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDropdownFieldValuesForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldValuesForTableResponse;
		if (size)
			*size = sizeof(struct TT1__getDropdownFieldValuesForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldValuesForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDropdownFieldValuesForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDropdownFieldValuesForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDropdownFieldValuesForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDropdownFieldValuesForTableResponse %p -> %p\n", q, p));
	*(struct TT1__getDropdownFieldValuesForTableResponse*)p = *(struct TT1__getDropdownFieldValuesForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDropdownFieldForTable(struct soap *soap, struct TT1__getDropdownFieldForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDropdownFieldForTable(struct soap *soap, const struct TT1__getDropdownFieldForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDropdownFieldForTable(struct soap *soap, const struct TT1__getDropdownFieldForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDropdownFieldForTable);
	if (soap_out_TT1__getDropdownFieldForTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDropdownFieldForTable(struct soap *soap, const char *tag, int id, const struct TT1__getDropdownFieldForTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDropdownFieldForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTable * SOAP_FMAC4 soap_get_TT1__getDropdownFieldForTable(struct soap *soap, struct TT1__getDropdownFieldForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDropdownFieldForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTable * SOAP_FMAC4 soap_in_TT1__getDropdownFieldForTable(struct soap *soap, const char *tag, struct TT1__getDropdownFieldForTable *a, const char *type)
{
	short soap_flag_cookie = 1, soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDropdownFieldForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDropdownFieldForTable, sizeof(struct TT1__getDropdownFieldForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDropdownFieldForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDropdownFieldForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDropdownFieldForTable, 0, sizeof(struct TT1__getDropdownFieldForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDropdownFieldForTable * SOAP_FMAC6 soap_new_TT1__getDropdownFieldForTable(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDropdownFieldForTable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDropdownFieldForTable(struct soap *soap, struct TT1__getDropdownFieldForTable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTable * SOAP_FMAC4 soap_instantiate_TT1__getDropdownFieldForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDropdownFieldForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDropdownFieldForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldForTable;
		if (size)
			*size = sizeof(struct TT1__getDropdownFieldForTable);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldForTable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDropdownFieldForTable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDropdownFieldForTable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDropdownFieldForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDropdownFieldForTable %p -> %p\n", q, p));
	*(struct TT1__getDropdownFieldForTable*)p = *(struct TT1__getDropdownFieldForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDropdownFieldForTableResponse(struct soap *soap, struct TT1__getDropdownFieldForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFieldList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDropdownFieldForTableResponse(struct soap *soap, const struct TT1__getDropdownFieldForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCTableField(soap, &a->pFieldList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDropdownFieldForTableResponse(struct soap *soap, const struct TT1__getDropdownFieldForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDropdownFieldForTableResponse);
	if (soap_out_TT1__getDropdownFieldForTableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDropdownFieldForTableResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDropdownFieldForTableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDropdownFieldForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCTableField(soap, "pFieldList", -1, &a->pFieldList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTableResponse * SOAP_FMAC4 soap_get_TT1__getDropdownFieldForTableResponse(struct soap *soap, struct TT1__getDropdownFieldForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDropdownFieldForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTableResponse * SOAP_FMAC4 soap_in_TT1__getDropdownFieldForTableResponse(struct soap *soap, const char *tag, struct TT1__getDropdownFieldForTableResponse *a, const char *type)
{
	short soap_flag_pFieldList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDropdownFieldForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDropdownFieldForTableResponse, sizeof(struct TT1__getDropdownFieldForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDropdownFieldForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFieldList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCTableField(soap, "pFieldList", &a->pFieldList, "TT1:CTableField"))
				{	soap_flag_pFieldList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDropdownFieldForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDropdownFieldForTableResponse, 0, sizeof(struct TT1__getDropdownFieldForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDropdownFieldForTableResponse * SOAP_FMAC6 soap_new_TT1__getDropdownFieldForTableResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDropdownFieldForTableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDropdownFieldForTableResponse(struct soap *soap, struct TT1__getDropdownFieldForTableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDropdownFieldForTableResponse * SOAP_FMAC4 soap_instantiate_TT1__getDropdownFieldForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDropdownFieldForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDropdownFieldForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldForTableResponse;
		if (size)
			*size = sizeof(struct TT1__getDropdownFieldForTableResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDropdownFieldForTableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDropdownFieldForTableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDropdownFieldForTableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDropdownFieldForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDropdownFieldForTableResponse %p -> %p\n", q, p));
	*(struct TT1__getDropdownFieldForTableResponse*)p = *(struct TT1__getDropdownFieldForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTableList(struct soap *soap, struct TT1__getTableList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTableList(struct soap *soap, const struct TT1__getTableList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTableList(struct soap *soap, const struct TT1__getTableList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTableList);
	if (soap_out_TT1__getTableList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTableList(struct soap *soap, const char *tag, int id, const struct TT1__getTableList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTableList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTableList * SOAP_FMAC4 soap_get_TT1__getTableList(struct soap *soap, struct TT1__getTableList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTableList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTableList * SOAP_FMAC4 soap_in_TT1__getTableList(struct soap *soap, const char *tag, struct TT1__getTableList *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTableList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTableList, sizeof(struct TT1__getTableList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTableList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTableList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTableList, 0, sizeof(struct TT1__getTableList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTableList * SOAP_FMAC6 soap_new_TT1__getTableList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTableList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTableList(struct soap *soap, struct TT1__getTableList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTableList * SOAP_FMAC4 soap_instantiate_TT1__getTableList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTableList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTableList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTableList;
		if (size)
			*size = sizeof(struct TT1__getTableList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTableList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTableList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTableList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTableList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTableList %p -> %p\n", q, p));
	*(struct TT1__getTableList*)p = *(struct TT1__getTableList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getTableListResponse(struct soap *soap, struct TT1__getTableListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTableList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getTableListResponse(struct soap *soap, const struct TT1__getTableListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCDatabaseTable(soap, &a->pTableList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getTableListResponse(struct soap *soap, const struct TT1__getTableListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getTableListResponse);
	if (soap_out_TT1__getTableListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getTableListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getTableListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getTableListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCDatabaseTable(soap, "pTableList", -1, &a->pTableList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getTableListResponse * SOAP_FMAC4 soap_get_TT1__getTableListResponse(struct soap *soap, struct TT1__getTableListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getTableListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getTableListResponse * SOAP_FMAC4 soap_in_TT1__getTableListResponse(struct soap *soap, const char *tag, struct TT1__getTableListResponse *a, const char *type)
{
	short soap_flag_pTableList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getTableListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getTableListResponse, sizeof(struct TT1__getTableListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getTableListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTableList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCDatabaseTable(soap, "pTableList", &a->pTableList, "TT1:CDatabaseTable"))
				{	soap_flag_pTableList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getTableListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getTableListResponse, 0, sizeof(struct TT1__getTableListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getTableListResponse * SOAP_FMAC6 soap_new_TT1__getTableListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getTableListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getTableListResponse(struct soap *soap, struct TT1__getTableListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getTableListResponse * SOAP_FMAC4 soap_instantiate_TT1__getTableListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getTableListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getTableListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getTableListResponse;
		if (size)
			*size = sizeof(struct TT1__getTableListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getTableListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getTableListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getTableListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getTableListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getTableListResponse %p -> %p\n", q, p));
	*(struct TT1__getTableListResponse*)p = *(struct TT1__getTableListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__DatabaseLogoff(struct soap *soap, struct TT1__DatabaseLogoff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__DatabaseLogoff(struct soap *soap, const struct TT1__DatabaseLogoff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__DatabaseLogoff(struct soap *soap, const struct TT1__DatabaseLogoff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__DatabaseLogoff);
	if (soap_out_TT1__DatabaseLogoff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__DatabaseLogoff(struct soap *soap, const char *tag, int id, const struct TT1__DatabaseLogoff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__DatabaseLogoff), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__DatabaseLogoff * SOAP_FMAC4 soap_get_TT1__DatabaseLogoff(struct soap *soap, struct TT1__DatabaseLogoff *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__DatabaseLogoff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__DatabaseLogoff * SOAP_FMAC4 soap_in_TT1__DatabaseLogoff(struct soap *soap, const char *tag, struct TT1__DatabaseLogoff *a, const char *type)
{
	short soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__DatabaseLogoff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__DatabaseLogoff, sizeof(struct TT1__DatabaseLogoff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__DatabaseLogoff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__DatabaseLogoff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__DatabaseLogoff, 0, sizeof(struct TT1__DatabaseLogoff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__DatabaseLogoff * SOAP_FMAC6 soap_new_TT1__DatabaseLogoff(struct soap *soap, int n)
{	return soap_instantiate_TT1__DatabaseLogoff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__DatabaseLogoff(struct soap *soap, struct TT1__DatabaseLogoff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__DatabaseLogoff * SOAP_FMAC4 soap_instantiate_TT1__DatabaseLogoff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__DatabaseLogoff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__DatabaseLogoff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__DatabaseLogoff;
		if (size)
			*size = sizeof(struct TT1__DatabaseLogoff);
	}
	else
	{	cp->ptr = (void*)new struct TT1__DatabaseLogoff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__DatabaseLogoff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__DatabaseLogoff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__DatabaseLogoff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__DatabaseLogoff %p -> %p\n", q, p));
	*(struct TT1__DatabaseLogoff*)p = *(struct TT1__DatabaseLogoff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__DatabaseLogoffResponse(struct soap *soap, struct TT1__DatabaseLogoffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__DatabaseLogoffResponse(struct soap *soap, const struct TT1__DatabaseLogoffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__DatabaseLogoffResponse(struct soap *soap, const struct TT1__DatabaseLogoffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__DatabaseLogoffResponse);
	if (soap_out_TT1__DatabaseLogoffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__DatabaseLogoffResponse(struct soap *soap, const char *tag, int id, const struct TT1__DatabaseLogoffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__DatabaseLogoffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__DatabaseLogoffResponse * SOAP_FMAC4 soap_get_TT1__DatabaseLogoffResponse(struct soap *soap, struct TT1__DatabaseLogoffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__DatabaseLogoffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__DatabaseLogoffResponse * SOAP_FMAC4 soap_in_TT1__DatabaseLogoffResponse(struct soap *soap, const char *tag, struct TT1__DatabaseLogoffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__DatabaseLogoffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__DatabaseLogoffResponse, sizeof(struct TT1__DatabaseLogoffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__DatabaseLogoffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__DatabaseLogoffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__DatabaseLogoffResponse, 0, sizeof(struct TT1__DatabaseLogoffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__DatabaseLogoffResponse * SOAP_FMAC6 soap_new_TT1__DatabaseLogoffResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__DatabaseLogoffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__DatabaseLogoffResponse(struct soap *soap, struct TT1__DatabaseLogoffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__DatabaseLogoffResponse * SOAP_FMAC4 soap_instantiate_TT1__DatabaseLogoffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__DatabaseLogoffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__DatabaseLogoffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__DatabaseLogoffResponse;
		if (size)
			*size = sizeof(struct TT1__DatabaseLogoffResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__DatabaseLogoffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__DatabaseLogoffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__DatabaseLogoffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__DatabaseLogoffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__DatabaseLogoffResponse %p -> %p\n", q, p));
	*(struct TT1__DatabaseLogoffResponse*)p = *(struct TT1__DatabaseLogoffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__ProjectLogon(struct soap *soap, struct TT1__ProjectLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProj = NULL;
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__ProjectLogon(struct soap *soap, const struct TT1__ProjectLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1__CProject(soap, &a->pProj);
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__ProjectLogon(struct soap *soap, const struct TT1__ProjectLogon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__ProjectLogon);
	if (soap_out_TT1__ProjectLogon(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__ProjectLogon(struct soap *soap, const char *tag, int id, const struct TT1__ProjectLogon *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__ProjectLogon), type))
		return soap->error;
	if (soap_out_PointerToTT1__CProject(soap, "pProj", -1, &a->pProj, ""))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__ProjectLogon * SOAP_FMAC4 soap_get_TT1__ProjectLogon(struct soap *soap, struct TT1__ProjectLogon *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__ProjectLogon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__ProjectLogon * SOAP_FMAC4 soap_in_TT1__ProjectLogon(struct soap *soap, const char *tag, struct TT1__ProjectLogon *a, const char *type)
{
	short soap_flag_pProj = 1, soap_flag_username = 1, soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__ProjectLogon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__ProjectLogon, sizeof(struct TT1__ProjectLogon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__ProjectLogon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProj && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1__CProject(soap, "pProj", &a->pProj, "TT1:CProject"))
				{	soap_flag_pProj--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__ProjectLogon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__ProjectLogon, 0, sizeof(struct TT1__ProjectLogon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__ProjectLogon * SOAP_FMAC6 soap_new_TT1__ProjectLogon(struct soap *soap, int n)
{	return soap_instantiate_TT1__ProjectLogon(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__ProjectLogon(struct soap *soap, struct TT1__ProjectLogon *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__ProjectLogon * SOAP_FMAC4 soap_instantiate_TT1__ProjectLogon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__ProjectLogon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__ProjectLogon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__ProjectLogon;
		if (size)
			*size = sizeof(struct TT1__ProjectLogon);
	}
	else
	{	cp->ptr = (void*)new struct TT1__ProjectLogon[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__ProjectLogon);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__ProjectLogon*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__ProjectLogon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__ProjectLogon %p -> %p\n", q, p));
	*(struct TT1__ProjectLogon*)p = *(struct TT1__ProjectLogon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__ProjectLogonResponse(struct soap *soap, struct TT1__ProjectLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->Cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__ProjectLogonResponse(struct soap *soap, const struct TT1__ProjectLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__ProjectLogonResponse(struct soap *soap, const struct TT1__ProjectLogonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__ProjectLogonResponse);
	if (soap_out_TT1__ProjectLogonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__ProjectLogonResponse(struct soap *soap, const char *tag, int id, const struct TT1__ProjectLogonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__ProjectLogonResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "Cookie", -1, &a->Cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__ProjectLogonResponse * SOAP_FMAC4 soap_get_TT1__ProjectLogonResponse(struct soap *soap, struct TT1__ProjectLogonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__ProjectLogonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__ProjectLogonResponse * SOAP_FMAC4 soap_in_TT1__ProjectLogonResponse(struct soap *soap, const char *tag, struct TT1__ProjectLogonResponse *a, const char *type)
{
	short soap_flag_Cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__ProjectLogonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__ProjectLogonResponse, sizeof(struct TT1__ProjectLogonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__ProjectLogonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "Cookie", &a->Cookie, "xsd:long"))
				{	soap_flag_Cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__ProjectLogonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__ProjectLogonResponse, 0, sizeof(struct TT1__ProjectLogonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__ProjectLogonResponse * SOAP_FMAC6 soap_new_TT1__ProjectLogonResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__ProjectLogonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__ProjectLogonResponse(struct soap *soap, struct TT1__ProjectLogonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__ProjectLogonResponse * SOAP_FMAC4 soap_instantiate_TT1__ProjectLogonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__ProjectLogonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__ProjectLogonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__ProjectLogonResponse;
		if (size)
			*size = sizeof(struct TT1__ProjectLogonResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__ProjectLogonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__ProjectLogonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__ProjectLogonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__ProjectLogonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__ProjectLogonResponse %p -> %p\n", q, p));
	*(struct TT1__ProjectLogonResponse*)p = *(struct TT1__ProjectLogonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__DatabaseLogon(struct soap *soap, struct TT1__DatabaseLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->dbname);
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__DatabaseLogon(struct soap *soap, const struct TT1__DatabaseLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->dbname);
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__DatabaseLogon(struct soap *soap, const struct TT1__DatabaseLogon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__DatabaseLogon);
	if (soap_out_TT1__DatabaseLogon(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__DatabaseLogon(struct soap *soap, const char *tag, int id, const struct TT1__DatabaseLogon *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__DatabaseLogon), type))
		return soap->error;
	if (soap_out_string(soap, "dbname", -1, &a->dbname, ""))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__DatabaseLogon * SOAP_FMAC4 soap_get_TT1__DatabaseLogon(struct soap *soap, struct TT1__DatabaseLogon *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__DatabaseLogon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__DatabaseLogon * SOAP_FMAC4 soap_in_TT1__DatabaseLogon(struct soap *soap, const char *tag, struct TT1__DatabaseLogon *a, const char *type)
{
	short soap_flag_dbname = 1, soap_flag_username = 1, soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__DatabaseLogon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__DatabaseLogon, sizeof(struct TT1__DatabaseLogon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__DatabaseLogon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dbname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dbname", &a->dbname, "xsd:string"))
				{	soap_flag_dbname--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__DatabaseLogon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__DatabaseLogon, 0, sizeof(struct TT1__DatabaseLogon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__DatabaseLogon * SOAP_FMAC6 soap_new_TT1__DatabaseLogon(struct soap *soap, int n)
{	return soap_instantiate_TT1__DatabaseLogon(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__DatabaseLogon(struct soap *soap, struct TT1__DatabaseLogon *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__DatabaseLogon * SOAP_FMAC4 soap_instantiate_TT1__DatabaseLogon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__DatabaseLogon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__DatabaseLogon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__DatabaseLogon;
		if (size)
			*size = sizeof(struct TT1__DatabaseLogon);
	}
	else
	{	cp->ptr = (void*)new struct TT1__DatabaseLogon[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__DatabaseLogon);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__DatabaseLogon*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__DatabaseLogon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__DatabaseLogon %p -> %p\n", q, p));
	*(struct TT1__DatabaseLogon*)p = *(struct TT1__DatabaseLogon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__DatabaseLogonResponse(struct soap *soap, struct TT1__DatabaseLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->Cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__DatabaseLogonResponse(struct soap *soap, const struct TT1__DatabaseLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Cookie, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__DatabaseLogonResponse(struct soap *soap, const struct TT1__DatabaseLogonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__DatabaseLogonResponse);
	if (soap_out_TT1__DatabaseLogonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__DatabaseLogonResponse(struct soap *soap, const char *tag, int id, const struct TT1__DatabaseLogonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__DatabaseLogonResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "Cookie", -1, &a->Cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__DatabaseLogonResponse * SOAP_FMAC4 soap_get_TT1__DatabaseLogonResponse(struct soap *soap, struct TT1__DatabaseLogonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__DatabaseLogonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__DatabaseLogonResponse * SOAP_FMAC4 soap_in_TT1__DatabaseLogonResponse(struct soap *soap, const char *tag, struct TT1__DatabaseLogonResponse *a, const char *type)
{
	short soap_flag_Cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__DatabaseLogonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__DatabaseLogonResponse, sizeof(struct TT1__DatabaseLogonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__DatabaseLogonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "Cookie", &a->Cookie, "xsd:long"))
				{	soap_flag_Cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__DatabaseLogonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__DatabaseLogonResponse, 0, sizeof(struct TT1__DatabaseLogonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__DatabaseLogonResponse * SOAP_FMAC6 soap_new_TT1__DatabaseLogonResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__DatabaseLogonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__DatabaseLogonResponse(struct soap *soap, struct TT1__DatabaseLogonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__DatabaseLogonResponse * SOAP_FMAC4 soap_instantiate_TT1__DatabaseLogonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__DatabaseLogonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__DatabaseLogonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__DatabaseLogonResponse;
		if (size)
			*size = sizeof(struct TT1__DatabaseLogonResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__DatabaseLogonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__DatabaseLogonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__DatabaseLogonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__DatabaseLogonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__DatabaseLogonResponse %p -> %p\n", q, p));
	*(struct TT1__DatabaseLogonResponse*)p = *(struct TT1__DatabaseLogonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getProjectDataOptionList(struct soap *soap, struct TT1__getProjectDataOptionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getProjectDataOptionList(struct soap *soap, const struct TT1__getProjectDataOptionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getProjectDataOptionList(struct soap *soap, const struct TT1__getProjectDataOptionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getProjectDataOptionList);
	if (soap_out_TT1__getProjectDataOptionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getProjectDataOptionList(struct soap *soap, const char *tag, int id, const struct TT1__getProjectDataOptionList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getProjectDataOptionList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getProjectDataOptionList * SOAP_FMAC4 soap_get_TT1__getProjectDataOptionList(struct soap *soap, struct TT1__getProjectDataOptionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getProjectDataOptionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getProjectDataOptionList * SOAP_FMAC4 soap_in_TT1__getProjectDataOptionList(struct soap *soap, const char *tag, struct TT1__getProjectDataOptionList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getProjectDataOptionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getProjectDataOptionList, sizeof(struct TT1__getProjectDataOptionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getProjectDataOptionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getProjectDataOptionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getProjectDataOptionList, 0, sizeof(struct TT1__getProjectDataOptionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getProjectDataOptionList * SOAP_FMAC6 soap_new_TT1__getProjectDataOptionList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getProjectDataOptionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getProjectDataOptionList(struct soap *soap, struct TT1__getProjectDataOptionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getProjectDataOptionList * SOAP_FMAC4 soap_instantiate_TT1__getProjectDataOptionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getProjectDataOptionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getProjectDataOptionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getProjectDataOptionList;
		if (size)
			*size = sizeof(struct TT1__getProjectDataOptionList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getProjectDataOptionList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getProjectDataOptionList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getProjectDataOptionList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getProjectDataOptionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getProjectDataOptionList %p -> %p\n", q, p));
	*(struct TT1__getProjectDataOptionList*)p = *(struct TT1__getProjectDataOptionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getProjectDataOptionListResponse(struct soap *soap, struct TT1__getProjectDataOptionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProjTypes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getProjectDataOptionListResponse(struct soap *soap, const struct TT1__getProjectDataOptionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCProjectDataOption(soap, &a->pProjTypes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getProjectDataOptionListResponse(struct soap *soap, const struct TT1__getProjectDataOptionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getProjectDataOptionListResponse);
	if (soap_out_TT1__getProjectDataOptionListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getProjectDataOptionListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getProjectDataOptionListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getProjectDataOptionListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCProjectDataOption(soap, "pProjTypes", -1, &a->pProjTypes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getProjectDataOptionListResponse * SOAP_FMAC4 soap_get_TT1__getProjectDataOptionListResponse(struct soap *soap, struct TT1__getProjectDataOptionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getProjectDataOptionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getProjectDataOptionListResponse * SOAP_FMAC4 soap_in_TT1__getProjectDataOptionListResponse(struct soap *soap, const char *tag, struct TT1__getProjectDataOptionListResponse *a, const char *type)
{
	short soap_flag_pProjTypes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getProjectDataOptionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getProjectDataOptionListResponse, sizeof(struct TT1__getProjectDataOptionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getProjectDataOptionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProjTypes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCProjectDataOption(soap, "pProjTypes", &a->pProjTypes, "TT1:CProjectDataOption"))
				{	soap_flag_pProjTypes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getProjectDataOptionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getProjectDataOptionListResponse, 0, sizeof(struct TT1__getProjectDataOptionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getProjectDataOptionListResponse * SOAP_FMAC6 soap_new_TT1__getProjectDataOptionListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getProjectDataOptionListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getProjectDataOptionListResponse(struct soap *soap, struct TT1__getProjectDataOptionListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getProjectDataOptionListResponse * SOAP_FMAC4 soap_instantiate_TT1__getProjectDataOptionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getProjectDataOptionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getProjectDataOptionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getProjectDataOptionListResponse;
		if (size)
			*size = sizeof(struct TT1__getProjectDataOptionListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getProjectDataOptionListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getProjectDataOptionListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getProjectDataOptionListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getProjectDataOptionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getProjectDataOptionListResponse %p -> %p\n", q, p));
	*(struct TT1__getProjectDataOptionListResponse*)p = *(struct TT1__getProjectDataOptionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getProjectList(struct soap *soap, struct TT1__getProjectList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getProjectList(struct soap *soap, const struct TT1__getProjectList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getProjectList(struct soap *soap, const struct TT1__getProjectList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getProjectList);
	if (soap_out_TT1__getProjectList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getProjectList(struct soap *soap, const char *tag, int id, const struct TT1__getProjectList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getProjectList), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getProjectList * SOAP_FMAC4 soap_get_TT1__getProjectList(struct soap *soap, struct TT1__getProjectList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getProjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getProjectList * SOAP_FMAC4 soap_in_TT1__getProjectList(struct soap *soap, const char *tag, struct TT1__getProjectList *a, const char *type)
{
	short soap_flag_username = 1, soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getProjectList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getProjectList, sizeof(struct TT1__getProjectList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getProjectList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getProjectList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getProjectList, 0, sizeof(struct TT1__getProjectList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getProjectList * SOAP_FMAC6 soap_new_TT1__getProjectList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getProjectList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getProjectList(struct soap *soap, struct TT1__getProjectList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getProjectList * SOAP_FMAC4 soap_instantiate_TT1__getProjectList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getProjectList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getProjectList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getProjectList;
		if (size)
			*size = sizeof(struct TT1__getProjectList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getProjectList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getProjectList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getProjectList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getProjectList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getProjectList %p -> %p\n", q, p));
	*(struct TT1__getProjectList*)p = *(struct TT1__getProjectList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getProjectListResponse(struct soap *soap, struct TT1__getProjectListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProjList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getProjectListResponse(struct soap *soap, const struct TT1__getProjectListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCProject(soap, &a->pProjList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getProjectListResponse(struct soap *soap, const struct TT1__getProjectListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getProjectListResponse);
	if (soap_out_TT1__getProjectListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getProjectListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getProjectListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getProjectListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCProject(soap, "pProjList", -1, &a->pProjList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getProjectListResponse * SOAP_FMAC4 soap_get_TT1__getProjectListResponse(struct soap *soap, struct TT1__getProjectListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getProjectListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getProjectListResponse * SOAP_FMAC4 soap_in_TT1__getProjectListResponse(struct soap *soap, const char *tag, struct TT1__getProjectListResponse *a, const char *type)
{
	short soap_flag_pProjList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getProjectListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getProjectListResponse, sizeof(struct TT1__getProjectListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getProjectListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProjList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCProject(soap, "pProjList", &a->pProjList, "TT1:CProject"))
				{	soap_flag_pProjList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getProjectListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getProjectListResponse, 0, sizeof(struct TT1__getProjectListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getProjectListResponse * SOAP_FMAC6 soap_new_TT1__getProjectListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getProjectListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getProjectListResponse(struct soap *soap, struct TT1__getProjectListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getProjectListResponse * SOAP_FMAC4 soap_instantiate_TT1__getProjectListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getProjectListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getProjectListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getProjectListResponse;
		if (size)
			*size = sizeof(struct TT1__getProjectListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getProjectListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getProjectListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getProjectListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getProjectListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getProjectListResponse %p -> %p\n", q, p));
	*(struct TT1__getProjectListResponse*)p = *(struct TT1__getProjectListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDatabaseList(struct soap *soap, struct TT1__getDatabaseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDatabaseList(struct soap *soap, const struct TT1__getDatabaseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDatabaseList(struct soap *soap, const struct TT1__getDatabaseList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDatabaseList);
	if (soap_out_TT1__getDatabaseList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDatabaseList(struct soap *soap, const char *tag, int id, const struct TT1__getDatabaseList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDatabaseList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDatabaseList * SOAP_FMAC4 soap_get_TT1__getDatabaseList(struct soap *soap, struct TT1__getDatabaseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDatabaseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDatabaseList * SOAP_FMAC4 soap_in_TT1__getDatabaseList(struct soap *soap, const char *tag, struct TT1__getDatabaseList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDatabaseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDatabaseList, sizeof(struct TT1__getDatabaseList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDatabaseList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDatabaseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDatabaseList, 0, sizeof(struct TT1__getDatabaseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDatabaseList * SOAP_FMAC6 soap_new_TT1__getDatabaseList(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDatabaseList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDatabaseList(struct soap *soap, struct TT1__getDatabaseList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDatabaseList * SOAP_FMAC4 soap_instantiate_TT1__getDatabaseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDatabaseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDatabaseList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDatabaseList;
		if (size)
			*size = sizeof(struct TT1__getDatabaseList);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDatabaseList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDatabaseList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDatabaseList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDatabaseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDatabaseList %p -> %p\n", q, p));
	*(struct TT1__getDatabaseList*)p = *(struct TT1__getDatabaseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TT1__getDatabaseListResponse(struct soap *soap, struct TT1__getDatabaseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDBList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TT1__getDatabaseListResponse(struct soap *soap, const struct TT1__getDatabaseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToTT1ArrayOfCDatabase(soap, &a->pDBList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TT1__getDatabaseListResponse(struct soap *soap, const struct TT1__getDatabaseListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_TT1__getDatabaseListResponse);
	if (soap_out_TT1__getDatabaseListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TT1__getDatabaseListResponse(struct soap *soap, const char *tag, int id, const struct TT1__getDatabaseListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TT1__getDatabaseListResponse), type))
		return soap->error;
	if (soap_out_PointerToTT1ArrayOfCDatabase(soap, "pDBList", -1, &a->pDBList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TT1__getDatabaseListResponse * SOAP_FMAC4 soap_get_TT1__getDatabaseListResponse(struct soap *soap, struct TT1__getDatabaseListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_TT1__getDatabaseListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct TT1__getDatabaseListResponse * SOAP_FMAC4 soap_in_TT1__getDatabaseListResponse(struct soap *soap, const char *tag, struct TT1__getDatabaseListResponse *a, const char *type)
{
	short soap_flag_pDBList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TT1__getDatabaseListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TT1__getDatabaseListResponse, sizeof(struct TT1__getDatabaseListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TT1__getDatabaseListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDBList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTT1ArrayOfCDatabase(soap, "pDBList", &a->pDBList, "TT1:CDatabase"))
				{	soap_flag_pDBList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TT1__getDatabaseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TT1__getDatabaseListResponse, 0, sizeof(struct TT1__getDatabaseListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct TT1__getDatabaseListResponse * SOAP_FMAC6 soap_new_TT1__getDatabaseListResponse(struct soap *soap, int n)
{	return soap_instantiate_TT1__getDatabaseListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_TT1__getDatabaseListResponse(struct soap *soap, struct TT1__getDatabaseListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct TT1__getDatabaseListResponse * SOAP_FMAC4 soap_instantiate_TT1__getDatabaseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TT1__getDatabaseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_TT1__getDatabaseListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct TT1__getDatabaseListResponse;
		if (size)
			*size = sizeof(struct TT1__getDatabaseListResponse);
	}
	else
	{	cp->ptr = (void*)new struct TT1__getDatabaseListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct TT1__getDatabaseListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct TT1__getDatabaseListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_TT1__getDatabaseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct TT1__getDatabaseListResponse %p -> %p\n", q, p));
	*(struct TT1__getDatabaseListResponse*)p = *(struct TT1__getDatabaseListResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCFolderItem(struct soap *soap, TT1ArrayOfCFolderItem *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCFolderItem(struct soap *soap, TT1ArrayOfCFolderItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCFolderItem);
	if (soap_out_PointerToTT1ArrayOfCFolderItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCFolderItem(struct soap *soap, const char *tag, int id, TT1ArrayOfCFolderItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFolderItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCFolderItem ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCFolderItem(struct soap *soap, TT1ArrayOfCFolderItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCFolderItem ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCFolderItem(struct soap *soap, const char *tag, TT1ArrayOfCFolderItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCFolderItem **)soap_malloc(soap, sizeof(TT1ArrayOfCFolderItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCFolderItem *)soap_instantiate_TT1ArrayOfCFolderItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCFolderItem ** p = (TT1ArrayOfCFolderItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCFolderItem, sizeof(TT1ArrayOfCFolderItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCTestRunVariantField(struct soap *soap, TT1ArrayOfCTestRunVariantField *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCTestRunVariantField(struct soap *soap, TT1ArrayOfCTestRunVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCTestRunVariantField);
	if (soap_out_PointerToTT1ArrayOfCTestRunVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, int id, TT1ArrayOfCTestRunVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTestRunVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCTestRunVariantField ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCTestRunVariantField(struct soap *soap, TT1ArrayOfCTestRunVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCTestRunVariantField ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, TT1ArrayOfCTestRunVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCTestRunVariantField **)soap_malloc(soap, sizeof(TT1ArrayOfCTestRunVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCTestRunVariantField *)soap_instantiate_TT1ArrayOfCTestRunVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCTestRunVariantField ** p = (TT1ArrayOfCTestRunVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCTestRunVariantField, sizeof(TT1ArrayOfCTestRunVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCItemToTrack(struct soap *soap, TT1ArrayOfCItemToTrack *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCItemToTrack(struct soap *soap, TT1ArrayOfCItemToTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCItemToTrack);
	if (soap_out_PointerToTT1ArrayOfCItemToTrack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCItemToTrack(struct soap *soap, const char *tag, int id, TT1ArrayOfCItemToTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCItemToTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCItemToTrack ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCItemToTrack(struct soap *soap, TT1ArrayOfCItemToTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCItemToTrack ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCItemToTrack(struct soap *soap, const char *tag, TT1ArrayOfCItemToTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCItemToTrack **)soap_malloc(soap, sizeof(TT1ArrayOfCItemToTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCItemToTrack *)soap_instantiate_TT1ArrayOfCItemToTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCItemToTrack ** p = (TT1ArrayOfCItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCItemToTrack, sizeof(TT1ArrayOfCItemToTrack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTestRun(struct soap *soap, TT1__CTestRun *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTestRun))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTestRun(struct soap *soap, TT1__CTestRun *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTestRun);
	if (soap_out_PointerToTT1__CTestRun(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTestRun(struct soap *soap, const char *tag, int id, TT1__CTestRun *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTestRun);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTestRun ** SOAP_FMAC4 soap_get_PointerToTT1__CTestRun(struct soap *soap, TT1__CTestRun **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestRun ** SOAP_FMAC4 soap_in_PointerToTT1__CTestRun(struct soap *soap, const char *tag, TT1__CTestRun **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestRun **)soap_malloc(soap, sizeof(TT1__CTestRun *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTestRun *)soap_instantiate_TT1__CTestRun(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTestRun ** p = (TT1__CTestRun **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestRun, sizeof(TT1__CTestRun), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTestCase(struct soap *soap, TT1__CTestCase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTestCase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTestCase(struct soap *soap, TT1__CTestCase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTestCase);
	if (soap_out_PointerToTT1__CTestCase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTestCase(struct soap *soap, const char *tag, int id, TT1__CTestCase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTestCase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTestCase ** SOAP_FMAC4 soap_get_PointerToTT1__CTestCase(struct soap *soap, TT1__CTestCase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestCase ** SOAP_FMAC4 soap_in_PointerToTT1__CTestCase(struct soap *soap, const char *tag, TT1__CTestCase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestCase **)soap_malloc(soap, sizeof(TT1__CTestCase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTestCase *)soap_instantiate_TT1__CTestCase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTestCase ** p = (TT1__CTestCase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestCase, sizeof(TT1__CTestCase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCLink(struct soap *soap, TT1ArrayOfCLink *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCLink(struct soap *soap, TT1ArrayOfCLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCLink);
	if (soap_out_PointerToTT1ArrayOfCLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCLink(struct soap *soap, const char *tag, int id, TT1ArrayOfCLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCLink ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCLink(struct soap *soap, TT1ArrayOfCLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCLink ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCLink(struct soap *soap, const char *tag, TT1ArrayOfCLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCLink **)soap_malloc(soap, sizeof(TT1ArrayOfCLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCLink *)soap_instantiate_TT1ArrayOfCLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCLink ** p = (TT1ArrayOfCLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCLink, sizeof(TT1ArrayOfCLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CUser(struct soap *soap, TT1__CUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CUser(struct soap *soap, TT1__CUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CUser);
	if (soap_out_PointerToTT1__CUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CUser(struct soap *soap, const char *tag, int id, TT1__CUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CUser ** SOAP_FMAC4 soap_get_PointerToTT1__CUser(struct soap *soap, TT1__CUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CUser ** SOAP_FMAC4 soap_in_PointerToTT1__CUser(struct soap *soap, const char *tag, TT1__CUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CUser **)soap_malloc(soap, sizeof(TT1__CUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CUser *)soap_instantiate_TT1__CUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CUser ** p = (TT1__CUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CUser, sizeof(TT1__CUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCUserLicense(struct soap *soap, TT1ArrayOfCUserLicense *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCUserLicense(struct soap *soap, TT1ArrayOfCUserLicense *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCUserLicense);
	if (soap_out_PointerToTT1ArrayOfCUserLicense(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCUserLicense(struct soap *soap, const char *tag, int id, TT1ArrayOfCUserLicense *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCUserLicense);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCUserLicense ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCUserLicense(struct soap *soap, TT1ArrayOfCUserLicense **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCUserLicense ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCUserLicense(struct soap *soap, const char *tag, TT1ArrayOfCUserLicense **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCUserLicense **)soap_malloc(soap, sizeof(TT1ArrayOfCUserLicense *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCUserLicense *)soap_instantiate_TT1ArrayOfCUserLicense(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCUserLicense ** p = (TT1ArrayOfCUserLicense **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCUserLicense, sizeof(TT1ArrayOfCUserLicense), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCGlobalUser(struct soap *soap, TT1ArrayOfCGlobalUser *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCGlobalUser(struct soap *soap, TT1ArrayOfCGlobalUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCGlobalUser);
	if (soap_out_PointerToTT1ArrayOfCGlobalUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCGlobalUser(struct soap *soap, const char *tag, int id, TT1ArrayOfCGlobalUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCGlobalUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCGlobalUser ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCGlobalUser(struct soap *soap, TT1ArrayOfCGlobalUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCGlobalUser ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCGlobalUser(struct soap *soap, const char *tag, TT1ArrayOfCGlobalUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCGlobalUser **)soap_malloc(soap, sizeof(TT1ArrayOfCGlobalUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCGlobalUser *)soap_instantiate_TT1ArrayOfCGlobalUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCGlobalUser ** p = (TT1ArrayOfCGlobalUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCGlobalUser, sizeof(TT1ArrayOfCGlobalUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTask(struct soap *soap, TT1__CTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTask(struct soap *soap, TT1__CTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTask);
	if (soap_out_PointerToTT1__CTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTask(struct soap *soap, const char *tag, int id, TT1__CTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTask ** SOAP_FMAC4 soap_get_PointerToTT1__CTask(struct soap *soap, TT1__CTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTask ** SOAP_FMAC4 soap_in_PointerToTT1__CTask(struct soap *soap, const char *tag, TT1__CTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTask **)soap_malloc(soap, sizeof(TT1__CTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTask *)soap_instantiate_TT1__CTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTask ** p = (TT1__CTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTask, sizeof(TT1__CTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CDefect(struct soap *soap, TT1__CDefect *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CDefect))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CDefect(struct soap *soap, TT1__CDefect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CDefect);
	if (soap_out_PointerToTT1__CDefect(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CDefect(struct soap *soap, const char *tag, int id, TT1__CDefect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CDefect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CDefect ** SOAP_FMAC4 soap_get_PointerToTT1__CDefect(struct soap *soap, TT1__CDefect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDefect ** SOAP_FMAC4 soap_in_PointerToTT1__CDefect(struct soap *soap, const char *tag, TT1__CDefect **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDefect **)soap_malloc(soap, sizeof(TT1__CDefect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CDefect *)soap_instantiate_TT1__CDefect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CDefect ** p = (TT1__CDefect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefect, sizeof(TT1__CDefect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCDefectEventDefinition(struct soap *soap, TT1ArrayOfCDefectEventDefinition *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCDefectEventDefinition(struct soap *soap, TT1ArrayOfCDefectEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCDefectEventDefinition);
	if (soap_out_PointerToTT1ArrayOfCDefectEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, int id, TT1ArrayOfCDefectEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCDefectEventDefinition ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCDefectEventDefinition(struct soap *soap, TT1ArrayOfCDefectEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCDefectEventDefinition ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, TT1ArrayOfCDefectEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCDefectEventDefinition **)soap_malloc(soap, sizeof(TT1ArrayOfCDefectEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCDefectEventDefinition *)soap_instantiate_TT1ArrayOfCDefectEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCDefectEventDefinition ** p = (TT1ArrayOfCDefectEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCDefectEventDefinition, sizeof(TT1ArrayOfCDefectEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCEventDefinition(struct soap *soap, TT1ArrayOfCEventDefinition *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCEventDefinition(struct soap *soap, TT1ArrayOfCEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCEventDefinition);
	if (soap_out_PointerToTT1ArrayOfCEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCEventDefinition(struct soap *soap, const char *tag, int id, TT1ArrayOfCEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCEventDefinition ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCEventDefinition(struct soap *soap, TT1ArrayOfCEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCEventDefinition ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCEventDefinition(struct soap *soap, const char *tag, TT1ArrayOfCEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCEventDefinition **)soap_malloc(soap, sizeof(TT1ArrayOfCEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCEventDefinition *)soap_instantiate_TT1ArrayOfCEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCEventDefinition ** p = (TT1ArrayOfCEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCEventDefinition, sizeof(TT1ArrayOfCEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CRecordListSoap(struct soap *soap, TT1__CRecordListSoap *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CRecordListSoap))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CRecordListSoap(struct soap *soap, TT1__CRecordListSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CRecordListSoap);
	if (soap_out_PointerToTT1__CRecordListSoap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CRecordListSoap(struct soap *soap, const char *tag, int id, TT1__CRecordListSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CRecordListSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CRecordListSoap ** SOAP_FMAC4 soap_get_PointerToTT1__CRecordListSoap(struct soap *soap, TT1__CRecordListSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CRecordListSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CRecordListSoap ** SOAP_FMAC4 soap_in_PointerToTT1__CRecordListSoap(struct soap *soap, const char *tag, TT1__CRecordListSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CRecordListSoap **)soap_malloc(soap, sizeof(TT1__CRecordListSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CRecordListSoap *)soap_instantiate_TT1__CRecordListSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CRecordListSoap ** p = (TT1__CRecordListSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CRecordListSoap, sizeof(TT1__CRecordListSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCFilter(struct soap *soap, TT1ArrayOfCFilter *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCFilter(struct soap *soap, TT1ArrayOfCFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCFilter);
	if (soap_out_PointerToTT1ArrayOfCFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCFilter(struct soap *soap, const char *tag, int id, TT1ArrayOfCFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCFilter ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCFilter(struct soap *soap, TT1ArrayOfCFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCFilter ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCFilter(struct soap *soap, const char *tag, TT1ArrayOfCFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCFilter **)soap_malloc(soap, sizeof(TT1ArrayOfCFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCFilter *)soap_instantiate_TT1ArrayOfCFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCFilter ** p = (TT1ArrayOfCFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCFilter, sizeof(TT1ArrayOfCFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCTableField(struct soap *soap, TT1ArrayOfCTableField *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCTableField(struct soap *soap, TT1ArrayOfCTableField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCTableField);
	if (soap_out_PointerToTT1ArrayOfCTableField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCTableField(struct soap *soap, const char *tag, int id, TT1ArrayOfCTableField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTableField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCTableField ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCTableField(struct soap *soap, TT1ArrayOfCTableField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCTableField ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCTableField(struct soap *soap, const char *tag, TT1ArrayOfCTableField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCTableField **)soap_malloc(soap, sizeof(TT1ArrayOfCTableField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCTableField *)soap_instantiate_TT1ArrayOfCTableField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCTableField ** p = (TT1ArrayOfCTableField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCTableField, sizeof(TT1ArrayOfCTableField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCDatabaseTable(struct soap *soap, TT1ArrayOfCDatabaseTable *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCDatabaseTable(struct soap *soap, TT1ArrayOfCDatabaseTable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCDatabaseTable);
	if (soap_out_PointerToTT1ArrayOfCDatabaseTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCDatabaseTable(struct soap *soap, const char *tag, int id, TT1ArrayOfCDatabaseTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDatabaseTable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabaseTable ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCDatabaseTable(struct soap *soap, TT1ArrayOfCDatabaseTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCDatabaseTable ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCDatabaseTable(struct soap *soap, const char *tag, TT1ArrayOfCDatabaseTable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCDatabaseTable **)soap_malloc(soap, sizeof(TT1ArrayOfCDatabaseTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCDatabaseTable *)soap_instantiate_TT1ArrayOfCDatabaseTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCDatabaseTable ** p = (TT1ArrayOfCDatabaseTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCDatabaseTable, sizeof(TT1ArrayOfCDatabaseTable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCProject(struct soap *soap, TT1ArrayOfCProject *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCProject(struct soap *soap, TT1ArrayOfCProject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCProject);
	if (soap_out_PointerToTT1ArrayOfCProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCProject(struct soap *soap, const char *tag, int id, TT1ArrayOfCProject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCProject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCProject ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCProject(struct soap *soap, TT1ArrayOfCProject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCProject ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCProject(struct soap *soap, const char *tag, TT1ArrayOfCProject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCProject **)soap_malloc(soap, sizeof(TT1ArrayOfCProject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCProject *)soap_instantiate_TT1ArrayOfCProject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCProject ** p = (TT1ArrayOfCProject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCProject, sizeof(TT1ArrayOfCProject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCDatabase(struct soap *soap, TT1ArrayOfCDatabase *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCDatabase(struct soap *soap, TT1ArrayOfCDatabase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCDatabase);
	if (soap_out_PointerToTT1ArrayOfCDatabase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCDatabase(struct soap *soap, const char *tag, int id, TT1ArrayOfCDatabase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCDatabase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCDatabase ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCDatabase(struct soap *soap, TT1ArrayOfCDatabase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCDatabase ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCDatabase(struct soap *soap, const char *tag, TT1ArrayOfCDatabase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCDatabase **)soap_malloc(soap, sizeof(TT1ArrayOfCDatabase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCDatabase *)soap_instantiate_TT1ArrayOfCDatabase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCDatabase ** p = (TT1ArrayOfCDatabase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCDatabase, sizeof(TT1ArrayOfCDatabase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCTestCaseVariantField(struct soap *soap, TT1ArrayOfCTestCaseVariantField *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCTestCaseVariantField(struct soap *soap, TT1ArrayOfCTestCaseVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCTestCaseVariantField);
	if (soap_out_PointerToTT1ArrayOfCTestCaseVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, int id, TT1ArrayOfCTestCaseVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCTestCaseVariantField ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCTestCaseVariantField(struct soap *soap, TT1ArrayOfCTestCaseVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCTestCaseVariantField ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, TT1ArrayOfCTestCaseVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCTestCaseVariantField **)soap_malloc(soap, sizeof(TT1ArrayOfCTestCaseVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCTestCaseVariantField *)soap_instantiate_TT1ArrayOfCTestCaseVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCTestCaseVariantField ** p = (TT1ArrayOfCTestCaseVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCTestCaseVariantField, sizeof(TT1ArrayOfCTestCaseVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCLinkHistoryItem(struct soap *soap, TT1ArrayOfCLinkHistoryItem *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCLinkHistoryItem(struct soap *soap, TT1ArrayOfCLinkHistoryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCLinkHistoryItem);
	if (soap_out_PointerToTT1ArrayOfCLinkHistoryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, int id, TT1ArrayOfCLinkHistoryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkHistoryItem ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCLinkHistoryItem(struct soap *soap, TT1ArrayOfCLinkHistoryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCLinkHistoryItem ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, TT1ArrayOfCLinkHistoryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCLinkHistoryItem **)soap_malloc(soap, sizeof(TT1ArrayOfCLinkHistoryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCLinkHistoryItem *)soap_instantiate_TT1ArrayOfCLinkHistoryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCLinkHistoryItem ** p = (TT1ArrayOfCLinkHistoryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCLinkHistoryItem, sizeof(TT1ArrayOfCLinkHistoryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCLinkedItem(struct soap *soap, TT1ArrayOfCLinkedItem *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCLinkedItem(struct soap *soap, TT1ArrayOfCLinkedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCLinkedItem);
	if (soap_out_PointerToTT1ArrayOfCLinkedItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCLinkedItem(struct soap *soap, const char *tag, int id, TT1ArrayOfCLinkedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCLinkedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCLinkedItem ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCLinkedItem(struct soap *soap, TT1ArrayOfCLinkedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCLinkedItem ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCLinkedItem(struct soap *soap, const char *tag, TT1ArrayOfCLinkedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCLinkedItem **)soap_malloc(soap, sizeof(TT1ArrayOfCLinkedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCLinkedItem *)soap_instantiate_TT1ArrayOfCLinkedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCLinkedItem ** p = (TT1ArrayOfCLinkedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCLinkedItem, sizeof(TT1ArrayOfCLinkedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__PhoneNumber(struct soap *soap, TT1__PhoneNumber *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__PhoneNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__PhoneNumber(struct soap *soap, TT1__PhoneNumber *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__PhoneNumber);
	if (soap_out_PointerToTT1__PhoneNumber(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__PhoneNumber(struct soap *soap, const char *tag, int id, TT1__PhoneNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__PhoneNumber);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__PhoneNumber ** SOAP_FMAC4 soap_get_PointerToTT1__PhoneNumber(struct soap *soap, TT1__PhoneNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__PhoneNumber ** SOAP_FMAC4 soap_in_PointerToTT1__PhoneNumber(struct soap *soap, const char *tag, TT1__PhoneNumber **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__PhoneNumber **)soap_malloc(soap, sizeof(TT1__PhoneNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__PhoneNumber *)soap_instantiate_TT1__PhoneNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__PhoneNumber ** p = (TT1__PhoneNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__PhoneNumber, sizeof(TT1__PhoneNumber), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCSCCFileRecord(struct soap *soap, TT1ArrayOfCSCCFileRecord *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCSCCFileRecord(struct soap *soap, TT1ArrayOfCSCCFileRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCSCCFileRecord);
	if (soap_out_PointerToTT1ArrayOfCSCCFileRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, int id, TT1ArrayOfCSCCFileRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCSCCFileRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCSCCFileRecord ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCSCCFileRecord(struct soap *soap, TT1ArrayOfCSCCFileRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCSCCFileRecord ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, TT1ArrayOfCSCCFileRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCSCCFileRecord **)soap_malloc(soap, sizeof(TT1ArrayOfCSCCFileRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCSCCFileRecord *)soap_instantiate_TT1ArrayOfCSCCFileRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCSCCFileRecord ** p = (TT1ArrayOfCSCCFileRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCSCCFileRecord, sizeof(TT1ArrayOfCSCCFileRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCEvent(struct soap *soap, TT1ArrayOfCEvent *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCEvent(struct soap *soap, TT1ArrayOfCEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCEvent);
	if (soap_out_PointerToTT1ArrayOfCEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCEvent(struct soap *soap, const char *tag, int id, TT1ArrayOfCEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCEvent ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCEvent(struct soap *soap, TT1ArrayOfCEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCEvent ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCEvent(struct soap *soap, const char *tag, TT1ArrayOfCEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCEvent **)soap_malloc(soap, sizeof(TT1ArrayOfCEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCEvent *)soap_instantiate_TT1ArrayOfCEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCEvent ** p = (TT1ArrayOfCEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCEvent, sizeof(TT1ArrayOfCEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCReportedByRecord(struct soap *soap, TT1ArrayOfCReportedByRecord *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCReportedByRecord(struct soap *soap, TT1ArrayOfCReportedByRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCReportedByRecord);
	if (soap_out_PointerToTT1ArrayOfCReportedByRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCReportedByRecord(struct soap *soap, const char *tag, int id, TT1ArrayOfCReportedByRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCReportedByRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCReportedByRecord ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCReportedByRecord(struct soap *soap, TT1ArrayOfCReportedByRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCReportedByRecord ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCReportedByRecord(struct soap *soap, const char *tag, TT1ArrayOfCReportedByRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCReportedByRecord **)soap_malloc(soap, sizeof(TT1ArrayOfCReportedByRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCReportedByRecord *)soap_instantiate_TT1ArrayOfCReportedByRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCReportedByRecord ** p = (TT1ArrayOfCReportedByRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCReportedByRecord, sizeof(TT1ArrayOfCReportedByRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CFolderItem))
		soap_serialize_PointerToTT1__CFolderItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CFolderItem);
	if (soap_out_PointerToPointerToTT1__CFolderItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CFolderItem(struct soap *soap, const char *tag, int id, TT1__CFolderItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CFolderItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CFolderItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CFolderItem *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFolderItem *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CFolderItem(struct soap *soap, const char *tag, TT1__CFolderItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFolderItem ***)soap_malloc(soap, sizeof(TT1__CFolderItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CFolderItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CFolderItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CFolderItem, sizeof(TT1__CFolderItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CFolderItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CFolderItem);
	if (soap_out_PointerToTT1__CFolderItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CFolderItem(struct soap *soap, const char *tag, int id, TT1__CFolderItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CFolderItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CFolderItem ** SOAP_FMAC4 soap_get_PointerToTT1__CFolderItem(struct soap *soap, TT1__CFolderItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFolderItem ** SOAP_FMAC4 soap_in_PointerToTT1__CFolderItem(struct soap *soap, const char *tag, TT1__CFolderItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFolderItem **)soap_malloc(soap, sizeof(TT1__CFolderItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CFolderItem *)soap_instantiate_TT1__CFolderItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CFolderItem ** p = (TT1__CFolderItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFolderItem, sizeof(TT1__CFolderItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CFolder(struct soap *soap, TT1__CFolder **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CFolder))
		soap_serialize_PointerToTT1__CFolder(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CFolder(struct soap *soap, TT1__CFolder **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CFolder);
	if (soap_out_PointerToPointerToTT1__CFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CFolder(struct soap *soap, const char *tag, int id, TT1__CFolder **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CFolder);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CFolder(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CFolder *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CFolder(struct soap *soap, TT1__CFolder ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFolder *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CFolder(struct soap *soap, const char *tag, TT1__CFolder ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFolder ***)soap_malloc(soap, sizeof(TT1__CFolder **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CFolder(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CFolder ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CFolder, sizeof(TT1__CFolder *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CFolder(struct soap *soap, TT1__CFolder *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CFolder))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CFolder(struct soap *soap, TT1__CFolder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CFolder);
	if (soap_out_PointerToTT1__CFolder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CFolder(struct soap *soap, const char *tag, int id, TT1__CFolder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CFolder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CFolder ** SOAP_FMAC4 soap_get_PointerToTT1__CFolder(struct soap *soap, TT1__CFolder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFolder ** SOAP_FMAC4 soap_in_PointerToTT1__CFolder(struct soap *soap, const char *tag, TT1__CFolder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFolder **)soap_malloc(soap, sizeof(TT1__CFolder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CFolder *)soap_instantiate_TT1__CFolder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CFolder ** p = (TT1__CFolder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFolder, sizeof(TT1__CFolder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CItemToTrack))
		soap_serialize_PointerToTT1__CItemToTrack(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CItemToTrack);
	if (soap_out_PointerToPointerToTT1__CItemToTrack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CItemToTrack(struct soap *soap, const char *tag, int id, TT1__CItemToTrack **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CItemToTrack);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CItemToTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CItemToTrack *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CItemToTrack *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CItemToTrack(struct soap *soap, const char *tag, TT1__CItemToTrack ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CItemToTrack ***)soap_malloc(soap, sizeof(TT1__CItemToTrack **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CItemToTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CItemToTrack ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CItemToTrack, sizeof(TT1__CItemToTrack *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CItemToTrack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CItemToTrack);
	if (soap_out_PointerToTT1__CItemToTrack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CItemToTrack(struct soap *soap, const char *tag, int id, TT1__CItemToTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CItemToTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CItemToTrack ** SOAP_FMAC4 soap_get_PointerToTT1__CItemToTrack(struct soap *soap, TT1__CItemToTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CItemToTrack ** SOAP_FMAC4 soap_in_PointerToTT1__CItemToTrack(struct soap *soap, const char *tag, TT1__CItemToTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CItemToTrack **)soap_malloc(soap, sizeof(TT1__CItemToTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CItemToTrack *)soap_instantiate_TT1__CItemToTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CItemToTrack ** p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CItemToTrack, sizeof(TT1__CItemToTrack), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CSystemBase, sizeof(TT1__CSystemBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefect, sizeof(TT1__CDefect), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTask, sizeof(TT1__CTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CUser, sizeof(TT1__CUser), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CLink, sizeof(TT1__CLink), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestCase, sizeof(TT1__CTestCase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestRun, sizeof(TT1__CTestRun), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFolder, sizeof(TT1__CFolder), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CSystem, sizeof(TT1__CSystem), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CLink(struct soap *soap, TT1__CLink **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CLink))
		soap_serialize_PointerToTT1__CLink(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CLink(struct soap *soap, TT1__CLink **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CLink);
	if (soap_out_PointerToPointerToTT1__CLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CLink(struct soap *soap, const char *tag, int id, TT1__CLink **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CLink);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CLink *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CLink(struct soap *soap, TT1__CLink ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLink *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CLink(struct soap *soap, const char *tag, TT1__CLink ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLink ***)soap_malloc(soap, sizeof(TT1__CLink **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CLink ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CLink, sizeof(TT1__CLink *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CLink(struct soap *soap, TT1__CLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CLink))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CLink(struct soap *soap, TT1__CLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CLink);
	if (soap_out_PointerToTT1__CLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CLink(struct soap *soap, const char *tag, int id, TT1__CLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CLink ** SOAP_FMAC4 soap_get_PointerToTT1__CLink(struct soap *soap, TT1__CLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLink ** SOAP_FMAC4 soap_in_PointerToTT1__CLink(struct soap *soap, const char *tag, TT1__CLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLink **)soap_malloc(soap, sizeof(TT1__CLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CLink *)soap_instantiate_TT1__CLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CLink ** p = (TT1__CLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CLink, sizeof(TT1__CLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CLinkHistoryItem))
		soap_serialize_PointerToTT1__CLinkHistoryItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CLinkHistoryItem);
	if (soap_out_PointerToPointerToTT1__CLinkHistoryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, TT1__CLinkHistoryItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CLinkHistoryItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CLinkHistoryItem *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLinkHistoryItem *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CLinkHistoryItem(struct soap *soap, const char *tag, TT1__CLinkHistoryItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLinkHistoryItem ***)soap_malloc(soap, sizeof(TT1__CLinkHistoryItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CLinkHistoryItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CLinkHistoryItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CLinkHistoryItem, sizeof(TT1__CLinkHistoryItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CLinkHistoryItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CLinkHistoryItem);
	if (soap_out_PointerToTT1__CLinkHistoryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, TT1__CLinkHistoryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CLinkHistoryItem ** SOAP_FMAC4 soap_get_PointerToTT1__CLinkHistoryItem(struct soap *soap, TT1__CLinkHistoryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLinkHistoryItem ** SOAP_FMAC4 soap_in_PointerToTT1__CLinkHistoryItem(struct soap *soap, const char *tag, TT1__CLinkHistoryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLinkHistoryItem **)soap_malloc(soap, sizeof(TT1__CLinkHistoryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CLinkHistoryItem *)soap_instantiate_TT1__CLinkHistoryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CLinkHistoryItem ** p = (TT1__CLinkHistoryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CLinkHistoryItem, sizeof(TT1__CLinkHistoryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CLinkedItem))
		soap_serialize_PointerToTT1__CLinkedItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CLinkedItem);
	if (soap_out_PointerToPointerToTT1__CLinkedItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CLinkedItem(struct soap *soap, const char *tag, int id, TT1__CLinkedItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CLinkedItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CLinkedItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CLinkedItem *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLinkedItem *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CLinkedItem(struct soap *soap, const char *tag, TT1__CLinkedItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLinkedItem ***)soap_malloc(soap, sizeof(TT1__CLinkedItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CLinkedItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CLinkedItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CLinkedItem, sizeof(TT1__CLinkedItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CLinkedItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CLinkedItem);
	if (soap_out_PointerToTT1__CLinkedItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CLinkedItem(struct soap *soap, const char *tag, int id, TT1__CLinkedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CLinkedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CLinkedItem ** SOAP_FMAC4 soap_get_PointerToTT1__CLinkedItem(struct soap *soap, TT1__CLinkedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CLinkedItem ** SOAP_FMAC4 soap_in_PointerToTT1__CLinkedItem(struct soap *soap, const char *tag, TT1__CLinkedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CLinkedItem **)soap_malloc(soap, sizeof(TT1__CLinkedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CLinkedItem *)soap_instantiate_TT1__CLinkedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CLinkedItem ** p = (TT1__CLinkedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CLinkedItem, sizeof(TT1__CLinkedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CUserLicense))
		soap_serialize_PointerToTT1__CUserLicense(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CUserLicense);
	if (soap_out_PointerToPointerToTT1__CUserLicense(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CUserLicense(struct soap *soap, const char *tag, int id, TT1__CUserLicense **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CUserLicense);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CUserLicense(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CUserLicense *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CUserLicense *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CUserLicense(struct soap *soap, const char *tag, TT1__CUserLicense ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CUserLicense ***)soap_malloc(soap, sizeof(TT1__CUserLicense **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CUserLicense(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CUserLicense ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CUserLicense, sizeof(TT1__CUserLicense *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CUserLicense))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CUserLicense);
	if (soap_out_PointerToTT1__CUserLicense(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CUserLicense(struct soap *soap, const char *tag, int id, TT1__CUserLicense *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CUserLicense);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CUserLicense ** SOAP_FMAC4 soap_get_PointerToTT1__CUserLicense(struct soap *soap, TT1__CUserLicense **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CUserLicense ** SOAP_FMAC4 soap_in_PointerToTT1__CUserLicense(struct soap *soap, const char *tag, TT1__CUserLicense **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CUserLicense **)soap_malloc(soap, sizeof(TT1__CUserLicense *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CUserLicense *)soap_instantiate_TT1__CUserLicense(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CUserLicense ** p = (TT1__CUserLicense **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CUserLicense, sizeof(TT1__CUserLicense), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CGlobalUser))
		soap_serialize_PointerToTT1__CGlobalUser(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CGlobalUser);
	if (soap_out_PointerToPointerToTT1__CGlobalUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CGlobalUser(struct soap *soap, const char *tag, int id, TT1__CGlobalUser **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CGlobalUser);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CGlobalUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CGlobalUser *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CGlobalUser *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CGlobalUser(struct soap *soap, const char *tag, TT1__CGlobalUser ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CGlobalUser ***)soap_malloc(soap, sizeof(TT1__CGlobalUser **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CGlobalUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CGlobalUser ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CGlobalUser, sizeof(TT1__CGlobalUser *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CGlobalUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CGlobalUser);
	if (soap_out_PointerToTT1__CGlobalUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CGlobalUser(struct soap *soap, const char *tag, int id, TT1__CGlobalUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CGlobalUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CGlobalUser ** SOAP_FMAC4 soap_get_PointerToTT1__CGlobalUser(struct soap *soap, TT1__CGlobalUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CGlobalUser ** SOAP_FMAC4 soap_in_PointerToTT1__CGlobalUser(struct soap *soap, const char *tag, TT1__CGlobalUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CGlobalUser **)soap_malloc(soap, sizeof(TT1__CGlobalUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CGlobalUser *)soap_instantiate_TT1__CGlobalUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CGlobalUser ** p = (TT1__CGlobalUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CGlobalUser, sizeof(TT1__CGlobalUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CDefectEventDefinition))
		soap_serialize_PointerToTT1__CDefectEventDefinition(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CDefectEventDefinition);
	if (soap_out_PointerToPointerToTT1__CDefectEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, TT1__CDefectEventDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CDefectEventDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CDefectEventDefinition *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDefectEventDefinition *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CDefectEventDefinition(struct soap *soap, const char *tag, TT1__CDefectEventDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDefectEventDefinition ***)soap_malloc(soap, sizeof(TT1__CDefectEventDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CDefectEventDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CDefectEventDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CDefectEventDefinition, sizeof(TT1__CDefectEventDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CDefectEventDefinition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CDefectEventDefinition);
	if (soap_out_PointerToTT1__CDefectEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, TT1__CDefectEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CDefectEventDefinition ** SOAP_FMAC4 soap_get_PointerToTT1__CDefectEventDefinition(struct soap *soap, TT1__CDefectEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDefectEventDefinition ** SOAP_FMAC4 soap_in_PointerToTT1__CDefectEventDefinition(struct soap *soap, const char *tag, TT1__CDefectEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDefectEventDefinition **)soap_malloc(soap, sizeof(TT1__CDefectEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CDefectEventDefinition *)soap_instantiate_TT1__CDefectEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CDefectEventDefinition ** p = (TT1__CDefectEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefectEventDefinition, sizeof(TT1__CDefectEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CEventDefinition))
		soap_serialize_PointerToTT1__CEventDefinition(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CEventDefinition);
	if (soap_out_PointerToPointerToTT1__CEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CEventDefinition(struct soap *soap, const char *tag, int id, TT1__CEventDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CEventDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CEventDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CEventDefinition *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CEventDefinition *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CEventDefinition(struct soap *soap, const char *tag, TT1__CEventDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CEventDefinition ***)soap_malloc(soap, sizeof(TT1__CEventDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CEventDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CEventDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CEventDefinition, sizeof(TT1__CEventDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CEventDefinition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CEventDefinition);
	if (soap_out_PointerToTT1__CEventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CEventDefinition(struct soap *soap, const char *tag, int id, TT1__CEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CEventDefinition ** SOAP_FMAC4 soap_get_PointerToTT1__CEventDefinition(struct soap *soap, TT1__CEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CEventDefinition ** SOAP_FMAC4 soap_in_PointerToTT1__CEventDefinition(struct soap *soap, const char *tag, TT1__CEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CEventDefinition **)soap_malloc(soap, sizeof(TT1__CEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CEventDefinition *)soap_instantiate_TT1__CEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CEventDefinition ** p = (TT1__CEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CEventDefinition, sizeof(TT1__CEventDefinition), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefectEventDefinition, sizeof(TT1__CDefectEventDefinition), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CDefectEvent))
		soap_serialize_PointerToTT1__CDefectEvent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CDefectEvent);
	if (soap_out_PointerToPointerToTT1__CDefectEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CDefectEvent(struct soap *soap, const char *tag, int id, TT1__CDefectEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CDefectEvent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CDefectEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CDefectEvent *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDefectEvent *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CDefectEvent(struct soap *soap, const char *tag, TT1__CDefectEvent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDefectEvent ***)soap_malloc(soap, sizeof(TT1__CDefectEvent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CDefectEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CDefectEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CDefectEvent, sizeof(TT1__CDefectEvent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CDefectEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CDefectEvent);
	if (soap_out_PointerToTT1__CDefectEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CDefectEvent(struct soap *soap, const char *tag, int id, TT1__CDefectEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CDefectEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CDefectEvent ** SOAP_FMAC4 soap_get_PointerToTT1__CDefectEvent(struct soap *soap, TT1__CDefectEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDefectEvent ** SOAP_FMAC4 soap_in_PointerToTT1__CDefectEvent(struct soap *soap, const char *tag, TT1__CDefectEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDefectEvent **)soap_malloc(soap, sizeof(TT1__CDefectEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CDefectEvent *)soap_instantiate_TT1__CDefectEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CDefectEvent ** p = (TT1__CDefectEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefectEvent, sizeof(TT1__CDefectEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CEvent(struct soap *soap, TT1__CEvent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CEvent))
		soap_serialize_PointerToTT1__CEvent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CEvent(struct soap *soap, TT1__CEvent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CEvent);
	if (soap_out_PointerToPointerToTT1__CEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CEvent(struct soap *soap, const char *tag, int id, TT1__CEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CEvent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CEvent *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CEvent(struct soap *soap, TT1__CEvent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CEvent *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CEvent(struct soap *soap, const char *tag, TT1__CEvent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CEvent ***)soap_malloc(soap, sizeof(TT1__CEvent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CEvent, sizeof(TT1__CEvent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CEvent(struct soap *soap, TT1__CEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CEvent(struct soap *soap, TT1__CEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CEvent);
	if (soap_out_PointerToTT1__CEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CEvent(struct soap *soap, const char *tag, int id, TT1__CEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CEvent ** SOAP_FMAC4 soap_get_PointerToTT1__CEvent(struct soap *soap, TT1__CEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CEvent ** SOAP_FMAC4 soap_in_PointerToTT1__CEvent(struct soap *soap, const char *tag, TT1__CEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CEvent **)soap_malloc(soap, sizeof(TT1__CEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CEvent *)soap_instantiate_TT1__CEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CEvent ** p = (TT1__CEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CEvent, sizeof(TT1__CEvent), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDefectEvent, sizeof(TT1__CDefectEvent), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfstring(struct soap *soap, TT1ArrayOfstring *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfstring(struct soap *soap, TT1ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfstring);
	if (soap_out_PointerToTT1ArrayOfstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfstring(struct soap *soap, const char *tag, int id, TT1ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfstring(struct soap *soap, TT1ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfstring(struct soap *soap, const char *tag, TT1ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfstring **)soap_malloc(soap, sizeof(TT1ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfstring *)soap_instantiate_TT1ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfstring ** p = (TT1ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfstring, sizeof(TT1ArrayOfstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CTestCaseVariantField))
		soap_serialize_PointerToTT1__CTestCaseVariantField(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CTestCaseVariantField);
	if (soap_out_PointerToPointerToTT1__CTestCaseVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, TT1__CTestCaseVariantField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CTestCaseVariantField(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CTestCaseVariantField *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestCaseVariantField *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CTestCaseVariantField(struct soap *soap, const char *tag, TT1__CTestCaseVariantField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestCaseVariantField ***)soap_malloc(soap, sizeof(TT1__CTestCaseVariantField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CTestCaseVariantField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CTestCaseVariantField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CTestCaseVariantField, sizeof(TT1__CTestCaseVariantField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTestCaseVariantField))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTestCaseVariantField);
	if (soap_out_PointerToTT1__CTestCaseVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, TT1__CTestCaseVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTestCaseVariantField ** SOAP_FMAC4 soap_get_PointerToTT1__CTestCaseVariantField(struct soap *soap, TT1__CTestCaseVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestCaseVariantField ** SOAP_FMAC4 soap_in_PointerToTT1__CTestCaseVariantField(struct soap *soap, const char *tag, TT1__CTestCaseVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestCaseVariantField **)soap_malloc(soap, sizeof(TT1__CTestCaseVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTestCaseVariantField *)soap_instantiate_TT1__CTestCaseVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTestCaseVariantField ** p = (TT1__CTestCaseVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestCaseVariantField, sizeof(TT1__CTestCaseVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CTestRunVariantField))
		soap_serialize_PointerToTT1__CTestRunVariantField(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CTestRunVariantField);
	if (soap_out_PointerToPointerToTT1__CTestRunVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CTestRunVariantField(struct soap *soap, const char *tag, int id, TT1__CTestRunVariantField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CTestRunVariantField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CTestRunVariantField(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CTestRunVariantField *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestRunVariantField *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CTestRunVariantField(struct soap *soap, const char *tag, TT1__CTestRunVariantField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestRunVariantField ***)soap_malloc(soap, sizeof(TT1__CTestRunVariantField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CTestRunVariantField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CTestRunVariantField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CTestRunVariantField, sizeof(TT1__CTestRunVariantField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTestRunVariantField))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTestRunVariantField);
	if (soap_out_PointerToTT1__CTestRunVariantField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTestRunVariantField(struct soap *soap, const char *tag, int id, TT1__CTestRunVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTestRunVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTestRunVariantField ** SOAP_FMAC4 soap_get_PointerToTT1__CTestRunVariantField(struct soap *soap, TT1__CTestRunVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTestRunVariantField ** SOAP_FMAC4 soap_in_PointerToTT1__CTestRunVariantField(struct soap *soap, const char *tag, TT1__CTestRunVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTestRunVariantField **)soap_malloc(soap, sizeof(TT1__CTestRunVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTestRunVariantField *)soap_instantiate_TT1__CTestRunVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTestRunVariantField ** p = (TT1__CTestRunVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestRunVariantField, sizeof(TT1__CTestRunVariantField), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CTestRunVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestCaseVariantField, sizeof(TT1__CTestCaseVariantField), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CField(struct soap *soap, TT1__CField **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CField))
		soap_serialize_PointerToTT1__CField(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CField(struct soap *soap, TT1__CField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CField);
	if (soap_out_PointerToPointerToTT1__CField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CField(struct soap *soap, const char *tag, int id, TT1__CField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CField(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CField *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CField(struct soap *soap, TT1__CField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CField *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CField(struct soap *soap, const char *tag, TT1__CField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CField ***)soap_malloc(soap, sizeof(TT1__CField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CField, sizeof(TT1__CField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CField(struct soap *soap, TT1__CField *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CField))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CField(struct soap *soap, TT1__CField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CField);
	if (soap_out_PointerToTT1__CField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CField(struct soap *soap, const char *tag, int id, TT1__CField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CField ** SOAP_FMAC4 soap_get_PointerToTT1__CField(struct soap *soap, TT1__CField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CField ** SOAP_FMAC4 soap_in_PointerToTT1__CField(struct soap *soap, const char *tag, TT1__CField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CField **)soap_malloc(soap, sizeof(TT1__CField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CField *)soap_instantiate_TT1__CField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CField ** p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CField, sizeof(TT1__CField), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CStringField, sizeof(TT1__CStringField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CIntegerField, sizeof(TT1__CIntegerField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDecimalField, sizeof(TT1__CDecimalField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CBooleanField, sizeof(TT1__CBooleanField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDateField, sizeof(TT1__CDateField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDateTimeField, sizeof(TT1__CDateTimeField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDropdownField, sizeof(TT1__CDropdownField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CMultiSelectDropdownField, sizeof(TT1__CMultiSelectDropdownField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CVersionField, sizeof(TT1__CVersionField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestRunVariantField, sizeof(TT1__CTestRunVariantField), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (TT1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTestCaseVariantField, sizeof(TT1__CTestCaseVariantField), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CReportedByRecord))
		soap_serialize_PointerToTT1__CReportedByRecord(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CReportedByRecord);
	if (soap_out_PointerToPointerToTT1__CReportedByRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CReportedByRecord(struct soap *soap, const char *tag, int id, TT1__CReportedByRecord **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CReportedByRecord);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CReportedByRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CReportedByRecord *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CReportedByRecord *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CReportedByRecord(struct soap *soap, const char *tag, TT1__CReportedByRecord ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CReportedByRecord ***)soap_malloc(soap, sizeof(TT1__CReportedByRecord **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CReportedByRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CReportedByRecord ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CReportedByRecord, sizeof(TT1__CReportedByRecord *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CReportedByRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CReportedByRecord);
	if (soap_out_PointerToTT1__CReportedByRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CReportedByRecord(struct soap *soap, const char *tag, int id, TT1__CReportedByRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CReportedByRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CReportedByRecord ** SOAP_FMAC4 soap_get_PointerToTT1__CReportedByRecord(struct soap *soap, TT1__CReportedByRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CReportedByRecord ** SOAP_FMAC4 soap_in_PointerToTT1__CReportedByRecord(struct soap *soap, const char *tag, TT1__CReportedByRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CReportedByRecord **)soap_malloc(soap, sizeof(TT1__CReportedByRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CReportedByRecord *)soap_instantiate_TT1__CReportedByRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CReportedByRecord ** p = (TT1__CReportedByRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CReportedByRecord, sizeof(TT1__CReportedByRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCFileAttachment(struct soap *soap, TT1ArrayOfCFileAttachment *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCFileAttachment(struct soap *soap, TT1ArrayOfCFileAttachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCFileAttachment);
	if (soap_out_PointerToTT1ArrayOfCFileAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCFileAttachment(struct soap *soap, const char *tag, int id, TT1ArrayOfCFileAttachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFileAttachment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCFileAttachment ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCFileAttachment(struct soap *soap, TT1ArrayOfCFileAttachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCFileAttachment ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCFileAttachment(struct soap *soap, const char *tag, TT1ArrayOfCFileAttachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCFileAttachment **)soap_malloc(soap, sizeof(TT1ArrayOfCFileAttachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCFileAttachment *)soap_instantiate_TT1ArrayOfCFileAttachment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCFileAttachment ** p = (TT1ArrayOfCFileAttachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCFileAttachment, sizeof(TT1ArrayOfCFileAttachment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToshort(struct soap *soap, short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToshort(struct soap *soap, short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToshort);
	if (soap_out_PointerToshort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToshort(struct soap *soap, const char *tag, int id, short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_short);
	if (id < 0)
		return soap->error;
	return soap_out_short(soap, tag, id, *a, type);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_get_PointerToshort(struct soap *soap, short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToshort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_in_PointerToshort(struct soap *soap, const char *tag, short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (short **)soap_malloc(soap, sizeof(short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_short(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_short, sizeof(short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CSystem(struct soap *soap, TT1__CSystem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CSystem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CSystem(struct soap *soap, TT1__CSystem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CSystem);
	if (soap_out_PointerToTT1__CSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CSystem(struct soap *soap, const char *tag, int id, TT1__CSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CSystem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CSystem ** SOAP_FMAC4 soap_get_PointerToTT1__CSystem(struct soap *soap, TT1__CSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CSystem ** SOAP_FMAC4 soap_in_PointerToTT1__CSystem(struct soap *soap, const char *tag, TT1__CSystem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CSystem **)soap_malloc(soap, sizeof(TT1__CSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CSystem *)soap_instantiate_TT1__CSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CSystem ** p = (TT1__CSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CSystem, sizeof(TT1__CSystem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CFileAttachment))
		soap_serialize_PointerToTT1__CFileAttachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CFileAttachment);
	if (soap_out_PointerToPointerToTT1__CFileAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CFileAttachment(struct soap *soap, const char *tag, int id, TT1__CFileAttachment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CFileAttachment);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CFileAttachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CFileAttachment *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFileAttachment *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CFileAttachment(struct soap *soap, const char *tag, TT1__CFileAttachment ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFileAttachment ***)soap_malloc(soap, sizeof(TT1__CFileAttachment **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CFileAttachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CFileAttachment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CFileAttachment, sizeof(TT1__CFileAttachment *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CFileAttachment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CFileAttachment);
	if (soap_out_PointerToTT1__CFileAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CFileAttachment(struct soap *soap, const char *tag, int id, TT1__CFileAttachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CFileAttachment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CFileAttachment ** SOAP_FMAC4 soap_get_PointerToTT1__CFileAttachment(struct soap *soap, TT1__CFileAttachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFileAttachment ** SOAP_FMAC4 soap_in_PointerToTT1__CFileAttachment(struct soap *soap, const char *tag, TT1__CFileAttachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFileAttachment **)soap_malloc(soap, sizeof(TT1__CFileAttachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CFileAttachment *)soap_instantiate_TT1__CFileAttachment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CFileAttachment ** p = (TT1__CFileAttachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFileAttachment, sizeof(TT1__CFileAttachment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CSCCFileRecord))
		soap_serialize_PointerToTT1__CSCCFileRecord(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CSCCFileRecord);
	if (soap_out_PointerToPointerToTT1__CSCCFileRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CSCCFileRecord(struct soap *soap, const char *tag, int id, TT1__CSCCFileRecord **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CSCCFileRecord);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CSCCFileRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CSCCFileRecord *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CSCCFileRecord *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CSCCFileRecord(struct soap *soap, const char *tag, TT1__CSCCFileRecord ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CSCCFileRecord ***)soap_malloc(soap, sizeof(TT1__CSCCFileRecord **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CSCCFileRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CSCCFileRecord ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CSCCFileRecord, sizeof(TT1__CSCCFileRecord *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CSCCFileRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CSCCFileRecord);
	if (soap_out_PointerToTT1__CSCCFileRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CSCCFileRecord(struct soap *soap, const char *tag, int id, TT1__CSCCFileRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CSCCFileRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CSCCFileRecord ** SOAP_FMAC4 soap_get_PointerToTT1__CSCCFileRecord(struct soap *soap, TT1__CSCCFileRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CSCCFileRecord ** SOAP_FMAC4 soap_in_PointerToTT1__CSCCFileRecord(struct soap *soap, const char *tag, TT1__CSCCFileRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CSCCFileRecord **)soap_malloc(soap, sizeof(TT1__CSCCFileRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CSCCFileRecord *)soap_instantiate_TT1__CSCCFileRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CSCCFileRecord ** p = (TT1__CSCCFileRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CSCCFileRecord, sizeof(TT1__CSCCFileRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CRecordRowSoap))
		soap_serialize_PointerToTT1__CRecordRowSoap(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CRecordRowSoap);
	if (soap_out_PointerToPointerToTT1__CRecordRowSoap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CRecordRowSoap(struct soap *soap, const char *tag, int id, TT1__CRecordRowSoap **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CRecordRowSoap);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CRecordRowSoap(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CRecordRowSoap *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CRecordRowSoap *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CRecordRowSoap(struct soap *soap, const char *tag, TT1__CRecordRowSoap ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CRecordRowSoap ***)soap_malloc(soap, sizeof(TT1__CRecordRowSoap **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CRecordRowSoap(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CRecordRowSoap ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CRecordRowSoap, sizeof(TT1__CRecordRowSoap *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CRecordRowSoap))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CRecordRowSoap);
	if (soap_out_PointerToTT1__CRecordRowSoap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CRecordRowSoap(struct soap *soap, const char *tag, int id, TT1__CRecordRowSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CRecordRowSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CRecordRowSoap ** SOAP_FMAC4 soap_get_PointerToTT1__CRecordRowSoap(struct soap *soap, TT1__CRecordRowSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CRecordRowSoap ** SOAP_FMAC4 soap_in_PointerToTT1__CRecordRowSoap(struct soap *soap, const char *tag, TT1__CRecordRowSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CRecordRowSoap **)soap_malloc(soap, sizeof(TT1__CRecordRowSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CRecordRowSoap *)soap_instantiate_TT1__CRecordRowSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CRecordRowSoap ** p = (TT1__CRecordRowSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CRecordRowSoap, sizeof(TT1__CRecordRowSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CRecordData))
		soap_serialize_PointerToTT1__CRecordData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CRecordData);
	if (soap_out_PointerToPointerToTT1__CRecordData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CRecordData(struct soap *soap, const char *tag, int id, TT1__CRecordData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CRecordData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CRecordData(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CRecordData *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CRecordData *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CRecordData(struct soap *soap, const char *tag, TT1__CRecordData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CRecordData ***)soap_malloc(soap, sizeof(TT1__CRecordData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CRecordData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CRecordData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CRecordData, sizeof(TT1__CRecordData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CRecordData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CRecordData);
	if (soap_out_PointerToTT1__CRecordData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CRecordData(struct soap *soap, const char *tag, int id, TT1__CRecordData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CRecordData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CRecordData ** SOAP_FMAC4 soap_get_PointerToTT1__CRecordData(struct soap *soap, TT1__CRecordData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CRecordData ** SOAP_FMAC4 soap_in_PointerToTT1__CRecordData(struct soap *soap, const char *tag, TT1__CRecordData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CRecordData **)soap_malloc(soap, sizeof(TT1__CRecordData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CRecordData *)soap_instantiate_TT1__CRecordData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CRecordData ** p = (TT1__CRecordData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CRecordData, sizeof(TT1__CRecordData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CFilter(struct soap *soap, TT1__CFilter **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CFilter))
		soap_serialize_PointerToTT1__CFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CFilter(struct soap *soap, TT1__CFilter **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CFilter);
	if (soap_out_PointerToPointerToTT1__CFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CFilter(struct soap *soap, const char *tag, int id, TT1__CFilter **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CFilter);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CFilter *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CFilter(struct soap *soap, TT1__CFilter ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFilter *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CFilter(struct soap *soap, const char *tag, TT1__CFilter ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFilter ***)soap_malloc(soap, sizeof(TT1__CFilter **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CFilter ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CFilter, sizeof(TT1__CFilter *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CFilter(struct soap *soap, TT1__CFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CFilter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CFilter(struct soap *soap, TT1__CFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CFilter);
	if (soap_out_PointerToTT1__CFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CFilter(struct soap *soap, const char *tag, int id, TT1__CFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CFilter ** SOAP_FMAC4 soap_get_PointerToTT1__CFilter(struct soap *soap, TT1__CFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFilter ** SOAP_FMAC4 soap_in_PointerToTT1__CFilter(struct soap *soap, const char *tag, TT1__CFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFilter **)soap_malloc(soap, sizeof(TT1__CFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CFilter *)soap_instantiate_TT1__CFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CFilter ** p = (TT1__CFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFilter, sizeof(TT1__CFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CTableColumn))
		soap_serialize_PointerToTT1__CTableColumn(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CTableColumn);
	if (soap_out_PointerToPointerToTT1__CTableColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CTableColumn(struct soap *soap, const char *tag, int id, TT1__CTableColumn **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CTableColumn);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CTableColumn(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CTableColumn *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTableColumn *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CTableColumn(struct soap *soap, const char *tag, TT1__CTableColumn ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTableColumn ***)soap_malloc(soap, sizeof(TT1__CTableColumn **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CTableColumn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CTableColumn ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CTableColumn, sizeof(TT1__CTableColumn *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTableColumn))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTableColumn);
	if (soap_out_PointerToTT1__CTableColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTableColumn(struct soap *soap, const char *tag, int id, TT1__CTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTableColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTableColumn ** SOAP_FMAC4 soap_get_PointerToTT1__CTableColumn(struct soap *soap, TT1__CTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTableColumn ** SOAP_FMAC4 soap_in_PointerToTT1__CTableColumn(struct soap *soap, const char *tag, TT1__CTableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTableColumn **)soap_malloc(soap, sizeof(TT1__CTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTableColumn *)soap_instantiate_TT1__CTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTableColumn ** p = (TT1__CTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTableColumn, sizeof(TT1__CTableColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CFieldValue))
		soap_serialize_PointerToTT1__CFieldValue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CFieldValue);
	if (soap_out_PointerToPointerToTT1__CFieldValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CFieldValue(struct soap *soap, const char *tag, int id, TT1__CFieldValue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CFieldValue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CFieldValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CFieldValue *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFieldValue *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CFieldValue(struct soap *soap, const char *tag, TT1__CFieldValue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFieldValue ***)soap_malloc(soap, sizeof(TT1__CFieldValue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CFieldValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CFieldValue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CFieldValue, sizeof(TT1__CFieldValue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CFieldValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CFieldValue);
	if (soap_out_PointerToTT1__CFieldValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CFieldValue(struct soap *soap, const char *tag, int id, TT1__CFieldValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CFieldValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CFieldValue ** SOAP_FMAC4 soap_get_PointerToTT1__CFieldValue(struct soap *soap, TT1__CFieldValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CFieldValue ** SOAP_FMAC4 soap_in_PointerToTT1__CFieldValue(struct soap *soap, const char *tag, TT1__CFieldValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CFieldValue **)soap_malloc(soap, sizeof(TT1__CFieldValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CFieldValue *)soap_instantiate_TT1__CFieldValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CFieldValue ** p = (TT1__CFieldValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CFieldValue, sizeof(TT1__CFieldValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CTableField(struct soap *soap, TT1__CTableField **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CTableField))
		soap_serialize_PointerToTT1__CTableField(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CTableField(struct soap *soap, TT1__CTableField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CTableField);
	if (soap_out_PointerToPointerToTT1__CTableField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CTableField(struct soap *soap, const char *tag, int id, TT1__CTableField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CTableField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CTableField(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CTableField *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CTableField(struct soap *soap, TT1__CTableField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTableField *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CTableField(struct soap *soap, const char *tag, TT1__CTableField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTableField ***)soap_malloc(soap, sizeof(TT1__CTableField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CTableField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CTableField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CTableField, sizeof(TT1__CTableField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CTableField(struct soap *soap, TT1__CTableField *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CTableField))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CTableField(struct soap *soap, TT1__CTableField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CTableField);
	if (soap_out_PointerToTT1__CTableField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CTableField(struct soap *soap, const char *tag, int id, TT1__CTableField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CTableField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CTableField ** SOAP_FMAC4 soap_get_PointerToTT1__CTableField(struct soap *soap, TT1__CTableField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CTableField ** SOAP_FMAC4 soap_in_PointerToTT1__CTableField(struct soap *soap, const char *tag, TT1__CTableField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CTableField **)soap_malloc(soap, sizeof(TT1__CTableField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CTableField *)soap_instantiate_TT1__CTableField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CTableField ** p = (TT1__CTableField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CTableField, sizeof(TT1__CTableField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CDatabaseTable))
		soap_serialize_PointerToTT1__CDatabaseTable(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CDatabaseTable);
	if (soap_out_PointerToPointerToTT1__CDatabaseTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CDatabaseTable(struct soap *soap, const char *tag, int id, TT1__CDatabaseTable **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CDatabaseTable);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CDatabaseTable(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CDatabaseTable *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDatabaseTable *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CDatabaseTable(struct soap *soap, const char *tag, TT1__CDatabaseTable ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDatabaseTable ***)soap_malloc(soap, sizeof(TT1__CDatabaseTable **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CDatabaseTable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CDatabaseTable ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CDatabaseTable, sizeof(TT1__CDatabaseTable *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CDatabaseTable))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CDatabaseTable);
	if (soap_out_PointerToTT1__CDatabaseTable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CDatabaseTable(struct soap *soap, const char *tag, int id, TT1__CDatabaseTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CDatabaseTable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CDatabaseTable ** SOAP_FMAC4 soap_get_PointerToTT1__CDatabaseTable(struct soap *soap, TT1__CDatabaseTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDatabaseTable ** SOAP_FMAC4 soap_in_PointerToTT1__CDatabaseTable(struct soap *soap, const char *tag, TT1__CDatabaseTable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDatabaseTable **)soap_malloc(soap, sizeof(TT1__CDatabaseTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CDatabaseTable *)soap_instantiate_TT1__CDatabaseTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CDatabaseTable ** p = (TT1__CDatabaseTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDatabaseTable, sizeof(TT1__CDatabaseTable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CProject(struct soap *soap, TT1__CProject **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CProject))
		soap_serialize_PointerToTT1__CProject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CProject(struct soap *soap, TT1__CProject **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CProject);
	if (soap_out_PointerToPointerToTT1__CProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CProject(struct soap *soap, const char *tag, int id, TT1__CProject **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CProject);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CProject(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CProject *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CProject(struct soap *soap, TT1__CProject ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CProject *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CProject(struct soap *soap, const char *tag, TT1__CProject ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CProject ***)soap_malloc(soap, sizeof(TT1__CProject **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CProject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CProject ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CProject, sizeof(TT1__CProject *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CProject(struct soap *soap, TT1__CProject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CProject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CProject(struct soap *soap, TT1__CProject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CProject);
	if (soap_out_PointerToTT1__CProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CProject(struct soap *soap, const char *tag, int id, TT1__CProject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CProject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CProject ** SOAP_FMAC4 soap_get_PointerToTT1__CProject(struct soap *soap, TT1__CProject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CProject ** SOAP_FMAC4 soap_in_PointerToTT1__CProject(struct soap *soap, const char *tag, TT1__CProject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CProject **)soap_malloc(soap, sizeof(TT1__CProject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CProject *)soap_instantiate_TT1__CProject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CProject ** p = (TT1__CProject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CProject, sizeof(TT1__CProject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CProjectDataOption))
		soap_serialize_PointerToTT1__CProjectDataOption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CProjectDataOption);
	if (soap_out_PointerToPointerToTT1__CProjectDataOption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CProjectDataOption(struct soap *soap, const char *tag, int id, TT1__CProjectDataOption **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CProjectDataOption);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CProjectDataOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CProjectDataOption *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CProjectDataOption *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CProjectDataOption(struct soap *soap, const char *tag, TT1__CProjectDataOption ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CProjectDataOption ***)soap_malloc(soap, sizeof(TT1__CProjectDataOption **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CProjectDataOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CProjectDataOption ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CProjectDataOption, sizeof(TT1__CProjectDataOption *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CProjectDataOption))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CProjectDataOption);
	if (soap_out_PointerToTT1__CProjectDataOption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CProjectDataOption(struct soap *soap, const char *tag, int id, TT1__CProjectDataOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CProjectDataOption);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CProjectDataOption ** SOAP_FMAC4 soap_get_PointerToTT1__CProjectDataOption(struct soap *soap, TT1__CProjectDataOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CProjectDataOption ** SOAP_FMAC4 soap_in_PointerToTT1__CProjectDataOption(struct soap *soap, const char *tag, TT1__CProjectDataOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CProjectDataOption **)soap_malloc(soap, sizeof(TT1__CProjectDataOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CProjectDataOption *)soap_instantiate_TT1__CProjectDataOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CProjectDataOption ** p = (TT1__CProjectDataOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CProjectDataOption, sizeof(TT1__CProjectDataOption), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToTT1__CDatabase))
		soap_serialize_PointerToTT1__CDatabase(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToTT1__CDatabase);
	if (soap_out_PointerToPointerToTT1__CDatabase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToTT1__CDatabase(struct soap *soap, const char *tag, int id, TT1__CDatabase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToTT1__CDatabase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToTT1__CDatabase(soap, tag, id, *a, type);
}

SOAP_FMAC3 TT1__CDatabase *** SOAP_FMAC4 soap_get_PointerToPointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToTT1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDatabase *** SOAP_FMAC4 soap_in_PointerToPointerToTT1__CDatabase(struct soap *soap, const char *tag, TT1__CDatabase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDatabase ***)soap_malloc(soap, sizeof(TT1__CDatabase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToTT1__CDatabase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (TT1__CDatabase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToTT1__CDatabase, sizeof(TT1__CDatabase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCField(struct soap *soap, TT1ArrayOfCField *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCField(struct soap *soap, TT1ArrayOfCField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCField);
	if (soap_out_PointerToTT1ArrayOfCField(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCField(struct soap *soap, const char *tag, int id, TT1ArrayOfCField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCField ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCField(struct soap *soap, TT1ArrayOfCField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCField ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCField(struct soap *soap, const char *tag, TT1ArrayOfCField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCField **)soap_malloc(soap, sizeof(TT1ArrayOfCField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCField *)soap_instantiate_TT1ArrayOfCField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCField ** p = (TT1ArrayOfCField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCField, sizeof(TT1ArrayOfCField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCFieldValue(struct soap *soap, TT1ArrayOfCFieldValue *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCFieldValue(struct soap *soap, TT1ArrayOfCFieldValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCFieldValue);
	if (soap_out_PointerToTT1ArrayOfCFieldValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCFieldValue(struct soap *soap, const char *tag, int id, TT1ArrayOfCFieldValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCFieldValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCFieldValue ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCFieldValue(struct soap *soap, TT1ArrayOfCFieldValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCFieldValue ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCFieldValue(struct soap *soap, const char *tag, TT1ArrayOfCFieldValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCFieldValue **)soap_malloc(soap, sizeof(TT1ArrayOfCFieldValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCFieldValue *)soap_instantiate_TT1ArrayOfCFieldValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCFieldValue ** p = (TT1ArrayOfCFieldValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCFieldValue, sizeof(TT1ArrayOfCFieldValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCRecordRowSoap(struct soap *soap, TT1ArrayOfCRecordRowSoap *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCRecordRowSoap(struct soap *soap, TT1ArrayOfCRecordRowSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCRecordRowSoap);
	if (soap_out_PointerToTT1ArrayOfCRecordRowSoap(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, int id, TT1ArrayOfCRecordRowSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCRecordRowSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordRowSoap ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCRecordRowSoap(struct soap *soap, TT1ArrayOfCRecordRowSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCRecordRowSoap ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, TT1ArrayOfCRecordRowSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCRecordRowSoap **)soap_malloc(soap, sizeof(TT1ArrayOfCRecordRowSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCRecordRowSoap *)soap_instantiate_TT1ArrayOfCRecordRowSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCRecordRowSoap ** p = (TT1ArrayOfCRecordRowSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCRecordRowSoap, sizeof(TT1ArrayOfCRecordRowSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCTableColumn(struct soap *soap, TT1ArrayOfCTableColumn *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCTableColumn(struct soap *soap, TT1ArrayOfCTableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCTableColumn);
	if (soap_out_PointerToTT1ArrayOfCTableColumn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCTableColumn(struct soap *soap, const char *tag, int id, TT1ArrayOfCTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCTableColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCTableColumn ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCTableColumn(struct soap *soap, TT1ArrayOfCTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCTableColumn ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCTableColumn(struct soap *soap, const char *tag, TT1ArrayOfCTableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCTableColumn **)soap_malloc(soap, sizeof(TT1ArrayOfCTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCTableColumn *)soap_instantiate_TT1ArrayOfCTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCTableColumn ** p = (TT1ArrayOfCTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCTableColumn, sizeof(TT1ArrayOfCTableColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCRecordData(struct soap *soap, TT1ArrayOfCRecordData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCRecordData(struct soap *soap, TT1ArrayOfCRecordData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCRecordData);
	if (soap_out_PointerToTT1ArrayOfCRecordData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCRecordData(struct soap *soap, const char *tag, int id, TT1ArrayOfCRecordData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCRecordData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCRecordData ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCRecordData(struct soap *soap, TT1ArrayOfCRecordData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCRecordData ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCRecordData(struct soap *soap, const char *tag, TT1ArrayOfCRecordData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCRecordData **)soap_malloc(soap, sizeof(TT1ArrayOfCRecordData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCRecordData *)soap_instantiate_TT1ArrayOfCRecordData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCRecordData ** p = (TT1ArrayOfCRecordData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCRecordData, sizeof(TT1ArrayOfCRecordData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1ArrayOfCProjectDataOption(struct soap *soap, TT1ArrayOfCProjectDataOption *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1ArrayOfCProjectDataOption(struct soap *soap, TT1ArrayOfCProjectDataOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1ArrayOfCProjectDataOption);
	if (soap_out_PointerToTT1ArrayOfCProjectDataOption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1ArrayOfCProjectDataOption(struct soap *soap, const char *tag, int id, TT1ArrayOfCProjectDataOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_TT1ArrayOfCProjectDataOption);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1ArrayOfCProjectDataOption ** SOAP_FMAC4 soap_get_PointerToTT1ArrayOfCProjectDataOption(struct soap *soap, TT1ArrayOfCProjectDataOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1ArrayOfCProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1ArrayOfCProjectDataOption ** SOAP_FMAC4 soap_in_PointerToTT1ArrayOfCProjectDataOption(struct soap *soap, const char *tag, TT1ArrayOfCProjectDataOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1ArrayOfCProjectDataOption **)soap_malloc(soap, sizeof(TT1ArrayOfCProjectDataOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1ArrayOfCProjectDataOption *)soap_instantiate_TT1ArrayOfCProjectDataOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1ArrayOfCProjectDataOption ** p = (TT1ArrayOfCProjectDataOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1ArrayOfCProjectDataOption, sizeof(TT1ArrayOfCProjectDataOption), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_TT1__CDatabase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToTT1__CDatabase);
	if (soap_out_PointerToTT1__CDatabase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTT1__CDatabase(struct soap *soap, const char *tag, int id, TT1__CDatabase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_TT1__CDatabase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 TT1__CDatabase ** SOAP_FMAC4 soap_get_PointerToTT1__CDatabase(struct soap *soap, TT1__CDatabase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTT1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 TT1__CDatabase ** SOAP_FMAC4 soap_in_PointerToTT1__CDatabase(struct soap *soap, const char *tag, TT1__CDatabase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TT1__CDatabase **)soap_malloc(soap, sizeof(TT1__CDatabase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TT1__CDatabase *)soap_instantiate_TT1__CDatabase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	TT1__CDatabase ** p = (TT1__CDatabase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TT1__CDatabase, sizeof(TT1__CDatabase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of TestTrackC.cpp */
