/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_MATERIAL_ENUMS
#define INCLUDED_ENGINE_MATERIAL_ENUMS 1

enum ESceneTextureType
{
    SceneTex_Lighting       =0,
    SceneTex_MAX            =1,
};
enum EMaterialVectorCoordTransform
{
    TRANSFORM_World         =0,
    TRANSFORM_View          =1,
    TRANSFORM_Local         =2,
    TRANSFORM_MAX           =3,
};
enum EMaterialPositionTransform
{
    TRANSFORMPOS_World      =0,
    TRANSFORMPOS_MAX        =1,
};

#endif // !INCLUDED_ENGINE_MATERIAL_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_MATERIAL_CLASSES
#define INCLUDED_ENGINE_MATERIAL_CLASSES 1

class UMaterialExpressionAbs : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAbs
    FExpressionInput Input;
    //## END PROPS MaterialExpressionAbs

    DECLARE_CLASS(UMaterialExpressionAbs,UMaterialExpression,0,Engine)
    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler );

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionAdd : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAdd
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAdd

    DECLARE_CLASS(UMaterialExpressionAdd,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionAppendVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAppendVector
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAppendVector

    DECLARE_CLASS(UMaterialExpressionAppendVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionBumpOffset : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionBumpOffset
    FExpressionInput Coordinate;
    FExpressionInput Height;
    FLOAT HeightRatio;
    FLOAT ReferencePlane;
    //## END PROPS MaterialExpressionBumpOffset

    DECLARE_CLASS(UMaterialExpressionBumpOffset,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCameraVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraVector
    //## END PROPS MaterialExpressionCameraVector

    DECLARE_CLASS(UMaterialExpressionCameraVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCameraWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraWorldPosition
    //## END PROPS MaterialExpressionCameraWorldPosition

    DECLARE_CLASS(UMaterialExpressionCameraWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCeil : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCeil
    FExpressionInput Input;
    //## END PROPS MaterialExpressionCeil

    DECLARE_CLASS(UMaterialExpressionCeil,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionClamp
    FExpressionInput Input;
    FExpressionInput Min;
    FExpressionInput Max;
    //## END PROPS MaterialExpressionClamp

    DECLARE_CLASS(UMaterialExpressionClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionComment : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComment
    INT PosX;
    INT PosY;
    INT SizeX;
    INT SizeY;
    FStringNoInit Text;
    //## END PROPS MaterialExpressionComment

    DECLARE_CLASS(UMaterialExpressionComment,UMaterialExpression,0,Engine)
	/**
	 * Text description of this expression.
	 */
	virtual FString GetCaption() const;
};

class UMaterialExpressionComponentMask : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComponentMask
    FExpressionInput Input;
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    //## END PROPS MaterialExpressionComponentMask

    DECLARE_CLASS(UMaterialExpressionComponentMask,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCompound : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCompound
    TArrayNoInit<class UMaterialExpression*> MaterialExpressions;
    FStringNoInit Caption;
    BITFIELD bExpanded:1;
    //## END PROPS MaterialExpressionCompound

    DECLARE_CLASS(UMaterialExpressionCompound,UMaterialExpression,0,Engine)
	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;
	
	/**
	 * Recursively gathers all UMaterialExpression objects referenced by this expression.
	 * Including self.
	 *
	 * @param	Expressions	- Reference to array of material expressions to add to
	 */	
	virtual void GetExpressions( TArray<const UMaterialExpression*>& Expressions ) const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionConstant : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant
    FLOAT R;
    //## END PROPS MaterialExpressionConstant

    DECLARE_CLASS(UMaterialExpressionConstant,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant2Vector
    FLOAT R;
    FLOAT G;
    //## END PROPS MaterialExpressionConstant2Vector

    DECLARE_CLASS(UMaterialExpressionConstant2Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant3Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    //## END PROPS MaterialExpressionConstant3Vector

    DECLARE_CLASS(UMaterialExpressionConstant3Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant4Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    FLOAT A;
    //## END PROPS MaterialExpressionConstant4Vector

    DECLARE_CLASS(UMaterialExpressionConstant4Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstantClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstantClamp
    FExpressionInput Input;
    FLOAT Min;
    FLOAT Max;
    //## END PROPS MaterialExpressionConstantClamp

    DECLARE_CLASS(UMaterialExpressionConstantClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCosine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCosine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionCosine

    DECLARE_CLASS(UMaterialExpressionCosine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCrossProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCrossProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionCrossProduct

    DECLARE_CLASS(UMaterialExpressionCrossProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedAlpha
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedAlpha

    DECLARE_CLASS(UMaterialExpressionDepthBiasedAlpha,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput RGB;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasedBlend,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 *	Get the outputs associated with the expression
	 *
	 *	@param	Outputs		The array that contains the output expression
	 */	
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDesaturation : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDesaturation
    FExpressionInput Input;
    FExpressionInput Percent;
    FLinearColor LuminanceFactors;
    //## END PROPS MaterialExpressionDesaturation

    DECLARE_CLASS(UMaterialExpressionDesaturation,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const
	{
		return TEXT("Desaturation");
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDestColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestColor
    //## END PROPS MaterialExpressionDestColor

    DECLARE_CLASS(UMaterialExpressionDestColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionDestDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestDepth
    BITFIELD bNormalize:1;
    //## END PROPS MaterialExpressionDestDepth

    DECLARE_CLASS(UMaterialExpressionDestDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionDivide : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDivide
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDivide

    DECLARE_CLASS(UMaterialExpressionDivide,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDotProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDotProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDotProduct

    DECLARE_CLASS(UMaterialExpressionDotProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFloor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFloor
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFloor

    DECLARE_CLASS(UMaterialExpressionFloor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFontSample
    class UFont* Font;
    INT FontTexturePage;
    //## END PROPS MaterialExpressionFontSample

    DECLARE_CLASS(UMaterialExpressionFontSample,UMaterialExpression,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	* List of outputs from this expression
	* @param Outputs - out list of expression
	*/
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	* Width of the thumbnail for this expression int he material editor
	* @return size in pixels
	*/
	virtual INT GetWidth() const;

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;

	/**
	* Padding for the text lable
	* @return size in pixels
	*/
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
public:
    //## BEGIN PROPS MaterialExpressionFontSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionFontSampleParameter

    DECLARE_CLASS(UMaterialExpressionFontSampleParameter,UMaterialExpressionFontSample,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;
	
	/**
	 *	Sets the default Font if none is set
	 */
	virtual void SetDefaultFont();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();
};

class UMaterialExpressionFrac : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFrac
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFrac

    DECLARE_CLASS(UMaterialExpressionFrac,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFresnel : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFresnel
    FLOAT Exponent;
    FExpressionInput Normal;
    //## END PROPS MaterialExpressionFresnel

    DECLARE_CLASS(UMaterialExpressionFresnel,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const
	{
		return FString(TEXT("Fresnel"));
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionIf : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionIf
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput AGreaterThanB;
    FExpressionInput AEqualsB;
    FExpressionInput ALessThanB;
    //## END PROPS MaterialExpressionIf

    DECLARE_CLASS(UMaterialExpressionIf,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionLensFlareIntensity : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareIntensity
    //## END PROPS MaterialExpressionLensFlareIntensity

    DECLARE_CLASS(UMaterialExpressionLensFlareIntensity,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareOcclusion
    //## END PROPS MaterialExpressionLensFlareOcclusion

    DECLARE_CLASS(UMaterialExpressionLensFlareOcclusion,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRadialDistance
    //## END PROPS MaterialExpressionLensFlareRadialDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRadialDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRayDistance
    //## END PROPS MaterialExpressionLensFlareRayDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRayDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareSourceDistance
    //## END PROPS MaterialExpressionLensFlareSourceDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareSourceDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLightVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightVector
    //## END PROPS MaterialExpressionLightVector

    DECLARE_CLASS(UMaterialExpressionLightVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLinearInterpolate
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput Alpha;
    //## END PROPS MaterialExpressionLinearInterpolate

    DECLARE_CLASS(UMaterialExpressionLinearInterpolate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMeshEmitterVertexColor
    //## END PROPS MaterialExpressionMeshEmitterVertexColor

    DECLARE_CLASS(UMaterialExpressionMeshEmitterVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
};

class UMaterialExpressionMultiply : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMultiply
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionMultiply

    DECLARE_CLASS(UMaterialExpressionMultiply,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionNormalize : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionNormalize
    FExpressionInput VectorInput;
    //## END PROPS MaterialExpressionNormalize

    DECLARE_CLASS(UMaterialExpressionNormalize,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const { return TEXT("Normalize"); }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionOneMinus : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionOneMinus
    FExpressionInput Input;
    //## END PROPS MaterialExpressionOneMinus

    DECLARE_CLASS(UMaterialExpressionOneMinus,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionPanner : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPanner
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT SpeedX;
    FLOAT SpeedY;
    //## END PROPS MaterialExpressionPanner

    DECLARE_CLASS(UMaterialExpressionPanner,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionParameter : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionParameter
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionParameter

    DECLARE_CLASS(UMaterialExpressionParameter,UMaterialExpression,0,Engine)
	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();
};

class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionScalarParameter
    FName ParameterName;
    FLOAT DefaultValue;
    //## END PROPS MaterialExpressionScalarParameter

    DECLARE_CLASS(UMaterialExpressionScalarParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticComponentMaskParameter
    FName ParameterName;
    FExpressionInput Input;
    BITFIELD DefaultR:1;
    BITFIELD DefaultG:1;
    BITFIELD DefaultB:1;
    BITFIELD DefaultA:1;
    const FStaticComponentMaskParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticComponentMaskParameter

    DECLARE_CLASS(UMaterialExpressionStaticComponentMaskParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticSwitchParameter
    FName ParameterName;
    BITFIELD DefaultValue:1;
    BITFIELD ExtendedCaptionDisplay:1;
    FExpressionInput A;
    FExpressionInput B;
    const FStaticSwitchParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticSwitchParameter

    DECLARE_CLASS(UMaterialExpressionStaticSwitchParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionVectorParameter
    FName ParameterName;
    FLinearColor DefaultValue;
    //## END PROPS MaterialExpressionVectorParameter

    DECLARE_CLASS(UMaterialExpressionVectorParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionPixelDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPixelDepth
    BITFIELD bNormalize:1;
    //## END PROPS MaterialExpressionPixelDepth

    DECLARE_CLASS(UMaterialExpressionPixelDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionPower : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPower
    FExpressionInput Base;
    FExpressionInput Exponent;
    //## END PROPS MaterialExpressionPower

    DECLARE_CLASS(UMaterialExpressionPower,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionReflectionVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionReflectionVector
    //## END PROPS MaterialExpressionReflectionVector

    DECLARE_CLASS(UMaterialExpressionReflectionVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionRotator : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionRotator
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT Speed;
    //## END PROPS MaterialExpressionRotator

    DECLARE_CLASS(UMaterialExpressionRotator,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSceneDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneDepth
    FExpressionInput Coordinates;
    BITFIELD bNormalize:1;
    //## END PROPS MaterialExpressionSceneDepth

    DECLARE_CLASS(UMaterialExpressionSceneDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionSceneTexture : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneTexture
    FExpressionInput Coordinates;
    BYTE SceneTextureType;
    BITFIELD ScreenAlign:1 GCC_BITFIELD_MAGIC;
    //## END PROPS MaterialExpressionSceneTexture

    DECLARE_CLASS(UMaterialExpressionSceneTexture,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionScreenPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionScreenPosition
    BITFIELD ScreenAlign:1;
    //## END PROPS MaterialExpressionScreenPosition

    DECLARE_CLASS(UMaterialExpressionScreenPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionSine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionSine

    DECLARE_CLASS(UMaterialExpressionSine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSquareRoot : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSquareRoot
    FExpressionInput Input;
    //## END PROPS MaterialExpressionSquareRoot

    DECLARE_CLASS(UMaterialExpressionSquareRoot,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSubtract : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSubtract
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionSubtract

    DECLARE_CLASS(UMaterialExpressionSubtract,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureCoordinate
    INT CoordinateIndex;
    FLOAT Tiling;
    //## END PROPS MaterialExpressionTextureCoordinate

    DECLARE_CLASS(UMaterialExpressionTextureCoordinate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSample
    class UTexture* Texture;
    FExpressionInput Coordinates;
    //## END PROPS MaterialExpressionTextureSample

    DECLARE_CLASS(UMaterialExpressionTextureSample,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Updates the material's cached reference to the resource for a given texture.
	 * @param Texture - The UTexture which has a new FTexture.
	 */
	void UpdateTextureResource(class UTexture* Texture);

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthBiasBlend : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasBlend,UMaterialExpressionTextureSample,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 *	Get the outputs associated with the expression
	 *
	 *	@param	Outputs		The array that contains the output expression
	 */	
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFlipBookSample : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionFlipBookSample
    //## END PROPS MaterialExpressionFlipBookSample

    DECLARE_CLASS(UMaterialExpressionFlipBookSample,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionMeshSubUV
    //## END PROPS MaterialExpressionMeshSubUV

    DECLARE_CLASS(UMaterialExpressionMeshSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionParticleSubUV
    //## END PROPS MaterialExpressionParticleSubUV

    DECLARE_CLASS(UMaterialExpressionParticleSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionTextureSampleParameter

    DECLARE_ABSTRACT_CLASS(UMaterialExpressionTextureSampleParameter,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();
};

class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter2D
    //## END PROPS MaterialExpressionTextureSampleParameter2D

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameter2D,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterCube
    //## END PROPS MaterialExpressionTextureSampleParameterCube

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterCube,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionTextureSampleParameterMovie : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMovie
    //## END PROPS MaterialExpressionTextureSampleParameterMovie

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMovie,UMaterialExpressionTextureSampleParameter,0,Engine)
	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Return true if the texture is a movie texture
	 *
	 * @param	InTexture - texture to test
	 * @return	true/false
	 */	
	virtual UBOOL TextureIsValid( UTexture* InTexture );

    /**
	 * Called when TextureIsValid==false
	 *
	 * @return	Descriptive error text
	 */	
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTime : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTime
    BITFIELD bIgnorePause:1;
    //## END PROPS MaterialExpressionTime

    DECLARE_CLASS(UMaterialExpressionTime,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTransform : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransform
    FExpressionInput Input;
    BYTE TransformType;
    //## END PROPS MaterialExpressionTransform

    DECLARE_CLASS(UMaterialExpressionTransform,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTransformPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransformPosition
    FExpressionInput Input;
    BYTE TransformType;
    //## END PROPS MaterialExpressionTransformPosition

    DECLARE_CLASS(UMaterialExpressionTransformPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionVertexColor
    //## END PROPS MaterialExpressionVertexColor

    DECLARE_CLASS(UMaterialExpressionVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
};

class UMaterialInstance : public UMaterialInterface
{
public:
    //## BEGIN PROPS MaterialInstance
    class UPhysicalMaterial* PhysMaterial;
    class UMaterialInterface* Parent;
    BITFIELD bHasStaticPermutationResource:1;
    BITFIELD ReentrantFlag:1;
    BITFIELD bStaticPermutationDirty:1;
    FStaticParameterSet* StaticParameters[2];
    FMaterialResource* StaticPermutationResources[2];
    class FMaterialInstanceResource* Resources[2];
    //## END PROPS MaterialInstance

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetVectorParameterValue(FName ParameterName,FLinearColor Value);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    DECLARE_FUNCTION(execSetParent)
    {
        P_GET_OBJECT(UMaterialInterface,NewParent);
        P_FINISH;
        SetParent(NewParent);
    }
    DECLARE_FUNCTION(execSetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FLinearColor,Value);
        P_FINISH;
        SetVectorParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        SetScalarParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT(FInterpCurveFloat,Value);
        P_FINISH;
        SetScalarCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UTexture,Value);
        P_FINISH;
        SetTextureParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UFont,FontValue);
        P_GET_INT(FontPage);
        P_FINISH;
        SetFontParameterValue(ParameterName,FontValue,FontPage);
    }
    DECLARE_FUNCTION(execClearParameterValues)
    {
        P_FINISH;
        ClearParameterValues();
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInstance,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterialInstance();

	/**
	* Passes the allocation request up the MIC chain
	* @return	The allocated resource
	*/
	FMaterialResource* AllocateResource();

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource * GetMaterialResource(EShaderPlatform Platform=GRHIShaderPlatform);

	// UMaterialInterface interface.
	virtual UMaterial* GetMaterial();

	/**
	* Gets the value of the given static switch parameter.  If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	* Gets the value of the given static component mask parameter. If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A,FGuid &OutExpressionGuid);

	virtual UBOOL IsDependent(UMaterialInterface* TestDependency);
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	* Makes a copy of all the instance's inherited and overriden static parameters
	*
	* @param StaticParameters - The set of static parameters to fill, must be empty
	*/
	void GetStaticParameterValues(FStaticParameterSet * StaticParameters);

	/**
	* Passes the override up the MIC chain
	*
	* @param	Permutation		The set of static parameters to override and their values	
	*/
	void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	* Passes the override clear up the MIC chain
	*/
	void ClearStaticParameterOverrides();

	/**
	* Sets the instance's static parameters and marks it dirty if appropriate. 
	*
	* @param	EditorParameters	The new static parameters.  If the set does not contain any static parameters,
	*								the static permutation resource will be released.
	* @return		TRUE if the static permutation resource has been marked dirty
	*/
	UBOOL SetStaticParameterValues(const FStaticParameterSet* EditorParameters);

	/**
	* Compiles the static permutation resource if the base material has changed and updates dirty states
	*/
	void UpdateStaticPermutation();

	/**
	* Updates static parameters and recompiles the static permutation resource if necessary
	*/
	void InitStaticPermutation();

	/**
	* Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	*
	* @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	* @param bForceAllPlatforms - compile for all platforms, not just the current.
	*/
	void CacheResourceShaders(UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bForceAllPlatforms=FALSE);

	/**
	 * Passes the compile request up the MIC chain
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* Permutation, 
		FMaterialResource* StaticPermutation, 
		EShaderPlatform Platform, 
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps);

	/**
	* Allocates the static permutation resources for all platforms if they haven't been already.
	* Also updates the material resource's Material member as it may have changed.
	* (This can happen if a Fallback Material is assigned after the material resource is created)
	*/
	void AllocateStaticPermutations();

	/**
	* Releases the static permutation resource if it exists, in a thread safe way
	*/
	void ReleaseStaticPermutations();

	// UObject interface.
	void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

};

struct FFontParameterValue
{
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
    FGuid ExpressionGUID;
};

struct FScalarParameterValue
{
    FName ParameterName;
    FLOAT ParameterValue;
    FGuid ExpressionGUID;
};

struct FTextureParameterValue
{
    FName ParameterName;
    class UTexture* ParameterValue;
    FGuid ExpressionGUID;
};

struct FVectorParameterValue
{
    FName ParameterName;
    FLinearColor ParameterValue;
    FGuid ExpressionGUID;
};

class UMaterialInstanceConstant : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceConstant
    TArrayNoInit<struct FFontParameterValue> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValue> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValue> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValue> VectorParameterValues;
    //## END PROPS MaterialInstanceConstant

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,FLinearColor Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    DECLARE_CLASS(UMaterialInstanceConstant,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceConstant();

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

};

struct FFontParameterValueOverTime
{
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
    FGuid ExpressionGUID;
};

struct FScalarParameterValueOverTime
{
    FName ParameterName;
    FLOAT ParameterValue;
    FLOAT StartTime;
    BITFIELD bAutoActivate:1;
    FInterpCurveFloat ParameterValueCurve;
    FGuid ExpressionGUID;

    /** Constructors */
    FScalarParameterValueOverTime() {}
    FScalarParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FScalarParameterValueOverTime));
    }
};

struct FTextureParameterValueOverTime
{
    FName ParameterName;
    class UTexture* ParameterValue;
    FGuid ExpressionGUID;
};

struct FVectorParameterValueOverTime
{
    FName ParameterName;
    FLinearColor ParameterValue;
    FGuid ExpressionGUID;
};

class UMaterialInstanceTimeVarying : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceTimeVarying
    TArrayNoInit<struct FFontParameterValueOverTime> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValueOverTime> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValueOverTime> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValueOverTime> VectorParameterValues;
    //## END PROPS MaterialInstanceTimeVarying

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat Value);
    virtual void SetScalarStartTime(FName ParameterName,FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,FLinearColor Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    DECLARE_FUNCTION(execSetScalarStartTime)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        SetScalarStartTime(ParameterName,Value);
    }
    DECLARE_CLASS(UMaterialInstanceTimeVarying,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceTimeVarying();

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	/**
	 * For MITVs you can utilize both single Scalar values and InterpCurve values.
	 *
	 * If there is any data in the InterpCurve, then the MITV will utilize that. Else it will utilize the Scalar value
	 * of the same name.
	 **/
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();
};

#endif // !INCLUDED_ENGINE_MATERIAL_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarStartTime);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetParent);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_MATERIAL_NATIVE_DEFS
#define ENGINE_MATERIAL_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionAbs);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionAdd);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionAppendVector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionBumpOffset);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCameraVector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCameraWorldPosition);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCeil);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionClamp);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionComment);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionComponentMask);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCompound);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionConstant);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionConstant2Vector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionConstant3Vector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionConstant4Vector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionConstantClamp);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCosine);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionCrossProduct);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDepthBiasBlend);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDepthBiasedAlpha);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDepthBiasedBlend);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDesaturation);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDestColor);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDestDepth);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDivide);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionDotProduct);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFlipBookSample);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFloor);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFontSample);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFontSampleParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFrac);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionFresnel);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionIf);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLensFlareIntensity);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLensFlareOcclusion);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLensFlareRadialDistance);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLensFlareRayDistance);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLensFlareSourceDistance);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLightVector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionLinearInterpolate);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionMeshEmitterVertexColor);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionMeshSubUV);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionMultiply);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionNormalize);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionOneMinus);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionPanner);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionParticleSubUV);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionPixelDepth);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionPower);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionReflectionVector);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionRotator);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionScalarParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionSceneDepth);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionSceneTexture);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionScreenPosition);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionSine);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionSquareRoot);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionStaticComponentMaskParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionStaticSwitchParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionSubtract);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureCoordinate);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureSample);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureSampleParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureSampleParameter2D);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureSampleParameterCube);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTextureSampleParameterMovie);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTime);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTransform);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionTransformPosition);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionVectorParameter);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpressionVertexColor);
DECLARE_NATIVE_TYPE(Engine,UMaterialInstance);
DECLARE_NATIVE_TYPE(Engine,UMaterialInstanceConstant);
DECLARE_NATIVE_TYPE(Engine,UMaterialInstanceTimeVarying);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_MATERIAL \
	UMaterialExpressionAbs::StaticClass(); \
	UMaterialExpressionAdd::StaticClass(); \
	UMaterialExpressionAppendVector::StaticClass(); \
	UMaterialExpressionBumpOffset::StaticClass(); \
	UMaterialExpressionCameraVector::StaticClass(); \
	UMaterialExpressionCameraWorldPosition::StaticClass(); \
	UMaterialExpressionCeil::StaticClass(); \
	UMaterialExpressionClamp::StaticClass(); \
	UMaterialExpressionComment::StaticClass(); \
	UMaterialExpressionComponentMask::StaticClass(); \
	UMaterialExpressionCompound::StaticClass(); \
	UMaterialExpressionConstant::StaticClass(); \
	UMaterialExpressionConstant2Vector::StaticClass(); \
	UMaterialExpressionConstant3Vector::StaticClass(); \
	UMaterialExpressionConstant4Vector::StaticClass(); \
	UMaterialExpressionConstantClamp::StaticClass(); \
	UMaterialExpressionCosine::StaticClass(); \
	UMaterialExpressionCrossProduct::StaticClass(); \
	UMaterialExpressionDepthBiasBlend::StaticClass(); \
	UMaterialExpressionDepthBiasedAlpha::StaticClass(); \
	UMaterialExpressionDepthBiasedBlend::StaticClass(); \
	UMaterialExpressionDesaturation::StaticClass(); \
	UMaterialExpressionDestColor::StaticClass(); \
	UMaterialExpressionDestDepth::StaticClass(); \
	UMaterialExpressionDivide::StaticClass(); \
	UMaterialExpressionDotProduct::StaticClass(); \
	UMaterialExpressionFlipBookSample::StaticClass(); \
	UMaterialExpressionFloor::StaticClass(); \
	UMaterialExpressionFontSample::StaticClass(); \
	UMaterialExpressionFontSampleParameter::StaticClass(); \
	UMaterialExpressionFrac::StaticClass(); \
	UMaterialExpressionFresnel::StaticClass(); \
	UMaterialExpressionIf::StaticClass(); \
	UMaterialExpressionLensFlareIntensity::StaticClass(); \
	UMaterialExpressionLensFlareOcclusion::StaticClass(); \
	UMaterialExpressionLensFlareRadialDistance::StaticClass(); \
	UMaterialExpressionLensFlareRayDistance::StaticClass(); \
	UMaterialExpressionLensFlareSourceDistance::StaticClass(); \
	UMaterialExpressionLightVector::StaticClass(); \
	UMaterialExpressionLinearInterpolate::StaticClass(); \
	UMaterialExpressionMeshEmitterVertexColor::StaticClass(); \
	UMaterialExpressionMeshSubUV::StaticClass(); \
	UMaterialExpressionMultiply::StaticClass(); \
	UMaterialExpressionNormalize::StaticClass(); \
	UMaterialExpressionOneMinus::StaticClass(); \
	UMaterialExpressionPanner::StaticClass(); \
	UMaterialExpressionParameter::StaticClass(); \
	UMaterialExpressionParticleSubUV::StaticClass(); \
	UMaterialExpressionPixelDepth::StaticClass(); \
	UMaterialExpressionPower::StaticClass(); \
	UMaterialExpressionReflectionVector::StaticClass(); \
	UMaterialExpressionRotator::StaticClass(); \
	UMaterialExpressionScalarParameter::StaticClass(); \
	UMaterialExpressionSceneDepth::StaticClass(); \
	UMaterialExpressionSceneTexture::StaticClass(); \
	UMaterialExpressionScreenPosition::StaticClass(); \
	UMaterialExpressionSine::StaticClass(); \
	UMaterialExpressionSquareRoot::StaticClass(); \
	UMaterialExpressionStaticComponentMaskParameter::StaticClass(); \
	UMaterialExpressionStaticSwitchParameter::StaticClass(); \
	UMaterialExpressionSubtract::StaticClass(); \
	UMaterialExpressionTextureCoordinate::StaticClass(); \
	UMaterialExpressionTextureSample::StaticClass(); \
	UMaterialExpressionTextureSampleParameter::StaticClass(); \
	UMaterialExpressionTextureSampleParameter2D::StaticClass(); \
	UMaterialExpressionTextureSampleParameterCube::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMovie::StaticClass(); \
	UMaterialExpressionTime::StaticClass(); \
	UMaterialExpressionTransform::StaticClass(); \
	UMaterialExpressionTransformPosition::StaticClass(); \
	UMaterialExpressionVectorParameter::StaticClass(); \
	UMaterialExpressionVertexColor::StaticClass(); \
	UMaterialInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInstanceNative; \
	UMaterialInstanceConstant::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInstanceConstantNative; \
	UMaterialInstanceTimeVarying::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInstanceTimeVaryingNative; \

#endif // ENGINE_MATERIAL_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UMaterialInstance) GEngineUMaterialInstanceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstance,execClearParameterValues)
	MAP_NATIVE(UMaterialInstance,execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstance,execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstance,execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstance,execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstance,execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstance,execSetParent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInstance);

NATIVE_INFO(UMaterialInstanceConstant) GEngineUMaterialInstanceConstantNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceConstant,execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceConstant,execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetParent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInstanceConstant);

NATIVE_INFO(UMaterialInstanceTimeVarying) GEngineUMaterialInstanceTimeVaryingNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceTimeVarying,execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetScalarStartTime)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying,execSetParent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInstanceTimeVarying);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionAbs,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAbs)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionAdd,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionAdd,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAdd)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionAppendVector,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionAppendVector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAppendVector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionBumpOffset,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionBumpOffset,ReferencePlane)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionBumpOffset)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCeil,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCeil)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionClamp)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionComment,PosX)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionComment,Text)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComment)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionComponentMask,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComponentMask)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCompound,MaterialExpressions)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCompound,Caption)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCompound)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant,R)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant2Vector,R)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant2Vector,G)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant2Vector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant3Vector,R)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant3Vector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant3Vector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant4Vector,R)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstant4Vector,A)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant4Vector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstantClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionConstantClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstantClamp)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCosine,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCosine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCosine)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCrossProduct,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionCrossProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCrossProduct)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasBlend)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasedAlpha,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasedAlpha,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedAlpha)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasedBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDepthBiasedBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedBlend)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDesaturation,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDesaturation,LuminanceFactors)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDesaturation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestDepth)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDivide,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDivide,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDivide)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDotProduct,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionDotProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDotProduct)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFlipBookSample)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFloor,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFloor)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFontSample,Font)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFontSample,FontTexturePage)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSample)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFontSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFontSampleParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSampleParameter)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFrac,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFrac)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFresnel,Exponent)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionFresnel,Normal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFresnel)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionIf,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionIf,ALessThanB)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionIf)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareIntensity)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareOcclusion)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRadialDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRayDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareSourceDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightVector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionLinearInterpolate,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionLinearInterpolate,Alpha)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLinearInterpolate)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshEmitterVertexColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshSubUV)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionMultiply,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionMultiply,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMultiply)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionNormalize,VectorInput)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionNormalize)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionOneMinus,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionOneMinus)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionPanner,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionPanner,SpeedY)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPanner)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPixelDepth)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionPower,Base)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionPower,Exponent)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPower)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionReflectionVector)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionRotator,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionRotator,Speed)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotator)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionScalarParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionScalarParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScalarParameter)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSceneDepth,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneDepth)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSceneTexture,Coordinates)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSceneTexture,SceneTextureType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneTexture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScreenPosition)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSine,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSine)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSquareRoot,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSquareRoot)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionStaticComponentMaskParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionStaticComponentMaskParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticComponentMaskParameter)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionStaticSwitchParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionStaticSwitchParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticSwitchParameter)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSubtract,A)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionSubtract,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSubtract)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureCoordinate,CoordinateIndex)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureCoordinate,Tiling)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureCoordinate)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureSample,Texture)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureSample,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSample)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTextureSampleParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter2D)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterCube)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMovie)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTime)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTransform,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTransform,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransform)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTransformPosition,Input)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionTransformPosition,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransformPosition)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionVectorParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialExpressionVectorParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVectorParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVertexColor)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstance,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstance,Resources)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstance)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstanceConstant,FontParameterValues)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstanceConstant,VectorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstanceTimeVarying,FontParameterValues)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialInstanceTimeVarying,VectorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceTimeVarying)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
