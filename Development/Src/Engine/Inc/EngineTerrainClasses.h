/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_TERRAIN_ENUMS
#define INCLUDED_ENGINE_TERRAIN_ENUMS 1

enum ETerrainMappingType
{
    TMT_Auto                =0,
    TMT_XY                  =1,
    TMT_XZ                  =2,
    TMT_YZ                  =3,
    TMT_MAX                 =4,
};

#endif // !INCLUDED_ENGINE_TERRAIN_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_TERRAIN_CLASSES
#define INCLUDED_ENGINE_TERRAIN_CLASSES 1

class ATerrain : public AInfo
{
public:
    //## BEGIN PROPS Terrain
    TArrayNoInit<FTerrainHeight> Heights;
    TArrayNoInit<FTerrainInfoData> InfoData;
    TArrayNoInit<FTerrainLayer> Layers;
    INT NormalMapLayer;
    TArrayNoInit<FTerrainDecoLayer> DecoLayers;
    TArrayNoInit<FAlphaMap> AlphaMaps;
    TArrayNoInit<class UTerrainComponent*> TerrainComponents;
    INT NumSectionsX;
    INT NumSectionsY;
    INT SectionSize;
    TArrayNoInit<FTerrainWeightedMaterial> WeightedMaterials;
    TArrayNoInit<class UTerrainWeightMapTexture*> WeightedTextureMaps;
    TArrayNoInit<BYTE> CachedDisplacements;
    FLOAT MaxCollisionDisplacement;
    INT MaxTesselationLevel;
    INT MinTessellationLevel;
    FLOAT TesselationDistanceScale;
    INT CollisionTesselationLevel;
    INT CachedMaterialCount;
    FTerrainMaterialResource** CachedMaterials;
    INT NumVerticesX;
    INT NumVerticesY;
    INT NumPatchesX;
    INT NumPatchesY;
    INT MaxComponentSize;
    INT StaticLightingResolution;
    BITFIELD bIsOverridingLightResolution:1;
    BITFIELD bCastShadow:1;
    BITFIELD bForceDirectLightMap:1;
    BITFIELD bCastDynamicShadow:1;
    BITFIELD bBlockRigidBody:1;
    BITFIELD bAllowRigidBodyUnderneath:1;
    BITFIELD bAcceptsDynamicLights:1;
    BITFIELD bMorphingEnabled:1;
    BITFIELD bMorphingGradientsEnabled:1;
    BITFIELD bLocked:1;
    BITFIELD bShowingCollision:1;
    FLightingChannelContainer LightingChannels;
    FRenderCommandFence* ReleaseResourcesFence;
    INT EditorTessellationLevel;
    TArrayNoInit<FSelectedTerrainVertex> SelectedVertices;
    //## END PROPS Terrain

    void CalcLayerBounds();
    DECLARE_FUNCTION(execCalcLayerBounds)
    {
        P_FINISH;
        CalcLayerBounds();
    }
    DECLARE_CLASS(ATerrain,AInfo,0,Engine)
    // UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PreEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostLoad();
	/**
	 *	Called before the Actor is saved.
	 */
	virtual void PreSave();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	virtual void ClearWeightMaps();
	virtual void TouchWeightMapResources();

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	// AActor interface

	virtual void Spawned();
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
	/**
	 * Function that is called from CheckForErrors - specifically checks for material errors.
	 */
	void CheckForMaterialErrors();

	virtual void ClearComponents();
protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
	virtual void UpdatePatchBounds(INT MinX,INT MinY,INT MaxX,INT MaxY);

	void WeldEdgesToOtherTerrains();

	virtual UBOOL ActorLineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// CompactAlphaMaps - Cleans up alpha maps that are no longer used.

	void CompactAlphaMaps();

	// CacheWeightMaps - Generates the weightmaps from the layer stack and filtered materials.

	void CacheWeightMaps(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// CacheDisplacements - Caches the amount each tesselated vertex is displaced.

	void CacheDisplacements(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// CacheDecorations - Generates a set of decoration components for an area of the terrain.
	void CacheDecorations(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// UpdateRenderData - Updates the weightmaps, displacements, decorations, vertex buffers and bounds when the heightmap, an alphamap or a terrain property changes.
	void UpdateRenderData(INT MinX,INT MinY,INT MaxX,INT MaxY);

	/** updates decoration components to account for terrain/layer property changes */
	void UpdateDecorationComponents();

	/**
	 * Allocates and initializes resolution dependent persistent data. (height-map, alpha-map, components)
	 * Keeps the old height-map and alpha-map data, cropping and extending as necessary.
	 * Uses DesiredSizeX, DesiredSizeY to determine the desired resolution.
	 * DesiredSectionSize determines the size of the components the terrain is split into.
	 */
	void Allocate();

	/**
	  * Recreates all the components
	  */
	void RecreateComponents();

	/**
	 *	Split a terrain along the X or Y axis
	 *	Returns the new terrain if successful
	 */
	ATerrain* SplitTerrain( UBOOL SplitOnXAxis, INT RemainingPatches );
	void SplitTerrainPreview( class FPrimitiveDrawInterface* PDI, UBOOL SplitOnXAxis, INT RemainingPatches );

	/**
	 *	Merges this terrain with another specified terrain if possible
	 *	Returns success TRUE/FALSE
	 */
	UBOOL MergeTerrain( ATerrain* Other );
	UBOOL MergeTerrainPreview( class FPrimitiveDrawInterface* PDI, ATerrain* Other );

	/**
	 *	Add or remove sectors to the terrain
	 *
	 *	@param	CountX		The number of sectors in the X-direction. If negative,
	 *						they will go to the left, otherwise to the right.
	 *	@param	CountY		The number of sectors in the Y-direction. If negative,
	 *						they will go to the bottom, otherwise to the top.
	 *	@param	bRemove		If TRUE, remove the sectors, otherwise add them.
	 *
	 *	@return	UBOOL		TRUE if successful.
	 */
	UBOOL AddRemoveSectors(INT CountX, INT CountY, UBOOL bRemove);
	
	// Internal functions for adding/removing sectos
	void StoreOldData(TArray<FTerrainHeight>& OldHeights, TArray<FTerrainInfoData>& OldInfoData, TArray<FAlphaMap>& OldAlphaMaps);
	void SetupSizeData();
	UBOOL AddSectors_X(INT Count);
	UBOOL AddSectors_Y(INT Count);
	UBOOL RemoveSectors_X(INT Count);
	UBOOL RemoveSectors_Y(INT Count);
	
	// Data access.

	const WORD& Height(INT X,INT Y) const;
	WORD& Height(INT X,INT Y);

	inline FTerrainInfoData* GetInfoData(INT X, INT Y)
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline const FTerrainInfoData* GetInfoData(INT X, INT Y) const
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline UBOOL IsTerrainQuadVisible(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsVisible();
	}

	inline UBOOL IsTerrainQuadFlipped(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsOrientationFlipped();
	}

	/**
	 *	Returns TRUE is the component at the given X,Y has ANY patches contained in are visible.
	 */
	UBOOL IsTerrainComponentVisible(INT InBaseX, INT InBaseY, INT InSizeX, INT InSizeY);
	UBOOL IsTerrainComponentVisible(UTerrainComponent* InComponent);

	FVector GetLocalVertex(INT X,INT Y) const; // Returns a vertex in actor-local space.
	FVector GetWorldVertex(INT X,INT Y) const; // Returns a vertex in world space.

	FTerrainPatch GetPatch(INT X,INT Y) const;
	FVector GetCollisionVertex(const FTerrainPatch& Patch,UINT PatchX,UINT PatchY,UINT SubX,UINT SubY,UINT TesselationLevel) const;

	const BYTE Alpha(INT AlphaMapIndex,INT X,INT Y) const;	// If AlphaMapIndex == INDEX_NONE, returns 0.
	BYTE& Alpha(INT& AlphaMapIndex,INT X,INT Y);			// If AlphaMapIndex == INDEX_NONE, creates a new alphamap and places the index in AlphaMapIndex.

	FLOAT GetCachedDisplacement(INT X,INT Y,INT SubX,INT SubY) const;

	// GetCachedMaterial - Returns a cached terrain material containing a given set of weighted materials.

	FMaterialRenderProxy* GetCachedMaterial(const FTerrainMaterialMask& Mask, UBOOL& bIsTerrainResource);

	/**
	 *	RetrieveReleaseResourcesFence
	 *
	 *	This function will grab the ReleaseResourcesFence.
	 *	If it is NULL, it will create one.
	 *	Should be used when a fence is required.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* RetrieveReleaseResourcesFence()
	{
		if (ReleaseResourcesFence == NULL)
		{
			ReleaseResourcesFence = ::new FRenderCommandFence();
			check(ReleaseResourcesFence);
		}
		return ReleaseResourcesFence;
	}

	/**
	 *	GetReleaseResourcesFence
	 *
	 *	This function will grab the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* GetReleaseResourcesFence()
	{
		return ReleaseResourcesFence;
	}

	/**
	 *	FreeReleaseResourcesFence
	 *
	 *	This function will free the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	void FreeReleaseResourcesFence()
	{
		if (ReleaseResourcesFence != NULL)
		{
			delete ReleaseResourcesFence;
			ReleaseResourcesFence = NULL;
		}
	}

	/**
	 *	MaterialUpdateCallback
	 *
	 *	Called when materials are edited to propagate the change to terrain materials.
	 *
	 *	@param	InMaterial		The material that was edited.
	 *
	 */
	static void MaterialUpdateCallback(UMaterial* InMaterial);

	/**
	 *	BuildCollisionData
	 *
	 *	Helper function to force the re-building of the collision date.
	 */
	void BuildCollisionData();

	/**
	 *	RecacheMaterials
	 *
	 *	Helper function that tosses the cached materials and regenerates them.
	 */
	void RecacheMaterials();

	/**
	 *	UpdateLayerSetup
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to update.
	 */
	void UpdateLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	RemoveLayerSetup
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to remove.
	 */
	void RemoveLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	UpdateTerrainMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to update.
	 */
	void UpdateTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	RemoveTerrainMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to Remove.
	 */
	void RemoveTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	UpdateMaterialInstance
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMatInst	The material instance to update.
	 */
	void UpdateMaterialInstance(UMaterialInterface* InMatInst);

	/**
	 *	UpdateCachedMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMat		The material instance to update.
	 */
	void UpdateCachedMaterial(UMaterial* InMat);

	/**
	 *	RemoveCachedMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InMat		The material instance to remove.
	 */
	void RemoveCachedMaterial(UMaterial* InMat);
	
	/**
	 *	TessellateTerrainUp
	 *	Tessellate the terrain up in detail
	 *	Also used for converting old terrain to the new hi-res model
	 *
	 *	@param	InTessellationlevel		The tessellation level to increase it to
	 *
	 *	@return	UBOOL					TRUE if successful
	 */
	UBOOL TessellateTerrainUp(INT InTessellationlevel = 2, UBOOL bRegenerateComponents = TRUE);
	
	/**
	 *	GetClosestVertex
	 *
	 *	Determine the vertex that is closest to the given location.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);

	/**
	 *	GetClosestLocalSpaceVertex
	 *
	 *	Determine the vertex that is closest to the given location in local space.
	 *	The returned position is also in local space.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestLocalSpaceVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);
	
	/**
	 *	ShowCollisionCallback
	 *
	 *	Called when SHOW terrain collision is toggled.
	 *
	 *	@param	bShow		Whether to show it or not.
	 *
	 */
	static void ShowCollisionCallback(UBOOL bShow);
	
	/**
	 *	Show/Hide terrain collision overlay
	 *
	 *	@param	bShow				Show or hide
	 */
	void ShowCollisionOverlay(UBOOL bShow);
	
	/**
	 *	Update the given selected vertex in the list.
	 *	If the vertex is not present, then add it to the list (provided Weight > 0)
	 *	
	 *	@param	X			
	 *	@param	Y			
	 *	@param	Weight		
	 *	
	 */
	void UpdateSelectedVertex(INT X, INT Y, FLOAT Weight);

	/**
	 *	Internal function for getting a selected vertex from the list
	 */
	INT FindSelectedVertexInList(INT X, INT Y, FSelectedTerrainVertex*& SelectedVert);

	/**
	 *	Clear all selected vertices
	 */
	void ClearSelectedVertexList();
	
	/**
	 *	Retrieve the component(s) that contain the given vertex point
	 *	The components will be added (using AddUniqueItem) to the supplied array.
	 *
	 *	@param	X				The X position of interest
	 *	@param	Y				The Y position of interest
	 *	@param	ComponentList	The array to add found components to
	 *
	 *	@return	UBOOL			TRUE if any components were found.
	 *							FALSE if none were found
	 */
	UBOOL GetComponentsAtXY(INT X, INT Y, TArray<UTerrainComponent*>& ComponentList);
};

class UTerrainWeightMapTexture : public UTexture2D
{
public:
    //## BEGIN PROPS TerrainWeightMapTexture
    class ATerrain* ParentTerrain;
    TArrayNoInit<struct FTerrainWeightedMaterial*> WeightedMaterials;
    //## END PROPS TerrainWeightMapTexture

    DECLARE_CLASS(UTerrainWeightMapTexture,UTexture2D,0,Engine)
    // UObject interface
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	void Initialize(ATerrain* InTerrain);
	void UpdateData();
};

class UTerrainLayerSetup : public UObject
{
public:
    //## BEGIN PROPS TerrainLayerSetup
    TArrayNoInit<FTerrainFilteredMaterial> Materials;
    //## END PROPS TerrainLayerSetup

    void SetMaterials(const TArray<FTerrainFilteredMaterial>& NewMaterials);
    DECLARE_FUNCTION(execSetMaterials)
    {
        P_GET_TARRAY(FTerrainFilteredMaterial,NewMaterials);
        P_FINISH;
        SetMaterials(NewMaterials);
    }
    DECLARE_CLASS(UTerrainLayerSetup,UObject,0,Engine)
	/** returns the alpha that should be used in the weighting for the given material in this layer at the given world vertex
	 * @param Material the filtered material that is being weighted
	 * @param WorldVertex the world location of the vertex
	 * @return the alpha to use for weighting
	 */
	virtual FLOAT GetMaterialAlpha(const FTerrainFilteredMaterial* Material, const FVector& WorldVertex) { return Material->Alpha; }

	// UObject interface.

	virtual void PostEditChange(UProperty* PropertyThatChanged);
	
	/**
	 * Called after serialization. Ensures that there are only 64 materials.
	 */
	virtual void PostLoad();
};

struct FTerrainFoliageMesh
{
    class UStaticMesh* StaticMesh;
    class UMaterialInterface* Material;
    INT Density;
    FLOAT MaxDrawRadius;
    FLOAT MinTransitionRadius;
    FLOAT MinScale;
    FLOAT MaxScale;
    INT Seed;
    FLOAT SwayScale;
    FLOAT AlphaMapThreshold;
    FLOAT SlopeRotationBlend;
};

class UTerrainMaterial : public UObject
{
public:
    //## BEGIN PROPS TerrainMaterial
    FMatrix LocalToMapping;
    BYTE MappingType;
    FLOAT MappingScale;
    FLOAT MappingRotation;
    FLOAT MappingPanU;
    FLOAT MappingPanV;
    class UMaterialInterface* Material;
    class UTexture2D* DisplacementMap;
    FLOAT DisplacementScale;
    TArrayNoInit<struct FTerrainFoliageMesh> FoliageMeshes;
    //## END PROPS TerrainMaterial

    DECLARE_CLASS(UTerrainMaterial,UObject,0,Engine)
	// UpdateMappingTransform

	void UpdateMappingTransform();

	// Displacement sampler.

	FLOAT GetDisplacement(BYTE* DisplacementData,FLOAT U,FLOAT V) const;

	// UObject interface.

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

#endif // !INCLUDED_ENGINE_TERRAIN_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ATerrain,-1,execCalcLayerBounds);
AUTOGENERATE_FUNCTION(UTerrainLayerSetup,-1,execSetMaterials);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_TERRAIN_NATIVE_DEFS
#define ENGINE_TERRAIN_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,ATerrain);
DECLARE_NATIVE_TYPE(Engine,UTerrainLayerSetup);
DECLARE_NATIVE_TYPE(Engine,UTerrainMaterial);
DECLARE_NATIVE_TYPE(Engine,UTerrainWeightMapTexture);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_TERRAIN \
	ATerrain::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineATerrainNative; \
	UTerrainComponent::StaticClass(); \
	UTerrainLayerSetup::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTerrainLayerSetupNative; \
	UTerrainMaterial::StaticClass(); \
	UTerrainWeightMapTexture::StaticClass(); \

#endif // ENGINE_TERRAIN_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(ATerrain) GEngineATerrainNatives[] = 
{ 
	MAP_NATIVE(ATerrain,execCalcLayerBounds)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ATerrain);

NATIVE_INFO(UTerrainLayerSetup) GEngineUTerrainLayerSetupNatives[] = 
{ 
	MAP_NATIVE(UTerrainLayerSetup,execSetMaterials)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTerrainLayerSetup);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,Terrain,Heights)
VERIFY_CLASS_OFFSET_NODIE(A,Terrain,SelectedVertices)
VERIFY_CLASS_SIZE_NODIE(ATerrain)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,ShadowMaps)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,IrrelevantLights)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,TerrainObject)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionBaseX)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionBaseY)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionSizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionSizeY)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,TrueSectionSizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,TrueSectionSizeY)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,LightMap)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBounds)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBatches)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,BatchMaterials)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,FullBatch)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBatchOffsets)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,WorkingOffsets)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBatchTriangles)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchCachedTessellationValues)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,TesselationLevels)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,BVTree)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,CollisionVertices)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,RBHeightfield)
VERIFY_CLASS_SIZE_NODIE(UTerrainComponent)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainLayerSetup,Materials)
VERIFY_CLASS_SIZE_NODIE(UTerrainLayerSetup)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainMaterial,LocalToMapping)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainMaterial,FoliageMeshes)
VERIFY_CLASS_SIZE_NODIE(UTerrainMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainWeightMapTexture,ParentTerrain)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainWeightMapTexture,WeightedMaterials)
VERIFY_CLASS_SIZE_NODIE(UTerrainWeightMapTexture)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
