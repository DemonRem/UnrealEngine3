/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PARTICLE_ENUMS
#define INCLUDED_ENGINE_PARTICLE_ENUMS 1

enum ParticleSystemLODMethod
{
    PARTICLESYSTEMLODMETHOD_Automatic=0,
    PARTICLESYSTEMLODMETHOD_DirectSet=1,
    PARTICLESYSTEMLODMETHOD_MAX=2,
};
enum EParticleSystemUpdateMode
{
    EPSUM_RealTime          =0,
    EPSUM_FixedTime         =1,
    EPSUM_MAX               =2,
};
enum EParticleSysParamType
{
    PSPT_None               =0,
    PSPT_Scalar             =1,
    PSPT_Vector             =2,
    PSPT_Color              =3,
    PSPT_Actor              =4,
    PSPT_Material           =5,
    PSPT_MAX                =6,
};
enum EEmitterRenderMode
{
    ERM_Normal              =0,
    ERM_Point               =1,
    ERM_Cross               =2,
    ERM_None                =3,
    ERM_MAX                 =4,
};
enum EParticleSubUVInterpMethod
{
    PSUVIM_None             =0,
    PSUVIM_Linear           =1,
    PSUVIM_Linear_Blend     =2,
    PSUVIM_Random           =3,
    PSUVIM_Random_Blend     =4,
    PSUVIM_MAX              =5,
};
enum EParticleBurstMethod
{
    EPBM_Instant            =0,
    EPBM_Interpolated       =1,
    EPBM_MAX                =2,
};
enum EParticleScreenAlignment
{
    PSA_Square              =0,
    PSA_Rectangle           =1,
    PSA_Velocity            =2,
    PSA_TypeSpecific        =3,
    PSA_MAX                 =4,
};
enum EParticleSourceSelectionMethod
{
    EPSSM_Random            =0,
    EPSSM_Sequential        =1,
    EPSSM_MAX               =2,
};
enum EModuleType
{
    EPMT_General            =0,
    EPMT_TypeData           =1,
    EPMT_Beam               =2,
    EPMT_Trail              =3,
    EPMT_MAX                =4,
};
enum EAttractorParticleSelectionMethod
{
    EAPSM_Random            =0,
    EAPSM_Sequential        =1,
    EAPSM_MAX               =2,
};
enum Beam2SourceTargetTangentMethod
{
    PEB2STTM_Direct         =0,
    PEB2STTM_UserSet        =1,
    PEB2STTM_Distribution   =2,
    PEB2STTM_Emitter        =3,
    PEB2STTM_MAX            =4,
};
enum Beam2SourceTargetMethod
{
    PEB2STM_Default         =0,
    PEB2STM_UserSet         =1,
    PEB2STM_Emitter         =2,
    PEB2STM_Particle        =3,
    PEB2STM_Actor           =4,
    PEB2STM_MAX             =5,
};
enum BeamModifierType
{
    PEB2MT_Source           =0,
    PEB2MT_Target           =1,
    PEB2MT_MAX              =2,
};
enum EParticleCollisionComplete
{
    EPCC_Kill               =0,
    EPCC_Freeze             =1,
    EPCC_HaltCollisions     =2,
    EPCC_FreezeTranslation  =3,
    EPCC_FreezeRotation     =4,
    EPCC_FreezeMovement     =5,
    EPCC_MAX                =6,
};
enum ELocationEmitterSelectionMethod
{
    ELESM_Random            =0,
    ELESM_Sequential        =1,
    ELESM_MAX               =2,
};
enum CylinderHeightAxis
{
    PMLPC_HEIGHTAXIS_X      =0,
    PMLPC_HEIGHTAXIS_Y      =1,
    PMLPC_HEIGHTAXIS_Z      =2,
    PMLPC_HEIGHTAXIS_MAX    =3,
};
enum EOrbitChainMode
{
    EOChainMode_Add         =0,
    EOChainMode_Scale       =1,
    EOChainMode_Link        =2,
    EOChainMode_MAX         =3,
};
enum EParticleAxisLock
{
    EPAL_NONE               =0,
    EPAL_X                  =1,
    EPAL_Y                  =2,
    EPAL_Z                  =3,
    EPAL_NEGATIVE_X         =4,
    EPAL_NEGATIVE_Y         =5,
    EPAL_NEGATIVE_Z         =6,
    EPAL_ROTATE_X           =7,
    EPAL_ROTATE_Y           =8,
    EPAL_ROTATE_Z           =9,
    EPAL_MAX                =10,
};
enum ETrail2SourceMethod
{
    PET2SRCM_Default        =0,
    PET2SRCM_Particle       =1,
    PET2SRCM_Actor          =2,
    PET2SRCM_MAX            =3,
};
enum ETrail2SpawnMethod
{
    PET2SM_Emitter          =0,
    PET2SM_Velocity         =1,
    PET2SM_Distance         =2,
    PET2SM_MAX              =3,
};
enum ETrailTaperMethod
{
    PETTM_None              =0,
    PETTM_Full              =1,
    PETTM_Partial           =2,
    PETTM_MAX               =3,
};
enum FluidPacketSizeMultiplier
{
    FPSM_4                  =0,
    FPSM_8                  =1,
    FPSM_16                 =2,
    FPSM_32                 =3,
    FPSM_64                 =4,
    FPSM_128                =5,
    FPSM_MAX                =6,
};
enum FluidSimulationMethod
{
    FSM_SPH                 =0,
    FSM_NO_PARTICLE_INTERACTION=1,
    FSM_MIXED_MODE          =2,
    FSM_MAX                 =3,
};
enum FluidEmitterShape
{
    FES_RECTANGLE           =0,
    FES_ELLIPSE             =1,
    FES_MAX                 =2,
};
enum FluidEmitterType
{
    FET_CONSTANT_FLOW       =0,
    FET_CONSTANT_PRESSURE   =1,
    FET_FILL_OWNER_VOLUME   =2,
    FET_MAX                 =3,
};
enum EBeamEndPointMethod
{
    PEBEPM_Calculated       =0,
    PEBEPM_Distribution     =1,
    PEBEPM_Distribution_Constant=2,
    PEBEPM_MAX              =3,
};
enum EBeamMethod
{
    PEBM_Distance           =0,
    PEBM_EndPoints          =1,
    PEBM_EndPoints_Interpolated=2,
    PEBM_UserSet_EndPoints  =3,
    PEBM_UserSet_EndPoints_Interpolated=4,
    PEBM_MAX                =5,
};
enum EBeamTaperMethod
{
    PEBTM_None              =0,
    PEBTM_Full              =1,
    PEBTM_Partial           =2,
    PEBTM_MAX               =3,
};
enum EBeam2Method
{
    PEB2M_Distance          =0,
    PEB2M_Target            =1,
    PEB2M_Branch            =2,
    PEB2M_MAX               =3,
};
enum EMeshScreenAlignment
{
    PSMA_MeshFaceCameraWithRoll=0,
    PSMA_MeshFaceCameraWithSpin=1,
    PSMA_MeshFaceCameraWithLockedAxis=2,
    PSMA_MAX                =3,
};
enum FluidMeshRotationMethod
{
    FMRM_DISABLED           =0,
    FMRM_SPHERICAL          =1,
    FMRM_BOX                =2,
    FMRM_LONG_BOX           =3,
    FMRM_FLAT_BOX           =4,
    FMRM_MAX                =5,
};
enum ESubUVInterpMethod
{
    PSSUVIM_Linear          =0,
    PSSUVIM_Linear_Blend    =1,
    PSSUVIM_Random          =2,
    PSSUVIM_Random_Blend    =3,
    PSSUVIM_MAX             =4,
};

#endif // !INCLUDED_ENGINE_PARTICLE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(OnSystemFinished)
AUTOGENERATE_NAME(SetTemplate)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PARTICLE_CLASSES
#define INCLUDED_ENGINE_PARTICLE_CLASSES 1

struct Emitter_eventSetTemplate_Parms
{
    class UParticleSystem* NewTemplate;
    UBOOL bDestroyOnFinish;
    Emitter_eventSetTemplate_Parms(EEventParm)
    {
    }
};
class AEmitter : public AActor
{
public:
    //## BEGIN PROPS Emitter
    class UParticleSystemComponent* ParticleSystemComponent;
    BITFIELD bDestroyOnSystemFinish:1;
    BITFIELD bCurrentlyActive:1;
    //## END PROPS Emitter

    DECLARE_FUNCTION(execSetTemplate);
    void eventSetTemplate(class UParticleSystem* NewTemplate,UBOOL bDestroyOnFinish=FALSE)
    {
        Emitter_eventSetTemplate_Parms Parms(EC_EventParm);
        Parms.NewTemplate=NewTemplate;
        Parms.bDestroyOnFinish=bDestroyOnFinish ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTemplate),&Parms);
    }
    DECLARE_CLASS(AEmitter,AActor,0,Engine)
	void SetTemplate(UParticleSystem* NewTemplate, UBOOL bDestroyOnFinish=false);
	void AutoPopulateInstanceProperties();

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

class UParticleSystem : public UObject
{
public:
    //## BEGIN PROPS ParticleSystem
    BYTE SystemUpdateMode;
    BYTE LODMethod;
    FLOAT UpdateTime_FPS;
    FLOAT UpdateTime_Delta;
    FLOAT WarmupTime;
    TArrayNoInit<class UParticleEmitter*> Emitters;
    class UParticleSystemComponent* PreviewComponent;
    FRotator ThumbnailAngle;
    FLOAT ThumbnailDistance;
    FLOAT ThumbnailWarmup;
    BITFIELD bLit:1;
    BITFIELD bRegenerateLODDuplicate:1;
    BITFIELD bUseFixedRelativeBoundingBox:1;
    BITFIELD bShouldResetPeakCounts:1;
    BITFIELD bUseRealtimeThumbnail:1;
    BITFIELD ThumbnailImageOutOfDate:1;
    class UInterpCurveEdSetup* CurveEdSetup;
    FLOAT LODDistanceCheckTime;
    TArrayNoInit<FLOAT> LODDistances;
    INT EditorLODSetting;
    INT LODCount;
    INT PreviewLODSetting;
    FBox FixedRelativeBoundingBox;
    FLOAT SecondsBeforeInactive;
    FStringNoInit FloorMesh;
    FVector FloorPosition;
    FRotator FloorRotation;
    FLOAT FloorScale;
    FVector FloorScale3D;
    BITFIELD bHasPhysics:1;
    class UTexture2D* ThumbnailImage;
    //## END PROPS ParticleSystem

    virtual BYTE GetCurrentLODMethod();
    virtual INT GetLODLevelCount();
    virtual FLOAT GetLODDistance(INT LODLevelIndex);
    virtual void SetCurrentLODMethod(BYTE InMethod);
    virtual UBOOL SetLODDistance(INT LODLevelIndex,FLOAT InDistance);
    DECLARE_FUNCTION(execGetCurrentLODMethod)
    {
        P_FINISH;
        *(BYTE*)Result=GetCurrentLODMethod();
    }
    DECLARE_FUNCTION(execGetLODLevelCount)
    {
        P_FINISH;
        *(INT*)Result=GetLODLevelCount();
    }
    DECLARE_FUNCTION(execGetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_FINISH;
        *(FLOAT*)Result=GetLODDistance(LODLevelIndex);
    }
    DECLARE_FUNCTION(execSetCurrentLODMethod)
    {
        P_GET_BYTE(InMethod);
        P_FINISH;
        SetCurrentLODMethod(InMethod);
    }
    DECLARE_FUNCTION(execSetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_GET_FLOAT(InDistance);
        P_FINISH;
        *(UBOOL*)Result=SetLODDistance(LODLevelIndex,InDistance);
    }
    DECLARE_CLASS(UParticleSystem,UObject,0,Engine)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PreSave();
	virtual void PostLoad();

	void UpdateColorModuleClampAlpha(class UParticleModuleColorBase* ColorModule);

	/**
	 *	CalculateMaxActiveParticleCounts
	 *	Determine the maximum active particles that could occur with each emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the numbers were determined for each emitter
	 *			FALSE	if not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCounts();
};

struct FParticleSysParam
{
    FName Name;
    BYTE ParamType;
    FLOAT Scalar;
    FVector Vector;
    FColor Color;
    class AActor* Actor;
    class UMaterialInterface* Material;
};

struct ParticleSystemComponent_eventOnSystemFinished_Parms
{
    class UParticleSystemComponent* PSystem;
    ParticleSystemComponent_eventOnSystemFinished_Parms(EEventParm)
    {
    }
};
class UParticleSystemComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS ParticleSystemComponent
    class UParticleSystem* Template;
    TArrayNoInit<struct FParticleEmitterInstance*> EmitterInstances;
    TArrayNoInit<class UStaticMeshComponent*> SMComponents;
    TArrayNoInit<class UMaterialInterface*> SMMaterialInterfaces;
    BITFIELD bAutoActivate:1;
    BITFIELD bWasCompleted:1;
    BITFIELD bSuppressSpawning:1;
    BITFIELD bWasDeactivated:1;
    BITFIELD bResetOnDetach:1;
    BITFIELD bUpdateOnDedicatedServer:1;
    BITFIELD bJustAttached:1;
    BITFIELD bWarmingUp:1;
    BITFIELD bIsCachedInPool:1;
    BITFIELD bOverrideLODMethod:1;
    BITFIELD bSkipUpdateDynamicDataDuringTick:1;
    BITFIELD bUpdateComponentInTick:1;
    BITFIELD bIsActive:1;
    BITFIELD bForcedInActive:1;
    BITFIELD bIsWarmingUp:1;
    BITFIELD bIsViewRelevanceDirty:1;
    TArrayNoInit<struct FParticleSysParam> InstanceParameters;
    FVector OldPosition;
    FVector PartSysVelocity;
    FLOAT WarmupTime;
    INT LODLevel;
    FLOAT SecondsBeforeInactive;
    INT EditorLODLevel;
    FLOAT AccumTickTime;
    BYTE LODMethod;
    TArrayNoInit<FMaterialViewRelevance> CachedViewRelevanceFlags;
    FScriptDelegate __OnSystemFinished__Delegate;
    //## END PROPS ParticleSystemComponent

    void SetTemplate(class UParticleSystem* NewTemplate);
    void ActivateSystem();
    void DeactivateSystem();
    void KillParticlesForced();
    void SetSkipUpdateDynamicDataDuringTick(UBOOL bInSkipUpdateDynamicDataDuringTick);
    UBOOL GetSkipUpdateDynamicDataDuringTick();
    virtual void SetKillOnDeactivate(INT EmitterIndex,UBOOL bKill);
    virtual void SetKillOnCompleted(INT EmitterIndex,UBOOL bKill);
    virtual void RewindEmitterInstance(INT EmitterIndex);
    virtual void RewindEmitterInstances();
    virtual void SetBeamType(INT EmitterIndex,INT NewMethod);
    virtual void SetBeamTessellationFactor(INT EmitterIndex,FLOAT NewFactor);
    virtual void SetBeamEndPoint(INT EmitterIndex,FVector NewEndPoint);
    virtual void SetBeamDistance(INT EmitterIndex,FLOAT Distance);
    virtual void SetBeamSourcePoint(INT EmitterIndex,FVector NewSourcePoint,INT SourceIndex);
    virtual void SetBeamSourceTangent(INT EmitterIndex,FVector NewTangentPoint,INT SourceIndex);
    virtual void SetBeamSourceStrength(INT EmitterIndex,FLOAT NewSourceStrength,INT SourceIndex);
    virtual void SetBeamTargetPoint(INT EmitterIndex,FVector NewTargetPoint,INT TargetIndex);
    virtual void SetBeamTargetTangent(INT EmitterIndex,FVector NewTangentPoint,INT TargetIndex);
    virtual void SetBeamTargetStrength(INT EmitterIndex,FLOAT NewTargetStrength,INT TargetIndex);
    void SetLODLevel(INT InLODLevel);
    void SetEditorLODLevel(INT InLODLevel);
    INT GetLODLevel();
    INT GetEditorLODLevel();
    void SetFloatParameter(FName ParameterName,FLOAT Param);
    void SetVectorParameter(FName ParameterName,FVector Param);
    void SetColorParameter(FName ParameterName,FColor Param);
    void SetActorParameter(FName ParameterName,class AActor* Param);
    void SetMaterialParameter(FName ParameterName,class UMaterialInterface* Param);
    void ClearParameter(FName ParameterName,BYTE ParameterType=0);
    void SetActive(UBOOL bNowActive);
    void ResetToDefaults();
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(UParticleSystem,NewTemplate);
        P_FINISH;
        SetTemplate(NewTemplate);
    }
    DECLARE_FUNCTION(execActivateSystem)
    {
        P_FINISH;
        ActivateSystem();
    }
    DECLARE_FUNCTION(execDeactivateSystem)
    {
        P_FINISH;
        DeactivateSystem();
    }
    DECLARE_FUNCTION(execKillParticlesForced)
    {
        P_FINISH;
        KillParticlesForced();
    }
    DECLARE_FUNCTION(execSetSkipUpdateDynamicDataDuringTick)
    {
        P_GET_UBOOL(bInSkipUpdateDynamicDataDuringTick);
        P_FINISH;
        SetSkipUpdateDynamicDataDuringTick(bInSkipUpdateDynamicDataDuringTick);
    }
    DECLARE_FUNCTION(execGetSkipUpdateDynamicDataDuringTick)
    {
        P_FINISH;
        *(UBOOL*)Result=GetSkipUpdateDynamicDataDuringTick();
    }
    DECLARE_FUNCTION(execSetKillOnDeactivate)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        SetKillOnDeactivate(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execSetKillOnCompleted)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        SetKillOnCompleted(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execRewindEmitterInstance)
    {
        P_GET_INT(EmitterIndex);
        P_FINISH;
        RewindEmitterInstance(EmitterIndex);
    }
    DECLARE_FUNCTION(execRewindEmitterInstances)
    {
        P_FINISH;
        RewindEmitterInstances();
    }
    DECLARE_FUNCTION(execSetBeamType)
    {
        P_GET_INT(EmitterIndex);
        P_GET_INT(NewMethod);
        P_FINISH;
        SetBeamType(EmitterIndex,NewMethod);
    }
    DECLARE_FUNCTION(execSetBeamTessellationFactor)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewFactor);
        P_FINISH;
        SetBeamTessellationFactor(EmitterIndex,NewFactor);
    }
    DECLARE_FUNCTION(execSetBeamEndPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewEndPoint);
        P_FINISH;
        SetBeamEndPoint(EmitterIndex,NewEndPoint);
    }
    DECLARE_FUNCTION(execSetBeamDistance)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(Distance);
        P_FINISH;
        SetBeamDistance(EmitterIndex,Distance);
    }
    DECLARE_FUNCTION(execSetBeamSourcePoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewSourcePoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourcePoint(EmitterIndex,NewSourcePoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourceTangent(EmitterIndex,NewTangentPoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewSourceStrength);
        P_GET_INT(SourceIndex);
        P_FINISH;
        SetBeamSourceStrength(EmitterIndex,NewSourceStrength,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTargetPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetPoint(EmitterIndex,NewTargetPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetTangent(EmitterIndex,NewTangentPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewTargetStrength);
        P_GET_INT(TargetIndex);
        P_FINISH;
        SetBeamTargetStrength(EmitterIndex,NewTargetStrength,TargetIndex);
    }
    DECLARE_FUNCTION(execSetLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        SetLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execSetEditorLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        SetEditorLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execGetLODLevel)
    {
        P_FINISH;
        *(INT*)Result=GetLODLevel();
    }
    DECLARE_FUNCTION(execGetEditorLODLevel)
    {
        P_FINISH;
        *(INT*)Result=GetEditorLODLevel();
    }
    DECLARE_FUNCTION(execSetFloatParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Param);
        P_FINISH;
        SetFloatParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetVectorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FVector,Param);
        P_FINISH;
        SetVectorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetColorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FColor,Param);
        P_FINISH;
        SetColorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetActorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(AActor,Param);
        P_FINISH;
        SetActorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetMaterialParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UMaterialInterface,Param);
        P_FINISH;
        SetMaterialParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execClearParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_BYTE_OPTX(ParameterType,0);
        P_FINISH;
        ClearParameter(ParameterName,ParameterType);
    }
    DECLARE_FUNCTION(execSetActive)
    {
        P_GET_UBOOL(bNowActive);
        P_FINISH;
        SetActive(bNowActive);
    }
    DECLARE_FUNCTION(execResetToDefaults)
    {
        P_FINISH;
        ResetToDefaults();
    }
    void delegateOnSystemFinished(class UParticleSystemComponent* PSystem)
    {
        ParticleSystemComponent_eventOnSystemFinished_Parms Parms(EC_EventParm);
        Parms.PSystem=PSystem;
        ProcessDelegate(ENGINE_OnSystemFinished,&__OnSystemFinished__Delegate,&Parms);
    }
    DECLARE_CLASS(UParticleSystemComponent,UPrimitiveComponent,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void BeginDestroy();
	virtual void FinishDestroy();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Serialize(FArchive& Ar);

	// Collision Handling...
	virtual UBOOL SingleLineCheck(FCheckResult& Hit, AActor* SourceActor, const FVector& End, const FVector& Start, DWORD TraceFlags, const FVector& Extent);

protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach();
	virtual void UpdateDynamicData(FParticleSystemSceneProxy* Proxy);

public:
	virtual void UpdateDynamicData();

	// UPrimitiveComponent interface
	virtual void UpdateBounds();
	virtual void Tick(FLOAT DeltaTime);
	virtual void TickEditor(FLOAT DeltaTime);

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// UParticleSystemComponent interface
	void InitParticles();
	void ResetParticles(UBOOL bEmptyInstances = FALSE);
	void ResetBurstLists();
	void UpdateInstances();
	UBOOL HasCompleted();

	void InitializeSystem();

	/**
	 *	Cache the view-relevance for each emitter at each LOD level.
	 *
	 *	@param	NewTemplate		The UParticleSystem* to use as the template.
	 *							If NULL, use the currently set template.
	 */
	void CacheViewRelevanceFlags(class UParticleSystem* NewTemplate = NULL);

	/**
	*	DetermineLODLevel - determines the appropriate LOD level to utilize.
	*/
	INT DetermineLODLevel(const FSceneView* View);

	// InstanceParameters interface
	UBOOL GetFloatParameter(const FName InName, FLOAT& OutFloat);
	UBOOL GetVectorParameter(const FName InName, FVector& OutVector);
	UBOOL GetMaterialParameter(const FName InName, UMaterialInterface*& OutMaterial);

	void	AutoPopulateInstanceProperties();
};

class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
public:
    //## BEGIN PROPS DistributionFloatParticleParameter
    //## END PROPS DistributionFloatParticleParameter

    DECLARE_CLASS(UDistributionFloatParticleParameter,UDistributionFloatParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat);
};

class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
public:
    //## BEGIN PROPS DistributionVectorParticleParameter
    //## END PROPS DistributionVectorParticleParameter

    DECLARE_CLASS(UDistributionVectorParticleParameter,UDistributionVectorParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FVector& OutVector);
};

class UParticleDataManager : public UObject
{
public:
    //## BEGIN PROPS ParticleDataManager
    //## END PROPS ParticleDataManager

    DECLARE_CLASS(UParticleDataManager,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleDataManager)
};

class UParticleEmitterInstance : public UObject
{
public:
    //## BEGIN PROPS ParticleEmitterInstance
    //## END PROPS ParticleEmitterInstance

    DECLARE_ABSTRACT_CLASS(UParticleEmitterInstance,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleEmitterInstance)
};

class UParticleBeam2EmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleBeam2EmitterInstance
    //## END PROPS ParticleBeam2EmitterInstance

    DECLARE_CLASS(UParticleBeam2EmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleBeam2EmitterInstance)
};

class UParticleBeamEmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleBeamEmitterInstance
    //## END PROPS ParticleBeamEmitterInstance

    DECLARE_CLASS(UParticleBeamEmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleBeamEmitterInstance)
};

class UParticleMeshEmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleMeshEmitterInstance
    //## END PROPS ParticleMeshEmitterInstance

    DECLARE_CLASS(UParticleMeshEmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleMeshEmitterInstance)
};

class UParticleMeshNxFluidEmitterInstance : public UParticleMeshEmitterInstance
{
public:
    //## BEGIN PROPS ParticleMeshNxFluidEmitterInstance
    //## END PROPS ParticleMeshNxFluidEmitterInstance

    DECLARE_CLASS(UParticleMeshNxFluidEmitterInstance,UParticleMeshEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleMeshNxFluidEmitterInstance)
};

class UParticleSpriteEmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleSpriteEmitterInstance
    //## END PROPS ParticleSpriteEmitterInstance

    DECLARE_CLASS(UParticleSpriteEmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleSpriteEmitterInstance)
};

class UParticleSpriteSubUVEmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleSpriteSubUVEmitterInstance
    //## END PROPS ParticleSpriteSubUVEmitterInstance

    DECLARE_CLASS(UParticleSpriteSubUVEmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleSpriteSubUVEmitterInstance)
};

class UParticleSpriteNxFluidEmitterInstance : public UParticleSpriteSubUVEmitterInstance
{
public:
    //## BEGIN PROPS ParticleSpriteNxFluidEmitterInstance
    //## END PROPS ParticleSpriteNxFluidEmitterInstance

    DECLARE_CLASS(UParticleSpriteNxFluidEmitterInstance,UParticleSpriteSubUVEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleSpriteNxFluidEmitterInstance)
};

class UParticleTrail2EmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleTrail2EmitterInstance
    //## END PROPS ParticleTrail2EmitterInstance

    DECLARE_CLASS(UParticleTrail2EmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleTrail2EmitterInstance)
};

class UParticleTrailEmitterInstance : public UParticleEmitterInstance
{
public:
    //## BEGIN PROPS ParticleTrailEmitterInstance
    //## END PROPS ParticleTrailEmitterInstance

    DECLARE_CLASS(UParticleTrailEmitterInstance,UParticleEmitterInstance,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleTrailEmitterInstance)
};

class UParticleLODLevel : public UObject
{
public:
    //## BEGIN PROPS ParticleLODLevel
    INT Level;
    INT LevelSetting;
    BITFIELD bEnabled:1;
    BITFIELD ConvertedModules:1;
    class UParticleModuleRequired* RequiredModule;
    TArrayNoInit<class UParticleModule*> Modules;
    class UParticleModule* TypeDataModule;
    TArrayNoInit<class UParticleModuleSpawnBase*> SpawningModules;
    TArrayNoInit<class UParticleModule*> SpawnModules;
    TArrayNoInit<class UParticleModule*> UpdateModules;
    TArrayNoInit<class UParticleModuleOrbit*> OrbitModules;
    INT PeakActiveParticles;
    //## END PROPS ParticleLODLevel

    DECLARE_CLASS(UParticleLODLevel,UObject,0,Engine)
	virtual void						PostEditChange(UProperty* PropertyThatChanged);

	virtual void						PostLoad();
	virtual void						UpdateModuleLists();

	virtual UBOOL						GenerateFromLODLevel(UParticleLODLevel* SourceLODLevel, FLOAT Percentage, UBOOL bGenerateModuleData = TRUE);
	virtual UBOOL						GenerateFromBoundingLODLevels(UParticleLODLevel* HighLODLevel, UParticleLODLevel* LowLODLevel, UBOOL bGenerateModuleData = TRUE);

	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return		The maximum active particle count for the LOD level.
	 */
	virtual INT	CalculateMaxActiveParticleCount();
	
	// For Cascade
	void	AddCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);
};

struct FParticleBurst
{
    INT Count;
    INT CountLow;
    FLOAT Time;
};

class UParticleEmitter : public UObject
{
public:
    //## BEGIN PROPS ParticleEmitter
    FName EmitterName;
    BITFIELD UseLocalSpace:1;
    BITFIELD KillOnDeactivate:1;
    BITFIELD bKillOnCompleted:1;
    BITFIELD ScaleUV:1;
    BITFIELD DirectUV:1;
    BITFIELD bEnabled:1;
    BITFIELD ConvertedModules:1;
    struct FRawDistributionFloat SpawnRate;
    FLOAT EmitterDuration;
    INT EmitterLoops;
    class UParticleModuleRequired* RequiredModule;
    BYTE ParticleBurstMethod;
    BYTE InterpolationMethod;
    BYTE EmitterRenderMode;
    TArrayNoInit<struct FParticleBurst> BurstList;
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    FLOAT RandomImageTime;
    INT RandomImageChanges;
    INT SubUVDataOffset;
    FColor EmitterEditorColor;
    TArrayNoInit<class UParticleLODLevel*> LODLevels;
    TArrayNoInit<class UParticleModule*> Modules;
    class UParticleModule* TypeDataModule;
    TArrayNoInit<class UParticleModule*> SpawnModules;
    TArrayNoInit<class UParticleModule*> UpdateModules;
    INT PeakActiveParticles;
    TArrayNoInit<FLOAT> LODSpawnRatios;
    INT InitialAllocationCount;
    //## END PROPS ParticleEmitter

    DECLARE_ABSTRACT_CLASS(UParticleEmitter,UObject,0,Engine)
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults() {}

	virtual void PostLoad();
	virtual void UpdateModuleLists();

	void SetEmitterName(FName Name);
	FName& GetEmitterName();
	virtual	void						SetLODCount(INT LODCount);

	// For Cascade
	void	AddEmitterCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveEmitterCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	// LOD
	INT					CreateLODLevel(INT LODLevel, UBOOL bGenerateModuleData = TRUE);
	UBOOL				IsLODLevelValid(INT LODLevel);

	/** GetCurrentLODLevel
	*	Returns the currently set LODLevel. Intended for game-time usage.
	*	Assumes that the given LODLevel will be in the [0..# LOD levels] range.
	*	
	*	@return NULL if the requested LODLevel is not valid.
	*			The pointer to the requested UParticleLODLevel if valid.
	*/
	inline UParticleLODLevel* GetCurrentLODLevel(FParticleEmitterInstance* Instance)
	{
		// for the game (where we care about perf) we don't branch
		if (GIsGame == TRUE)
		{
			return Instance->CurrentLODLevel;
		}
		else
		{
			EditorUpdateCurrentLOD( Instance );
			return Instance->CurrentLODLevel;
		}

	}

	void EditorUpdateCurrentLOD(FParticleEmitterInstance* Instance);

	UParticleLODLevel*	GetLODLevel(INT LODLevel);
	UParticleLODLevel*	GetClosestLODLevel(INT LODLevel);
	UBOOL				GetClosestLODLevels(INT LODLevel, UParticleLODLevel*& HigherLOD, UParticleLODLevel*& LowerLOD);

	UBOOL				GetLODLevelModules(INT LODLevel, TArray<UParticleModule*>*& LevelModules);
	UBOOL				GetClosestLODLevelModules(INT LODLevel, TArray<UParticleModule*>*& HigherLODModule, TArray<UParticleModule*>*& LowerLODModules);
	UBOOL				GetLODLevelSpawnModules(INT LODLevel, TArray<UParticleModule*>*& LevelSpawnModules);
	UBOOL				GetClosestLODLevelSpawnModules(INT LODLevel, TArray<UParticleModule*>*& HigherLODSpawnModule, TArray<UParticleModule*>*& LowerLODSpawnModules);
	UBOOL				GetLODLevelUpdateModules(INT LODLevel, TArray<UParticleModule*>*& LevelUpdateModules);
	UBOOL				GetClosestLODLevelUpdateModules(INT LODLevel, TArray<UParticleModule*>*& HigherLODUpdateModule, TArray<UParticleModule*>*& LowerLODUpdateModules);
	
	virtual UBOOL		AutogenerateLowestLODLevel(UBOOL bDuplicateHighest = FALSE);
	
	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the number was determined
	 *			FALSE	if the number could not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCount();
};

class UParticleMeshEmitter : public UParticleEmitter
{
public:
    //## BEGIN PROPS ParticleMeshEmitter
    //## END PROPS ParticleMeshEmitter

    DECLARE_CLASS(UParticleMeshEmitter,UParticleEmitter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleMeshEmitter)
};

class UParticleSpriteEmitter : public UParticleEmitter
{
public:
    //## BEGIN PROPS ParticleSpriteEmitter
    BYTE ScreenAlignment;
    class UMaterialInterface* Material;
    //## END PROPS ParticleSpriteEmitter

    DECLARE_CLASS(UParticleSpriteEmitter,UParticleEmitter,0,Engine)
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);
	virtual void SetToSensibleDefaults();
};

class UParticleSpriteSubUVEmitter : public UParticleSpriteEmitter
{
public:
    //## BEGIN PROPS ParticleSpriteSubUVEmitter
    //## END PROPS ParticleSpriteSubUVEmitter

    DECLARE_CLASS(UParticleSpriteSubUVEmitter,UParticleSpriteEmitter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleSpriteSubUVEmitter)
};

struct FParticleCurvePair
{
    FString CurveName;
    class UObject* CurveObject;

    /** Constructors */
    FParticleCurvePair()
    : CurveObject(NULL)
    {}
    FParticleCurvePair(EEventParm)
    {
        appMemzero(this, sizeof(FParticleCurvePair));
    }
};

class UParticleModule : public UObject
{
public:
    //## BEGIN PROPS ParticleModule
    BITFIELD bSpawnModule:1;
    BITFIELD bUpdateModule:1;
    BITFIELD bCurvesAsColor:1;
    BITFIELD b3DDrawMode:1;
    BITFIELD bSupported3DDrawMode:1;
    BITFIELD bEnabled:1;
    BITFIELD bEditable:1;
    FColor ModuleEditorColor;
    //## END PROPS ParticleModule

    DECLARE_ABSTRACT_CLASS(UParticleModule,UObject,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	// For Cascade
	/**
	 *	In the editor, called on a particle that is freshly spawned by the emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	SpawnTime		The time of the spawn.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	In the editor, called on a particle that is being updated by its emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	DeltaTime		The time since the last update.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Remove all curve-editable Objects within this module from the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to remove the curve from.
	 */
	void	RemoveModuleCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Does the module contain curves?
	 *
	 *	@return	UBOOL		TRUE if it does, FALSE if not.
	 */
	UBOOL	ModuleHasCurves();
	/** 
	 *	Are the modules curves displayed in the curve editor?
	 *
	 *	@param	EdSetup		The CurveEd setup to check.
	 *
	 *	@return	UBOOL		TRUE if they are, FALSE if not.
	 */
	UBOOL	IsDisplayedInCurveEd(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Helper function for updating the curve editor when the module editor color changes.
	 *
	 *	@param	Color		The new color the module is using.
	 *	@param	EdSetup		The CurveEd setup for the module.
	 */
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	/** 
	 *	Render the modules 3D visualization helper primitive.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the module.
	 *	@param	View		The scene view that is being rendered.
	 *	@param	PDI			The FPrimitiveDrawInterface to use for rendering.
	 */
	virtual void Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI)	{};

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_General;	}

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);
	
	/**
	 *	Helper function used by the editor to auto-generate LOD values from a source module
	 *	and a percentage value used to scale its values.
	 *
	 *	@param	SourceModule	The ParticleModule to utilize as the template.
	 *	@param	Percentage		The value to use when scaling the source values.
	 */
	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);

	/**
	 *	Conversion functions for distributions.
	 *
	 *	Used to convert from an old representation of data (rotations in degrees, etc.)
	 *	to new ones (rotations in Turns/Sec, etc.).
	 */
	virtual UBOOL	ConvertFloatDistribution(UDistributionFloat* FloatDist, UDistributionFloat* SourceFloatDist, FLOAT Percentage);
	virtual UBOOL	ConvertVectorDistribution(UDistributionVector* VectorDist, UDistributionVector* SourceVectorDist, FLOAT Percentage);
	virtual UBOOL	ConvertColorFloatDistribution(UDistributionFloat* FloatDist);
	virtual UBOOL	ConvertColorVectorDistribution(UDistributionVector* VectorDist);
};

class UParticleModuleAccelerationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationBase
    //## END PROPS ParticleModuleAccelerationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAccelerationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleAccelerationBase)
};

class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAcceleration
    struct FRawDistributionVector Acceleration;
    //## END PROPS ParticleModuleAcceleration

    DECLARE_CLASS(UParticleModuleAcceleration,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationOverLifetime
    struct FRawDistributionVector AccelOverLife;
    //## END PROPS ParticleModuleAccelerationOverLifetime

    DECLARE_CLASS(UParticleModuleAccelerationOverLifetime,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleAttractorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAttractorBase
    //## END PROPS ParticleModuleAttractorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAttractorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleAttractorBase)
};

class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorLine
    FVector EndPoint0;
    FVector EndPoint1;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleAttractorLine

    DECLARE_CLASS(UParticleModuleAttractorLine,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorParticle
    FName EmitterName;
    struct FRawDistributionFloat Range;
    BITFIELD bStrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bRenewSource:1;
    BITFIELD bInheritSourceVel:1;
    struct FRawDistributionFloat Strength;
    BYTE SelectionMethod;
    INT LastSelIndex;
    //## END PROPS ParticleModuleAttractorParticle

    DECLARE_CLASS(UParticleModuleAttractorParticle,UParticleModuleAttractorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorPoint
    struct FRawDistributionVector Position;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    BITFIELD StrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bOverrideVelocity:1;
    //## END PROPS ParticleModuleAttractorPoint

    DECLARE_CLASS(UParticleModuleAttractorPoint,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleBeamBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleBeamBase
    //## END PROPS ParticleModuleBeamBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleBeamBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Beam;	}
};

struct FBeamModifierOptions
{
    BITFIELD bModify:1;
    BITFIELD bScale:1;
    BITFIELD bLock:1;
};

class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamModifier
    BYTE ModifierType;
    struct FBeamModifierOptions PositionOptions;
    struct FRawDistributionVector Position;
    struct FBeamModifierOptions TangentOptions;
    struct FRawDistributionVector Tangent;
    BITFIELD bAbsoluteTangent:1;
    struct FBeamModifierOptions StrengthOptions;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleBeamModifier

    DECLARE_CLASS(UParticleModuleBeamModifier,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);


			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, FBeam2TypeDataPayload*& BeamDataPayload, 
						FBeamParticleModifierPayloadData*& SourceModifierPayload,
						FBeamParticleModifierPayloadData*& TargetModifierPayload);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& BeamDataOffset, INT& SourceModifierOffset, 
						INT& TargetModifierOffset);
};

class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamNoise
    BITFIELD bNoise:1;
    BITFIELD bLowFreq_Enabled:1;
    BITFIELD bNRScaleEmitterTime:1;
    BITFIELD bMoving:1;
    BITFIELD bSmooth:1;
    BITFIELD bNoiseLock:1;
    BITFIELD bOscillate:1;
    BITFIELD bUseNoiseTangents:1;
    BITFIELD bTargetNoise:1;
    BITFIELD bApplyNoiseScale:1;
    INT Frequency;
    INT Frequency_LowRange;
    struct FRawDistributionVector NoiseRange;
    struct FRawDistributionFloat NoiseRangeScale;
    struct FRawDistributionVector NoiseSpeed;
    FLOAT NoiseLockRadius;
    FLOAT NoiseLockTime;
    FLOAT NoiseTension;
    struct FRawDistributionFloat NoiseTangentStrength;
    INT NoiseTessellation;
    FLOAT FrequencyDistance;
    struct FRawDistributionFloat NoiseScale;
    //## END PROPS ParticleModuleBeamNoise

    DECLARE_CLASS(UParticleModuleBeamNoise,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamSource
    BYTE SourceMethod;
    BYTE SourceTangentMethod;
    FName SourceName;
    BITFIELD bSourceAbsolute:1;
    BITFIELD bLockSource:1;
    BITFIELD bLockSourceTangent:1;
    BITFIELD bLockSourceStength:1;
    struct FRawDistributionVector Source;
    struct FRawDistributionVector SourceTangent;
    struct FRawDistributionFloat SourceStrength;
    //## END PROPS ParticleModuleBeamSource

    DECLARE_CLASS(UParticleModuleBeamSource,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource,
						FBeamParticleSourceBranchPayloadData*& BranchSource);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& ParticleSourceOffset, INT& BranchSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);
};

class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamTarget
    BYTE TargetMethod;
    BYTE TargetTangentMethod;
    FName TargetName;
    struct FRawDistributionVector Target;
    BITFIELD bTargetAbsolute:1;
    BITFIELD bLockTarget:1;
    BITFIELD bLockTargetTangent:1;
    BITFIELD bLockTargetStength:1;
    struct FRawDistributionVector TargetTangent;
    struct FRawDistributionFloat TargetStrength;
    FLOAT LockRadius;
    //## END PROPS ParticleModuleBeamTarget

    DECLARE_CLASS(UParticleModuleBeamTarget,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource);
						
			UBOOL	ResolveTargetData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);
};

class UParticleModuleCollisionBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleCollisionBase
    //## END PROPS ParticleModuleCollisionBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleCollisionBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleCollisionBase)
};

class UParticleModuleCollision : public UParticleModuleCollisionBase
{
public:
    //## BEGIN PROPS ParticleModuleCollision
    struct FRawDistributionVector DampingFactor;
    struct FRawDistributionVector DampingFactorRotation;
    struct FRawDistributionFloat MaxCollisions;
    BYTE CollisionCompletionOption;
    BITFIELD bApplyPhysics:1 GCC_BITFIELD_MAGIC;
    BITFIELD bPawnsDoNotDecrementCount:1;
    BITFIELD bOnlyVerticalNormalsDecrementCount:1;
    struct FRawDistributionFloat ParticleMass;
    FLOAT DirScalar;
    FLOAT VerticalFudgeFactor;
    struct FRawDistributionFloat DelayAmount;
    //## END PROPS ParticleModuleCollision

    DECLARE_CLASS(UParticleModuleCollision,UParticleModuleCollisionBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleColorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleColorBase
    //## END PROPS ParticleModuleColorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleColorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleColorBase)
};

class UParticleModuleColor : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColor
    struct FRawDistributionVector StartColor;
    struct FRawDistributionFloat StartAlpha;
    BITFIELD bClampAlpha:1;
    //## END PROPS ParticleModuleColor

    DECLARE_CLASS(UParticleModuleColor,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChange(UProperty* PropertyThatChanged);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorByParameter : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorByParameter
    FName ColorParam;
    FColor DefaultColor;
    //## END PROPS ParticleModuleColorByParameter

    DECLARE_CLASS(UParticleModuleColorByParameter,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);
};

class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorOverLife
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    BITFIELD bClampAlpha:1;
    //## END PROPS ParticleModuleColorOverLife

    DECLARE_CLASS(UParticleModuleColorOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChange(UProperty* PropertyThatChanged);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorScaleOverLife
    struct FRawDistributionVector ColorScaleOverLife;
    struct FRawDistributionFloat AlphaScaleOverLife;
    BITFIELD bEmitterTime:1;
    //## END PROPS ParticleModuleColorScaleOverLife

    DECLARE_CLASS(UParticleModuleColorScaleOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleKillBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleKillBase
    //## END PROPS ParticleModuleKillBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleKillBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleKillBase)
};

class UParticleModuleKillBox : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillBox
    struct FRawDistributionVector LowerLeftCorner;
    struct FRawDistributionVector UpperRightCorner;
    BITFIELD bAbsolute:1;
    BITFIELD bKillInside:1;
    //## END PROPS ParticleModuleKillBox

    DECLARE_CLASS(UParticleModuleKillBox,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleKillHeight : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillHeight
    struct FRawDistributionFloat Height;
    BITFIELD bAbsolute:1;
    BITFIELD bFloor:1;
    //## END PROPS ParticleModuleKillHeight

    DECLARE_CLASS(UParticleModuleKillHeight,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLifetimeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLifetimeBase
    //## END PROPS ParticleModuleLifetimeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLifetimeBase,UParticleModule,0,Engine)
	virtual FLOAT	GetMaxLifetime()
	{
		return 0.0f;
	}
};

class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
    //## BEGIN PROPS ParticleModuleLifetime
    struct FRawDistributionFloat Lifetime;
    //## END PROPS ParticleModuleLifetime

    DECLARE_CLASS(UParticleModuleLifetime,UParticleModuleLifetimeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	virtual FLOAT	GetMaxLifetime();
};

class UParticleModuleLocationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLocationBase
    //## END PROPS ParticleModuleLocationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLocationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleLocationBase)
};

class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocation
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleLocation

    DECLARE_CLASS(UParticleModuleLocation,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationDirect
    struct FRawDistributionVector Location;
    struct FRawDistributionVector LocationOffset;
    struct FRawDistributionVector ScaleFactor;
    struct FRawDistributionVector Direction;
    //## END PROPS ParticleModuleLocationDirect

    DECLARE_CLASS(UParticleModuleLocationDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitter
    FName EmitterName;
    BYTE SelectionMethod;
    BITFIELD InheritSourceVelocity:1 GCC_BITFIELD_MAGIC;
    BITFIELD bInheritSourceRotation:1;
    FLOAT InheritSourceVelocityScale;
    FLOAT InheritSourceRotationScale;
    //## END PROPS ParticleModuleLocationEmitter

    DECLARE_CLASS(UParticleModuleLocationEmitter,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitterDirect
    FName EmitterName;
    //## END PROPS ParticleModuleLocationEmitterDirect

    DECLARE_CLASS(UParticleModuleLocationEmitterDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveBase
    BITFIELD Positive_X:1;
    BITFIELD Positive_Y:1;
    BITFIELD Positive_Z:1;
    BITFIELD Negative_X:1;
    BITFIELD Negative_Y:1;
    BITFIELD Negative_Z:1;
    BITFIELD SurfaceOnly:1;
    BITFIELD Velocity:1;
    struct FRawDistributionFloat VelocityScale;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleLocationPrimitiveBase

    DECLARE_CLASS(UParticleModuleLocationPrimitiveBase,UParticleModuleLocationBase,0,Engine)
	virtual void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);
};

class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveCylinder
    BITFIELD RadialVelocity:1;
    struct FRawDistributionFloat StartRadius;
    struct FRawDistributionFloat StartHeight;
    BYTE HeightAxis;
    //## END PROPS ParticleModuleLocationPrimitiveCylinder

    DECLARE_CLASS(UParticleModuleLocationPrimitiveCylinder,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveSphere
    struct FRawDistributionFloat StartRadius;
    //## END PROPS ParticleModuleLocationPrimitiveSphere

    DECLARE_CLASS(UParticleModuleLocationPrimitiveSphere,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleMaterialBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleMaterialBase
    //## END PROPS ParticleModuleMaterialBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleMaterialBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleMaterialBase)
};

class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMaterialByParameter
    TArrayNoInit<FName> MaterialParameters;
    TArrayNoInit<class UMaterialInterface*> DefaultMaterials;
    //## END PROPS ParticleModuleMaterialByParameter

    DECLARE_CLASS(UParticleModuleMaterialByParameter,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshMaterial
    TArrayNoInit<class UMaterialInterface*> MeshMaterials;
    //## END PROPS ParticleModuleMeshMaterial

    DECLARE_CLASS(UParticleModuleMeshMaterial,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	In the editor, called on a particle that is freshly spawned by the emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	SpawnTime		The time of the spawn.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleOrbitBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrbitBase
    BITFIELD bUseEmitterTime:1;
    //## END PROPS ParticleModuleOrbitBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrbitBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrbitBase)
};

struct FOrbitOptions
{
    BITFIELD bProcessDuringSpawn:1;
    BITFIELD bProcessDuringUpdate:1;
    BITFIELD bUseEmitterTime:1;
};

class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
public:
    //## BEGIN PROPS ParticleModuleOrbit
    BYTE ChainMode GCC_BITFIELD_MAGIC;
    struct FRawDistributionVector OffsetAmount;
    struct FOrbitOptions OffsetOptions;
    struct FRawDistributionVector RotationAmount;
    struct FOrbitOptions RotationOptions;
    struct FRawDistributionVector RotationRateAmount;
    struct FOrbitOptions RotationRateOptions;
    //## END PROPS ParticleModuleOrbit

    DECLARE_CLASS(UParticleModuleOrbit,UParticleModuleOrbitBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	// For Cascade
	/**
	 *	In the editor, called on a particle that is freshly spawned by the emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	SpawnTime		The time of the spawn.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	In the editor, called on a particle that is being updated by its emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	DeltaTime		The time since the last update.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleOrientationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrientationBase
    //## END PROPS ParticleModuleOrientationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrientationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrientationBase)
};

class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
public:
    //## BEGIN PROPS ParticleModuleOrientationAxisLock
    BYTE LockAxisFlags;
    //## END PROPS ParticleModuleOrientationAxisLock

    DECLARE_CLASS(UParticleModuleOrientationAxisLock,UParticleModuleOrientationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	SetLockAxis(EParticleAxisLock eLockFlags);
};

class UParticleModuleRequired : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRequired
    class UMaterialInterface* Material;
    BYTE ScreenAlignment;
    BYTE ParticleBurstMethod;
    BYTE InterpolationMethod;
    BYTE EmitterRenderMode;
    BITFIELD bUseLocalSpace:1 GCC_BITFIELD_MAGIC;
    BITFIELD bKillOnDeactivate:1;
    BITFIELD bKillOnCompleted:1;
    BITFIELD bRequiresSorting:1;
    BITFIELD bEmitterDurationUseRange:1;
    BITFIELD bDurationRecalcEachLoop:1;
    BITFIELD bUseMaxDrawCount:1;
    BITFIELD bDelayFirstLoopOnly:1;
    BITFIELD bScaleUV:1;
    BITFIELD bDirectUV:1;
    FLOAT EmitterDuration;
    FLOAT EmitterDurationLow;
    INT EmitterLoops;
    INT MaxDrawCount;
    struct FRawDistributionFloat SpawnRate;
    TArrayNoInit<struct FParticleBurst> BurstList;
    FLOAT EmitterDelay;
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    FLOAT RandomImageTime;
    INT RandomImageChanges;
    FColor EmitterEditorColor;
    //## END PROPS ParticleModuleRequired

    DECLARE_CLASS(UParticleModuleRequired,UParticleModule,0,Engine)
	virtual void	PostEditChange(UProperty* PropertyThatChanged);
	virtual void	PostLoad();

	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleRotationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationBase
    //## END PROPS ParticleModuleRotationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationBase)
};

class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotation
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    //## END PROPS ParticleModuleMeshRotation

    DECLARE_CLASS(UParticleModuleMeshRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotation
    struct FRawDistributionFloat StartRotation;
    //## END PROPS ParticleModuleRotation

    DECLARE_CLASS(UParticleModuleRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationOverLifetime
    struct FRawDistributionFloat RotationOverLife;
    BITFIELD Scale:1;
    //## END PROPS ParticleModuleRotationOverLifetime

    DECLARE_CLASS(UParticleModuleRotationOverLifetime,UParticleModuleRotationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleRotationRateBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateBase
    //## END PROPS ParticleModuleRotationRateBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationRateBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationRateBase)
};

class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRate
    struct FRawDistributionVector StartRotationRate;
    //## END PROPS ParticleModuleMeshRotationRate

    DECLARE_CLASS(UParticleModuleMeshRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRateMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    //## END PROPS ParticleModuleMeshRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleMeshRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRate
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleRotationRate

    DECLARE_CLASS(UParticleModuleRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateMultiplyLife
    struct FRawDistributionFloat LifeMultiplier;
    //## END PROPS ParticleModuleRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSizeBase
    //## END PROPS ParticleModuleSizeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSizeBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSizeBase)
};

class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSize
    struct FRawDistributionVector StartSize;
    //## END PROPS ParticleModuleSize

    DECLARE_CLASS(UParticleModuleSize,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    //## END PROPS ParticleModuleSizeMultiplyLife

    DECLARE_CLASS(UParticleModuleSizeMultiplyLife,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyVelocity
    struct FRawDistributionVector VelocityMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    //## END PROPS ParticleModuleSizeMultiplyVelocity

    DECLARE_CLASS(UParticleModuleSizeMultiplyVelocity,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeScale
    struct FRawDistributionVector SizeScale;
    BITFIELD EnableX:1;
    BITFIELD EnableY:1;
    BITFIELD EnableZ:1;
    //## END PROPS ParticleModuleSizeScale

    DECLARE_CLASS(UParticleModuleSizeScale,UParticleModuleSizeBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSpawnBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSpawnBase
    BITFIELD bProcessSpawnRate:1;
    //## END PROPS ParticleModuleSpawnBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSpawnBase,UParticleModule,0,Engine)
	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate)
	{
		return bProcessSpawnRate;
	}

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *	Editor-only version - this will interpolate between the module and the provided LowerLODModule
	 *	using the value of multiplier.
	 *
	 *	@param	Owner			The particle emitter instance that is spawning.
	 *	@param	Offset			The offset into the particle payload for the module.
	 *	@param	LowerLODModule	The lower LOD module to interpolate with.
	 *	@param	Multiplier		The interpolation 'alpha' value.
	 *	@param	OldLeftover		The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime		The time that has expired since the last frame.
	 *	@param	Number			The number of particles to spawn. (OUTPUT)
	 *	@param	Rate			The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL			FALSE if the SpawnRate should be ignored.
	 *							TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, UParticleModule* LowerLODModule, FLOAT Multiplier,
		FLOAT OldLeftover, FLOAT DeltaTime, INT& Number, FLOAT& Rate)
	{
		return bProcessSpawnRate;
	}
};

class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
public:
    //## BEGIN PROPS ParticleModuleSpawnPerUnit
    FLOAT UnitScalar;
    struct FRawDistributionFloat SpawnPerUnit;
    BITFIELD bIgnoreSpawnRateWhenMoving:1;
    FLOAT MovementTolerance;
    //## END PROPS ParticleModuleSpawnPerUnit

    DECLARE_CLASS(UParticleModuleSpawnPerUnit,UParticleModuleSpawnBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	In the editor, called on a particle that is freshly spawned by the emitter.
	 *	Is responsible for performing the intepolation between LOD levels for realtime 
	 *	previewing.
	 *	
	 *	@param	Owner			The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset			The modules offset into the data payload of the particle.
	 *	@param	SpawnTime		The time of the spawn.
	 *	@param	LowerLODModule	The next lower LOD module - used during interpolation.
	 *	@param	Multiplier		The interpolation alpha value to use.
	 */
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *	Editor-only version - this will interpolate between the module and the provided LowerLODModule
	 *	using the value of multiplier.
	 *
	 *	@param	Owner			The particle emitter instance that is spawning.
	 *	@param	Offset			The offset into the particle payload for the module.
	 *	@param	LowerLODModule	The lower LOD module to interpolate with.
	 *	@param	Multiplier		The interpolation 'alpha' value.
	 *	@param	OldLeftover		The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime		The time that has expired since the last frame.
	 *	@param	Number			The number of particles to spawn. (OUTPUT)
	 *	@param	Rate			The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL			FALSE if the SpawnRate should be ignored.
	 *							TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, UParticleModule* LowerLODModule, FLOAT Multiplier,
		FLOAT OldLeftover, FLOAT DeltaTime, INT& Number, FLOAT& Rate);
};

class UParticleModuleSubUVBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSubUVBase
    //## END PROPS ParticleModuleSubUVBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSubUVBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSubUVBase)
};

class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUV
    struct FRawDistributionFloat SubImageIndex;
    //## END PROPS ParticleModuleSubUV

    DECLARE_CLASS(UParticleModuleSubUV,UParticleModuleSubUVBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	SpawnEditorSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnEditorTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	SpawnEditorMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnEditorTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditorSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditorMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	
			UBOOL	DetermineSpriteImageIndex(FParticleEmitterInstance* Owner, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FSubUVSpritePayload*& SubUVPayload, INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);
			UBOOL	DetermineMeshImageIndex(FParticleEmitterInstance* Owner, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FSubUVMeshPayload*& SubUVPayload, INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVDirect
    struct FRawDistributionVector SubUVPosition;
    struct FRawDistributionVector SubUVSize;
    //## END PROPS ParticleModuleSubUVDirect

    DECLARE_CLASS(UParticleModuleSubUVDirect,UParticleModuleSubUVBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditorSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditorMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVSelect
    struct FRawDistributionVector SubImageSelect;
    //## END PROPS ParticleModuleSubUVSelect

    DECLARE_CLASS(UParticleModuleSubUVSelect,UParticleModuleSubUVBase,0,Engine)
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void UpdateEditorSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void UpdateEditorMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleTrailBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTrailBase
    //## END PROPS ParticleModuleTrailBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTrailBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Trail;	}
};

class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSource
    BYTE SourceMethod;
    BYTE SelectionMethod;
    FName SourceName;
    struct FRawDistributionFloat SourceStrength;
    BITFIELD bLockSourceStength:1;
    BITFIELD bInheritRotation:1;
    INT SourceOffsetCount;
    TArrayNoInit<FVector> SourceOffsetDefaults;
    //## END PROPS ParticleModuleTrailSource

    DECLARE_CLASS(UParticleModuleTrailSource,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						FTrailParticleSourcePayloadData*& ParticleSource);
			void	GetDataPointerOffsets(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						INT& ParticleSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, FTrail2TypeDataPayload* TrailData, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning);

			UBOOL	ResolveSourcePoint(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData, 
				FVector& Position, FVector& Tangent);

			FVector	ResolveSourceOffset(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData);
};

class UParticleModuleTrailSpawn : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSpawn
    BYTE SpawnMethod;
    class UDistributionFloat* SpawnVelocity;
    FLOAT VelocityScale;
    class UDistributionVector* SpawnDistance;
    class UDistributionFloatParticleParameter* SpawnDistanceMap;
    FLOAT MinSpawnVelocity;
    //## END PROPS ParticleModuleTrailSpawn

    DECLARE_CLASS(UParticleModuleTrailSpawn,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);

			UINT	GetSpawnCount(FParticleTrail2EmitterInstance* TrailInst, FLOAT DeltaTime);
};

class UParticleModuleTrailTaper : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailTaper
    BYTE TaperMethod;
    struct FRawDistributionFloat TaperFactor;
    //## END PROPS ParticleModuleTrailTaper

    DECLARE_CLASS(UParticleModuleTrailTaper,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);
};

struct FPhysXFluidTypeData
{
    INT FluidMaxParticles;
    FLOAT FluidRestParticlesPerMeter;
    FLOAT FluidRestDensity;
    FLOAT FluidKernelRadiusMultiplier;
    FLOAT FluidMotionLimitMultiplier;
    FLOAT FluidCollisionDistanceMultiplier;
    BYTE FluidPacketSizeMultiplier;
    FLOAT FluidStiffness;
    FLOAT FluidViscosity;
    FLOAT FluidDamping;
    FLOAT FluidFadeInTime;
    FVector FluidExternalAcceleration;
    FLOAT FluidStaticCollisionRestitution;
    FLOAT FluidStaticCollisionAdhesion;
    FLOAT FluidStaticCollisionAttraction;
    FLOAT FluidDynamicCollisionRestitution;
    FLOAT FluidDynamicCollisionAdhesion;
    FLOAT FluidDynamicCollisionAttraction;
    FLOAT FluidCollisionResponseCoefficient;
    BYTE FluidSimulationMethod;
    BITFIELD bFluidStaticCollision:1 GCC_BITFIELD_MAGIC;
    BITFIELD bFluidDynamicCollision:1;
    BITFIELD bFluidTwoWayCollision:1;
    BITFIELD bDisableGravity:1;
    INT FluidPacketMaxCount;
    FLOAT FluidForceScale;
    BYTE FluidEmitterType;
    INT FluidEmitterMaxParticles;
    BYTE FluidEmitterShape;
    FLOAT FluidEmitterDimensionX;
    FLOAT FluidEmitterDimensionY;
    FVector FluidEmitterRandomPos;
    FLOAT FluidEmitterRandomAngle;
    FLOAT FluidEmitterFluidVelocityMagnitude;
    FLOAT FluidEmitterRate;
    FLOAT FluidEmitterParticleLifetime;
    FLOAT FluidEmitterRepulsionCoefficient;
    class NxFluid* NovodexFluid;
    class FRBPhysScene* RBPhysScene;
    class NxFluidEmitter* PrimaryEmitter;
    INT FluidNumParticles;
    INT FluidNumCreated;
    INT FluidNumDeleted;
    DWORD* FluidIDCreationBuffer;
    DWORD* FluidIDDeletionBuffer;
    class NxFluidParticle* FluidParticleBuffer;
    class NxFluidParticleEx* FluidParticleBufferEx;
    class NxVec3* FluidParticleContacts;
    WORD* ParticleRanks;
    class NxVec3* FluidAddParticlePos;
    class NxVec3* FluidAddParticleVel;
    FLOAT* FluidAddParticleLife;
    INT FluidNumParticlePackets;
    struct NxFluidPacket* FluidParticlePacketData;
    INT FluidNumParticleForceUpdate;
    class FVector* FluidParticleForceUpdate;
    BITFIELD bFluidApplyParticleForceUpdates:1;
    BITFIELD bNeedsExtendedParticleData:1;
    BITFIELD bNeedsParticleContactData:1;
    BITFIELD bNeedsParticleRanks:1;

		FPhysXFluidTypeData();
		~FPhysXFluidTypeData();

		void					PostEditChange(void);
		void					FinishDestroy(void);

		void					UpdatePrimaryEmitter(void);

		class NxFluidEmitter*	CreateEmitter(FPhysXEmitterInstance &Instance);

		void					ReleaseEmitter(class NxFluidEmitter &emitter);
		void					TickEmitter(class NxFluidEmitter &emitter, FLOAT DeltaTime);

		 
		void					AddForceField(class NxFluidEmitter &emitter, class FForceApplicator* Applicator, const FBox& FieldBoundingBox);
	
		 
		void					ApplyParticleForces(class NxFluidEmitter &emitter);

		 
		void					FillVolume(class AActor &BaseActor);
	
};

class UParticleModuleTypeDataBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBase
    //## END PROPS ParticleModuleTypeDataBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTypeDataBase,UParticleModule,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void	SetToSensibleDefaults();
	virtual void	PreSpawn(FParticleEmitterInstance* Owner, FBaseParticle* Particle)			{};
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)		{};
	virtual void	PostUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)	{};

	virtual EModuleType	GetModuleType() const							{	return EPMT_TypeData;	}
	virtual UBOOL		SupportsSpecificScreenAlignmentFlags() const	{	return FALSE;			}
};

class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam
    BYTE BeamMethod;
    BYTE EndPointMethod;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionVector EndPoint;
    INT TessellationFactor;
    struct FRawDistributionFloat EmitterStrength;
    struct FRawDistributionFloat TargetStrength;
    struct FRawDistributionVector EndPointDirection;
    INT TextureTile;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    //## END PROPS ParticleModuleTypeDataBeam

    DECLARE_CLASS(UParticleModuleTypeDataBeam,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	FVector			DetermineEndPointPosition(FParticleEmitterInstance* Owner, FLOAT DeltaTime);
	FVector			DetermineParticlePosition(FParticleEmitterInstance* Owner, FBaseParticle* pkParticle, FLOAT DeltaTime);

	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults();

	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam2
    BYTE BeamMethod;
    BYTE TaperMethod;
    INT TessellationFactor;
    INT TextureTile;
    FLOAT TextureTileDistance;
    INT Sheets;
    INT MaxBeamCount;
    FLOAT Speed;
    INT InterpolationPoints;
    BITFIELD bAlwaysOn:1;
    BITFIELD bSourceDirect:1;
    BITFIELD bTargetDirect:1;
    BITFIELD bNoise:1;
    BITFIELD bMoving:1;
    BITFIELD bSmooth:1;
    BITFIELD bNoiseLock:1;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    FName BranchParentName;
    struct FRawDistributionVector Source;
    struct FRawDistributionFloat SourceStrength;
    FName SourceName;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionVector Target;
    FLOAT LockRadius;
    struct FRawDistributionFloat TargetStrength;
    FName TargetName;
    TArrayNoInit<FBeamTargetData> MultipleTargets;
    INT Frequency;
    struct FRawDistributionVector NoiseRange;
    struct FRawDistributionVector NoiseSpeed;
    FLOAT NoiseLockTime;
    FLOAT NoiseTension;
    struct FRawDistributionFloat TaperFactor;
    struct FRawDistributionFloat TaperScale;
    //## END PROPS ParticleModuleTypeDataBeam2

    DECLARE_CLASS(UParticleModuleTypeDataBeam2,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	// For Cascade
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);

	// Beam
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
			FLOAT*& NoiseRate, FLOAT*& NoiseDeltaTime, FVector*& TargetNoisePoints, 
			FVector*& NextNoisePoints, FLOAT*& TaperValues, FLOAT*& NoiseDistanceScale,
			FBeamParticleModifierPayloadData*& SourceModifier,
			FBeamParticleModifierPayloadData*& TargetModifier);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& BeamDataOffset, INT& InterpolatedPointsOffset, INT& NoiseRateOffset, 
			INT& NoiseDeltaTimeOffset, INT& TargetNoisePointsOffset, INT& NextNoisePointsOffset, 
			INT& TaperCount, INT& TaperValuesOffset, INT& NoiseDistanceScaleOffset);

			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMesh
    class UStaticMesh* Mesh;
    BITFIELD CastShadows:1;
    BITFIELD DoCollisions:1;
    BITFIELD bOverrideMaterial:1;
    BYTE MeshAlignment GCC_BITFIELD_MAGIC;
    //## END PROPS ParticleModuleTypeDataMesh

    DECLARE_CLASS(UParticleModuleTypeDataMesh,UParticleModuleTypeDataBase,0,Engine)
	virtual void						PostEditChange(UProperty* PropertyThatChanged);
	virtual FParticleEmitterInstance*	CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void						SetToSensibleDefaults();

	virtual UBOOL	SupportsSpecificScreenAlignmentFlags() const	{	return TRUE;	}
};

class UParticleModuleTypeDataMeshNxFluid : public UParticleModuleTypeDataMesh
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMeshNxFluid
    struct FPhysXFluidTypeData PhysXFluid;
    BYTE FluidRotationMethod;
    FLOAT FluidRotationCoefficient;
    //## END PROPS ParticleModuleTypeDataMeshNxFluid

    DECLARE_CLASS(UParticleModuleTypeDataMeshNxFluid,UParticleModuleTypeDataMesh,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);
	
	virtual void                      SetToSensibleDefaults();	
	virtual void                      PostEditChange(UProperty* PropertyThatChanged);
	virtual void                      FinishDestroy();
	
	void                              TickEmitter(class NxFluidEmitter &emitter, FLOAT DeltaTime);
	
	void                              TickRotationSpherical(FLOAT DeltaTime);
	void                              TickRotationBox(FLOAT DeltaTime);
};

class UParticleModuleTypeDataNxFluid : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataNxFluid
    struct FPhysXFluidTypeData PhysXFluid;
    //## END PROPS ParticleModuleTypeDataNxFluid

    DECLARE_CLASS(UParticleModuleTypeDataNxFluid,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);
	
	virtual void                      PostEditChange(UProperty* PropertyThatChanged);
	virtual void                      FinishDestroy();
	
	void                              TickEmitter(class NxFluidEmitter &emitter, FLOAT DeltaTime);
};

class UParticleModuleTypeDataSubUV : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataSubUV
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    BYTE InterpolationMethod;
    BITFIELD DirectUV:1 GCC_BITFIELD_MAGIC;
    //## END PROPS ParticleModuleTypeDataSubUV

    DECLARE_CLASS(UParticleModuleTypeDataSubUV,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults();

	virtual void PostEditChange(UProperty* PropertyThatChanged);

};

class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail
    BITFIELD RenderGeometry:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    BITFIELD Tapered:1;
    BITFIELD SpawnByDistance:1;
    INT TessellationFactor;
    struct FRawDistributionFloat Tension;
    FVector SpawnDistance;
    //## END PROPS ParticleModuleTypeDataTrail

    DECLARE_CLASS(UParticleModuleTypeDataTrail,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults();

	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail2
    INT TessellationFactor;
    FLOAT TessellationFactorDistance;
    FLOAT TessellationStrength;
    INT TextureTile;
    INT Sheets;
    INT MaxTrailCount;
    INT MaxParticleInTrailCount;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    //## END PROPS ParticleModuleTypeDataTrail2

    DECLARE_CLASS(UParticleModuleTypeDataTrail2,UParticleModuleTypeDataBase,0,Engine)
	virtual void	PreSpawn(FParticleEmitterInstance* Owner, FBaseParticle* Particle);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual void	SetToSensibleDefaults();
	virtual void	PostEditChange(UProperty* PropertyThatChanged);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	// Trail
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FTrail2TypeDataPayload*& TrailData, FLOAT*& TaperValues);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& TrailDataOffset, INT& TaperValuesOffset);
};

class UParticleModuleUberBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleUberBase
    TArrayNoInit<FName> RequiredModules;
    //## END PROPS ParticleModuleUberBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleUberBase,UParticleModule,0,Engine)
	/** This function will determine the proper uber-module to utilize.					*/
	static	UParticleModule*	DetermineBestUberModule(UParticleEmitter* InputEmitter);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberLTISIVCL

    DECLARE_CLASS(UParticleModuleUberLTISIVCL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLIL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleUberLTISIVCLIL

    DECLARE_CLASS(UParticleModuleUberLTISIVCLIL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    struct FRawDistributionFloat StartRotation;
    struct FRawDistributionVector SizeLifeMultiplier;
    BITFIELD SizeMultiplyX:1;
    BITFIELD SizeMultiplyY:1;
    BITFIELD SizeMultiplyZ:1;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR

    DECLARE_CLASS(UParticleModuleUberLTISIVCLILIRSSBLIRR,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberRainDrops : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainDrops
    FLOAT LifetimeMin;
    FLOAT LifetimeMax;
    FVector StartSizeMin;
    FVector StartSizeMax;
    FVector StartVelocityMin;
    FVector StartVelocityMax;
    FLOAT StartVelocityRadialMin;
    FLOAT StartVelocityRadialMax;
    FVector ColorOverLife;
    FLOAT AlphaOverLife;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    FLOAT PC_VelocityScale;
    FVector PC_StartLocation;
    FLOAT PC_StartRadius;
    FLOAT PC_StartHeight;
    BYTE PC_HeightAxis;
    FVector StartLocationMin;
    FVector StartLocationMax;
    //## END PROPS ParticleModuleUberRainDrops

    DECLARE_CLASS(UParticleModuleUberRainDrops,UParticleModuleUberBase,0,Engine)
	virtual void	PostLoad();
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainImpacts : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainImpacts
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionFloat PC_VelocityScale;
    struct FRawDistributionVector PC_StartLocation;
    struct FRawDistributionFloat PC_StartRadius;
    struct FRawDistributionFloat PC_StartHeight;
    BYTE PC_HeightAxis;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainImpacts

    DECLARE_CLASS(UParticleModuleUberRainImpacts,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainSplashA : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashA
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainSplashA

    DECLARE_CLASS(UParticleModuleUberRainSplashA,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainSplashB : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashB
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberRainSplashB

    DECLARE_CLASS(UParticleModuleUberRainSplashB,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleVelocityBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleVelocityBase
    //## END PROPS ParticleModuleVelocityBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleVelocityBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleVelocityBase)
};

class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocity
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    //## END PROPS ParticleModuleVelocity

    DECLARE_CLASS(UParticleModuleVelocity,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityInheritParent
    struct FRawDistributionVector Scale;
    //## END PROPS ParticleModuleVelocityInheritParent

    DECLARE_CLASS(UParticleModuleVelocityInheritParent,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityOverLifetime
    struct FRawDistributionVector VelOverLife;
    BITFIELD Absolute:1;
    //## END PROPS ParticleModuleVelocityOverLifetime

    DECLARE_CLASS(UParticleModuleVelocityOverLifetime,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SpawnEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
	virtual void	UpdateEditor(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime, UParticleModule* LowerLODModule, FLOAT Multiplier);
};

#endif // !INCLUDED_ENGINE_PARTICLE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AEmitter,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetCurrentLODMethod);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODLevelCount);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetCurrentLODMethod);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execResetToDefaults);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActive);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execClearParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetMaterialParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetColorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetVectorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetFloatParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourcePoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamDistance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamEndPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTessellationFactor);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamType);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstances);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnCompleted);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnDeactivate);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execKillParticlesForced);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execDeactivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execActivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetTemplate);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PARTICLE_NATIVE_DEFS
#define ENGINE_PARTICLE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UDistributionFloatParticleParameter);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorParticleParameter);
DECLARE_NATIVE_TYPE(Engine,AEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleBeam2EmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleBeamEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleDataManager);
DECLARE_NATIVE_TYPE(Engine,UParticleEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleLODLevel);
DECLARE_NATIVE_TYPE(Engine,UParticleMeshEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleMeshEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleMeshNxFluidEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleModule);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAcceleration);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAccelerationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAccelerationOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorLine);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorParticle);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleAttractorPoint);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamModifier);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamNoise);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamSource);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleBeamTarget);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleCollision);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleCollisionBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColor);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorByParameter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorOverLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleColorScaleOverLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillBox);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleKillHeight);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLifetimeBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationEmitterDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveCylinder);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleLocationPrimitiveSphere);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMaterialBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMaterialByParameter);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshMaterial);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotationRate);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleMeshRotationRateMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrbit);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrbitBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrientationAxisLock);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleOrientationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRequired);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotation);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRate);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRateBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleRotationRateMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSize);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeMultiplyLife);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeMultiplyVelocity);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSizeScale);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSpawnBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSpawnPerUnit);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUV);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVDirect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleSubUVSelect);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailSource);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailSpawn);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTrailTaper);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBeam);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataBeam2);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataMesh);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataMeshNxFluid);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataNxFluid);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataSubUV);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataTrail);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleTypeDataTrail2);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCL);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCLIL);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberLTISIVCLILIRSSBLIRR);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainDrops);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainImpacts);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainSplashA);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleUberRainSplashB);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocity);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityBase);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityInheritParent);
DECLARE_NATIVE_TYPE(Engine,UParticleModuleVelocityOverLifetime);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteNxFluidEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteSubUVEmitter);
DECLARE_NATIVE_TYPE(Engine,UParticleSpriteSubUVEmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleSystem);
DECLARE_NATIVE_TYPE(Engine,UParticleSystemComponent);
DECLARE_NATIVE_TYPE(Engine,UParticleTrail2EmitterInstance);
DECLARE_NATIVE_TYPE(Engine,UParticleTrailEmitterInstance);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PARTICLE \
	UDistributionFloatParticleParameter::StaticClass(); \
	UDistributionVectorParticleParameter::StaticClass(); \
	AEmitter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAEmitterNative; \
	UParticleBeam2EmitterInstance::StaticClass(); \
	UParticleBeamEmitterInstance::StaticClass(); \
	UParticleDataManager::StaticClass(); \
	UParticleEmitter::StaticClass(); \
	UParticleEmitterInstance::StaticClass(); \
	UParticleLODLevel::StaticClass(); \
	UParticleMeshEmitter::StaticClass(); \
	UParticleMeshEmitterInstance::StaticClass(); \
	UParticleMeshNxFluidEmitterInstance::StaticClass(); \
	UParticleModule::StaticClass(); \
	UParticleModuleAcceleration::StaticClass(); \
	UParticleModuleAccelerationBase::StaticClass(); \
	UParticleModuleAccelerationOverLifetime::StaticClass(); \
	UParticleModuleAttractorBase::StaticClass(); \
	UParticleModuleAttractorLine::StaticClass(); \
	UParticleModuleAttractorParticle::StaticClass(); \
	UParticleModuleAttractorPoint::StaticClass(); \
	UParticleModuleBeamBase::StaticClass(); \
	UParticleModuleBeamModifier::StaticClass(); \
	UParticleModuleBeamNoise::StaticClass(); \
	UParticleModuleBeamSource::StaticClass(); \
	UParticleModuleBeamTarget::StaticClass(); \
	UParticleModuleCollision::StaticClass(); \
	UParticleModuleCollisionBase::StaticClass(); \
	UParticleModuleColor::StaticClass(); \
	UParticleModuleColorBase::StaticClass(); \
	UParticleModuleColorByParameter::StaticClass(); \
	UParticleModuleColorOverLife::StaticClass(); \
	UParticleModuleColorScaleOverLife::StaticClass(); \
	UParticleModuleKillBase::StaticClass(); \
	UParticleModuleKillBox::StaticClass(); \
	UParticleModuleKillHeight::StaticClass(); \
	UParticleModuleLifetime::StaticClass(); \
	UParticleModuleLifetimeBase::StaticClass(); \
	UParticleModuleLocation::StaticClass(); \
	UParticleModuleLocationBase::StaticClass(); \
	UParticleModuleLocationDirect::StaticClass(); \
	UParticleModuleLocationEmitter::StaticClass(); \
	UParticleModuleLocationEmitterDirect::StaticClass(); \
	UParticleModuleLocationPrimitiveBase::StaticClass(); \
	UParticleModuleLocationPrimitiveCylinder::StaticClass(); \
	UParticleModuleLocationPrimitiveSphere::StaticClass(); \
	UParticleModuleMaterialBase::StaticClass(); \
	UParticleModuleMaterialByParameter::StaticClass(); \
	UParticleModuleMeshMaterial::StaticClass(); \
	UParticleModuleMeshRotation::StaticClass(); \
	UParticleModuleMeshRotationRate::StaticClass(); \
	UParticleModuleMeshRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleOrbit::StaticClass(); \
	UParticleModuleOrbitBase::StaticClass(); \
	UParticleModuleOrientationAxisLock::StaticClass(); \
	UParticleModuleOrientationBase::StaticClass(); \
	UParticleModuleRequired::StaticClass(); \
	UParticleModuleRotation::StaticClass(); \
	UParticleModuleRotationBase::StaticClass(); \
	UParticleModuleRotationOverLifetime::StaticClass(); \
	UParticleModuleRotationRate::StaticClass(); \
	UParticleModuleRotationRateBase::StaticClass(); \
	UParticleModuleRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleSize::StaticClass(); \
	UParticleModuleSizeBase::StaticClass(); \
	UParticleModuleSizeMultiplyLife::StaticClass(); \
	UParticleModuleSizeMultiplyVelocity::StaticClass(); \
	UParticleModuleSizeScale::StaticClass(); \
	UParticleModuleSpawnBase::StaticClass(); \
	UParticleModuleSpawnPerUnit::StaticClass(); \
	UParticleModuleSubUV::StaticClass(); \
	UParticleModuleSubUVBase::StaticClass(); \
	UParticleModuleSubUVDirect::StaticClass(); \
	UParticleModuleSubUVSelect::StaticClass(); \
	UParticleModuleTrailBase::StaticClass(); \
	UParticleModuleTrailSource::StaticClass(); \
	UParticleModuleTrailSpawn::StaticClass(); \
	UParticleModuleTrailTaper::StaticClass(); \
	UParticleModuleTypeDataBase::StaticClass(); \
	UParticleModuleTypeDataBeam::StaticClass(); \
	UParticleModuleTypeDataBeam2::StaticClass(); \
	UParticleModuleTypeDataMesh::StaticClass(); \
	UParticleModuleTypeDataMeshNxFluid::StaticClass(); \
	UParticleModuleTypeDataNxFluid::StaticClass(); \
	UParticleModuleTypeDataSubUV::StaticClass(); \
	UParticleModuleTypeDataTrail::StaticClass(); \
	UParticleModuleTypeDataTrail2::StaticClass(); \
	UParticleModuleUberBase::StaticClass(); \
	UParticleModuleUberLTISIVCL::StaticClass(); \
	UParticleModuleUberLTISIVCLIL::StaticClass(); \
	UParticleModuleUberLTISIVCLILIRSSBLIRR::StaticClass(); \
	UParticleModuleUberRainDrops::StaticClass(); \
	UParticleModuleUberRainImpacts::StaticClass(); \
	UParticleModuleUberRainSplashA::StaticClass(); \
	UParticleModuleUberRainSplashB::StaticClass(); \
	UParticleModuleVelocity::StaticClass(); \
	UParticleModuleVelocityBase::StaticClass(); \
	UParticleModuleVelocityInheritParent::StaticClass(); \
	UParticleModuleVelocityOverLifetime::StaticClass(); \
	UParticleSpriteEmitter::StaticClass(); \
	UParticleSpriteEmitterInstance::StaticClass(); \
	UParticleSpriteNxFluidEmitterInstance::StaticClass(); \
	UParticleSpriteSubUVEmitter::StaticClass(); \
	UParticleSpriteSubUVEmitterInstance::StaticClass(); \
	UParticleSystem::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUParticleSystemNative; \
	UParticleSystemComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUParticleSystemComponentNative; \
	UParticleTrail2EmitterInstance::StaticClass(); \
	UParticleTrailEmitterInstance::StaticClass(); \

#endif // ENGINE_PARTICLE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AEmitter) GEngineAEmitterNatives[] = 
{ 
	MAP_NATIVE(AEmitter,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AEmitter);

NATIVE_INFO(UParticleSystem) GEngineUParticleSystemNatives[] = 
{ 
	MAP_NATIVE(UParticleSystem,execSetLODDistance)
	MAP_NATIVE(UParticleSystem,execSetCurrentLODMethod)
	MAP_NATIVE(UParticleSystem,execGetLODDistance)
	MAP_NATIVE(UParticleSystem,execGetLODLevelCount)
	MAP_NATIVE(UParticleSystem,execGetCurrentLODMethod)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UParticleSystem);

NATIVE_INFO(UParticleSystemComponent) GEngineUParticleSystemComponentNatives[] = 
{ 
	MAP_NATIVE(UParticleSystemComponent,execResetToDefaults)
	MAP_NATIVE(UParticleSystemComponent,execSetActive)
	MAP_NATIVE(UParticleSystemComponent,execClearParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetMaterialParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetActorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetColorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent,execGetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execGetLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetLODLevel)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetStrength)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetTangent)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTargetPoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourceStrength)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourceTangent)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamSourcePoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamDistance)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamEndPoint)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamTessellationFactor)
	MAP_NATIVE(UParticleSystemComponent,execSetBeamType)
	MAP_NATIVE(UParticleSystemComponent,execRewindEmitterInstances)
	MAP_NATIVE(UParticleSystemComponent,execRewindEmitterInstance)
	MAP_NATIVE(UParticleSystemComponent,execSetKillOnCompleted)
	MAP_NATIVE(UParticleSystemComponent,execSetKillOnDeactivate)
	MAP_NATIVE(UParticleSystemComponent,execGetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent,execSetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent,execKillParticlesForced)
	MAP_NATIVE(UParticleSystemComponent,execDeactivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execActivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UParticleSystemComponent);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatParticleParameter)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorParticleParameter)
VERIFY_CLASS_OFFSET_NODIE(A,Emitter,ParticleSystemComponent)
VERIFY_CLASS_SIZE_NODIE(AEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleBeam2EmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleBeamEmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleDataManager)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleEmitter,InitialAllocationCount)
VERIFY_CLASS_SIZE_NODIE(UParticleEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleEmitterInstance)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleLODLevel,Level)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleLODLevel,PeakActiveParticles)
VERIFY_CLASS_SIZE_NODIE(UParticleLODLevel)
VERIFY_CLASS_SIZE_NODIE(UParticleMeshEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleMeshEmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleMeshNxFluidEmitterInstance)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModule,ModuleEditorColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModule)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAcceleration,Acceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAcceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAccelerationOverLifetime,AccelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorLine,EndPoint0)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorLine,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorLine)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorParticle,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorParticle,LastSelIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorParticle)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorPoint,Position)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleAttractorPoint,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorPoint)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamModifier,ModifierType)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamModifier,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamModifier)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamNoise,Frequency)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamNoise,NoiseScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamNoise)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamSource,SourceStrength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamSource)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamTarget,TargetMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleBeamTarget,LockRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamTarget)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleCollision,DampingFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleCollision,DelayAmount)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollision)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollisionBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColor,StartColor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColor,StartAlpha)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorByParameter,ColorParam)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorByParameter,DefaultColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorByParameter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorOverLife,ColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorOverLife,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorScaleOverLife,ColorScaleOverLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleColorScaleOverLife,AlphaScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillBox,LowerLeftCorner)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillBox,UpperRightCorner)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBox)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleKillHeight,Height)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillHeight)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLifetime,Lifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetimeBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocation,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationDirect,Location)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationDirect,Direction)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitter,InheritSourceRotationScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationEmitterDirect,EmitterName)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitterDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveBase,VelocityScale)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveBase,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveCylinder,StartRadius)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveCylinder,HeightAxis)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveCylinder)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleLocationPrimitiveSphere,StartRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveSphere)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMaterialByParameter,MaterialParameters)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMaterialByParameter,DefaultMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialByParameter)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshMaterial,MeshMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotation)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRate)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleMeshRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRateMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrbit,ChainMode)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrbit,RotationRateOptions)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbit)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbitBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleOrientationAxisLock,LockAxisFlags)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationAxisLock)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRequired,Material)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRequired,EmitterEditorColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRequired)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationOverLifetime,RotationOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationOverLifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSize,StartSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeMultiplyVelocity,VelocityMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSizeScale,SizeScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawnPerUnit,UnitScalar)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSpawnPerUnit,MovementTolerance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnPerUnit)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUV,SubImageIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUV)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVDirect,SubUVPosition)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVDirect,SubUVSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVDirect)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleSubUVSelect,SubImageSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSource,SourceOffsetDefaults)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSource)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSpawn,SpawnMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailSpawn,MinSpawnVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSpawn)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailTaper,TaperMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTrailTaper,TaperFactor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailTaper)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam,TextureTile)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam2,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataBeam2,TaperScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam2)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMesh,Mesh)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMesh,MeshAlignment)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMesh)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMeshNxFluid,PhysXFluid)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataMeshNxFluid,FluidRotationCoefficient)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMeshNxFluid)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataNxFluid,PhysXFluid)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataNxFluid)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataSubUV,SubImages_Horizontal)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataSubUV,InterpolationMethod)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataSubUV)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail,SpawnDistance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail2,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleTypeDataTrail2,MaxParticleInTrailCount)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail2)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberBase,RequiredModules)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCL,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCL)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLIL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLIL,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLIL)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLILIRSSBLIRR,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberLTISIVCLILIRSSBLIRR,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLILIRSSBLIRR)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainDrops,LifetimeMin)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainDrops,StartLocationMax)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainDrops)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainImpacts,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainImpacts,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainImpacts)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashA,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashA,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashA)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashB,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleUberRainSplashB,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashB)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocity,StartVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocity,StartVelocityRadial)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityBase)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocityInheritParent,Scale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityInheritParent)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleModuleVelocityOverLifetime,VelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityOverLifetime)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSpriteEmitter,ScreenAlignment)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSpriteEmitter,Material)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteEmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteNxFluidEmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteSubUVEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteSubUVEmitterInstance)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystem,SystemUpdateMode)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystem,ThumbnailImage)
VERIFY_CLASS_SIZE_NODIE(UParticleSystem)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemComponent,Template)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemComponent,__OnSystemFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemComponent)
VERIFY_CLASS_SIZE_NODIE(UParticleTrail2EmitterInstance)
VERIFY_CLASS_SIZE_NODIE(UParticleTrailEmitterInstance)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
