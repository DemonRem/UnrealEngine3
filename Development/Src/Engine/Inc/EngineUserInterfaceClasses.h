/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "EngineUserInterfaceGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_USERINTERFACE_ENUMS
#define INCLUDED_ENGINE_USERINTERFACE_ENUMS 1

enum ERotationAnchor
{
    RA_Absolute             =0,
    RA_Center               =1,
    RA_PivotLeft            =2,
    RA_PivotRight           =3,
    RA_PivotTop             =4,
    RA_PivotBottom          =5,
    RA_UpperLeft            =6,
    RA_UpperRight           =7,
    RA_LowerLeft            =8,
    RA_LowerRight           =9,
    RA_MAX                  =10,
};
enum EUIDataProviderFieldType
{
    DATATYPE_Property       =0,
    DATATYPE_Provider       =1,
    DATATYPE_RangeProperty  =2,
    DATATYPE_Collection     =3,
    DATATYPE_ProviderCollection=4,
    DATATYPE_MAX            =5,
};
enum ESplitscreenRenderMode
{
    SPLITRENDER_Fullscreen  =0,
    SPLITRENDER_PlayerOwner =1,
    SPLITRENDER_MAX         =2,
};
enum EScreenInputMode
{
    INPUTMODE_None          =0,
    INPUTMODE_Locked        =1,
    INPUTMODE_MatchingOnly  =2,
    INPUTMODE_ActiveOnly    =3,
    INPUTMODE_Free          =4,
    INPUTMODE_Simultaneous  =5,
    INPUTMODE_MAX           =6,
};
enum ENavigationLinkType
{
    NAVLINK_Automatic       =0,
    NAVLINK_Manual          =1,
    NAVLINK_MAX             =2,
};
enum EUIDefaultPenColor
{
    UIPEN_White             =0,
    UIPEN_Black             =1,
    UIPEN_Grey              =2,
    UIPEN_MAX               =3,
};
enum EUIAspectRatioConstraint
{
    UIASPECTRATIO_AdjustNone=0,
    UIASPECTRATIO_AdjustWidth=1,
    UIASPECTRATIO_AdjustHeight=2,
    UIASPECTRATIO_MAX       =3,
};
enum EUIWidgetFace
{
    UIFACE_Left             =0,
    UIFACE_Top              =1,
    UIFACE_Right            =2,
    UIFACE_Bottom           =3,
    UIFACE_MAX              =4,
};
enum EUIOrientation
{
    UIORIENT_Horizontal     =0,
    UIORIENT_Vertical       =1,
    UIORIENT_MAX            =2,
};
enum EUIListElementState
{
    ELEMENT_Normal          =0,
    ELEMENT_Active          =1,
    ELEMENT_Selected        =2,
    ELEMENT_UnderCursor     =3,
    ELEMENT_MAX             =4,
};
enum EUIAlignment
{
    UIALIGN_Left            =0,
    UIALIGN_Center          =1,
    UIALIGN_Right           =2,
    UIALIGN_Default         =3,
    UIALIGN_MAX             =4,
};
enum ETextAutoScaleMode
{
    UIAUTOSCALE_None        =0,
    UIAUTOSCALE_Normal      =1,
    UIAUTOSCALE_Justified   =2,
    UIAUTOSCALE_MAX         =3,
};
enum ETextClipMode
{
    CLIP_None               =0,
    CLIP_Normal             =1,
    CLIP_Ellipsis           =2,
    CLIP_Wrap               =3,
    CLIP_MAX                =4,
};
enum EUIAutoSizeConstraintType
{
    UIAUTOSIZEREGION_Minimum=0,
    UIAUTOSIZEREGION_Maximum=1,
    UIAUTOSIZEREGION_MAX    =2,
};
enum EUIDockPaddingEvalType
{
    UIPADDINGEVAL_Pixels    =0,
    UIPADDINGEVAL_PercentTarget=1,
    UIPADDINGEVAL_PercentOwner=2,
    UIPADDINGEVAL_PercentScene=3,
    UIPADDINGEVAL_PercentViewport=4,
    UIPADDINGEVAL_MAX       =5,
};
enum EUIExtentEvalType
{
    UIEXTENTEVAL_Pixels     =0,
    UIEXTENTEVAL_PercentOwner=1,
    UIEXTENTEVAL_PercentScene=2,
    UIEXTENTEVAL_PercentViewport=3,
    UIEXTENTEVAL_MAX        =4,
};
enum EPositionEvalType
{
    EVALPOS_None            =0,
    EVALPOS_PixelViewport   =1,
    EVALPOS_PixelScene      =2,
    EVALPOS_PixelOwner      =3,
    EVALPOS_PercentageViewport=4,
    EVALPOS_PercentageOwner =5,
    EVALPOS_PercentageScene =6,
    EVALPOS_MAX             =7,
};
enum EMaterialAdjustmentType
{
    ADJUST_None             =0,
    ADJUST_Normal           =1,
    ADJUST_Bound            =2,
    ADJUST_Stretch          =3,
    ADJUST_MAX              =4,
};
enum EUIAnimNotifyType
{
    EANT_WidgetFunction     =0,
    EANT_SceneFunction      =1,
    EANT_KismetEvent        =2,
    EANT_Sound              =3,
    EANT_MAX                =4,
};
enum EUIAnimType
{
    EAT_None                =0,
    EAT_Position            =1,
    EAT_RelPosition         =2,
    EAT_Rotation            =3,
    EAT_RelRotation         =4,
    EAT_Color               =5,
    EAT_Opacity             =6,
    EAT_Visibility          =7,
    EAT_Scale               =8,
    EAT_Notify              =9,
    EAT_MAX                 =10,
};

#endif // !INCLUDED_ENGINE_USERINTERFACE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(ActivateState)
AUTOGENERATE_NAME(DeactivateState)
AUTOGENERATE_NAME(GetDefaultStyle)
AUTOGENERATE_NAME(IsStateAllowed)
AUTOGENERATE_NAME(IsWidgetClassSupported)
AUTOGENERATE_NAME(OnActivate)
AUTOGENERATE_NAME(OnDeactivate)
AUTOGENERATE_NAME(OnInitialize)
AUTOGENERATE_NAME(OnReceivedNativeInputAxis)
AUTOGENERATE_NAME(OnReceivedNativeInputChar)
AUTOGENERATE_NAME(OnReceivedNativeInputKey)
AUTOGENERATE_NAME(OutputText)
AUTOGENERATE_NAME(PlayerInput)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_USERINTERFACE_CLASSES
#define INCLUDED_ENGINE_USERINTERFACE_CLASSES 1

struct FWIDGET_ID : public FGuid
{

	FWIDGET_ID()
	: FGuid()
	{ }

	FWIDGET_ID(EEventParm)
	: FGuid(0,0,0,0)
	{}

	FWIDGET_ID( const FGuid& Other )
	: FGuid(Other)
	{ }

};

struct FSTYLE_ID : public FGuid
{

	FSTYLE_ID()
	: FGuid()
	{ }

	FSTYLE_ID(EEventParm)
	: FGuid(0,0,0,0)
	{}

	FSTYLE_ID( const FGuid& Other )
	: FGuid(Other)
	{ }

};

struct FUIRangeData
{
private:
    FLOAT CurrentValue;
public:
    FLOAT MinValue;
    FLOAT MaxValue;
private:
    FLOAT NudgeValue;
public:
    BITFIELD bIntRange:1;

	/** Constructors */
	FUIRangeData() {}
	FUIRangeData(EEventParm)
	: CurrentValue(0.f), MinValue(0.f), MaxValue(0.f), NudgeValue(0.f), bIntRange(FALSE)
	{}

	FUIRangeData( const FUIRangeData& Other )
	: CurrentValue(Other.CurrentValue)
	, MinValue(Other.MinValue), MaxValue(Other.MaxValue)
	, NudgeValue(Other.NudgeValue), bIntRange(Other.bIntRange)
	{}

	/**
	 * Returns true if any values in this struct are non-zero.
	 */
	UBOOL HasValue() const;

	/**
	 * Returns the amount that this range should be incremented/decremented when nudging.
	 */
	FLOAT GetNudgeValue() const;

	/**
	 * Sets the NudgeValue for this UIRangeData to the value specified.
	 */
	void SetNudgeValue( FLOAT NewNudgeValue )
	{
		NudgeValue = NewNudgeValue;
	}

	/**
	 * Returns the current value of this UIRange.
	 */
	FLOAT GetCurrentValue() const;

	/**
	 * Sets the value of this UIRange.
	 *
	 * @param	NewValue				the new value to assign to this UIRange.
	 * @param	bClampInvalidValues		specify TRUE to automatically clamp NewValue to a valid value for this UIRange.
	 *
	 * @return	TRUE if the value was successfully assigned.  FALSE if NewValue was outside the valid range and
	 *			bClampInvalidValues was FALSE or MinValue <= MaxValue.
	 */
	UBOOL SetCurrentValue( FLOAT NewValue, UBOOL bClampInvalidValues=TRUE );

};

struct FUIProviderScriptFieldValue
{
    FName PropertyTag;
    BYTE PropertyType;
    FStringNoInit StringValue;
    class USurface* ImageValue;
    TArrayNoInit<INT> ArrayValue;
    struct FUIRangeData RangeValue;

	/** Constructors */
	FUIProviderScriptFieldValue() {}
	FUIProviderScriptFieldValue(EEventParm)
	{
		appMemzero(this, sizeof(FUIProviderScriptFieldValue));
	}

    /** Copy constructor */
    FUIProviderScriptFieldValue( const FUIProviderScriptFieldValue& Other )
    : PropertyTag(Other.PropertyTag)
    , PropertyType(Other.PropertyType)
    , StringValue(Other.StringValue)
    , ImageValue(Other.ImageValue)
    , ArrayValue(Other.ArrayValue)
    , RangeValue(Other.RangeValue)
    {}

    /**
     * Returns true if this field value has been assigned.
     */
    UBOOL HasValue() const;

};

struct FUIProviderFieldValue : public FUIProviderScriptFieldValue
{
    struct FUIStringNode* CustomStringNode;

	/** Constructor */
	FUIProviderFieldValue()
	: FUIProviderScriptFieldValue(), CustomStringNode(NULL)
	{ }
	FUIProviderFieldValue(EEventParm)
	: FUIProviderScriptFieldValue(EC_EventParm), CustomStringNode(NULL)
	{ }

	/** Copy constructor */
	FUIProviderFieldValue( const FUIProviderFieldValue& Other )
	: FUIProviderScriptFieldValue( (const FUIProviderScriptFieldValue&)Other ), CustomStringNode(Other.CustomStringNode)
	{ }

	FUIProviderFieldValue( const FUIProviderScriptFieldValue& Other )
	: FUIProviderScriptFieldValue(Other), CustomStringNode(NULL)
	{ }

};

struct FUIStyleReference
{
    FName DefaultStyleTag;
    class UClass* RequiredStyleClass;
    struct FSTYLE_ID AssignedStyleID;
private:
    class UUIStyle* ResolvedStyle;
public:

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FUIStyleReference();
	/** Initialization constructor - zero initialize all members */
	FUIStyleReference(EEventParm);

	/**
	 * Clears the value for the resolved style.  Called whenever the resolved style is no longer valid, such as when the
	 * active skin has been changed.
	 */
	void InvalidateResolvedStyle();

	/**
	 * Returns the value of ResolvedStyle, optionally resolving the style reference from the currently active skin.
	 *
	 * @param	CurrentlyActiveSkin		if specified, will call ResolveStyleReference if the current value for ResolvedStyle is not valid
	 *									for the active skin (i.e. if ResolvedStyle is NULL or isn't contained by the active skin)
	 * @param	ResolvedStyleChanged	if specified, will be set to TRUE if the value for ResolvedStyle was changed during this call
	 *									to GetResolvedStyle()
	 *
	 * @return	a pointer to the UIStyle object that has been resolved from the style id and/or default style type for this
	 *			style reference.
	 */
	class UUIStyle* GetResolvedStyle( class UUISkin* CurrentlyActiveSkin=NULL, UBOOL* bResolvedStyleChanged=NULL );

	/**
	 * Resolves the style id or default style tag for this style reference into a UIStyle from the currently active skin, and assigns the result
	 * to ResolvedStyle
	 *
	 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
	 *
	 * @return	TRUE if the style reference was successfully resolved
	 */
	UBOOL ResolveStyleReference( class UUISkin* CurrentlyActiveSkin );

	/**
	 * Resolves the style id or default style tag for this UIStyleReference and returns the result.
	 *
	 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
	 *
	 * @return	a pointer to the UIStyle object resolved from the specified skin
	 */
	class UUIStyle* ResolveStyleFromSkin( class UUISkin* CurrentlyActiveSkin ) const;

	/**
	 * Determines whether the specified style is a valid style for this style reference, taking into account the RequiredStyleClass.
	 *
	 * @param	StyleToCheck	a pointer to a UIStyle with a valid StyleID.
	 * @param	bAllowNULLStyle	indicates whether a NULL value for StyleToCheck should be considered valid.
	 *
	 * @return	TRUE if the specified style is the right type for this style reference, or if StyleToCheck is NULL (it is always
	 *			valid to assign NULL styles to a style reference) and bAllowNULLStyle is TRUE.
	 */
	UBOOL IsValidStyle( class UUIStyle* StyleToCheck, UBOOL bAllowNULLStyle=TRUE ) const;

	/**
	 * Determines whether the specified style corresonds to the default style for this style reference.
	 *
	 * @param	StyleToCheck	a pointer to a UIStyle
	 *
	 * @return	TRUE if StyleToCheck is the same style that would be resolved by this style reference if it didn't have
	 *			a valid AssignedStyleId
	 */
	UBOOL IsDefaultStyle( class UUIStyle* StyleToCheck ) const;

	/**
	 * Returns the tag for the default style associated with this UIStyleReference.
	 *
	 * @param	CurrentlyActiveSkin		the skin to search for this style references' style tag in
	 * @param	bSkinContainsStyleTag	if specified, set to TRUE if CurrentlyActiveSkin contains this style reference's
	 *									DefaultStyleTag; useful for determining whether a result of e.g. "DefaultTextStyle" is
	 *									because the active skin didn't contain the style corresponding to this reference's DefaultStyleTag,
	 *									or whether this style reference's DefaultStyleTag is actually "DefaultTextStyle"
	 *
	 * @return	if DefaultStyleTag is set and a style with that tag exists in CurrentlyActiveSkin, returns that
	 *			style's tag; otherwise returns the tag for the default style corresponding to RequiredStyleClass.
	 */
	FName GetDefaultStyleTag( class UUISkin* CurrentlyActiveSkin, UBOOL* bSkinContainsStyleTag=NULL ) const;

	/**
	 * Returns the style data for the menu state specified.
	 */
	class UUIStyle_Data* GetStyleData( class UUIState* MenuState ) const;

	/**
	 * Returns the style data for the menu state specified.
	 */
	class UUIStyle_Data* GetStyleDataByClass( class UClass* MenuState ) const;

	/**
	 * Changes the style associated with this style refrerence.
	 *
	 * @param	NewStyle	the new style to assign to this style reference
	 *
	 * @return	TRUE if the style was successfully assigned to this reference.  FALSE if the specified style was invalid
	 *			or the currently assigned style matched the new style.
	 */
	UBOOL SetStyle( class UUIStyle* NewStyle );

	/**
	 * Changes the AssignedStyleID for this style reference
	 *
	 * @param	NewStyleID	the STYLE_ID for the UIStyle to link this style reference to
	 *
	 * @return	TRUE if the AssignedStyleId was changed.  FALSE if NewStyleID matched the value of AssignedStyleID.
	 */
	UBOOL SetStyleID( const struct FSTYLE_ID& NewStyleID );


};

struct FUIScreenValue
{
    FLOAT Value;
    BYTE ScaleType;
    BYTE Orientation;

	/**
	 * Calculates the origin and extent for the position value of a single widget face
	 *
	 * @param	OwnerWidget			the widget that owns this position
	 * @param	Face				the face to evaluate
	 * @param	Type				indicates how the base values will be used, how they should be formatted
	 * @param	BaseValue			[out] absolute pixel values for the base of this position for the specified face.  For example,
	 *								if the Face is UIFACE_Left, BaseValue will represent the X position of the OwnerWidget's container,
	 *								in absolute pixel values
	 * @param	bInternalPosition	specify TRUE to indicate that BaseValue should come from OwnerWidget; FALSE to indicate that BaseValue should come from
	 *								OwnerWidget's parent widget.
	 * @param	bIgnoreDockPadding	used to prevent recursion when evaluting docking links
	 */
	static void CalculateBaseValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType Type, FLOAT& BaseValue, FLOAT& BaseExtent, UBOOL bInternalPosition=FALSE, UBOOL bIgnoreDockPadding=FALSE );

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 * @param	bInternalPosition
	 *						specify TRUE if this UIScreenValue represents a point or distance inside of OwnerWidget, in which case any
	 *						relative scale types will use OwnerWidget as the base.  Specify FALSE if it represents a point/distance outside
	 *						OwnerWidget, in which case OwnerWidget's parent will be used as a base.
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
	 */
	FLOAT GetValue( const class UUIScreenObject* OwnerWidget, EPositionEvalType OutputType=EVALPOS_None, UBOOL bInternalPosition=TRUE ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 */
	void SetValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

	/**
	 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
	 *
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the evaluation type to set for the specified face
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( class UUIScreenObject* OwnerWidget, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Constructors
	 */
	FUIScreenValue()
	{ }

	FUIScreenValue(EEventParm)
	{
		Value = 0.f;
		ScaleType = EVALPOS_PixelViewport;
	}

	FUIScreenValue( FLOAT inValue, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(EVALPOS_None), Orientation(inOrientation)
	{ }

	FUIScreenValue( FLOAT inValue, EPositionEvalType inScaleType, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(inScaleType), Orientation(inOrientation)
	{ }

};

struct FUIScreenValue_Extent
{
    FLOAT Value;
    BYTE ScaleType;
    BYTE Orientation;

	/**
	 * Calculates the extent to use as the base for evaluating percentage values.
	 *
	 * @param	OwnerWidget		the widget that contains this extent value
	 * @param	EvaluationType	indicates which base to use for calculating the base extent
	 * @param	BaseExtent		[out] set to the size of the region that will be used for evaluating this extent as a percentage; actual pixels
	 */
	void CalculateBaseExtent( const class UUIScreenObject* OwnerWidget, EUIExtentEvalType EvalType, FLOAT& BaseExtent ) const;

	/**
	 * Resolves the value stored in this extent according to the specified output type.
	 *
	 * @param	OwnerWidget		the widget that contains this extent value
	 * @param	OutputType	indicates the desired format for the result
	 *						UIEXTENTEVAL_Pixels:
	 *							Result should be the actual number of pixels
	 *						UIEXTENTEVAL_PercentOwner:
	 *							result should be formatted as a percentage of the widget's parent
	 *						UIEXTENTEVAL_PercentScene:
	 *							result should be formatted as a percentage of the scene
	 *						UIEXTENTEVAL_PercentViewport:
	 *							result should be formatted as a percentage of the viewport
	 *
	 * @return	the value of the auto-size region's min or max value
	 */
	FLOAT GetValue( const class UUIScreenObject* OwnerWidget, EUIExtentEvalType OutputType=UIEXTENTEVAL_Pixels ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	OwnerWidget	the widget that contains this extent value
	 * @param	NewValue	the new value (in pixels or percentage) to use
	 * @param	OutputType	specifies how NewValue should be interpreted format for the result
	 *						UIEXTENTEVAL_Pixels:
	 *							NewValue is in absolute pixels
	 *						UIEXTENTEVAL_PercentOwner:
	 *							NewValue is a percentage of the OwnerWidget
	 *						UIEXTENTEVAL_PercentScene:
	 *							NewValue is a percentage of the scene
	 *						UIEXTENTEVAL_PercentViewport:
	 *							NewValue is a percentage of the viewport
	 */
	void SetValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIExtentEvalType InputType=UIEXTENTEVAL_Pixels );

	/**
	 * Changes the scale type for this extent to the type specified, optionally converting the current Value into the new type.
	 *
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the new evaluation type to ise
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( class UUIScreenObject* OwnerWidget, EUIExtentEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Constructors
	 */
	FUIScreenValue_Extent()
	{ }

	FUIScreenValue_Extent(EEventParm)
	{
		Value = 0.f;
		ScaleType = UIEXTENTEVAL_Pixels;
		Orientation = UIORIENT_Horizontal;
	}

	FUIScreenValue_Extent( FLOAT inValue, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(UIEXTENTEVAL_Pixels), Orientation(inOrientation)
	{ }

	FUIScreenValue_Extent( FLOAT inValue, EUIExtentEvalType inScaleType, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(inScaleType), Orientation(inOrientation)
	{ }

	/** @name Comparison operators */
	//@{
	UBOOL operator==( const FUIScreenValue_Extent& Other ) const
	{
		return	Value		== Other.Value
			&&	ScaleType	== Other.ScaleType
			&&	Orientation	== Other.Orientation;
	}
	UBOOL operator!=( const FUIScreenValue_Extent& Other ) const
	{
		return	Value		!= Other.Value
			||	ScaleType	!= Other.ScaleType
			||	Orientation	!= Other.Orientation;
	}
	//@}

};

struct FUIScreenValue_Position
{
    FLOAT Value[2];
    BYTE ScaleType[2];

	/**
	 * Evaluates the value stored in this UIScreenValue. It assumes that a Dimension of UIORIENT_Horizontal will correspond to the Left face and
	 * that a Dinemsion of UIORIENT_Vertical will correspond to the Right face.
	 *
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner:
	 *							EVALPOS_PixelScene:
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	OwnerWidget		the widget that contains this screen value
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
	 */
	FLOAT GetValue( EUIOrientation Dimension, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	Face			indicates which face on the owner widget the element from the Value array will be relative to (if InputType is
	 *							applicable ).
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner:
	 *							EVALPOS_PixelScene:
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	OwnerWidget		the widget that contains this screen value
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
	 */
	FLOAT GetValue( EUIOrientation Dimension, EUIWidgetFace Face, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 */
	void SetValue( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

	/** Constructors */
	FUIScreenValue_Position()
	{
		// do not initialize any members in the default constructor
	}
	FUIScreenValue_Position(EEventParm)
	{
		Value[UIORIENT_Horizontal] = 0.f;
		Value[UIORIENT_Vertical] = 0.f;
		ScaleType[UIORIENT_Horizontal] = EVALPOS_PixelOwner;
		ScaleType[UIORIENT_Vertical] = EVALPOS_PixelOwner;
	}
	FUIScreenValue_Position( FLOAT XValue, FLOAT YValue )
	{
		Value[UIORIENT_Horizontal]	=	XValue;
		Value[UIORIENT_Vertical]	=	YValue;
		for ( INT i = 0; i < UIORIENT_MAX; i++ )
		{
			ScaleType[i] = EVALPOS_None;
		}
	}
	FUIScreenValue_Position( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
	{
		Value[UIORIENT_Horizontal]		=	XValue;
		Value[UIORIENT_Vertical]		=	YValue;

		ScaleType[UIORIENT_Horizontal]	=	XScaleType;
		ScaleType[UIORIENT_Vertical]	=	YScaleType;
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIScreenValue_Position& Other ) const
	{
		return	Other.Value[UIORIENT_Horizontal]		== Value[UIORIENT_Horizontal]
			&&	Other.Value[UIORIENT_Vertical]			== Value[UIORIENT_Vertical]
			&&	Other.ScaleType[UIORIENT_Horizontal]	== ScaleType[UIORIENT_Horizontal]
			&&	Other.ScaleType[UIORIENT_Vertical]		== ScaleType[UIORIENT_Vertical];
	}
	FORCEINLINE UBOOL operator!=( const FUIScreenValue_Position& Other ) const
	{
		return	Other.Value[UIORIENT_Horizontal]		!= Value[UIORIENT_Horizontal]
			||	Other.Value[UIORIENT_Vertical]			!= Value[UIORIENT_Vertical]
			||	Other.ScaleType[UIORIENT_Horizontal]	!= ScaleType[UIORIENT_Horizontal]
			||	Other.ScaleType[UIORIENT_Vertical]		!= ScaleType[UIORIENT_Vertical];
	}

};

struct FUIScreenValue_Bounds
{
private:
    FLOAT Value[4];
    BYTE ScaleType[4];
    BYTE bInvalidated[4];
    BYTE AspectRatioMode;
public:

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	Face		indicates which element of the Value array to evaluate
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 * @param	bIgnoreDockPadding
	 *						used to prevent recursion when evaluting docking links
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
	 */
	FLOAT GetPositionValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType OutputType=EVALPOS_None, UBOOL bIgnoreDockPadding=FALSE ) const;


	/**
	 * Convert the value specified into the appropriate type for this screen value, and set that as the value for the face specified.
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	Face			indicates which element of the Value array to modify
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bResolveChange	indicates whether a scene update should be requested if NewValue does not match the current value.
	 */
	void SetPositionValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIWidgetFace Face, EPositionEvalType InputType=EVALPOS_PixelOwner, UBOOL bResolveChange=TRUE );

	/**
	 * Retrieves the value of the width or height of this widget's bounds.
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	Dimension	determines whether width or height is desired.  Specify UIORIENT_Horizontal to get the width, or UIORIENT_Vertical to get the height.
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 * @param	bIgnoreDockPadding
	 *						used to prevent recursion when evaluting docking links
	 *
	 * @return	the value of the width/height of this UIScreenValue, in pixels or percentage.
	 */
	FLOAT GetBoundsExtent( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, EPositionEvalType OutputType=EVALPOS_PixelOwner, UBOOL bIgnoreDockPadding=FALSE ) const;

	/**
	 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
	 *
	 * @param	Face				indicates which element of the Value array to modify
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the evaluation type to set for the specified face
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Returns the ScaleType for the specified face.
	 *
	 * @param	Face	indicates which element of the ScaleType array to return.
	 *
	 * @return	the current value of ScaleType for the specified face.
	 */
	FORCEINLINE EPositionEvalType GetScaleType( EUIWidgetFace Face ) const
	{
		checkSlow(Face<UIFACE_MAX);
		return (EPositionEvalType)ScaleType[Face];
	}

	/**
	 * Changes the value for the specified face without performing any conversion.
	 *
	 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	NewScaleType	if specified, modified the ScaleType for this face as well.
	 */
	void SetRawPositionValue( BYTE Face, FLOAT NewValue, EPositionEvalType NewScaleType=EVALPOS_None );

	/**
	 * Changes the ScaleType for the specified face without performing any conversion.
	 *
	 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
	 * @param	NewScaleType	the new scale type to use.
	 */
	void SetRawScaleType( BYTE Face, EPositionEvalType NewScaleType );

	/**
	 * Changes the AspectRatioMode for this screen value.
	 *
	 * @param	NewAspectRatioMode	the new aspect ratio mode; must be one of the EUIAspectRatioConstraint values.
	 */
	void SetAspectRatioMode( BYTE NewAspectRatioMode );

	/**
	 * Gets the current AspectRatioMode for this screen value.
	 */
	EUIAspectRatioConstraint GetAspectRatioMode() const
	{
		return (EUIAspectRatioConstraint)AspectRatioMode;
	}

	/**
	 * Toggles the bInvalidated flag for the specified face.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	FORCEINLINE void ValidatePosition( BYTE Face )
	{
		checkSlow(Face<UIFACE_MAX);
		bInvalidated[Face] = FALSE;
	}
	FORCEINLINE void InvalidatePosition( BYTE Face )
	{
		checkSlow(Face<UIFACE_MAX);
		bInvalidated[Face] = TRUE;
	}
	FORCEINLINE void InvalidateAllFaces()
	{
		bInvalidated[UIFACE_Left] = TRUE;
		bInvalidated[UIFACE_Top] = TRUE;
		bInvalidated[UIFACE_Right] = TRUE;
		bInvalidated[UIFACE_Bottom] = TRUE;
	}

	/**
	 * Returns whether the Value for the specified face has been modified since that face was last resolved.
	 *
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	UBOOL IsPositionCurrent( const class UUIObject* OwnerWidget, EUIWidgetFace Face ) const;

	/** @name Constructors */
	//@{
	FUIScreenValue_Bounds()
	{
		// do not initialize any members in the default constructor
	}
	FUIScreenValue_Bounds( EEventParm )
	{
		// zero-initialization ctor
		appMemzero(this, sizeof(FUIScreenValue_Bounds));
	}
	FUIScreenValue_Bounds( FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue )
	{
		Value[UIFACE_Left]		=	LeftValue;
		Value[UIFACE_Top]		=	RightValue;
		Value[UIFACE_Right]		=	LeftValue;
		Value[UIFACE_Bottom]	=	RightValue;

		for ( INT i = 0; i < UIFACE_MAX; i++ )
		{
			ScaleType[i] = EVALPOS_None;
			bInvalidated[i] = TRUE;
		}
		AspectRatioMode = UIASPECTRATIO_AdjustNone;
	}
	FUIScreenValue_Bounds
	(
		FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue,
		EPositionEvalType LeftScaleType, EPositionEvalType TopScaleType, EPositionEvalType RightScaleType, EPositionEvalType BottomScaleType
	)
	{
		Value[UIFACE_Left]			=	LeftValue;
		Value[UIFACE_Top]			=	RightValue;
		Value[UIFACE_Right]			=	LeftValue;
		Value[UIFACE_Bottom]		=	RightValue;
		ScaleType[UIFACE_Left]		=	LeftScaleType;
		ScaleType[UIFACE_Top]		=	TopScaleType;
		ScaleType[UIFACE_Right]		=	RightScaleType;
		ScaleType[UIFACE_Bottom]	=	BottomScaleType;
		for ( INT i = 0; i < UIFACE_MAX; i++ )
		{
			bInvalidated[i] = TRUE;
		}

		AspectRatioMode = UIASPECTRATIO_AdjustNone;
	}
	//@}

	/** @name Comparison operators */
	//@{
	UBOOL operator==( const FUIScreenValue_Bounds& Other ) const
	{
		return	AspectRatioMode == Other.AspectRatioMode
			&&	appMemcmp(Value, Other.Value, sizeof(Value)) == 0
			&&	appMemcmp(ScaleType, Other.ScaleType, sizeof(ScaleType)) == 0
			&&	appMemcmp(bInvalidated, Other.bInvalidated, sizeof(bInvalidated)) == 0;
	}
	UBOOL operator!=( const FUIScreenValue_Bounds& Other ) const
	{
		return !(FUIScreenValue_Bounds::operator==(Other));
	}
	//@}

};

struct FUIAnchorPosition : public FUIScreenValue_Position
{
    FLOAT ZDepth;

	/** Constructors */
	FUIAnchorPosition()
	{
		// do not initialize any members in the default constructor
	}
	FUIAnchorPosition(EEventParm)
	: FUIScreenValue_Position(EC_EventParm), ZDepth(0.f)
	{ }
	FUIAnchorPosition(FLOAT XValue, FLOAT YValue)
	: FUIScreenValue_Position(XValue, YValue), ZDepth(0.f)
	{ }
	FUIAnchorPosition(FLOAT XValue, FLOAT YValue, FLOAT InZDepth)
	: FUIScreenValue_Position(XValue, YValue), ZDepth(InZDepth)
	{ }
	FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
	: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(0.f)
	{ }
	FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType, FLOAT InZDepth )
	: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(InZDepth)
	{ }

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIAnchorPosition& Other ) const
	{
		return (Abs(ZDepth - Other.ZDepth) <= SMALL_NUMBER)
			&& FUIScreenValue_Position::operator==((const FUIScreenValue_Position&)Other);
	}
	FORCEINLINE UBOOL operator!=( const FUIAnchorPosition& Other ) const
	{
		return (Abs(ZDepth - Other.ZDepth) > SMALL_NUMBER)
			|| FUIScreenValue_Position::operator!=((const FUIScreenValue_Position&)Other);
	}

};

struct FScreenPositionRange : public FUIScreenValue_Position
{

	/**
	 * Retrieves the value of the distance between the endpoints of this region
	 *
	 * @param	Dimension	indicates which element of the Value array to evaluate
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:	(only valid when OwnerWidget is specified)
	 *						EVALPOS_PercentageScene:	(only valid when OwnerWidget is specified)
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner:			(only valid when OwnerWidget is specified)
	 *						EVALPOS_PixelScene:			(only valid when OwnerWidget is specified)
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 * @param	OwnerWidget	the widget that contains this screen value
	 *
	 * @return	the value of the width of this UIScreenValue, in pixels or percentage.
	 */
	FLOAT GetRegionValue( EUIOrientation Dimension, EPositionEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

	/** Comparison */
	UBOOL operator ==( const FScreenPositionRange& Other ) const;
	UBOOL operator !=( const FScreenPositionRange& Other ) const;

};

struct FUIScreenValue_DockPadding
{
private:
    FLOAT PaddingValue[4];
    BYTE PaddingScaleType[4];
public:

	/**
	 * Calculates the size of the base region used for formatting the padding value of a single widget face
	 *
	 * @param	OwnerWidget			the widget that owns this padding
	 * @param	EvalFace			the face to evaluate
	 * @param	EvalType			indicates which type of base value is desired
	 * @param	BaseExtent			[out] the base extent for the specified face, in absolute pixel values.  BaseExtent is defined as the size of the widget associated with
	 *								the specified dock padding type and face's orientation.
	 */
	static void CalculateBaseExtent( const class UUIObject* OwnerWidget, EUIWidgetFace EvalFace, EUIDockPaddingEvalType EvalType, FLOAT& BaseExtent );

	/**
	 * Evaluates the value stored in this UIScreenValue_DockPadding
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	Face		indicates which element of the Value array to evaluate
	 * @param	OutputType	indicates the desired format for the result
	 *						UIPADDINGEVAL_Pixels:
	 *							Result should be the actual number of pixels
	 *						UIPADDINGEVAL_PercentTarget:
	 *							result should be formatted as a percentage of the dock target
	 *						UIPADDINGEVAL_PercentOwner:
	 *							result should be formatted as a percentage of the widget's parent
	 *						UIPADDINGEVAL_PercentScene:
	 *							result should be formatted as a percentage of the scene
	 *						UIPADDINGEVAL_PercentViewport:
	 *							result should be formatted as a percentage of the viewport
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
	 */
	FLOAT GetPaddingValue( const class UUIObject* OwnerWidget, EUIWidgetFace Face, EUIDockPaddingEvalType OutputType=UIPADDINGEVAL_Pixels ) const;


	/**
	 * Convert the value specified into the appropriate format and assign the converted value to the Value element for the face specified.
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	Face			indicates which element of the Value array to modify
	 * @param	InputType		indicates the desired format for the result
	 *							UIPADDINGEVAL_Pixels:
	 *								NewValue is in pixels
	 *							UIPADDINGEVAL_PercentTarget:
	 *								NewValue is a percentage of the dock target extent in the corresponding orientation
	 *							UIPADDINGEVAL_PercentOwner:
	 *								NewValue is a percentage of OwnerWidget parent's extent in the corresponding orientation
	 *							UIPADDINGEVAL_PercentScene:
	 *								NewValue is a percentage of the scene
	 *							UIPADDINGEVAL_PercentViewport:
	 *								NewValue is a percentage of the viewport.
	 * @param	bResolveChange	indicates whether a scene update should be requested if NewValue does not match the current value.
	 */
	void SetPaddingValue( class UUIObject* OwnerWidget, FLOAT NewValue, EUIWidgetFace Face, EUIDockPaddingEvalType InputType=UIPADDINGEVAL_Pixels, UBOOL bResolveChange=TRUE );

	/**
	 * Changes the scale type for the specified face to the value specified, optionally converting the Value for that face into the new type.
	 *
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	Face				indicates which element of the Value array to modify
	 * @param	NewEvalType			the evaluation type to set for the specified face
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangePaddingScaleType( class UUIObject* OwnerWidget, EUIWidgetFace Face, EUIDockPaddingEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Returns the PaddingScaleType for the specified face.
	 *
	 * @param	Face	indicates which element of the ScaleType array to return.
	 *
	 * @return	the current value of ScaleType for the specified face.
	 */
	FORCEINLINE EUIDockPaddingEvalType GetPaddingScaleType( EUIWidgetFace Face ) const
	{
		checkSlow(Face<UIFACE_MAX);
		return static_cast<EUIDockPaddingEvalType>(PaddingScaleType[Face]);
	}

	/** @name Constructors */
	//@{
	FUIScreenValue_DockPadding()
	{
		// do not initialize any members in the default constructor
	}
	FUIScreenValue_DockPadding( EEventParm )
	{
		// zero-initialization ctor
		appMemzero(this, sizeof(FUIScreenValue_DockPadding));
	}
	/** Stack constructor */
	FUIScreenValue_DockPadding
	(
		FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue,
		EUIDockPaddingEvalType LeftScaleType=UIPADDINGEVAL_Pixels, EUIDockPaddingEvalType TopScaleType=UIPADDINGEVAL_Pixels,
		EUIDockPaddingEvalType RightScaleType=UIPADDINGEVAL_Pixels, EUIDockPaddingEvalType BottomScaleType=UIPADDINGEVAL_Pixels
	)
	{
		PaddingValue[UIFACE_Left]		=	LeftValue;
		PaddingValue[UIFACE_Top]		=	RightValue;
		PaddingValue[UIFACE_Right]		=	LeftValue;
		PaddingValue[UIFACE_Bottom]		=	RightValue;
		PaddingScaleType[UIFACE_Left]	=	LeftScaleType;
		PaddingScaleType[UIFACE_Top]	=	TopScaleType;
		PaddingScaleType[UIFACE_Right]	=	RightScaleType;
		PaddingScaleType[UIFACE_Bottom]	=	BottomScaleType;
	}
	//@}

	/** @name Comparison operators */
	//@{
	UBOOL operator==( const FUIScreenValue_DockPadding& Other ) const
	{
		return	appMemcmp(PaddingValue, Other.PaddingValue, sizeof(PaddingValue)) == 0
			&&	appMemcmp(PaddingScaleType, Other.PaddingScaleType, sizeof(PaddingScaleType)) == 0;
	}
	UBOOL operator!=( const FUIScreenValue_DockPadding& Other ) const
	{
		return !(FUIScreenValue_DockPadding::operator==(Other));
	}
	//@}

};

struct FUIScreenValue_AutoSizeRegion
{
    FLOAT Value[2];
    BYTE EvalType[2];

	/** Constructors */
	FUIScreenValue_AutoSizeRegion()
	{}
	FUIScreenValue_AutoSizeRegion(EEventParm)
	{
		Value[UIAUTOSIZEREGION_Minimum] = 0.f;
		Value[UIAUTOSIZEREGION_Maximum] = 0.f;
		EvalType[UIAUTOSIZEREGION_Minimum] = UIEXTENTEVAL_Pixels;
		EvalType[UIAUTOSIZEREGION_Maximum] = UIEXTENTEVAL_Pixels;
	}

	/** Comparison operator */
	UBOOL operator==( const FUIScreenValue_AutoSizeRegion& Other ) const
	{
		return
			Value[UIAUTOSIZEREGION_Minimum] == Other.Value[UIAUTOSIZEREGION_Minimum]
		&&	Value[UIAUTOSIZEREGION_Maximum] == Other.Value[UIAUTOSIZEREGION_Maximum]
		&&	EvalType[UIAUTOSIZEREGION_Minimum] == Other.EvalType[UIAUTOSIZEREGION_Minimum]
		&&	EvalType[UIAUTOSIZEREGION_Maximum] == Other.EvalType[UIAUTOSIZEREGION_Maximum];
	}

	/**
	 * Calculates the extent to use as the base for evaluating percentage values.
	 *
	 * @param	Orientation		indicates which orientation to use for evaluating the actual extent of the widget's parent
	 * @param	EvaluationType	indicates which base to use for calculating the base extent
	 * @param	OwnerWidget		the widget that this auto-size region is for
	 * @param	BaseExtent		[out] set to the size of the region that will be used for evaluating this auto-size region as a percentage; actual pixels
	 */
	static void CalculateBaseValue( EUIOrientation Orientation, EUIExtentEvalType EvaluationType, class UUIScreenObject* OwnerWidget, FLOAT& BaseExtent );

	/**
	 * Resolves the value stored in this AutoSizeRegion according to the specified output type.
	 *
	 * @param	ValueType	indicates whether to return the min or max value.
	 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
	 * @param	OutputType	indicates the desired format for the result
	 *						UIEXTENTEVAL_Pixels:
	 *							Result should be the actual number of pixels
	 *						UIEXTENTEVAL_PercentOwner:
	 *							result should be formatted as a percentage of the widget's parent
	 *						UIEXTENTEVAL_PercentScene:
	 *							result should be formatted as a percentage of the scene
	 *						UIEXTENTEVAL_PercentViewport:
	 *							result should be formatted as a percentage of the viewport
	 * @param	OwnerWidget	the widget that this auto-size region is for
	 *
	 * @return	the value of the auto-size region's min or max value
	 */
	FLOAT GetValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, EUIExtentEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	ValueType	indicates whether to set the min or max value.
	 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
	 * @param	OwnerWidget	the widget that contains this extent value
	 * @param	NewValue	the new value (in pixels or percentage) to use
	 * @param	OutputType	specifies how NewValue should be interpreted format for the result
	 *						UIEXTENTEVAL_Pixels:
	 *							NewValue is in absolute pixels
	 *						UIEXTENTEVAL_PercentOwner:
	 *							NewValue is a percentage of the OwnerWidget
	 *						UIEXTENTEVAL_PercentScene:
	 *							NewValue is a percentage of the scene
	 *						UIEXTENTEVAL_PercentViewport:
	 *							NewValue is a percentage of the viewport
	 */
	void SetValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIExtentEvalType InputType=UIEXTENTEVAL_Pixels );

	/**
	 * Changes the scale type for this extent to the type specified, optionally converting the current Value into the new type.
	 *
	 * @param	ValueType			indicates whether to set the min or max value.
	 * @param	Orientation			indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the new evaluation type to ise
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget, EUIExtentEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

};

struct FAutoSizePadding : public FUIScreenValue_AutoSizeRegion
{
};

struct FAutoSizeData
{
    struct FUIScreenValue_AutoSizeRegion Extent;
    struct FAutoSizePadding Padding;
    BITFIELD bAutoSizeEnabled:1;

	/**
	 * Evaluates and returns the padding value stored in this AutoSizeData
	 *
	 * @param	ValueType	indicates which element of the Value array to evaluate
	 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
	 * @param	OutputType	specifies how the result should be formatted
	 *						UIEXTENTEVAL_Pixels:
	 *							NewValue is in absolute pixels
	 *						UIEXTENTEVAL_PercentOwner:
	 *							NewValue is a percentage of the OwnerWidget
	 *						UIEXTENTEVAL_PercentScene:
	 *							NewValue is a percentage of the scene
	 *						UIEXTENTEVAL_PercentViewport:
	 *							NewValue is a percentage of the viewport
	* @param	OwnerWidget		the widget that contains this screen value
	*
	* @return	the actual padding value for this AutoSizeData, in pixels or percentage, for the dimension specified.
	*/
	FLOAT GetPaddingValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, EUIExtentEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Returns the minimum allowed size for this auto-size region.
	 *
	 * @param	OutputType		indicates how the result should be formatted.
	 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
	 * @param	OwnerWidget		the widget that this auto-size region is used by.
	 *
	 * @return	the minimum size allowed for this auto-size region, or 0 if this auto-size region is disabled.
	 */
	FLOAT GetMinValue( EUIExtentEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Returns the maximum allowed size for this auto-size region.
	 *
	 * @param	OutputType		indicates how the result should be formatted.
	 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
	 * @param	OwnerWidget		the widget that this auto-size region is used by.
	 *
	 * @return	the maximum size allowed for this auto-size region, or 0 if there is no max size configured or this auto-size region
	 *			is not enabled.
	 */
	FLOAT GetMaxValue( EUIExtentEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;

};

struct FInputEventSubscription
{
    FName KeyName;
    TArray<class UUIScreenObject*> Subscribers;

	/** Constructors */
	FInputEventSubscription() {}
	FInputEventSubscription( FName InKeyName )
	: KeyName(InKeyName)
	{}

};

struct FDefaultEventSpecification
{
    class UUIEvent* EventTemplate;
    class UClass* EventState;
};

struct FInputKeyAction
{
    FName InputKeyName;
    BYTE InputKeyState;
    class UUIAction* ActionToExecute;
    TArrayNoInit<class USequenceAction*> ActionsToExecute;

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FInputKeyAction() {}

	/** Initialization constructor - zero initialize all members */
	FInputKeyAction(EEventParm)
	{
		appMemzero(this, sizeof(FInputKeyAction));
		InputKeyName = NAME_None;
		InputKeyState = IE_Released;
	}

	/** Copy constructor */
	FInputKeyAction( const FInputKeyAction& Other )
	: InputKeyName(Other.InputKeyName), InputKeyState(Other.InputKeyState), ActionToExecute(Other.ActionToExecute), ActionsToExecute(Other.ActionsToExecute)
	{}

	/** Standard ctor */
	FInputKeyAction( FName InKeyName, EInputEvent InKeyState )
	{
		appMemzero(this, sizeof(FInputKeyAction));
		InputKeyName = InKeyName;
		InputKeyState = InKeyState;
	}

	/** Comparison operator */
	UBOOL operator==( const FInputKeyAction& Other ) const;

	/** Serialization operator */
    friend FArchive& operator<<(FArchive& Ar,FInputKeyAction& MyInputKeyAction);

};

struct FStateInputKeyAction : public FInputKeyAction
{
    class UClass* Scope;

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FStateInputKeyAction() {}
	/** Initialization constructor - zero initialize all members */
	FStateInputKeyAction(EEventParm) : FInputKeyAction(EC_EventParm), Scope(NULL) {}
	/** Copy constructor */
	FStateInputKeyAction( const FStateInputKeyAction& Other )
	: FInputKeyAction(Other), Scope(Other.Scope) { }
	/** Standard ctor */
	FStateInputKeyAction( FName InKeyName, EInputEvent InKeyState, UClass* InScope )
	: FInputKeyAction(InKeyName,InKeyState), Scope(InScope)
	{}
	/** Copy ctor from FInputKeyAction */
	FStateInputKeyAction( const FInputKeyAction& Other, class UClass* OwnerStateClass )
	: FInputKeyAction(Other), Scope(OwnerStateClass)
	{}

	/** Comparison operator */
	UBOOL operator==( const FStateInputKeyAction& Other ) const
	{
		return ((FInputKeyAction&)*this) == Other && Scope == Other.Scope;
	}

};

struct FPlayerInteractionData
{
    class UUIObject* FocusedControl;
    class UUIObject* LastFocusedControl;

	/**
	 * Changes the FocusedControl to the widget specified
	 *
	 * @param	NewFocusedControl	the widget that should become the focused control
	 */
	void SetFocusedControl( class UUIObject* NewFocusedControl );

	/**
	 * Gets the currently focused control.
	 */
	class UUIObject* GetFocusedControl() const;

	/**
	 * Changes the FocusedControl to the widget specified
	 *
	 * @param	Widget	the widget that should become the LastFocusedControl control
	 */
	void SetLastFocusedControl( class UUIObject* Widget );

	/**
	 * Gets the previously focused control.
	 */
	class UUIObject* GetLastFocusedControl() const;

};

struct FUIFocusPropagationData
{
    class UUIObject* FirstFocusTarget;
    class UUIObject* LastFocusTarget;
    class UUIObject* NextFocusTarget;
    class UUIObject* PrevFocusTarget;
    BITFIELD bPendingReceiveFocus:1;

	/**
	 * Returns the child widget that is configured as the first focus target for this widget.
	 */
	class UUIObject* GetFirstFocusTarget() const;

	/**
	 * Returns the child widget that is configured as the last focus target for this widget.
	 */
	class UUIObject* GetLastFocusTarget() const;

	/**
	 * Returns the sibling widget that is configured as the next focus target for tab navigation.
	 */
	class UUIObject* GetNextFocusTarget() const;

	/**
	 * Returns the sibling widget that is configured as the previous focus target for tab navigation.
	 */
	class UUIObject* GetPrevFocusTarget() const;

	/**
	 * Sets the default first focus target for this widget.
	 *
	 * @param	FocusTarget			the child of this widget that should become the first focus target for this widget
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetFirstFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the default last focus target for this widget.
	 *
	 * @param	FocusTarget			the child of this widget that should become the last focus target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetLastFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the next tab-nav focus target for this widget.
	 *
	 * @param	FocusTarget			a sibling of this widget that should become the next tab-nav target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetNextFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the previous tab-nav focus target for this widget.
	 *
	 * @param	FocusTarget			a sibling of this widget that should become the previous tab-nav target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetPrevFocusTarget( class UUIObject* FocusTarget );

};

struct FUINavigationData
{
    class UUIObject* NavigationTarget[4];
    class UUIObject* ForcedNavigationTarget[4];
    BYTE bNullOverride[4];

private:
	friend class UUIObject;

	/**
	 * Sets the actual navigation target for the specified face.
	 *
	 * @param	Face			the face to set the navigation link for
	 * @param	NewNavTarget	the widget to set as the link for the specified face
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetNavigationTarget( EUIWidgetFace Face, class UUIObject* NewNavTarget );
	UBOOL SetNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

	/**
	 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
	 * the designer-specified navigation target will always override any auto-calculated targets.
	 *
	 * @param	Face				the face to set the navigation link for
	 * @param	NavTarget			the widget to set as the link for the specified face
	 * @param	bIsNullOverride		if NavTarget is NULL, specify TRUE to indicate that this face's nav target should not
	 *								be automatically calculated.
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetForcedNavigationTarget( EUIWidgetFace Face, class UUIObject* NavTarget, UBOOL bIsNullOverride=FALSE );
	UBOOL SetForcedNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

public:
	/**
	 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
	 * that object is returned.
	 *
	 * @param	Face		the face to get the nav target for
	 * @param	LinkType	specifies which navigation link type to return.
	 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
	 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
	 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
	 *
	 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
	 *			no nav target for that face.
	 */
	class UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

	/**
	 * Determines whether the designer has overriden all navigation targets.
	 *
	 * @return	FALSE if an override target has been specified for all faces.
	 */
	UBOOL NeedsLinkGeneration() const;

};

struct FUIDockingSet
{
    class UUIObject* OwnerWidget;
private:
    class UUIObject* TargetWidget[4];
    struct FUIScreenValue_DockPadding DockPadding;
    BITFIELD bLockWidthWhenDocked:1;
    BITFIELD bLockHeightWhenDocked:1;
    BYTE TargetFace[4] GCC_BITFIELD_MAGIC;
public:
    BYTE bResolved[4];
    BYTE bLinking[4];

	/**
	 * Evaluate the widget's Position into an absolute pixel value, and store that value in the corresponding
	 * member of the widget's RenderBounds array.
	 * This function assumes that UpdateDockingSet has already been called for the TargetFace of the TargetWidget.
	 * This function should only be called from ResolveScenePositions.
	 *
	 * @param	Face			the face that needs to be resolved
	 */
	void UpdateDockingSet( EUIWidgetFace Face );

	/**
	 * Used to determine whether the specified face is docked.
	 *
	 * @return	TRUE if SourceFace is docked, FALSE if it isn't.
	 */
	UBOOL IsDocked( EUIWidgetFace SourceFace, UBOOL bRequireValidTargetFace=TRUE, UBOOL bIgnoreSceneTargets=FALSE ) const
	{
		checkSlow(SourceFace<UIFACE_MAX);
		return (TargetWidget[SourceFace] != NULL || !bIgnoreSceneTargets) && (!bRequireValidTargetFace || TargetFace[SourceFace] < UIFACE_MAX);
	}

	/**
	 * Retrieves the target widget for the specified face in this docking set.
	 *
	 * @param	SourceFace		the face to retrieve the dock target for
	 *
	 * @return	a pointer to the widget that the specified face is docked to.  NULL if the face is not docked or is docked to the scene.
	 *			If return value is NULL, IsDocked() can be used to determine whether the face is docked to the scene or not.
	 */
	class UUIObject* GetDockTarget( EUIWidgetFace SourceFace ) const;

	/**
	 * Retrieves the target face for the specified source face in this docking set.
	 *
	 * @param	SourceFace		the face to retrieve the dock target face for
	 *
	 * @return	the face of the dock target that SourceFace is docked to, or UIFACE_MAX if SourceFace is not docked.
	 */
	EUIWidgetFace GetDockFace( EUIWidgetFace SourceFace ) const;

	/**
	 *	Returns the ammount of padding for the specified face.
	 */
	FLOAT GetDockPadding( EUIWidgetFace SourceFace, EUIDockPaddingEvalType OutputType=UIPADDINGEVAL_Pixels ) const;

	/**
	 * Returns the dock padding eval type for the specified face.
	 */
	EUIDockPaddingEvalType GetDockPaddingType( EUIWidgetFace SourceFace ) const;

	/**
	 * Changes the configured dock target and face for the specified face.
	 *
	 * @param	SourceFace	the face to set the value for
	 * @param	DockTarget	the widget that SourceFace should be docked to, or NULL to indicate that this face should no longer be docked.
	 * @param	DockFace	the face on the dock target that SourceFace should be docked to.
	 *
	 * @return	TRUE indicates that the dock target values for the specified face were successfully changed.
	 */
	UBOOL SetDockTarget( EUIWidgetFace SourceFace, class UUIScreenObject* DockTarget, EUIWidgetFace DockFace );

	/**
	 * Changes the dock padding value for the specified face.
	 *
	 * @param	DockFace			the face to change padding for
	 * @param	NewValue			the new value to use for padding
	 * @param	InputType			the format to use for interpreting NewValue.
	 * @param	bChangeScaleType	specify TRUE to permanently change the scale type for the specified face to InputType.
	 *
	 * @return	TRUE indicates that the dock padding values for the specified face were successfully changed.
	 */
	UBOOL SetDockPadding( EUIWidgetFace DockFace, float NewValue, EUIDockPaddingEvalType InputType=UIPADDINGEVAL_Pixels, UBOOL bChangeScaleType=FALSE );

	/**
	 * Initializes the value of this docking set's OwnerWidget and convert UIDockingSets over to the new behavior
	 * (where TargetFace == OwnerWidget if docked to the scene)
	 *
	 * @param	inOwnerWidget	the widget that contains this docking set.
	 */
	void InitializeDockingSet( UUIObject* inOwnerWidget );

	/**
	 * Returns whether this widget's width should remain constant when adjusting its position due to docking relationships.
	 */
	UBOOL IsWidthLocked() const
	{
		return bLockWidthWhenDocked;
	}

	/**
	 * Returns whether this widget's height should remain constant when adjusting its position due to docking relationships.
	 */
	UBOOL IsHeightLocked() const
	{
		return bLockHeightWhenDocked;
	}

	/**
	 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
	 * according to the value specified.
	 */
	void LockWidth( UBOOL bShouldLockWidth=TRUE )
	{
		bLockWidthWhenDocked = bShouldLockWidth;
	}

	/**
	 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
	 * according to the value specified.
	 */
	void LockHeight( UBOOL bShouldLockHeight=TRUE )
	{
		bLockHeightWhenDocked = bShouldLockHeight;
	}

};

struct FUIDockingNode
{
    class UUIObject* Widget;
    BYTE Face;

	/**
	 * Comparison operator
	 */
	UBOOL operator==( const FUIDockingNode& Other ) const
	{
		return Widget == Other.Widget && Face == Other.Face;
	}

	/**
	 * Constructors
	 */
	FUIDockingNode( UUIObject* inWidget=NULL, EUIWidgetFace inFace=UIFACE_MAX )
	: Widget(inWidget), Face(inFace)
	{ }

	FUIDockingNode( const FUIDockingNode& Other )
	: Widget(Other.Widget), Face(Other.Face)
	{ }

};

struct FUIRotation
{
    FRotator Rotation;
    FMatrix TransformMatrix;
    struct FUIAnchorPosition AnchorPosition;
    BYTE AnchorType;

	/**
	 * Sets the location of the anchor of rotation for this widget.
	 *
	 * @param	AnchorPos		New location for the anchor of rotation.
	 * @param	InputType		indicates which format the AnchorPos value is in
	 */
	void SetAnchorLocation(const class UUIScreenObject* OwnerWidget, const FVector& AnchorPos, EPositionEvalType InputType=EVALPOS_PixelViewport);

};

struct FUIDataStoreBinding
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    BYTE RequiredFieldType;
    FStringNoInit MarkupString;
    INT BindingIndex;
    FName DataStoreName;
    FName DataStoreField;
    class UUIDataStore* ResolvedDataStore;

	/**
	 * Registers the current subscriber with ResolvedDataStore's list of RefreshSubscriberNotifies
	 */
	void RegisterSubscriberCallback();

	/**
	 * Removes the current subscriber from ResolvedDataStore's list of RefreshSubscriberNotifies.
	 */
	void UnregisterSubscriberCallback();

	/**
	 * Determines whether the specified data field can be assigned to this data store binding.
	 *
	 * @param	DataField	the data field to verify.
	 *
	 * @return	TRUE if DataField's FieldType is compatible with the RequiredFieldType for this data binding.
	 */
	UBOOL IsValidDataField( const struct FUIDataProviderField& DataField ) const;

	/**
	 * Determines whether the specified field type is valid for this data store binding.
	 *
	 * @param	FieldType	the data field type to check
	 *
	 * @return	TRUE if FieldType is compatible with the RequiredFieldType for this data binding.
	 */
	UBOOL IsValidDataField( EUIDataProviderFieldType FieldType ) const;

	/**
	 * Resolves the value of MarkupString into a data store reference, and fills in the values for all members of this struct
	 *
	 * @param	InSubscriber	the subscriber that contains this data store binding
	 *
	 * @return	TRUE if the markup was successfully resolved.
	 */
	UBOOL ResolveMarkup( TScriptInterface<class IUIDataStoreSubscriber> InSubscriber );

	/**
	 * Retrieves the value for this data store binding from the ResolvedDataStore.
	 *
	 * @param	out_ResolvedValue	will contain the value of the data store binding.
	 *
	 * @return	TRUE if the value for this data store binding was successfully retrieved from the data store.
	 */
	UBOOL GetBindingValue( struct FUIProviderFieldValue& out_ResolvedValue ) const;

	/**
	 * Publishes the value for this data store binding to the ResolvedDataStore.
	 *
	 * @param	NewValue	contains the value that should be published to the data store
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	UBOOL SetBindingValue( const struct FUIProviderScriptFieldValue& NewValue ) const;

	/**
	 * Unregisters any bound data stores and clears all references.
	 */
	UBOOL ClearDataBinding();

    /** Constructors */
	FUIDataStoreBinding() {}
    FUIDataStoreBinding(EEventParm)
	{
		appMemzero(this, sizeof(FUIDataStoreBinding));
	}

	/**
	 * Member access operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 */
	FORCEINLINE class UUIDataStore* operator->()
	{
		return ResolvedDataStore;
	}

	/**
	 * Dereference operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 *
	 * @return	ResolvedDataStore
	 */
	FORCEINLINE class UUIDataStore*& operator*()
	{
		return ResolvedDataStore;
	}

	/**
	 * Boolean operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 *
	 * @return	TRUE if ResolvedDataStore is non-NULL.
	 */
	FORCEINLINE operator UBOOL() const
	{
		return ResolvedDataStore != NULL;
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIDataStoreBinding& Other ) const
	{
		return	Subscriber			== Other.Subscriber
			&&	RequiredFieldType	== Other.RequiredFieldType
			&&	MarkupString		== Other.MarkupString
			&&	DataStoreName		== Other.DataStoreName
			&&	DataStoreField		== Other.DataStoreField
			&&	ResolvedDataStore	== Other.ResolvedDataStore;
	}
	FORCEINLINE UBOOL operator!=( const FUIDataStoreBinding& Other ) const
	{
		return !(FUIDataStoreBinding::operator==(Other));
	}

	/* Editor serialization operator */
	friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding& Binding )
	{
		return Ar << (UObject*&)Binding.ResolvedDataStore << Binding.Subscriber;
	}
	friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding* Binding )
	{
		if ( Binding != NULL )
		{
			Ar << (UObject*&)Binding->ResolvedDataStore << Binding->Subscriber;
		}
		return Ar;
	}

};

struct FUIStyleSubscriberReference
{
    FName SubscriberId;
    TScriptInterface<class IUIStyleResolver> Subscriber;

	/** Constructors */
	FUIStyleSubscriberReference()
	: SubscriberId(NAME_None)
	{
	}
	FUIStyleSubscriberReference(EEventParm)
	: SubscriberId(NAME_None)
	{
	}

	FUIStyleSubscriberReference( FName InSubscriberId, const class TScriptInterface<class IUIStyleResolver>& InSubscriber );

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIStyleSubscriberReference& Other ) const
	{
		return SubscriberId == Other.SubscriberId && Subscriber == Other.Subscriber;
	}
	FORCEINLINE UBOOL operator!=( const FUIStyleSubscriberReference& Other ) const
	{
		return SubscriberId != Other.SubscriberId || Subscriber != Other.Subscriber;
	}

};

struct FStyleReferenceId
{
    FName StyleReferenceTag;
    class UProperty* StyleProperty;

	/** Constructors */
	FStyleReferenceId()
	: StyleReferenceTag(NAME_None), StyleProperty(NULL)
	{}
	FStyleReferenceId( UProperty* InStyleProperty )
	: StyleReferenceTag(NAME_None), StyleProperty(InStyleProperty)
	{}
	FStyleReferenceId( const FName& InReferenceTag, class UProperty* InStyleProperty )
	: StyleReferenceTag(InReferenceTag), StyleProperty(InStyleProperty)
	{}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FStyleReferenceId& Other ) const
	{
		return GetStyleReferenceTag() == Other.GetStyleReferenceTag() && StyleProperty == Other.StyleProperty;
	}
	FORCEINLINE UBOOL operator!=( const FStyleReferenceId& Other ) const
	{
		return GetStyleReferenceTag() != Other.GetStyleReferenceTag() || StyleProperty != Other.StyleProperty;
	}

	friend FORCEINLINE DWORD GetTypeHash( const FStyleReferenceId& RefId )
	{
		return PointerHash(RefId.StyleProperty);
	}

	/**
	 * Returns the display name for this style reference
	 */
	FString GetStyleReferenceName( UBOOL bAllowDisplayName=!GIsGame ) const;

	/**
	 * Faster version of GetStyleReferenceName which never allows meta data localized text to be used.
	 */
	FName GetStyleReferenceTag() const;

};

struct FUITextAttributes
{
    BITFIELD Bold:1;
    BITFIELD Italic:1;
    BITFIELD Underline:1;
    BITFIELD Shadow:1;
    BITFIELD Strikethrough:1;

	/** Comparison operator */
	UBOOL operator==( const FUITextAttributes& Other ) const
	{
		return appMemcmp(this, &Other, sizeof(FUITextAttributes)) == 0;
	}

	UBOOL operator!=( const FUITextAttributes& Other ) const
	{
		return !((*this)==Other);
	}

	/**
	 * Resets the values for all attributes to false.
	 */
	void Reset();

};

struct FUIImageAdjustmentData
{
    struct FScreenPositionRange ProtectedRegion;
    BYTE AdjustmentType;
    BYTE Alignment;

	/** Comparison */
	UBOOL operator ==( const FUIImageAdjustmentData& Other ) const;
	UBOOL operator !=( const FUIImageAdjustmentData& Other ) const;

};

struct FTextureCoordinates
{
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

	/** Constructors */
	FTextureCoordinates()
	{ }

	FTextureCoordinates( FLOAT inU, FLOAT inV, FLOAT inUL, FLOAT inVL )
	: U(inU), V(inV), UL(inUL), VL(inVL)
	{ }

	/**
	 * Returns whether the values in this coordinate are zero, accounting for floating point
	 * precision errors.
	 */
	inline UBOOL IsZero() const
	{
		return	Abs(U) < KINDA_SMALL_NUMBER && Abs(V) < KINDA_SMALL_NUMBER
			&&	Abs(UL) < KINDA_SMALL_NUMBER && Abs(VL) < KINDA_SMALL_NUMBER;
	}

	/** Comparison operators */
	inline UBOOL operator==( const FTextureCoordinates& Other ) const
	{
		return this->U == Other.U && this->V == Other.V && this->UL == Other.UL && this->VL == Other.VL;
	}
	inline UBOOL operator!=( const FTextureCoordinates& Other ) const
	{
		return this->U != Other.U || this->V != Other.V || this->UL != Other.UL || this->VL != Other.VL;
	}

	/** Error tolerant comparison operator */
	inline UBOOL Equals( const FTextureCoordinates& Other, FLOAT Tolerance=KINDA_SMALL_NUMBER ) const
	{
		return	Abs(this->U - Other.U) < Tolerance		&&	Abs(this->V - Other.V) < Tolerance
			&&	Abs(this->UL - Other.UL) < Tolerance	&&	Abs(this->VL - Other.VL) < Tolerance;
	}

};

struct FUIStringCaretParameters
{
    BITFIELD bDisplayCaret:1;
    BYTE CaretType GCC_BITFIELD_MAGIC;
    FLOAT CaretWidth;
    FName CaretStyle;
    INT CaretPosition;
    class UMaterialInterface* CaretMaterial;
};

struct FRenderParameters
{
    FLOAT DrawX;
    FLOAT DrawY;
    FLOAT DrawXL;
    FLOAT DrawYL;
    FVector2D Scaling;
    class UFont* DrawFont;
    BYTE TextAlignment[2];
    FVector2D ImageExtent;
    struct FTextureCoordinates DrawCoords;

	/** Constructors */
	FRenderParameters()
	: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
	, Scaling(1.f,1.f), DrawFont(NULL), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

	FRenderParameters( FLOAT inDrawX, FLOAT inDrawY, FLOAT inDrawXL, FLOAT inDrawYL, UFont* inFont=NULL )
	: DrawX(inDrawX), DrawY(inDrawY), DrawXL(inDrawXL), DrawYL(inDrawYL)
	, Scaling(1.f,1.f), DrawFont(inFont), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

	FRenderParameters( UFont* inFont, FLOAT ScaleX, FLOAT ScaleY )
	: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
	, Scaling(ScaleX,ScaleY), DrawFont(inFont), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

};

struct FTextAutoScaleValue
{
    FLOAT MinScale;
    BYTE AutoScaleMode;

	/** Constructors */
	FTextAutoScaleValue() {}
	FTextAutoScaleValue(EEventParm)
	: MinScale(0.f), AutoScaleMode(UIAUTOSCALE_None)
	{}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FTextAutoScaleValue& Other ) const
	{
		return	MinScale		== Other.MinScale
			&&	AutoScaleMode	== Other.AutoScaleMode;
	}
	FORCEINLINE UBOOL operator!=( const FTextAutoScaleValue& Other ) const
	{
		return	MinScale		!= Other.MinScale
			||	AutoScaleMode	!= Other.AutoScaleMode;
	}

};

struct FUITextStyleOverride
{
    FLinearColor DrawColor;
    FLOAT Opacity;
    class UFont* DrawFont;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
    BYTE ClipMode;
    BYTE ClipAlignment;
    struct FTextAutoScaleValue AutoScaling;
    FLOAT DrawScale[2];
private:
    BITFIELD bOverrideDrawColor:1;
    BITFIELD bOverrideOpacity:1;
    BITFIELD bOverrideDrawFont:1;
    BITFIELD bOverrideAttributes:1;
    BITFIELD bOverrideAlignment:1;
    BITFIELD bOverrideClipMode:1;
    BITFIELD bOverrideClipAlignment:1;
    BITFIELD bOverrideAutoScale:1;
    BITFIELD bOverrideScale:1;
public:

	/**
	 * Enables/disables customization of style data without changing the existing value.
	 *
	 * @return	TRUE if the value was changed.
	 */
	UBOOL EnableCustomDrawColor( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawColor != bEnabled);
		bOverrideDrawColor=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomOpacity( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideOpacity != bEnabled);
		bOverrideOpacity=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomDrawFont( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawFont != bEnabled);
		bOverrideDrawFont=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomAttributes( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideAttributes != bEnabled);
		bOverrideAttributes=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomClipMode( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideClipMode != bEnabled);
		bOverrideClipMode=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomClipAlignment( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideClipAlignment != bEnabled);
		bOverrideClipAlignment=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomAlignment( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideAlignment != bEnabled);
		bOverrideAlignment=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomAutoScaleMode( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideAutoScale != bEnabled);
		bOverrideAutoScale=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomScale( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideScale != bEnabled);
		bOverrideScale=bEnabled;
		return bResult;
	}
	UBOOL IsCustomDrawColorEnabled()	const	{ return bOverrideDrawColor; }
	UBOOL IsCustomOpacityEnabled()		const	{ return bOverrideOpacity; }
	UBOOL IsCustomDrawFontEnabled()		const	{ return bOverrideDrawFont; }
	UBOOL IsCustomAttributesEnabled()	const	{ return bOverrideAttributes; }
	UBOOL IsCustomClipModeEnabled()		const	{ return bOverrideClipMode; }
	UBOOL IsCustomAlignmentEnabled()	const	{ return bOverrideAlignment; }
	UBOOL IsCustomClipAlignmentEnabled()const	{ return bOverrideClipAlignment; }
	UBOOL IsCustomAutoScaleEnabled()	const	{ return bOverrideAutoScale; }
	UBOOL IsCustomScaleEnabled()		const	{ return bOverrideScale; }

	/**
	 * Changes the draw color to the color specified and enables draw color override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawColor( const struct FLinearColor& NewDrawColor );

	/**
	 * Changes the opacity
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomOpacity( float NewOpacity );


	/**
	 * Changes the draw font to the font specified and enables font override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawFont( class UFont* NewFont );

	/**
	 * Changes the custom attributes to the value specified and enables text attribute customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAttributes( const struct FUITextAttributes& NewAttributes );

	/**
	 * Changes the custom text clipping mode to the value specified and enables clipmode customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomClipMode( enum ETextClipMode CustomClipMode );

	/**
	 * Changes the custom text clip alignment to the value specified and enables clip alignment customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomClipAlignment( enum EUIAlignment NewClipAlignment );

	/**
	 * Changes the custom text alignment to the value specified and enables alignment customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAlignment( enum EUIOrientation Orientation, enum EUIAlignment NewAlignment );

	/**
	 * Changes the custom text auto scale mode to the value specified and enables auto scale mode customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAutoScaling( enum ETextAutoScaleMode NewAutoScaleMode, FLOAT NewMinScale );

	/**
	 * Changes the custom text auto scale mode to the value specified and enables auto scale mode customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAutoScaling( const struct FTextAutoScaleValue& NewAutoScaleValue );

	/**
	 * Changes the custom text scale to the value specified and enables scale customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomScale(  enum EUIOrientation Orientation, FLOAT NewScale );

	/**
	 * Copies the value of DrawColor onto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawColor( struct FLinearColor& OriginalColor ) const;

	/**
	 * Applies the value of Opacity tonto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeOpacity( struct FLinearColor& OriginalColor ) const;

	/**
	 * Copies the value of DrawFont onto the specified value if font customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawFont( class UFont*& OriginalFont ) const;

	/**
	 * Copies the value of TextAttributes into the specified value if attribute customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeAttributes( struct FUITextAttributes& OriginalAttributes ) const;

	/**
	 * Copies the value of ClipMode into the specified value if clipmode customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeClipMode( enum ETextClipMode& OriginalClipMode ) const;

	/**
	 * Copies the value of TextAlignment for the specified orientation into the specified value if alignment customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeAlignment( enum EUIOrientation Orientation, enum EUIAlignment& OriginalAlignment ) const;

	/**
	 * Copies the value of ClipAlignment into the specified value if alignment customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeClipAlignment( enum EUIAlignment& OriginalAlignment ) const;

	/**
	 * Copies the value of AutoScaleMode into the specified value if attribute customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeAutoScaling( struct FTextAutoScaleValue& OriginalAutoScaling ) const;

	/**
	 * Copies the value of Scale into the specified value if attribute customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeScale( enum EUIOrientation Orientation, FLOAT& OriginalScale ) const;

};

struct FUIImageStyleOverride
{
    FLinearColor DrawColor;
    FLOAT Opacity;
    struct FTextureCoordinates Coordinates;
    struct FUIImageAdjustmentData Formatting[2];
private:
    BITFIELD bOverrideDrawColor:1;
    BITFIELD bOverrideOpacity:1;
    BITFIELD bOverrideCoordinates:1;
    BITFIELD bOverrideFormatting:1;
public:

	/**
	 * Enables/disables customization of style data without changing the existing value.
	 *
	 * @return	TRUE if the value was changed.
	 */
	UBOOL EnableCustomDrawColor( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawColor != bEnabled);
		bOverrideDrawColor=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomOpacity( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideOpacity != bEnabled);
		bOverrideOpacity=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomCoordinates( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideCoordinates != bEnabled);
		bOverrideCoordinates=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomFormatting( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideFormatting != bEnabled);
		bOverrideFormatting=bEnabled;
		return bResult;
	}
	UBOOL IsCustomDrawColorEnabled()	const	{ return bOverrideDrawColor; }
	UBOOL IsCustomOpacityEnabled()		const	{ return bOverrideOpacity; }
	UBOOL IsCustomCoordinatesEnabled()	const	{ return bOverrideCoordinates; }
	UBOOL IsCustomFormattingEnabled()	const	{ return bOverrideFormatting; }

	/**
	 * Changes the draw color to the color specified and enables draw color override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawColor( const struct FLinearColor& NewDrawColor );

	/**
	 * Changes the opacity
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomOpacity( float NewOpacity );


	/**
	 * Changes the draw coordinates to the coordinates specified and enables coordinate override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomCoordinates( const struct FTextureCoordinates& NewCoordinates );

	/**
	 * Changes the image adjustment data to the values specified and enables image adjustment data override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomFormatting( enum EUIOrientation Orientation, const struct FUIImageAdjustmentData& NewAdjustmentData );

	/**
	 * Copies the value of DrawColor onto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawColor( struct FLinearColor& OriginalColor ) const;

	/**
	 * Applies the value of Opacity tonto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeOpacity( struct FLinearColor& OriginalColor ) const;

	/**
	 * Copies the value of Coordinates onto the specified value if coordinates customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeCoordinates( struct FTextureCoordinates& OriginalCoordinates ) const;

	/**
	 * Copies the value of Formatting for the specified orientation onto the specified value if formatting customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeFormatting( enum EUIOrientation Orientation, struct FUIImageAdjustmentData& OriginalFormatting ) const;

};

struct FUICombinedStyleData
{
    FLinearColor TextColor;
    FLinearColor ImageColor;
    class UFont* DrawFont;
    class USurface* FallbackImage;
    struct FTextureCoordinates AtlasCoords;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
    BYTE TextClipMode;
    BYTE TextClipAlignment;
    struct FUIImageAdjustmentData AdjustmentType[2];
    struct FTextAutoScaleValue TextAutoScaling;
    FVector2D TextScale;
private:
    BITFIELD bInitialized:1;
public:

	/** Serializer for GC */
    friend FArchive& operator<<( FArchive& Ar, struct FUICombinedStyleData& Container)
    {
        Ar << (UObject*&)Container.DrawFont << (UObject*&)Container.FallbackImage;
        return Ar;
    }

	/** Default Constructor */
	FUICombinedStyleData();

	/** Copy constructor */
	FUICombinedStyleData( const struct FUICombinedStyleData& Other );

	/**
	 * Standard constructor
	 *
	 * @param	SourceStyle		the style to use for initializing this StyleDataContainer.
	 */
	FUICombinedStyleData( class UUIStyle_Data* SourceStyle );

	/** Comparison operators */
	UBOOL operator==( const struct FUICombinedStyleData& Other ) const;
	UBOOL operator!=(const struct FUICombinedStyleData& Other ) const;

	/**
	 * Initializes the values of this UICombinedStyleData based on the values of the UIStyle_Data specified.
	 *
	 * @param	SourceStyle			the style to copy values from
	 * @param	bClearUnusedData	controls whether style data that isn't found in SourceStyle should be zero'd; for example
	 *								if SourceStyle is a text style, the image style data in this struct will be cleared if
	 *								bClearUnusedData is TRUE, or left alone if FALSE
	 */
	void InitializeStyleDataContainer( class UUIStyle_Data* SourceStyle, UBOOL bClearUnusedData=TRUE );

	/**
	 * Determines if this style data container has been initialized.
	 *
	 * @return	TRUE if either DrawFont or FallbackImage is set.
	 */
	UBOOL IsInitialized() const { return bInitialized; }

};

struct FUIStringNodeModifier
{
    struct FModifierData
    {
        class UUIStyle_Data* Style;
        TArray<class UFont*> InlineFontStack;

        /** Constructors */
        FModifierData()
        : Style(NULL)
        {}
        FModifierData(EEventParm)
        {
            appMemzero(this, sizeof(FModifierData));
        }
    };

private:
    struct FUICombinedStyleData CustomStyleData;
    struct FUICombinedStyleData BaseStyleData;
    TArray<struct FModifierData> ModifierStack;
    class UUIState* CurrentMenuState;
public:

	/**
	 * Constructor
	 *
	 * @param	SourceStyle		the style to use for initializing the CustomStyleData member;  normally the UIString's DefaultStringStyle
	 * @param	MenuState		the current menu state of the widget that owns the UIString.
	 */
	FUIStringNodeModifier( class UUIStyle_Data* SourceStyle, class UUIState* MenuState );
	FUIStringNodeModifier( const struct FUICombinedStyleData& SourceStyleData, class UUIState* MenuState );

	/** Copy constructor */
	FUIStringNodeModifier( const struct FUIStringNodeModifier& Other );

	/**
	 * Adds the specified font to the InlineFontStack of the current ModifierData, then updates the DrawFont of CustomStyleData to point to the new font
	 *
	 * @param	NewFont	the font to use when creating new string nodes
	 *
	 * @return	TRUE if the specified font was successfully added to the list.
	 */
	UBOOL AddFont( class UFont* NewFont );

	/**
	 * Removes a font from the InlineFontStack of the current ModifierData.  If the font that was removed was the style data container's
	 * current DrawFont, updates CustomStyleData's font as well.
	 *
	 * @param	FontToRemove	if specified, the font to remove.  If NULL, removes the font at the top of the stack.
	 *
	 * @return	TRUE if the font was successfully removed from the InlineFontStack.  FALSE if the font wasn't part of the InlineFontStack
	 */
	UBOOL RemoveFont( class UFont* FontToRemove=NULL );

	/**
	 * Adds a new element to the ModifierStack using the specified style, then reinitializes the CustomStyleData with the values from this style.
	 *
	 * @param	NewStyle	the style to add to the stack
	 *
	 * @return	TRUE if the specified style was successfully added to the list.
	 */
	UBOOL AddStyle( class UUIStyle_Data* NewStyle );

	/**
	 * Removes the element containing StyleToRemove from ModifierStack.  If the style that was removed was style at the top of the StyleStack,
	 * reinitializes CustomStyleData with the style data from the previous style in the stack.
	 *
	 * @param	StyleToRemove	if specified, the style to remove.  If NULL, removes the style at the top of the stack.
	 *
	 * @return	TRUE if the style was successfully removed from the ModifierStack.  FALSE if the style wasn't part of the ModifierStack or it
	 *			was the last node in the ModifierStack (which cannot be removed).
	 */
	UBOOL RemoveStyle( class UUIStyle_Data* StyleToRemove=NULL );

	/**
	 * Returns the location of the ModifierData that contains the specified style.
	 *
	 * @param	SearchStyle	the style to search for
	 *
	 * @return	an index into the ModifierStack array for the ModifierData that contains the specified style, or INDEX_NONE
	 *			if there are no elements referencing that style.
	 */
	INT FindModifierIndex( class UUIStyle_Data* SearchStyle );

	/**
	 * Returns the style data contained by this string customizer
	 */
	const struct FUICombinedStyleData& GetCustomStyleData() const;

	/**
	 * Returns the configured menu state.
	 */
	class UUIState* GetMenuState() { return CurrentMenuState; }

	/**
	 * Sets the Custom Text Color to use
	 *
	 * @param	CustomTextColor		The linear color to use
	 */
	void SetCustomTextColor(FLinearColor CustomTextColor);

	/**
	 * returns the current text color
	 */
	FLinearColor GetCustomTextColor();



};

struct FUIStringNode
{
    class UUIDataStore* NodeDataStore;
    FUIStringNode* ParentNode;
    FString SourceText;
    FVector2D Extent;
    FVector2D Scaling;
    BITFIELD bForceWrap:1;

	/** Constructor */
	FUIStringNode( const TCHAR* inSourceText )
	: NodeDataStore(NULL), ParentNode(NULL)
	, SourceText(inSourceText), Extent(0.f,0.f)
	, Scaling(1.f,1.f), bForceWrap(FALSE)
	{}

	/** Destructor */
	virtual ~FUIStringNode() {}

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle )=0;

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData )=0;

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight )=0;

	/**
	 * Returns the value of this UIStringNode
	 *
	 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
	 *								The raw value will contain any markup; the processed string will be text only.
	 *								Any image tokens are converted to their text counterpart.
	 *
	 * @return	the value of this UIStringNode, or NULL if this node has no value
	 */
	virtual const TCHAR* GetValue( UBOOL bProcessedValue ) const;

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {};

	// UObject interface.
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects ) {};

	/** Serializers */
	friend FArchive& operator<<( FArchive& Ar, FUIStringNode& StringNode);
	virtual void Serialize( FArchive& Ar ) {};

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const=0;
	virtual UBOOL IsImageNode() const=0;
	virtual UBOOL IsNestParent() const { return FALSE; }
	virtual UBOOL IsFormattingParent() const { return FALSE; }

	/**
	 * Determines whether this node was created to contain additional text as a result of wrapping, clipping, or nested markup resolution.
	 *
	 * @param	SearchParent	if specified, will iterate up the ParentNode chain to determine whether this string node is a direct or indirect
	 *							slave of the specified parent node.
	 */
	UBOOL IsSlaveNode( struct FUIStringNode* SearchParent=NULL ) const;

};

struct FUIStringNode_Text : public FUIStringNode
{
    FString RenderedText;
protected:
    struct FUICombinedStyleData NodeStyleParameters;
public:

	FUIStringNode_Text( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText)
	{}

	/** Conversion constructor - copies the data from a formatting parent to a text node */
	FUIStringNode_Text( const struct FUIStringNode_FormattedNodeParent& SourceNode );

	/**
	 * Initializes this node's style data
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

	/**
	 * Return the style data for this node.
	 */
	virtual struct FUICombinedStyleData& GetNodeStyleData();

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	/**
	 * Assigns the RenderedText to the value specified, and recalculates the extent for this node.
	 */
	void SetRenderText( const TCHAR* NewRenderText );

	/**
	 * Returns the value of this UIStringNode
	 *
	 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
	 *								The raw value will contain any markup; the processed string will be text only.
	 *								Any image tokens are converted to their text counterpart.
	 *
	 * @return	the value of this UIStringNode, or NULL if this node has no value
	 */
	virtual const TCHAR* GetValue( UBOOL bProcessedValue ) const;

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

	/**
	 * Determines whether this node contains only modification markup.
	 */
	UBOOL IsModifierNode() const;

	// UObject interface
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

	/**
	 * Serializer
	 */
	virtual void Serialize( FArchive& Ar )
	{
		Ar << RenderedText << NodeStyleParameters;
	}

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const { return TRUE; }
	virtual UBOOL IsImageNode() const { return FALSE; }

};

struct FUIStringNode_Image : public FUIStringNode
{
    FVector2D ForcedExtent;
    struct FTextureCoordinates TexCoords;
    class UUITexture* RenderedImage;

	FUIStringNode_Image( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText), ForcedExtent(0.f,0.f), RenderedImage(NULL)
	{}

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

	// UObject interface
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

	/**
	 * Serializer
	 */
	virtual void Serialize( FArchive& Ar )
	{
		Ar << (UObject*&)RenderedImage;
	}

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const { return FALSE; }
	virtual UBOOL IsImageNode() const { return TRUE; }

};

struct FUIStringNode_NestedMarkupParent : public FUIStringNode
{

	/* === UIStringNode_NestedMarkupParent interface === */
	FUIStringNode_NestedMarkupParent( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText)
	{}


	/** === UIStringNode interface === */

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle ) {};

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData ) {};

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	virtual UBOOL IsTextNode() const { return FALSE; }
	virtual UBOOL IsImageNode() const { return FALSE; }
	virtual UBOOL IsNestParent() const { return TRUE; }

};

struct FUIStringNode_FormattedNodeParent : public FUIStringNode_Text
{

	/** constructor */
	FUIStringNode_FormattedNodeParent( struct FUIStringNode_Text& SourceNode );

	/**
	 * UIString_WrappedNodeParent is never rendered, so the extent for this node type is always 0.
	 */
	virtual void CalculateExtent( FLOAT Unused ) { Extent.X = Extent.Y = 0.f; }

	/**
	 * UIString_WrappedNodeParent is never rendered.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {}

	virtual UBOOL IsFormattingParent() const { return TRUE; }

};

struct FWrappedStringElement
{
    FString Value;
    FVector2D LineExtent;

	/** Constructor */
	FWrappedStringElement( const TCHAR* InValue, FLOAT Width, FLOAT Height )
	: Value(InValue), LineExtent(Width,Height)
	{}

};

struct FUIMouseCursor
{
    FName CursorStyle;
    class UUITexture* Cursor;
    friend FArchive& operator<<(FArchive& Ar,FUIMouseCursor& MyUIMouseCursor)
    {
        return Ar << MyUIMouseCursor.CursorStyle << (UObject*&)MyUIMouseCursor.Cursor;
    }
};

struct FInputEventParameters
{
    INT PlayerIndex;
    INT ControllerId;
    FName InputKeyName;
    BYTE EventType;
    FLOAT InputDelta;
    FLOAT DeltaTime;
    BITFIELD bAltPressed:1;
    BITFIELD bCtrlPressed:1;
    BITFIELD bShiftPressed:1;

	/** Default constructor */
	FInputEventParameters();

	/** Input Key Event constructor */
	FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

	/** Input Axis Event constructor */
	FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

};

struct FSubscribedInputEventParameters : public FInputEventParameters
{
    FName InputAliasName;

	/** Default constructor */
	FSubscribedInputEventParameters();

	/** Input Key Event constructor */
	FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, FName InInputAliasName, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

	/** Input Axis Event constructor */
	FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FName InInputAliasName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

	/** Copy constructor */
	FSubscribedInputEventParameters( const FSubscribedInputEventParameters& Other );
	FSubscribedInputEventParameters( const FInputEventParameters& Other, FName InInputAliasName );

};

struct FUIAxisEmulationDefinition
{
    FName AxisInputKey;
    FName AdjacentAxisInputKey;
    BITFIELD bEmulateButtonPress:1;
    FName InputKeyToEmulate[2];
};

struct FRawInputKeyEventData
{
    FName InputKeyName;
    BYTE ModifierKeyFlags;
    friend FArchive& operator<<(FArchive& Ar,FRawInputKeyEventData& MyRawInputKeyEventData)
    {
        return Ar << MyRawInputKeyEventData.InputKeyName << MyRawInputKeyEventData.ModifierKeyFlags;
    }

	/** Constructors */
	FRawInputKeyEventData() {}
	FRawInputKeyEventData(EEventParm)
	{
		appMemzero(this, sizeof(FRawInputKeyEventData));
	}

	explicit FRawInputKeyEventData( FName InKeyName, BYTE InModifierFlags=(KEYMODIFIER_AltExcluded|KEYMODIFIER_CtrlExcluded|KEYMODIFIER_ShiftExcluded) )
	: InputKeyName(InKeyName), ModifierKeyFlags(InModifierFlags)
	{}

	FRawInputKeyEventData( const FRawInputKeyEventData& Other )
	: InputKeyName(Other.InputKeyName), ModifierKeyFlags(Other.ModifierKeyFlags)
	{}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FRawInputKeyEventData& Other ) const
	{
		return InputKeyName == Other.InputKeyName && ModifierKeyFlags == Other.ModifierKeyFlags;
	}
	FORCEINLINE UBOOL operator!=( const FRawInputKeyEventData& Other ) const
	{
		return InputKeyName != Other.InputKeyName || ModifierKeyFlags != Other.ModifierKeyFlags;
	}
	/** Required in order for FRawInputKeyEventData to be used as the key in a map */
	friend inline DWORD GetTypeHash( const FRawInputKeyEventData& KeyEvt )
	{
		return GetTypeHash(KeyEvt.InputKeyName);
	}

	/**
	 * Applies the specified modifier key bitmask to ModifierKeyFlags
	 */
	FORCEINLINE void SetModifierKeyFlags( BYTE ModifierFlags )
	{
		ModifierKeyFlags |= ModifierFlags;
	}
	/** Clears the specified modifier key bitmask from ModifierKeyFlags */
	FORCEINLINE void ClearModifierKeyFlags( BYTE ModifierFlags )
	{
		ModifierKeyFlags &= ~ModifierFlags;
	}

	/**
	 * Returns TRUE if ModifierKeyFlags contains any of the bits in FlagsToCheck.
	 */
	FORCEINLINE UBOOL HasAnyModifierKeyFlags( BYTE FlagsToCheck ) const
	{
		return (ModifierKeyFlags&FlagsToCheck) != 0 || FlagsToCheck == KEYMODIFIER_All;
	}

	/**
	 * Returns TRUE if ModifierKeyFlags contains all of the bits in FlagsToCheck
	 */
	FORCEINLINE UBOOL HasAllModifierFlags( BYTE FlagsToCheck ) const
	{
		return (ModifierKeyFlags&FlagsToCheck) == FlagsToCheck;
	}

};

struct FUIInputActionAlias
{
    FName InputAliasName;
    TArrayNoInit<FName> InputKeyNames;
    TArrayNoInit<struct FRawInputKeyEventData> LinkedInputKeys;
    friend FArchive& operator<<(FArchive& Ar,FUIInputActionAlias& MyUIInputActionAlias)
    {
        return Ar << MyUIInputActionAlias.InputAliasName << MyUIInputActionAlias.InputKeyNames << MyUIInputActionAlias.LinkedInputKeys;
    }

    /** Constructors */
    FUIInputActionAlias() {}
    FUIInputActionAlias(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputActionAlias));
    }
};

struct FUIInputAliasValue
{
    BYTE ModifierFlagMask;
    FName InputAliasName;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasValue& MyUIInputAliasValue)
    {
        return Ar << MyUIInputAliasValue.ModifierFlagMask << MyUIInputAliasValue.InputAliasName;
    }

	FUIInputAliasValue()
	: ModifierFlagMask(0), InputAliasName(NAME_None)
	{}

	FUIInputAliasValue( BYTE InModifierFlagMask, const FName& inAliasName )
	: ModifierFlagMask(InModifierFlagMask), InputAliasName(inAliasName)
	{}
	FUIInputAliasValue(EEventParm)
	{
		appMemzero(this, sizeof(FUIInputAliasValue));
	}

	/**
	 * Returns FALSE if this input alias value's ModifierFlagMask disallows the provided modifier key states.
	 */
	UBOOL MatchesModifierState( UBOOL bAltPressed, UBOOL bCtrlPressed, UBOOL bShiftPressed ) const;

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIInputAliasValue& Other ) const
	{
		return InputAliasName == Other.InputAliasName && ModifierFlagMask == Other.ModifierFlagMask;
	}
	FORCEINLINE UBOOL operator!=( const FUIInputAliasValue& Other ) const
	{
		return InputAliasName != Other.InputAliasName || ModifierFlagMask != Other.ModifierFlagMask;
	}

};

struct FUIInputAliasMap
{
    TMultiMap< FName, FUIInputAliasValue > InputAliasLookupTable;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasMap& MyUIInputAliasMap)
    {
        return Ar << MyUIInputAliasMap.InputAliasLookupTable;
    }

	/** Constructors */
    FUIInputAliasMap() {}
    FUIInputAliasMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputAliasMap));
    }

};

struct FUIInputAliasStateMap
{
    FStringNoInit StateClassName;
    class UClass* State;
    TArrayNoInit<struct FUIInputActionAlias> StateInputAliases;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasStateMap& MyUIInputAliasStateMap)
    {
        return Ar << MyUIInputAliasStateMap.StateClassName << (UObject*&)MyUIInputAliasStateMap.State << MyUIInputAliasStateMap.StateInputAliases;
    }

    /** Constructors */
    FUIInputAliasStateMap() {}
    FUIInputAliasStateMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputAliasStateMap));
    }
};

struct FUIInputAliasClassMap
{
    FStringNoInit WidgetClassName;
    class UClass* WidgetClass;
    TArrayNoInit<struct FUIInputAliasStateMap> WidgetStates;
    TMap< UClass*,  FUIInputAliasMap > StateLookupTable;
    TMap< UClass*,  TArray<const FUIInputAliasStateMap*> > StateReverseLookupTable;

		/** Constructors */
	    FUIInputAliasClassMap() {}
	    FUIInputAliasClassMap(EEventParm)
	    {
	        appMemzero(this, sizeof(FUIInputAliasClassMap));
	    }

		/**
		 * Initializes the runtime lookup table with the aliases stored in WidgetInputAliases
		 *
		 * @param	InputAliasList	the list of input alias mappings for all registered UI classes.
		 */
		void InitializeLookupTable( const TMap<UClass*,FUIInputAliasClassMap*>& InputAliasList );
	
};

#define UCONST_MAX_SUPPORTED_GAMEPADS 4
#define UCONST_SCENE_DATASTORE_TAG SceneData
#define UCONST_DEFAULT_SIZE_Y 600
#define UCONST_DEFAULT_SIZE_X 800
#define UCONST_ASPECTRATIO_Widescreen 1.777778f
#define UCONST_ASPECTRATIO_Monitor 1.25f
#define UCONST_ASPECTRATIO_Normal 1.333333f
#define UCONST_PRIVATE_Protected 0x380
#define UCONST_PRIVATE_EditorNoReparent 0x200
#define UCONST_PRIVATE_EditorNoRename 0x100
#define UCONST_PRIVATE_EditorNoDelete 0x080
#define UCONST_PRIVATE_TreeHiddenRecursive 0x042
#define UCONST_PRIVATE_ManagedStyle 0x020
#define UCONST_PRIVATE_NotRotatable 0x010
#define UCONST_PRIVATE_NotDockable 0x008
#define UCONST_PRIVATE_NotFocusable 0x004
#define UCONST_PRIVATE_TreeHidden 0x002
#define UCONST_PRIVATE_NotEditorSelectable 0x001
#define UCONST_TEMP_SPLITSCREEN_INDEX 0

class UUIRoot : public UObject
{
public:
    //## BEGIN PROPS UIRoot
    //## END PROPS UIRoot

    UBOOL SetDataStoreFieldValue(const FString& InDataStoreMarkup,const struct FUIProviderFieldValue& InFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    UBOOL GetDataStoreFieldValue(const FString& InDataStoreMarkup,struct FUIProviderFieldValue& OutFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    DECLARE_FUNCTION(execGetCurrentUIController);
    DECLARE_FUNCTION(execGetSceneClient);
    DECLARE_FUNCTION(execGetFaceOrientation);
    DECLARE_FUNCTION(execGetCursorPosition);
    DECLARE_FUNCTION(execGetCursorSize);
    DECLARE_FUNCTION(execSetMouseCaptureOverride);
    DECLARE_FUNCTION(execGetPrimitiveTransform);
    DECLARE_FUNCTION(execSetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,InFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=SetDataStoreFieldValue(InDataStoreMarkup,InFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_FUNCTION(execGetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,OutFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=GetDataStoreFieldValue(InDataStoreMarkup,OutFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_ABSTRACT_CLASS(UUIRoot,UObject,0,Engine)
	/**
	 * Given a face, return the opposite face.
	 *
	 * @return	the EUIWidgetFace member corresponding to the opposite face of the input value, or UIFACE_MAX if the input
	 *			value is invalid.
	 */
	static EUIWidgetFace GetOppositeFace( BYTE Face );

	/**
	 * Returns the friendly name of for the specified face from the EUIWidgetFace enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDockFaceText( BYTE Face );

	/**
	 * Returns the friendly name for the specified input event from the EInputEvent enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputEventText( BYTE InputEvent );

	/**
	 * Returns the friendly name for the specified cell state from the UIListElementState enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetCellStateText( BYTE CellState );

	/**
	 * Returns the friendly name for the specified field type from the UIDataProviderFieldType enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDataProviderFieldTypeText( BYTE FieldType );

	/**
	 * Wrapper for returns the orientation associated with the specified face.
	 */
	static EUIOrientation GetFaceOrientation( BYTE Face );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorPosition	receives the position of the cursor
	 * @param	Scene			if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *							for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( FVector2D& CursorPosition, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorX		receives the X position of the cursor
	 * @param	CursorY		receives the Y position of the cursor
	 * @param	Scene		if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *						for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( INT& CursorX, INT& CursorY, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorXL	receives the width of the cursor
	 * @param	CursorYL	receives the height of the cursor
	 *
	 * @return	TRUE if the cursor size was retrieved correctly.
	 */
	static UBOOL GetCursorSize( FLOAT& CursorXL, FLOAT& CursorYL );

	/**
	 * Changes the value of GameViewportClient.bUIMouseCaptureOverride to the specified value.  Used by widgets that process
	 * dragging to ensure that the widget receives the mouse button release event.
	 *
	 * @param	bCaptureMouse	whether to capture all mouse input.
	 */
	static void SetMouseCaptureOverride( UBOOL bCaptureMouse );

	/**
	 * @return	TRUE if the specified key is a mouse key
	 */
	static UBOOL IsCursorInputKey( FName KeyName );

	/**
	 * Returns the UIController class set for this game.
	 *
	 * @return	a pointer to a UIInteraction class which is set as the value for GameViewportClient.UIControllerClass.
	 */
	static class UClass* GetUIControllerClass();

	/**
	 * Returns the default object for the UIController class set for this game.
	 *
	 * @return	a pointer to the CDO for UIInteraction class configured for this game.
	 */
	static class UUIInteraction* GetDefaultUIController();

	/**
	 * Returns the UIInteraction instance currently controlling the UI system, which is valid in game.
	 *
	 * @return	a pointer to the UIInteraction object currently controlling the UI system.
	 */
	static class UUIInteraction* GetCurrentUIController();

	/**
	 * Returns the game's scene client.
	 *
	 * @return 	a pointer to the UGameUISceneClient instance currently managing the scenes for the UI System.
	 */
	static class UGameUISceneClient* GetSceneClient();

	/**
	 * Resolves a data store from markup.
	 *
	 * @param	DatafieldMarkupString	The markup string to resolve
	 * @param	InOwnerScene			The scene to use (can be null)
	 * @param	InOwnerPlayer			The local player to use (can be null)
	 * @param	out_ResolvedProvider	The provider associated with the markup
	 * @param 	out_DataFieldName		The Datafield associated with the markup
	 * @param	out_ResolvedDataStore	The resolved data store
	 *
	 */
	static UBOOL ResolveDataStoreMarkup(const FString &DataFieldMarkupString, UUIScene* InOwnerScene, ULocalPlayer* InOwnerPlayer,
					class UUIDataProvider*& out_ResolvedProvider, FString& out_DataFieldName, class UUIDataStore** out_ResolvedDataStore=NULL );

	/**
	 * Returns a matrix which includes the translation, rotation and scale necessary to transform a point from origin to the
	 * the specified widget's position onscreen.  This matrix can then be passed to ConditionalUpdateTransform() for primitives
	 * in use by the UI.
	 *
	 * @param	Widget					the widget to generate the matrix for
	 * @param	bIncludeAnchorPosition	specify TRUE to include translation to the widget's anchor; if FALSE, the translation will move
	 *									the point to the widget's upper left corner (in local space)
	 * @param	bIncludeRotation		specify FALSE to remove the widget's rotation from the resulting matrix
	 * @param	bIncludeScale			specify FALSE to remove the viewport's scale from the resulting matrix
	 *
	 * @return	a matrix which can be used to translate from origin (0,0) to the widget's position, including rotation and viewport scale.
	 */
	static class FMatrix GetPrimitiveTransform( UUIObject* Widget, UBOOL bIncludeAnchorPosition=FALSE, UBOOL bIncludeRotation=TRUE, UBOOL bIncludeScale=TRUE );
};

struct FPlayerDataStoreGroup
{
    class ULocalPlayer* PlayerOwner;
    TArray<class UUIDataStore*> DataStores;

    /** Constructors */
    FPlayerDataStoreGroup()
    : PlayerOwner(NULL)
    {}
    FPlayerDataStoreGroup(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDataStoreGroup));
    }
};

class UDataStoreClient : public UUIRoot
{
public:
    //## BEGIN PROPS DataStoreClient
    TArrayNoInit<FString> GlobalDataStoreClasses;
    TArrayNoInit<class UUIDataStore*> GlobalDataStores;
    TArrayNoInit<FString> PlayerDataStoreClassNames;
    TArrayNoInit<class UClass*> PlayerDataStoreClasses;
    TArrayNoInit<struct FPlayerDataStoreGroup> PlayerDataStores;
    //## END PROPS DataStoreClient

    class UUIDataStore* FindDataStore(FName DataStoreTag,class ULocalPlayer* PlayerOwner=NULL);
    class UUIDataStore* CreateDataStore(class UClass* DataStoreClass);
    UBOOL RegisterDataStore(class UUIDataStore* DataStore,class ULocalPlayer* PlayerOwner=NULL);
    UBOOL UnregisterDataStore(class UUIDataStore* DataStore);
    void GetAvailableDataStores(class UUIScene* CurrentScene,TArray<class UUIDataStore*>& out_DataStores) const;
    INT FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner) const;
    DECLARE_FUNCTION(execFindDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=FindDataStore(DataStoreTag,PlayerOwner);
    }
    DECLARE_FUNCTION(execCreateDataStore)
    {
        P_GET_OBJECT(UClass,DataStoreClass);
        P_FINISH;
        *(class UUIDataStore**)Result=CreateDataStore(DataStoreClass);
    }
    DECLARE_FUNCTION(execRegisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(UBOOL*)Result=RegisterDataStore(DataStore,PlayerOwner);
    }
    DECLARE_FUNCTION(execUnregisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_FINISH;
        *(UBOOL*)Result=UnregisterDataStore(DataStore);
    }
    DECLARE_FUNCTION(execGetAvailableDataStores)
    {
        P_GET_OBJECT(UUIScene,CurrentScene);
        P_GET_TARRAY_REF(class UUIDataStore*,out_DataStores);
        P_FINISH;
        GetAvailableDataStores(CurrentScene,out_DataStores);
    }
    DECLARE_FUNCTION(execFindPlayerDataStoreIndex)
    {
        P_GET_OBJECT(ULocalPlayer,PlayerOwner);
        P_FINISH;
        *(INT*)Result=FindPlayerDataStoreIndex(PlayerOwner);
    }
    DECLARE_CLASS(UDataStoreClient,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Loads each of the classes from the GlobalDataStoreClasses array, creates an instance of that class, and stores
	 * that instance in the GlobalDataStores array.
	 */
	virtual void InitializeDataStores();
};

struct Interaction_eventOnInitialize_Parms
{
    Interaction_eventOnInitialize_Parms(EEventParm)
    {
    }
};
struct Interaction_eventTick_Parms
{
    FLOAT DeltaTime;
    Interaction_eventTick_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputChar_Parms
{
    INT ControllerId;
    FString Unicode;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputChar_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputAxis_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputKey_Parms(EEventParm)
    {
    }
};
class UInteraction : public UUIRoot
{
public:
    //## BEGIN PROPS Interaction
    FScriptDelegate __OnReceivedNativeInputKey__Delegate;
    FScriptDelegate __OnReceivedNativeInputAxis__Delegate;
    FScriptDelegate __OnReceivedNativeInputChar__Delegate;
    FScriptDelegate __OnInitialize__Delegate;
    //## END PROPS Interaction

    DECLARE_FUNCTION(execInit);
    void delegateOnInitialize()
    {
        ProcessDelegate(ENGINE_OnInitialize,&__OnInitialize__Delegate,NULL);
    }
    void eventTick(FLOAT DeltaTime)
    {
        Interaction_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    UBOOL delegateOnReceivedNativeInputChar(INT ControllerId,const FString& Unicode)
    {
        Interaction_eventOnReceivedNativeInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.Unicode=Unicode;
        ProcessDelegate(ENGINE_OnReceivedNativeInputChar,&__OnReceivedNativeInputChar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputAxis,&__OnReceivedNativeInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed=1.000000,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputKey,&__OnReceivedNativeInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UInteraction,UUIRoot,0|CLASS_Transient,Engine)
	/**
	 * Minimal initialization constructor.
	 */
	UInteraction();

	/**
	 * Called when the interaction is added to the GlobalInteractions array.  You must always call Super::Init() so that
	 * unrealscript receives the OnInitialize delegate call.
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime)
	{
		eventTick(DeltaTime);
	}

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process an input axis (joystick, thumbstick, or mouse) event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process a character input event (typing) received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	Character		the character that was typed
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character)
	{
		return FALSE;
	}
public:
};

#define UCONST_MaxHistory 16

struct Console_eventOutputText_Parms
{
    FString Text;
    Console_eventOutputText_Parms(EEventParm)
    {
    }
};
class UConsole : public UInteraction
{
public:
    //## BEGIN PROPS Console
    class ULocalPlayer* ConsoleTargetPlayer;
    class UUIScene* LargeConsoleScene;
    class UUIScene* MiniConsoleScene;
    class UUILabel* ConsoleBufferText;
    class UConsoleEntry* MiniConsoleInput;
    class UConsoleEntry* LargeConsoleInput;
    class UTexture2D* DefaultTexture_Black;
    class UTexture2D* DefaultTexture_White;
    FName ConsoleKey;
    FName TypeKey;
    INT MaxScrollbackSize;
    TArrayNoInit<FString> Scrollback;
    INT SBHead;
    INT SBPos;
    INT HistoryTop;
    INT HistoryBot;
    INT HistoryCur;
    FStringNoInit History[16];
    FStringNoInit TypedStr;
    INT TypedStrPos;
    BITFIELD bIgnoreKeys:1;
    BITFIELD bCtrl:1;
    BITFIELD bEnableUI:1;
    //## END PROPS Console

    void eventOutputText(const FString& Text)
    {
        Console_eventOutputText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(ENGINE_OutputText),&Parms);
    }
    DECLARE_CLASS(UConsole,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

    NO_DEFAULT_CONSTRUCTOR(UConsole)
};

struct FKeyBind
{
    FName Name;
    FStringNoInit Command;
    BITFIELD Control:1;
    BITFIELD Shift:1;
    BITFIELD Alt:1;

	FKeyBind()
	: Name()
	, Control(0)
	, Shift(0)
	, Alt(0)
	{}

};

class UInput : public UInteraction
{
public:
    //## BEGIN PROPS Input
    TArrayNoInit<struct FKeyBind> Bindings;
    TArrayNoInit<FName> PressedKeys;
    BYTE CurrentEvent;
    FLOAT CurrentDelta;
    FLOAT CurrentDeltaTime;
    TMap< FName,void* > NameToPtr;
    TArray<FLOAT*> AxisArray;
    //## END PROPS Input

    DECLARE_CLASS(UInput,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	// UInteraction interface.

	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual void Tick(FLOAT DeltaTime);
	UBOOL IsPressed( FName InKey ) const;
	UBOOL IsCtrlPressed() const;
	UBOOL IsShiftPressed() const;
	UBOOL IsAltPressed() const;

	// UInput interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
	virtual void ResetInput();

	/**
	 * Clears the PressedKeys array.  Should be called when another interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys()
	{
		PressedKeys.Empty();
	}

	// Protected.

	BYTE* FindButtonName(const TCHAR* ButtonName);
	FLOAT* FindAxisName(const TCHAR* ButtonName);
	FString GetBind(FName Key) const;
	/**
	 * Returns the Name of a bind using the bind's Command as the key
	 * StartBind Index is where the search will start from and where the index result will be stored
	 *   -- If you don't where to start your search from (as the list will search backwards), set the StartBindIndex to -1 before passing it in
	 */
	FString GetBindNameFromCommand(const FString& KeyCommand, INT* StartBindIndex = NULL ) const;
	void ExecInputCommands(const TCHAR* Cmd,class FOutputDevice& Ar);
	virtual void UpdateAxisValue( FLOAT* Axis, FLOAT Delta );
};

struct PlayerInput_eventPlayerInput_Parms
{
    FLOAT DeltaTime;
    PlayerInput_eventPlayerInput_Parms(EEventParm)
    {
    }
};
class UPlayerInput : public UInput
{
public:
    //## BEGIN PROPS PlayerInput
    BITFIELD bUsingGamepad:1;
    BITFIELD bInvertMouse:1;
    BITFIELD bInvertTurn:1;
    BITFIELD bWasForward:1;
    BITFIELD bWasBack:1;
    BITFIELD bWasLeft:1;
    BITFIELD bWasRight:1;
    BITFIELD bEdgeForward:1;
    BITFIELD bEdgeBack:1;
    BITFIELD bEdgeLeft:1;
    BITFIELD bEdgeRight:1;
    BITFIELD bEnableMouseSmoothing:1;
    BITFIELD bEnableFOVScaling:1;
    FName LastAxisKeyName;
    FLOAT DoubleClickTimer;
    FLOAT DoubleClickTime;
    FLOAT MouseSensitivity;
    FLOAT aBaseX;
    FLOAT aBaseY;
    FLOAT aBaseZ;
    FLOAT aMouseX;
    FLOAT aMouseY;
    FLOAT aForward;
    FLOAT aTurn;
    FLOAT aStrafe;
    FLOAT aUp;
    FLOAT aLookUp;
    FLOAT aPS3AccelX;
    FLOAT aPS3AccelY;
    FLOAT aPS3AccelZ;
    FLOAT aPS3Gyro;
    FLOAT RawJoyUp;
    FLOAT RawJoyRight;
    FLOAT RawJoyLookRight;
    FLOAT RawJoyLookUp;
    FLOAT MoveForwardSpeed;
    FLOAT MoveStrafeSpeed;
    FLOAT LookRightScale;
    FLOAT LookUpScale;
    BYTE bStrafe;
    BYTE bXAxis;
    BYTE bYAxis;
    FLOAT ZeroTime[2];
    FLOAT SmoothedMouse[2];
    INT MouseSamples;
    FLOAT MouseSamplingTotal;
    //## END PROPS PlayerInput

    void eventPlayerInput(FLOAT DeltaTime)
    {
        PlayerInput_eventPlayerInput_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerInput),&Parms);
    }
    DECLARE_CLASS(UPlayerInput,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(APlayerController)
	/**
	 * Generates an IE_Released event for each key in the PressedKeys array, then clears the array.  Should be called when another
	 * interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys();

	/** Override to detect input from a gamepad */
	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual void  UpdateAxisValue( FLOAT* Axis, FLOAT Delta );

};

class UPlayerManagerInteraction : public UInteraction
{
public:
    //## BEGIN PROPS PlayerManagerInteraction
    //## END PROPS PlayerManagerInteraction

    DECLARE_CLASS(UPlayerManagerInteraction,UInteraction,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UGameViewportClient)
	/* === UInteraction interface === */
	/**
	 * Routes an input key event to the player's interactions array
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Routes an axis input event to the player's interactions array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Routes a character input to the player's Interaction array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);
};

struct FUIKeyRepeatData
{
    FName CurrentRepeatKey;
    FLOAT NextRepeatTime;

    /** Constructors */
	FUIKeyRepeatData()
	: CurrentRepeatKey(NAME_None)
	, NextRepeatTime(0.f)
	{}

};

struct FUIAxisEmulationData : public FUIKeyRepeatData
{
    BITFIELD bEnabled:1;

    /** Constructors */
	FUIAxisEmulationData()
	: FUIKeyRepeatData(), bEnabled(TRUE)
	{}

	/**
	 * Toggles whether this axis emulation is enabled.
	 */
	void EnableAxisEmulation( UBOOL bShouldEnable )
	{
		if ( bEnabled != bShouldEnable )
		{
			bEnabled = bShouldEnable;
			CurrentRepeatKey = NAME_None;
			NextRepeatTime = 0.f;
		}
	}

};

#define UCONST_DEFAULT_UISKIN TEXT("DefaultUISkin.DefaultSkin")

class UUIInteraction : public UInteraction, public FExec, public FGlobalDataStoreClientManager
{
public:
    //## BEGIN PROPS UIInteraction
    class UClass* SceneClientClass;
    class UGameUISceneClient* SceneClient;
    FStringNoInit UISkinName;
    TArrayNoInit<FName> UISoundCueNames;
    TArrayNoInit<FName> SupportedDoubleClickKeys;
    class UDataStoreClient* DataStoreManager;
private:
    class UUIInputConfiguration* UIInputConfig;
public:
    TMap< UClass*,struct FUIInputAliasClassMap* > WidgetInputAliasLookupTable;
    BITFIELD bProcessInput:1;
    BITFIELD bDisableToolTips:1;
    BITFIELD bFocusOnActive:1;
    BITFIELD bCaptureUnprocessedInput:1;
    FLOAT UIJoystickDeadZone;
    FLOAT UIAxisMultiplier;
    FLOAT AxisRepeatDelay;
    FLOAT MouseButtonRepeatDelay;
    FLOAT DoubleClickTriggerSeconds;
    INT DoubleClickPixelTolerance;
    FLOAT ToolTipInitialDelaySeconds;
    FLOAT ToolTipExpirationSeconds;
    struct FUIKeyRepeatData MouseButtonRepeatInfo;
    TMap< FName,struct FUIAxisEmulationDefinition > AxisEmulationDefinitions;
    struct FUIAxisEmulationData AxisInputEmulation[4];
    class FCanvasScene* CanvasScene;
    BITFIELD bIsUIPrimitiveSceneInitialized:1;
    //## END PROPS UIInteraction

    UBOOL PlayUISound(FName SoundCueName,INT PlayerIndex=0);
    class UUIObject* CreateTransientWidget(class UClass* WidgetClass,FName WidgetTag,class UUIObject* Owner=NULL);
    class UUIScene* CreateScene(class UClass* SceneClass,FName SceneTag=NAME_None);
    DECLARE_FUNCTION(execGetPlayerCount);
    DECLARE_FUNCTION(execGetPlayerIndex);
    DECLARE_FUNCTION(execGetPlayerControllerId);
    DECLARE_FUNCTION(execGetDataStoreClient);
    DECLARE_FUNCTION(execPlayUISound)
    {
        P_GET_NAME(SoundCueName);
        P_GET_INT_OPTX(PlayerIndex,0);
        P_FINISH;
        *(UBOOL*)Result=PlayUISound(SoundCueName,PlayerIndex);
    }
    DECLARE_FUNCTION(execCreateTransientWidget)
    {
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_NAME(WidgetTag);
        P_GET_OBJECT_OPTX(UUIObject,Owner,NULL);
        P_FINISH;
        *(class UUIObject**)Result=CreateTransientWidget(WidgetClass,WidgetTag,Owner);
    }
    DECLARE_FUNCTION(execCreateScene)
    {
        P_GET_OBJECT(UClass,SceneClass);
        P_GET_NAME_OPTX(SceneTag,NAME_None);
        P_FINISH;
        *(class UUIScene**)Result=CreateScene(SceneClass,SceneTag);
    }
    DECLARE_CLASS(UUIInteraction,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		UObject interface
	======================================= */
	/**
	* Called to finish destroying the object.
	*/
	virtual void FinishDestroy();

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* ==============================================
		FGlobalDataStoreClientManager interface
	============================================== */
	/**
	 * Initializes the singleton data store client that will manage the global data stores.
	 */
	virtual void InitializeGlobalDataStore();

	/* =======================================
		UInteraction interface
	======================================= */
	/**
	 * Called when UIInteraction is added to the GameViewportClient's Interactions array
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UUIInteraction interface
	======================================= */
	/**
	 * Constructor
	 */
	UUIInteraction();

	/**
	 * Cleans up all objects created by this UIInteraction, including unrooting objects and unreferencing any other objects.
	 * Called when the UI system is being closed down (such as when exiting PIE).
	 */
	virtual void TearDownUI();

	/**
	 * Initializes the axis button-press/release emulation map.
	 */
	void InitializeAxisInputEmulations();

	/**
	 * Initializes all of the UI input alias names.
	 */
	void InitializeUIInputAliasNames();

	/**
	 * Initializes all of the UI event key lookup maps.
	 */
	void InitializeInputAliasLookupTable();

	/**
	 * Load the UISkin specified by UISkinName
	 *
	 * @return	a pointer to the UISkin object corresponding to UISkinName, or
	 *			the default UISkin if the configured skin couldn't be loaded
	 */
	class UUISkin* LoadInitialSkin() const;

	/**
	 * Notifies the scene client to render all scenes
	 */
	void RenderUI( FCanvas* Canvas );

	/**
	 * Returns the CDO for the configured scene client class.
	 */
	class UGameUISceneClient* GetDefaultSceneClient() const;

	/**
	 * Returns the UIInputConfiguration singleton, creating one if necessary.
	 */
	class UUIInputConfiguration* GetInputSettings();

	/**
	 * Returns the number of players currently active.
	 */
	static INT GetPlayerCount();

	/**
	 * Retrieves the index (into the Engine.GamePlayers array) for the player which has the ControllerId specified
	 *
	 * @param	ControllerId	the gamepad index of the player to search for
	 *
	 * @return	the index [into the Engine.GamePlayers array] for the player that has the ControllerId specified, or INDEX_NONE
	 *			if no players have that ControllerId
	 */
	static INT GetPlayerIndex( INT ControllerId );

	/**
	 * Returns the index [into the Engine.GamePlayers array] for the player specified.
	 *
	 * @param	Player	the player to search for
	 *
	 * @return	the index of the player specified, or INDEX_NONE if the player is not in the game's list of active players.
	 */
	static INT GetPlayerIndex( class ULocalPlayer* Player );

	/**
	 * Retrieves the ControllerId for the player specified.
	 *
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player to retrieve the ControllerId for
	 *
	 * @return	the ControllerId for the player at the specified index in the GamePlayers array, or INDEX_NONE if the index is invalid
	 */
	static INT GetPlayerControllerId( INT PlayerIndex );

	/**
	 * Returns TRUE if button press/release events should be emulated for the specified axis input.
	 *
	 * @param	AxisKeyName		the name of the axis key that
	 */
	static UBOOL ShouldEmulateKeyPressForAxis( const FName& AxisKeyName );

	/**
	 * Returns a reference to the global data store client, if it exists.
	 *
	 * @return	the global data store client for the game.
	 */
	static class UDataStoreClient* GetDataStoreClient();

	/**
	 * Returns if this UI requires a CanvasScene for rendering 3D primitives
	 *
	 * @return TRUE if 3D primitives are used
	 */
	virtual UBOOL UsesUIPrimitiveScene() const;

	/**
	 * Returns the internal CanvasScene that may be used by this UI
	 *
	 * @return canvas scene or NULL
	 */
	virtual class FCanvasScene* GetUIPrimitiveScene();

	/**
	 * Determine if the canvas scene for primitive rendering needs to be initialized
	 *
	 * @return TRUE if InitUIPrimitiveScene should be called
	 */
	virtual UBOOL NeedsInitUIPrimitiveScene();

	/**
	 * Setup a canvas scene by adding primtives and lights to it from this UI
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void InitUIPrimitiveScene( class FCanvasScene* InCanvasScene );

	/**
	 * Updates the actor components in the canvas scene
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void UpdateUIPrimitiveScene( class FCanvasScene* InCanvasScene );
};

struct FUIAnimationNotify
{
    BYTE NotifyType;
    FName NotifyName;
};

struct FUIAnimationRawData
{
    FLOAT DestAsFloat;
    FLinearColor DestAsColor;
    FRotator DestAsRotator;
    FVector DestAsVector;
    struct FUIAnimationNotify DestAsNotify;
};

struct FUIAnimationKeyFrame
{
    FLOAT TimeMark;
    struct FUIAnimationRawData Data;
};

struct FUIAnimTrack
{
    BYTE TrackType;
    FName TrackWidgetTag;
    TArrayNoInit<struct FUIAnimationKeyFrame> KeyFrames;
    class UUIObject* TargetWidget;

    /** Constructors */
    FUIAnimTrack() {}
    FUIAnimTrack(EEventParm)
    {
        appMemzero(this, sizeof(FUIAnimTrack));
    }
};

struct FUIAnimSeqRef
{
    class UUIAnimationSeq* SeqRef;
    FLOAT PlaybackRate;
    FLOAT AnimTime;
    BITFIELD bIsPlaying:1;
    BITFIELD bIsLooping:1;
    INT LoopCount;
    FVector InitialRenderOffset;
    FRotator InitialRotation;
};

class UUIAnimation : public UUIRoot
{
public:
    //## BEGIN PROPS UIAnimation
    //## END PROPS UIAnimation

    DECLARE_ABSTRACT_CLASS(UUIAnimation,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimation)
};

class UUIInputConfiguration : public UUIRoot
{
public:
    //## BEGIN PROPS UIInputConfiguration
private:
    TArrayNoInit<struct FUIInputAliasClassMap> WidgetInputAliases;
public:
    TArrayNoInit<struct FUIAxisEmulationDefinition> AxisEmulationDefinitions;
    //## END PROPS UIInputConfiguration

    void LoadInputAliasClasses();
    DECLARE_FUNCTION(execLoadInputAliasClasses)
    {
        P_FINISH;
        LoadInputAliasClasses();
    }
    DECLARE_CLASS(UUIInputConfiguration,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	friend class WxDlgUIEventKeyBindings;

	/**
	 * Returns the list of widget class input aliases.
	 */
	TArray<struct FUIInputAliasClassMap>& GetInputAliasList();
};

class UUILayerBase : public UUIRoot
{
public:
    //## BEGIN PROPS UILayerBase
    //## END PROPS UILayerBase

    DECLARE_ABSTRACT_CLASS(UUILayerBase,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUILayerBase)
};

class UUISceneClient : public UUIRoot, public FExec, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UISceneClient
    FViewport* RenderViewport;
    class UUISkin* ActiveSkin;
    FIntPoint MousePosition;
    class UUIObject* ActiveControl;
    class UDataStoreClient* DataStoreManager;
    class UMaterialInstanceConstant* OpacityParameter;
    FName OpacityParameterName;
    FMatrix CanvasToScreen;
    FMatrix InvCanvasToScreen;
    class UPostProcessChain* UIScenePostProcess;
    BITFIELD bEnablePostProcess:1;
    //## END PROPS UISceneClient

    virtual UBOOL CloseScene(class UUIScene* Scene);
    virtual void SetMousePosition(INT NewMouseX,INT NewMouseY);
    virtual UBOOL ChangeMouseCursor(FName CursorName);
    FMatrix GetCanvasToScreen(const class UUIObject* Widget=NULL) const;
    FMatrix GetInverseCanvasToScreen(const class UUIObject* Widget=NULL) const;
    DECLARE_FUNCTION(execChangeActiveSkin);
    DECLARE_FUNCTION(execIsSceneInitialized);
    DECLARE_FUNCTION(execInitializeScene);
    DECLARE_FUNCTION(execOpenScene);
    DECLARE_FUNCTION(execCloseScene)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_FINISH;
        *(UBOOL*)Result=CloseScene(Scene);
    }
    DECLARE_FUNCTION(execSetMousePosition)
    {
        P_GET_INT(NewMouseX);
        P_GET_INT(NewMouseY);
        P_FINISH;
        SetMousePosition(NewMouseX,NewMouseY);
    }
    DECLARE_FUNCTION(execChangeMouseCursor)
    {
        P_GET_NAME(CursorName);
        P_FINISH;
        *(UBOOL*)Result=ChangeMouseCursor(CursorName);
    }
    DECLARE_FUNCTION(execUpdateCanvasToScreen);
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen(Widget);
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen(Widget);
    }
    DECLARE_ABSTRACT_CLASS(UUISceneClient,UUIRoot,0|CLASS_Transient,Engine)
	/**
	 * Used to limit which scenes should be considered when determining whether the UI should be considered "active"
	 */
	enum ESceneFilterTypes
	{
		SCENEFILTER_None				=0x00000000,

		/** Include the transient scene */
		SCENEFILTER_IncludeTransient	=0x00000001,

		/** Consider only scenes which can process input */
		SCENEFILTER_InputProcessorOnly	=0x00000002,

		/** Consider only scenes which require the game to be paused */
		SCENEFILTER_PausersOnly			=0x00000004,

		/** Consider only scenes which support 3D primitives rendering */
		SCENEFILTER_PrimitiveUsersOnly	=0x00000008,

		/** Only consider scenes which render full-screen */
		SCENEFILTER_UsesPostProcessing	=0x00000010,
	};

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */

	/**
	 * Performs any initialization for the UISceneClient.
	 *
	 * @param	InitialSkin		UISkin that should be set to the initial ActiveSkin
	 */
	virtual void InitializeClient( UUISkin* InitialSkin );

	/**
	 * Assigns the viewport that scenes will use for rendering.
	 *
	 * @param	inViewport	the viewport to use for rendering scenes
	 */
	virtual void SetRenderViewport( FViewport* SceneViewport );

	/**
	 * Changes the active skin to the skin specified
	 */
	void SetActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Changes the active skin to the skin specified, initializes the skin and performs all necessary cleanup and callbacks.
	 * This method should only be called from script.
	 *
	 * @param	NewActiveScene	The skin to activate
	 *
	 * @return	TRUE if the skin was successfully changed.
	 */
	virtual UBOOL ChangeActiveSkin( UUISkin* NewActiveSkin ) PURE_VIRTUAL(UUISceneClient::ChangeActiveSkin, return FALSE;);

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin.
	 */
	virtual void OnActiveSkinChanged() PURE_VIRTUAL(UUISceneClient::OnActiveSkinChanged,);

	/**
	 * Retrieves the virtual offset for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 * Non-zero when the user has panned or zoomed the UI editor such that the 0,0 viewport position is no longer the same
	 * as the 0,0 canvas location.
	 *
	 * @param	out_ViewportOffset	[out] will be filled in with the delta between the viewport's actual origin and virtual origin.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOffset( const UUIScene* Scene, FVector2D& out_ViewportOffset )
	{
		out_ViewportOffset = FVector2D(0,0);
		return FALSE;
	}

	/**
	 * Retrieves the scale factor for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 */
	virtual FLOAT GetViewportScale( const UUIScene* Scene ) const
	{
		return 1.f;
	}

	/**
	 * Retrieves the virtual point of origin for the viewport that renders the specified scene
	 *
	 * In the game, this will be non-zero if Scene is for split-screen and isn't for the first player.
	 * In the editor, this will be equal to the value of the gutter region around the viewport.
	 *
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the virtual origin point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin )
	{
		out_ViewportOrigin = FVector2D(0,0);
		return TRUE;
	}

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen() PURE_VIRTUAL(UUISceneClient::UpdateCanvasToScreen,);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE) PURE_VIRTUAL(UUISceneClient::InputKey,return FALSE;);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE) PURE_VIRTUAL(UUISceneClient::InputAxis,return FALSE;);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character) PURE_VIRTUAL(UUISceneClient::InputChar,return FALSE;);

	/**
	 * Initializes the specified scene without opening it.
	 *
	 * @param	Scene				the scene to initialize;  if the scene specified is contained in a content package, a copy of the scene
	 *								will be created, and that scene will be initialized instead.
	 * @param	SceneOwner			the player that should be associated with the new scene.  Will be assigned to the scene's
	 *								PlayerOwner property.
	 * @param	InitializedScene	the scene that was actually initialized.  If Scene is located in a content package, InitializedScene will be
	 *								the copy of the scene that was created.  Otherwise, InitializedScene will be the same as the scene passed in.
	 *
	 * @return	TRUE if the scene was successfully initialized
	 */
	virtual UBOOL InitializeScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** InitializedScene=NULL );

	/**
	 * Initializes and activates the specified scene.
	 *
	 * @param	Scene			the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *							and the copy will be opened instead.
	 * @param	SceneOwner		the player that should be associated with the new scene.  Will be assigned to the scene's
	 *							PlayerOwner property.
	 * @param	OpenedScene		the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *							the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL );

	/**
	 * Perform 2D rendering for all active scenes
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 */
	virtual void RenderScenes( class FCanvas* Canvas ) PURE_VIRTUAL(UUISceneClient::RenderScenes,);

	/**
	 * Renders the specified scene and its widgets using a 2D plane
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 * @param	Scene	the UIScene to render
	 */
	virtual void Render_Scene( class FCanvas* Canvas, UUIScene* Scene );

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( class UUIScene* Sender ) PURE_VIRTUAL(UUISceneClient::RequestPrimitiveReinitialization,);

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::InitializePrimitives,);

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::UpdateActivePrimitives,);

	/**
	 * Updates 3D primitives for the specified scene and its child widgets.
	 *
	 * @param	CanvasScene	the scene to use for attaching any 3D primitives
	 * @param	Scene		the UIScene to update
	 */
	virtual void Update_ScenePrimitives( FCanvasScene* Canvas, UUIScene* Scene );

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=0 ) const PURE_VIRTUAL(UUISceneClient::IsUIActive,return FALSE;);

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const class UUIScene* Scene ) const PURE_VIRTUAL(UUISceneClient::IsSceneInitialized,return TRUE;);

	/**
	 * Returns true if the UI scenes should be rendered with post process
	 *
	 * @return TRUE if post process is enabled and there is a valid pp chain
	 */
	virtual UBOOL UsesPostProcess() const;
};

class UUIEventContainer : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIEventContainer,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIEventContainer)
};

class IUIEventContainer
{
public:
	typedef UUIEventContainer UClassType;
	virtual UObject* GetUObjectInterfaceUIEventContainer()=0;
    virtual void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL)=0;
    virtual UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=FALSE)=0;
    virtual void RemoveSequenceObject(class USequenceObject* ObjectToRemove)=0;
    virtual void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIEventContainer)
};

struct UIState_eventIsStateAllowed_Parms
{
    class UUIScreenObject* Target;
    class UUIState* NewState;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventIsStateAllowed_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnDeactivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPoppedState;
    UIState_eventOnDeactivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnActivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPushedState;
    UIState_eventOnActivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventDeactivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventDeactivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventActivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventActivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventIsWidgetClassSupported_Parms
{
    class UClass* WidgetClass;
    UBOOL ReturnValue;
    UIState_eventIsWidgetClassSupported_Parms(EEventParm)
    {
    }
};
class UUIState : public UUIRoot, public IUIEventContainer
{
public:
    //## BEGIN PROPS UIState
    class UUIStateSequence* StateSequence;
    TArrayNoInit<struct FInputKeyAction> StateInputActions;
    TArrayNoInit<struct FInputKeyAction> DisabledInputActions;
    FName MouseCursorName;
    BYTE PlayerIndexMask;
    BYTE StackPriority;
    //## END PROPS UIState

    UBOOL IsActiveForPlayer(INT PlayerIndex) const;
    void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL);
    UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=FALSE);
    void RemoveSequenceObject(class USequenceObject* ObjectToRemove);
    void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove);
    DECLARE_FUNCTION(execIsActiveForPlayer)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=IsActiveForPlayer(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetUIEvents)
    {
        P_GET_TARRAY_REF(class UUIEvent*,out_Events);
        P_GET_OBJECT_OPTX(UClass,LimitClass,NULL);
        P_FINISH;
        GetUIEvents(out_Events,LimitClass);
    }
    DECLARE_FUNCTION(execAddSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,NewObj);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(UBOOL*)Result=AddSequenceObject(NewObj,bRecurse);
    }
    DECLARE_FUNCTION(execRemoveSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,ObjectToRemove);
        P_FINISH;
        RemoveSequenceObject(ObjectToRemove);
    }
    DECLARE_FUNCTION(execRemoveSequenceObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,ObjectsToRemove);
        P_FINISH;
        RemoveSequenceObjects(ObjectsToRemove);
    }
    UBOOL eventIsStateAllowed(class UUIScreenObject* Target,class UUIState* NewState,INT PlayerIndex)
    {
        UIState_eventIsStateAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.NewState=NewState;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsStateAllowed),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnDeactivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPoppedState)
    {
        UIState_eventOnDeactivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPoppedState=bPoppedState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnDeactivate),&Parms);
    }
    void eventOnActivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPushedState)
    {
        UIState_eventOnActivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPushedState=bPushedState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnActivate),&Parms);
    }
    UBOOL eventDeactivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventDeactivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_DeactivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventActivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsWidgetClassSupported(class UClass* WidgetClass)
    {
        UIState_eventIsWidgetClassSupported_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.WidgetClass=WidgetClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsWidgetClassSupported),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIState,UUIRoot,0,Engine)
    virtual UObject* GetUObjectInterfaceUIEventContainer(){return this;}
	/**
	 * Called when the state is created.
	 */
	virtual void Created();

	/**
	 * Creates and initializes a UIStateSequence for this UIState.
	 *
	 * @param	SequenceName	the name for the new sequence.  only specified when importing (copy/paste) to ensure that
	 *							the new sequence's name matches the name for any references to that sequence in the t3d text
	 */
	virtual void CreateStateSequence( FName SequenceName=NAME_None );

	/**
	 * Returns the widget that contains this UIState.
	 */
	UUIScreenObject* GetOwner() const;

	/**
	 * Activate this state for the specified target.
	 *
	 * @param	Target			the widget that is activating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be activated for the specified
	 *			Target or this state was already part of the Target's state stack.
	 */
	virtual UBOOL ActivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Deactivate this state for the specified target.
	 *
	 * @param	Target			the widget that is deactivating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be deactivated for the specified
	 *			Target or this state wasn't part of the Target's state stack.
	 */
	virtual UBOOL DeactivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );

	/**
	 * Adds the specified InputAction to this UIState's StateInputActions array, if it doesn't already exist.
	 *
	 * @param	InputAction		the key/action combo that will be scoped by this UIState
	 */
	virtual void AddInputAction( const FInputKeyAction& InputAction );

	/**
	 * Removes the specified InputAction from this UIState's StateInputActions array.  If the input action was instanced
	 * from a default input action in the widget class's default properties, adds the input action to the state's DisabledInputActions array
	 *
	 * @param	InputAction		the key/action combo to remove from this state's list of input keys
	 */
	virtual void RemoveInputAction( const FInputKeyAction& InputAction );

	/**
	 * Adds the specified PlayerIndex to this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void EnablePlayerIndex( INT PlayerIndex );

	/**
	 * Removes the specified PlayerIndex from this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void DisablePlayerIndex( INT PlayerIndex );

	/**
	 * Changes this state's StackPriority to the specified value.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	NewStackPriority	the new priority to assign to this state
	 * @param	bSkipNotification	specify TRUE to prevent the widget from re-resolving its style (useful when calling
	 *								this method on several states at a time)
	 */
	void SetStatePriority( INT PlayerIndex, BYTE NewStackPriority, UBOOL bSkipNotification=FALSE );

	/**
	 * Resets this state's StackPriority to its default value.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bSkipNotification	specify TRUE to prevent the widget from re-resolving its style (useful when calling
	 *								this method on several states at a time)
	 */
	void ResetStatePriority( INT PlayerIndex, UBOOL bSkipNotification=FALSE );

protected:
	/**
	 * Called when this state's StackPriority is changed at runtime.  Moves the state to the appropriate location in the
	 * the owning widget's list of active states, if applicable.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bSendNotification	specify TRUE to re-resolve the owning widget's style if the top-most state changed as
	 *								a result of this state's StackPriority changing.
	 */
	virtual void OnStackPriorityChanged( INT PlayerIndex, UBOOL bSendNotification );

public:

	/* === UObject interface === */
	/**
	 * Called after the object has loaded.
	 */
	virtual void PostLoad();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIState_Disabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Disabled
    //## END PROPS UIState_Disabled

    DECLARE_CLASS(UUIState_Disabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIState_Enabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Enabled
    //## END PROPS UIState_Enabled

    DECLARE_CLASS(UUIState_Enabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIString : public UUIRoot
{
public:
    //## BEGIN PROPS UIString
    TArrayNoInit<FUIStringNode*> Nodes;
    struct FUICombinedStyleData StringStyleData;
private:
    class UUIStyle_Combo* DefaultStringStyle;
public:
    FVector2D StringExtent;
    //## END PROPS UIString

    virtual UBOOL SetValue(const FString& InputString,UBOOL bIgnoreMarkup);
    FString GetValue(UBOOL bReturnProcessedText=TRUE) const;
    UBOOL ContainsMarkup() const;
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(InputString);
        P_GET_UBOOL(bIgnoreMarkup);
        P_FINISH;
        *(UBOOL*)Result=SetValue(InputString,bIgnoreMarkup);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnProcessedText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnProcessedText);
    }
    DECLARE_FUNCTION(execContainsMarkup)
    {
        P_FINISH;
        *(UBOOL*)Result=ContainsMarkup();
    }
    DECLARE_CLASS(UUIString,UUIRoot,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UIString Interface === */
	/**
	 * Calculates the size of the specified string.
	 *
	 * @param	Parameters	Used for various purposes
	 *							DrawXL:		[out] will be set to the width of the string
	 *							DrawYL:		[out] will be set to the height of the string
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[out] specifies the amount of scaling to apply to the string
	 * @param	pText		the string to calculate the size for
	 * @param	EOL			a pointer to a single character that is used as the end-of-line marker in this string
	 */
	static void StringSize( FRenderParameters& Parameters, const TCHAR* pText, const TCHAR* EOL=NULL );

	/**
	 * Clips text to the bounding region specified.
	 *
	 * @param	Parameters			Various:
	 *									DrawX:		[in] specifies the pixel location of the start of the bounding region that should be used for clipping
	 *									DrawXL:		[in] specifies the pixel location of the end of the bounding region that should be used for clipping
	 *												[out] set to the width of out_ResultString, in pixels
	 *									DrawY:		unused
	 *									DrawYL:		[out] set to the height of the string
	 *									Scaling:	specifies the amount of scaling to apply to the string
	 * @param	pText				the text that should be clipped
	 * @param	out_ResultString	[out] a string containing all characters from the source string that fit into the bounding region
	 * @param	ClipAlignment		controls which part of the input string is preserved (remains after clipping).
	 */
	static void ClipString( FRenderParameters& Parameters, const TCHAR* pText, FString& out_ResultString, EUIAlignment ClipAlignment=UIALIGN_Left );

	/**
	 * Parses a single string into an array of strings that will fit inside the specified bounding region.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the pixel location of the start of the horizontal bounding region that should be used for wrapping.
	 *							DrawY:		[in] specifies the Y origin of the bounding region.  This should normally be set to 0, as this will be
	 *										     used as the base value for DrawYL.
	 *										[out] Will be set to the Y position (+YL) of the last line, i.e. the total height of all wrapped lines relative to the start of the bounding region
	 *							DrawXL:		[in] specifies the pixel location of the end of the horizontal bounding region that should be used for wrapping
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.  A input value of 0 indicates that
	 *										     the bounding region height should not be considered.  Once the total height of lines reaches this
	 *										     value, the function returns and no further processing occurs.
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in] specifies the amount of scaling to apply to the string
	 * @param	CurX			specifies the pixel location to begin the wrapping; usually equal to the X pos of the bounding region, unless wrapping is initiated
	 *								in the middle of the bounding region (i.e. indentation)
	 * @param	pText			the text that should be wrapped
	 * @param	out_Lines		[out] will contain an array of strings which fit inside the bounding region specified.  Does
	 *							not clear the array first.
	 * @param	EOL				a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	MaxLines		the maximum number of lines that can be created.
	 */
	static void WrapString( FRenderParameters& Parameters, FLOAT CurX, const TCHAR* pText, TArray<struct FWrappedStringElement>& out_Lines, const TCHAR* EOL = NULL, INT MaxLines = MAXINT);

	/**
	 * Changes the style data for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( const struct FUICombinedStyleData& NewStringStyle );

	/**
	 * Changes the complete style for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( UUIStyle_Combo* NewStringStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewTextStyle	the new text style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( const struct FStyleDataReference& NewTextStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new text style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewTextStyle	the new image style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( const struct FStyleDataReference& NewImageStyle );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new image style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Retrieves the UIState that should be used for applying style data.
	 */
	virtual class UUIState* GetCurrentMenuState() const;

	/**
	 * Propagates the string's text and image styles to all existing string nodes.
	 */
	void RefreshNodeStyles();

	/**
	 * Removes all slave nodes which were created as a result of wrapping or other string formatting, appending their RenderedText
	 * to the parent node.
	 */
	void UnrollWrappedNodes();

	/**
	 * Reformats this UIString's nodes to fit within the bounding region specified.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the X position of the bounding region, in pixels
	 *										[out] Will be set to the X position of the end of the last node in the string.
	 *							DrawY:		[out] Will be set to the Y position of the last node in the string
	 *							DrawXL:		[in] specifies the width of the bounding region, in pixels.
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.
	 *							DrawFont:	unused
	 *							Scale:		unused
	 * @param	bIgnoreMarkup	if TRUE, does not attempt to process any markup and only one UITextNode is created
	 */
	void ApplyFormatting( FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Converts the raw source text containing optional markup (such as tokens and inline images)
	 * into renderable data structures.
	 *
	 * @param	InputString			A string containing optional markup.
	 * @param	bSystemMarkupOnly	if TRUE, only system generated markup will be processed (such as markup for rendering carets, etc.)
	 * @param	out_Nodes			[out] A collection of UITextNodes which will contain the parsed nodes.
	 * @param	StringNodeModifier	the style data to use as the starting point for string node modifications.  If not specified, uses the
	 *								string's DefaultStringStyle as the starting point.  Generally only specified when recursively calling
	 *								ParseString.
	 *
	 * @return	TRUE if InputString was successfully parsed into out_Nodes
	 */
	UBOOL ParseString( const FString& InputString, UBOOL bSystemMarkupOnly, TArray<FUIStringNode*>& out_Nodes, struct FUIStringNodeModifier* StringNodeModifier=NULL ) const;

	/**
	 * Render this UIString using the parameters specified.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this string
	 * @param	Parameters	the bounds for the region that this string can render to.
	 */
	void Render_String( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Calculates the height of a single line of text using the string's default text style for sizing.
	 *
	 * @return	the average height a single line in this string, in pixels, using the string's current text style.
	 */
	FLOAT GetDefaultLineHeight() const;

	/**
	 * Retrieves a list of all data stores resolved by this UIString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by this string.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

protected:

	/**
	 * Find the data store that has the specified tag.
	 *
	 * @param	DataStoreTag	A name corresponding to the 'Tag' property of a data store
	 *
	 * @return	a pointer to the data store that has a Tag corresponding to DataStoreTag, or NULL if no data
	 *			were found with that tag.
	 */
	UUIDataStore* ResolveDataStore( FName DataStoreTag ) const;

	/**
	 * Deletes all nodes allocated by this UIString and empties the Nodes array
	 */
	void ClearNodes();

	/**
	 * Hook for adjusting the extents and render text of any nodes prior to applyig formatting data.
	 */
	virtual void AdjustNodeExtents( struct FNodeFormattingData& FormatData ) {}

public:
	/* === UObject interface. === */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void FinishDestroy();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

struct UIStyle_eventGetDefaultStyle_Parms
{
    class UUIStyle_Data* ReturnValue;
    UIStyle_eventGetDefaultStyle_Parms(EEventParm)
    {
    }
};
class UUIStyle : public UUIRoot
{
public:
    //## BEGIN PROPS UIStyle
    struct FSTYLE_ID StyleID;
    FName StyleTag;
    FStringNoInit StyleName;
    FStringNoInit StyleGroupName;
    class UClass* StyleDataClass;
    TMap< class UUIState*,class UUIStyle_Data* > StateDataMap;
    //## END PROPS UIStyle

    class UUIStyle_Data* GetStyleForState(class UUIState* StateObject) const;
    class UUIStyle_Data* GetStyleForStateByClass(class UClass* StateClass) const;
    DECLARE_FUNCTION(execGetStyleForState)
    {
        P_GET_OBJECT(UUIState,StateObject);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForState(StateObject);
    }
    DECLARE_FUNCTION(execGetStyleForStateByClass)
    {
        P_GET_OBJECT(UClass,StateClass);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForStateByClass(StateClass);
    }
    class UUIStyle_Data* eventGetDefaultStyle()
    {
        UIStyle_eventGetDefaultStyle_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDefaultStyle),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIStyle,UUIRoot,0,Engine)
    DECLARE_WITHIN(UUISkin)
	/**
	 *	Obtain style data for the specified state from the archetype style
	 *
	 *	@param StateObject	State for which the data will be extracted
	 *	@return returns the corresponding state data or NULL archetype doesn't contain this state or
	 *			if this style's archetype is the class default object
	 */
	UUIStyle_Data* GetArchetypeStyleForState(class UUIState* StateObject) const;

	/**
	 * Called when this style is loaded by its owner skin.
	 *
	 * @param	OwnerSkin	the skin that contains this style.
	 */
	void InitializeStyle( class UUISkin* OwnerSkin );

	/**
	 * Get the name for this style.
	 *
	 * @return	If the value for StyleName is identical to the value for this style's template, returns this style's
	 *			StyleTag....otherwise, returns this style's StyleName
	 */
	FString	GetStyleName() const;

	/**
	 * Creates and initializes a new style data object for the UIState specified.
	 *
	 * @param	StateToAdd		the state to add style data for.  If StateToAdd does not have either the RF_ArchetypeObject
	 * 							or RF_ClassDefaultObject flags set, the new style data will be associated with StateToAdd's
	 *							ObjectArchetype instead.
	 * @param	DataArchetype	if specified, uses this object as the template for the new style data object
	 */
	UUIStyle_Data* AddNewState( class UUIState* StateToAdd, class UUIStyle_Data* DataArchetype=NULL );

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	DataToCheck		if specified, returns whether the values have been modified for that style data only.  If not
	 *							specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIStyle_Data* DataToCheck=NULL ) const;

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	StateToCheck	if specified, returns whether the values have been modified for that menu state's style data only.
	 *							If not specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIState* StateToCheck=NULL ) const;

	/**
	 * Sets or clears the dirty flag for this style, which indicates whether this style's data should be reapplied.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 * @param	Target		if specified, only sets the dirty flag for this style data object.  Otherwise, sets the dirty
	 *						flag for all style data contained by this style.
	 */
	void SetDirtiness( UBOOL bIsDirty, UUIStyle_Data* Target=NULL );

	/**
	 * Creates a newly constructed copy of the receiver with a hard copy of its StateDataMap.
	 * New style will be transient and cannot be saved out.
	 *
	 * @return	Pointer to a newly constructed transient copy of the passed style
	 */
	UUIStyle* CreateTransientCopy();

	/**
	 * Returns TRUE if this style indirectly references specified style through its DataMap
	 */
	UBOOL ReferencesStyle(const UUIStyle* Style) const;

	/**
     * Returns TRUE if this style is one of the designated default styles
     */
    UBOOL IsDefaultStyle() const;

    /**
     * Restores the archetype for the specified style and reinitializes the style data object against the new archetype,
	 * preserving the values serialized into StyleData
     *
     * @param	StyleData			the style data object that has the wrong archetype
     * @param	StyleDataArchetype	the style data object that should be the archetype
     */
	void RestoreStyleArchetype( class UUIStyle_Data* StyleData, class UUIStyle_Data* StyleDataArchetype );

	/* === UObject interface === */
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& Objects );

	/** File I/O */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Fixes the archetypes for any style data objects which have lost their archetypes.
	 */
	virtual void PostLoad();
};

class UUIComponent : public UComponent
{
public:
    //## BEGIN PROPS UIComponent
    //## END PROPS UIComponent

    DECLARE_ABSTRACT_CLASS(UUIComponent,UComponent,0,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UObject interface === */
	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIComp_Event : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_Event
    TArrayNoInit<struct FDefaultEventSpecification> DefaultEvents;
    class UUISequence* EventContainer;
    class UUIEvent_ProcessInput* InputProcessor;
    TArrayNoInit<FName> DisabledEventAliases;
    //## END PROPS UIComp_Event

    void RegisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    void UnregisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    DECLARE_FUNCTION(execRegisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        RegisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_FUNCTION(execUnregisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        UnregisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_CLASS(UUIComp_Event,UUIComponent,0,Engine)
	/**
	 * Returns the widget associated with this event provider.
	 */
	class UUIScreenObject* GetOwner() const;

	/**
	 * Called when the screen object that owns this UIComp_Event is created.  Creates the UISequence which will contain
	 * the events for this widget, instances any objects assigned to the DefaultEvents array and adds those instances
	 * to the sequence container.
	 */
	void Created();

	/**
	 * Determines which sequences should be instanced for the widget that owns this event component.  Note that this method
	 * does not care whether the sequences have ALREADY been instanced - it just determines whether a sequence should be instanced
	 * in the case where the corresponding sequence container has a NULL sequence.
	 *
	 * @param	out_EventsToInstance	will receive the list of indexes of the event templates which have linked ops, thus need to be instanced
	 *
	 * @return	TRUE if the global sequence for this component should be instanced.
	 */
	UBOOL ShouldInstanceSequence( TArray<INT>& out_EventsToInstance );

	/**
	 * Determines whether the specified event template should be instanced when this event component is initializing its sequence.
	 *
	 * @param	DefaultIndex	index into the DefaultEvents array for the event to check
	 *
	 * @return	returns TRUE if the event located at the specified index is valid for instancing; FALSE otherwise.
	 *			Note that this function does not care whether the event has ALREADY been instanced or not - just whether
	 *			it is valid to instance that event.
	 */
	UBOOL ShouldInstanceDefaultEvent( INT DefaultIndex );

	/**
	 * Creates the sequence for this event component
	 *
	 * @param	SequenceName	optionally specify the name for the sequence container....used by the T3D import code to
	 *							make sure that the new sequence can be resolved by other objects which reference it
	 *
	 * @return	a pointer to a new UISequence which has this component as its Outer
	 */
	class UUISequence* CreateEventContainer( FName SequenceName=NAME_None ) const;

	/**
	 * Initializes the sequence associated with this event component.  Assigns the parent sequence for the EventContainer
	 * to the UISequence associated with the widget that owns this component's owner widget.
	 *
	 * @param	bInitializeSequence		if TRUE, calls InitializeSequence on the sequence owned by this widget.  Should only
	 *									be TRUE in the game.
	 */
	void InitializeEventProvider( UBOOL bInitializeSequence=GIsGame );

	/**
	 * Cleans up any references to objects contained in other widgets.  Called when the owning widget is removed from the scene.
	 */
	void CleanupEventProvider();

	/**
	 * Adds the specified sub-sequence to the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to add.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully added to [or if it already existed] the widget's sequence
	 */
	virtual UBOOL PushStateSequence( class UUIStateSequence* StateSequence );

	/**
	 * Removes the specified sub-sequence from the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to remove.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully removed [or wasn't in the list] from the widget's sequence
	 */
	virtual UBOOL PopStateSequence( class UUIStateSequence* StateSequence );

protected:
	/**
	 * Creates a UIEvent_ProcessInput object for routing input events to actions.
	 */
	void CreateInputProcessor();

	/**
	 * Assigns the parent sequence for this widget's sequence to the sequence owned by this widget's parent, if necessary.
	 */
	void SetParentSequence();

	/**
	 * Creates instances for any newly attached actions, variables, etc. that were declared in the class defaultproperties which don't exist in the sequence.
	 *
	 * @param	StateInstanceMap	maps the DefaultStates array to the UIState instance of that class living in the owning widget's InactiveStates array
	 * @param	EventsToInstance	the indexes for the elements of the DefaultEvents array which should be instanced.
	 */
	void InstanceEventTemplates( TMap<UClass*,UUIState*>& StateInstanceMap, const TArray<INT>& EventsToInstance );

	/**
	 * Creates an UIEvent instance using the DefaultEvent template located at the index specified.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	DefaultIndex	index into the DefaultEvents array for the template to use when creating the event
	 *
	 * @return	a pointer to the UIEvent instance that was creatd, or NULL if it couldn't be created for some reason
	 */
	UUIEvent* InstanceDefaultEvent( class IUIEventContainer* TargetContainer, INT DefaultIndex );

	/**
	 * Used for initializing sequence operations which have been instanced from event templates assigned to the
	 * DefaultEvents array.  Iterates through the op's input links, output links, and variable links, instancing
	 * any linked sequence objects which are contained within a class default object.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	OpInstance			the SequenceOp to initialize.  This should either be a UIEvent created during
	 *								UUIComp_Event::Created() or some other sequence op referenced by an script-declared
	 */
	void InitializeInstancedOp( class IUIEventContainer* TargetContainer, class USequenceOp* OpInstance );

	/**
	 * Generates a list of UIEvent instances that have been previously created and added to either the widget's sequence
	 * or one of its states.
	 *
	 * @param	StateInstanceMap		map of UIState classes to the corresonding instance of that UIState from the owning widget's
	 *									InactiveStates array
	 * @param	out_ExistingEventMap	Will be filled with the list of previously instanced UIEvents, mapped to
	 *									their corresponding containers
	 */
	void GetInstancedEvents( TMap<UClass*,UUIState*>& StateInstanceMap, TMultiMap<IUIEventContainer*,UUIEvent*>& out_ExistingEventMap );

public:
	/** Fixup default event templates that were incorrectly instanced */
	virtual void PostLoad();
};

#endif // !INCLUDED_ENGINE_USERINTERFACE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindPlayerDataStoreIndex);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execGetAvailableDataStores);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execUnregisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execRegisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execCreateDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindDataStore);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInit);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execUnregisterInputEvents);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execRegisterInputEvents);
AUTOGENERATE_FUNCTION(UUIInputConfiguration,-1,execLoadInputAliasClasses);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateScene);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateTransientWidget);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetDataStoreClient);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerControllerId);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerIndex);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerCount);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetPrimitiveTransform);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetMouseCaptureOverride);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorSize);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorPosition);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetFaceOrientation);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetSceneClient);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCurrentUIController);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execUpdateCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execChangeMouseCursor);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execSetMousePosition);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execCloseScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execOpenScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execInitializeScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execIsSceneInitialized);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execChangeActiveSkin);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObjects);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execAddSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execGetUIEvents);
AUTOGENERATE_FUNCTION(UUIState,-1,execIsActiveForPlayer);
AUTOGENERATE_FUNCTION(UUIString,-1,execContainsMarkup);
AUTOGENERATE_FUNCTION(UUIString,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIString,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForStateByClass);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForState);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_USERINTERFACE_NATIVE_DEFS
#define ENGINE_USERINTERFACE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UConsole);
DECLARE_NATIVE_TYPE(Engine,UDataStoreClient);
DECLARE_NATIVE_TYPE(Engine,UInput);
DECLARE_NATIVE_TYPE(Engine,UInteraction);
DECLARE_NATIVE_TYPE(Engine,UPlayerInput);
DECLARE_NATIVE_TYPE(Engine,UPlayerManagerInteraction);
DECLARE_NATIVE_TYPE(Engine,UUIAnimation);
DECLARE_NATIVE_TYPE(Engine,UUIComp_Event);
DECLARE_NATIVE_TYPE(Engine,UUIComponent);
DECLARE_NATIVE_TYPE(Engine,UUIEventContainer);
DECLARE_NATIVE_TYPE(Engine,UUIInputConfiguration);
DECLARE_NATIVE_TYPE(Engine,UUIInteraction);
DECLARE_NATIVE_TYPE(Engine,UUILayerBase);
DECLARE_NATIVE_TYPE(Engine,UUIRoot);
DECLARE_NATIVE_TYPE(Engine,UUISceneClient);
DECLARE_NATIVE_TYPE(Engine,UUIState);
DECLARE_NATIVE_TYPE(Engine,UUIState_Disabled);
DECLARE_NATIVE_TYPE(Engine,UUIState_Enabled);
DECLARE_NATIVE_TYPE(Engine,UUIString);
DECLARE_NATIVE_TYPE(Engine,UUIStyle);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_USERINTERFACE \
	UConsole::StaticClass(); \
	UDataStoreClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUDataStoreClientNative; \
	UInput::StaticClass(); \
	UInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUInteractionNative; \
	UPlayerInput::StaticClass(); \
	UPlayerManagerInteraction::StaticClass(); \
	UUIAnimation::StaticClass(); \
	UUIComp_Event::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_EventNative; \
	UUIComponent::StaticClass(); \
	UUIEventContainer::StaticClass(); \
	UUIInputConfiguration::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInputConfigurationNative; \
	UUIInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInteractionNative; \
	UUILayerBase::StaticClass(); \
	UUIRoot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIRootNative; \
	UUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneClientNative; \
	UUIState::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStateNative; \
	UUIState_Disabled::StaticClass(); \
	UUIState_Enabled::StaticClass(); \
	UUIString::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStringNative; \
	UUIStyle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStyleNative; \

#endif // ENGINE_USERINTERFACE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UDataStoreClient) GEngineUDataStoreClientNatives[] = 
{ 
	MAP_NATIVE(UDataStoreClient,execFindPlayerDataStoreIndex)
	MAP_NATIVE(UDataStoreClient,execGetAvailableDataStores)
	MAP_NATIVE(UDataStoreClient,execUnregisterDataStore)
	MAP_NATIVE(UDataStoreClient,execRegisterDataStore)
	MAP_NATIVE(UDataStoreClient,execCreateDataStore)
	MAP_NATIVE(UDataStoreClient,execFindDataStore)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UDataStoreClient);

NATIVE_INFO(UInteraction) GEngineUInteractionNatives[] = 
{ 
	MAP_NATIVE(UInteraction,execInit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UInteraction);

NATIVE_INFO(UUIComp_Event) GEngineUUIComp_EventNatives[] = 
{ 
	MAP_NATIVE(UUIComp_Event,execUnregisterInputEvents)
	MAP_NATIVE(UUIComp_Event,execRegisterInputEvents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_Event);

NATIVE_INFO(UUIInputConfiguration) GEngineUUIInputConfigurationNatives[] = 
{ 
	MAP_NATIVE(UUIInputConfiguration,execLoadInputAliasClasses)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInputConfiguration);

NATIVE_INFO(UUIInteraction) GEngineUUIInteractionNatives[] = 
{ 
	MAP_NATIVE(UUIInteraction,execCreateScene)
	MAP_NATIVE(UUIInteraction,execCreateTransientWidget)
	MAP_NATIVE(UUIInteraction,execPlayUISound)
	MAP_NATIVE(UUIInteraction,execGetDataStoreClient)
	MAP_NATIVE(UUIInteraction,execGetPlayerControllerId)
	MAP_NATIVE(UUIInteraction,execGetPlayerIndex)
	MAP_NATIVE(UUIInteraction,execGetPlayerCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInteraction);

NATIVE_INFO(UUIRoot) GEngineUUIRootNatives[] = 
{ 
	MAP_NATIVE(UUIRoot,execGetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execSetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execGetPrimitiveTransform)
	MAP_NATIVE(UUIRoot,execSetMouseCaptureOverride)
	MAP_NATIVE(UUIRoot,execGetCursorSize)
	MAP_NATIVE(UUIRoot,execGetCursorPosition)
	MAP_NATIVE(UUIRoot,execGetFaceOrientation)
	MAP_NATIVE(UUIRoot,execGetSceneClient)
	MAP_NATIVE(UUIRoot,execGetCurrentUIController)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIRoot);

NATIVE_INFO(UUISceneClient) GEngineUUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUISceneClient,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execGetCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execUpdateCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execChangeMouseCursor)
	MAP_NATIVE(UUISceneClient,execSetMousePosition)
	MAP_NATIVE(UUISceneClient,execCloseScene)
	MAP_NATIVE(UUISceneClient,execOpenScene)
	MAP_NATIVE(UUISceneClient,execInitializeScene)
	MAP_NATIVE(UUISceneClient,execIsSceneInitialized)
	MAP_NATIVE(UUISceneClient,execChangeActiveSkin)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISceneClient);

NATIVE_INFO(UUIState) GEngineUUIStateNatives[] = 
{ 
	MAP_NATIVE(UUIState,execRemoveSequenceObjects)
	MAP_NATIVE(UUIState,execRemoveSequenceObject)
	MAP_NATIVE(UUIState,execAddSequenceObject)
	MAP_NATIVE(UUIState,execGetUIEvents)
	MAP_NATIVE(UUIState,execIsActiveForPlayer)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIState);

NATIVE_INFO(UUIString) GEngineUUIStringNatives[] = 
{ 
	MAP_NATIVE(UUIString,execContainsMarkup)
	MAP_NATIVE(UUIString,execGetValue)
	MAP_NATIVE(UUIString,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIString);

NATIVE_INFO(UUIStyle) GEngineUUIStyleNatives[] = 
{ 
	MAP_NATIVE(UUIStyle,execGetStyleForStateByClass)
	MAP_NATIVE(UUIStyle,execGetStyleForState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIStyle);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,Console,ConsoleTargetPlayer)
VERIFY_CLASS_OFFSET_NODIE(U,Console,TypedStrPos)
VERIFY_CLASS_SIZE_NODIE(UConsole)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,GlobalDataStoreClasses)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,PlayerDataStores)
VERIFY_CLASS_SIZE_NODIE(UDataStoreClient)
VERIFY_CLASS_OFFSET_NODIE(U,Input,Bindings)
VERIFY_CLASS_OFFSET_NODIE(U,Input,AxisArray)
VERIFY_CLASS_SIZE_NODIE(UInput)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,__OnReceivedNativeInputKey__Delegate)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,__OnInitialize__Delegate)
VERIFY_CLASS_SIZE_NODIE(UInteraction)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,LastAxisKeyName)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,MouseSamplingTotal)
VERIFY_CLASS_SIZE_NODIE(UPlayerInput)
VERIFY_CLASS_SIZE_NODIE(UPlayerManagerInteraction)
VERIFY_CLASS_SIZE_NODIE(UUIAnimation)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DefaultEvents)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DisabledEventAliases)
VERIFY_CLASS_SIZE_NODIE(UUIComp_Event)
VERIFY_CLASS_SIZE_NODIE(UUIComponent)
VERIFY_CLASS_SIZE_NODIE(UUIEventContainer)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,WidgetInputAliases)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,AxisEmulationDefinitions)
VERIFY_CLASS_SIZE_NODIE(UUIInputConfiguration)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,SceneClientClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,CanvasScene)
VERIFY_CLASS_SIZE_NODIE(UUIInteraction)
VERIFY_CLASS_SIZE_NODIE(UUILayerBase)
VERIFY_CLASS_SIZE_NODIE(UUIRoot)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,RenderViewport)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,UIScenePostProcess)
VERIFY_CLASS_SIZE_NODIE(UUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,StateSequence)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,StackPriority)
VERIFY_CLASS_SIZE_NODIE(UUIState)
VERIFY_CLASS_SIZE_NODIE(UUIState_Disabled)
VERIFY_CLASS_SIZE_NODIE(UUIState_Enabled)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,Nodes)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,StringExtent)
VERIFY_CLASS_SIZE_NODIE(UUIString)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StyleID)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StateDataMap)
VERIFY_CLASS_SIZE_NODIE(UUIStyle)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
