/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PHYSICS_ENUMS
#define INCLUDED_ENGINE_PHYSICS_ENUMS 1

enum ERadialForceType
{
    RFT_Force               =0,
    RFT_Impulse             =1,
    RFT_MAX                 =2,
};
enum EWheelSide
{
    SIDE_None               =0,
    SIDE_Left               =1,
    SIDE_Right              =2,
    SIDE_MAX                =3,
};

#endif // !INCLUDED_ENGINE_PHYSICS_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(SuspensionHeavyShift)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PHYSICS_CLASSES
#define INCLUDED_ENGINE_PHYSICS_CLASSES 1

class ARB_ForceFieldExcludeVolume : public AVolume
{
public:
    //## BEGIN PROPS RB_ForceFieldExcludeVolume
    INT ForceFieldChannel;
    //## END PROPS RB_ForceFieldExcludeVolume

    DECLARE_CLASS(ARB_ForceFieldExcludeVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ARB_ForceFieldExcludeVolume)
};

class AKActor : public ADynamicSMActor
{
public:
    //## BEGIN PROPS KActor
    BITFIELD bDamageAppliesImpulse:1 GCC_BITFIELD_MAGIC;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bCurrentSlide:1;
    BITFIELD bSlideActive:1;
    class UParticleSystemComponent* ImpactEffectComponent;
    class UAudioComponent* ImpactSoundComponent;
    class UAudioComponent* ImpactSoundComponent2;
    FLOAT LastImpactTime;
    class UParticleSystemComponent* SlideEffectComponent;
    class UAudioComponent* SlideSoundComponent;
    FLOAT LastSlideTime;
    FRigidBodyState RBState;
    FLOAT AngErrorAccumulator;
    FLOAT DrawScaleX;
    FLOAT DrawScaleY;
    FLOAT DrawScaleZ;
    FVector InitialLocation;
    FRotator InitialRotation;
    //## END PROPS KActor

    class UPhysicalMaterial* GetKActorPhysMaterial();
    void ResolveRBState();
    DECLARE_FUNCTION(execGetKActorPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=GetKActorPhysMaterial();
    }
    DECLARE_FUNCTION(execResolveRBState)
    {
        P_FINISH;
        ResolveRBState();
    }
    DECLARE_CLASS(AKActor,ADynamicSMActor,0|CLASS_NativeReplication,Engine)
	// UObject interface
	virtual void PostLoad();

	// AActor interface
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

class AKActorSpawnable : public AKActor
{
public:
    //## BEGIN PROPS KActorSpawnable
    //## END PROPS KActorSpawnable

    virtual void ResetComponents();
    DECLARE_FUNCTION(execResetComponents)
    {
        P_FINISH;
        ResetComponents();
    }
    DECLARE_CLASS(AKActorSpawnable,AKActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AKActorSpawnable)
};

class AKAsset : public AActor
{
public:
    //## BEGIN PROPS KAsset
    class USkeletalMeshComponent* SkeletalMeshComponent;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bBlockPawns:1;
    BITFIELD bTempRep:1;
    class USkeletalMesh* ReplicatedMesh;
    struct FReplicatedHitImpulse RepHitImpulse;
    BYTE OldImpulseCount;
    FRigidBodyState RigidBodyStates[16];
    //## END PROPS KAsset

    virtual void GetAssetPhysicsState();
    virtual void SetAssetPhysicsState(UBOOL bWakeBodies);
    DECLARE_FUNCTION(execGetAssetPhysicsState)
    {
        P_FINISH;
        GetAssetPhysicsState();
    }
    DECLARE_FUNCTION(execSetAssetPhysicsState)
    {
        P_GET_UBOOL(bWakeBodies);
        P_FINISH;
        SetAssetPhysicsState(bWakeBodies);
    }
    DECLARE_CLASS(AKAsset,AActor,0|CLASS_NativeReplication,Engine)
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
public:
	// UObject interface
	virtual void PostLoad();

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
	UBOOL IgnoreBlockingBy(const AActor* Other);
};

struct FVehicleState
{
    FRigidBodyState RBState;
    BYTE ServerBrake;
    BYTE ServerGas;
    BYTE ServerGear;
    BYTE ServerSteering;
    BYTE ServerRise;
    BITFIELD bServerHandbrake:1 GCC_BITFIELD_MAGIC;
    INT ServerViewPitch;
    INT ServerViewYaw;
};

struct SVehicle_eventSuspensionHeavyShift_Parms
{
    FLOAT Delta;
    SVehicle_eventSuspensionHeavyShift_Parms(EEventParm)
    {
    }
};
class ASVehicle : public AVehicle
{
public:
    //## BEGIN PROPS SVehicle
    class USVehicleSimBase* SimObj;
    TArrayNoInit<class USVehicleWheel*> Wheels;
    FVector COMOffset;
    FVector InertiaTensorMultiplier;
    BITFIELD bStayUpright:1;
    BITFIELD bUseSuspensionAxis:1;
    BITFIELD bUpdateWheelShapes:1;
    BITFIELD bVehicleOnGround:1;
    BITFIELD bVehicleOnWater:1;
    BITFIELD bIsInverted:1;
    BITFIELD bChassisTouchingGround:1;
    BITFIELD bWasChassisTouchingGroundLastTick:1;
    BITFIELD bCanFlip:1;
    BITFIELD bFlipRight:1;
    BITFIELD bIsUprighting:1;
    BITFIELD bOutputHandbrake:1;
    BITFIELD bHoldingDownHandbrake:1;
    FLOAT StayUprightRollResistAngle;
    FLOAT StayUprightPitchResistAngle;
    FLOAT StayUprightStiffness;
    FLOAT StayUprightDamping;
    class URB_StayUprightSetup* StayUprightConstraintSetup;
    class URB_ConstraintInstance* StayUprightConstraintInstance;
    FLOAT HeavySuspensionShiftPercent;
    FLOAT MaxSpeed;
    FLOAT MaxAngularVelocity;
    FLOAT TimeOffGround;
    FLOAT UprightLiftStrength;
    FLOAT UprightTorqueStrength;
    FLOAT UprightTime;
    FLOAT UprightStartTime;
    class UAudioComponent* EngineSound;
    class UAudioComponent* SquealSound;
    class UAudioComponent* CollideSound;
    class USoundCue* EnterVehicleSound;
    class USoundCue* ExitVehicleSound;
    FLOAT CollisionIntervalSecs;
    FLOAT SquealThreshold;
    FLOAT SquealLatThreshold;
    FLOAT LatAngleVolumeMult;
    FLOAT EngineStartOffsetSecs;
    FLOAT EngineStopOffsetSecs;
    FLOAT LastCollisionSoundTime;
    FLOAT OutputBrake;
    FLOAT OutputGas;
    INT OutputGear;
    FLOAT OutputSteering;
    FLOAT OutputRise;
    FLOAT ForwardVel;
    INT NumPoweredWheels;
    FVector BaseOffset;
    FLOAT CamDist;
    INT DriverViewPitch;
    INT DriverViewYaw;
    struct FVehicleState VState;
    FLOAT AngErrorAccumulator;
    FLOAT RadialImpulseScaling;
    //## END PROPS SVehicle

    void SetWheelCollision(INT WheelNum,UBOOL bCollision);
    virtual void InitVehicleRagdoll(class USkeletalMesh* RagdollMesh,class UPhysicsAsset* RagdollPhysAsset,FVector ActorMove);
    virtual UBOOL HasWheelsOnGround();
    DECLARE_FUNCTION(execSetWheelCollision)
    {
        P_GET_INT(WheelNum);
        P_GET_UBOOL(bCollision);
        P_FINISH;
        SetWheelCollision(WheelNum,bCollision);
    }
    DECLARE_FUNCTION(execInitVehicleRagdoll)
    {
        P_GET_OBJECT(USkeletalMesh,RagdollMesh);
        P_GET_OBJECT(UPhysicsAsset,RagdollPhysAsset);
        P_GET_STRUCT(FVector,ActorMove);
        P_FINISH;
        InitVehicleRagdoll(RagdollMesh,RagdollPhysAsset,ActorMove);
    }
    DECLARE_FUNCTION(execHasWheelsOnGround)
    {
        P_FINISH;
        *(UBOOL*)Result=HasWheelsOnGround();
    }
    void eventSuspensionHeavyShift(FLOAT Delta)
    {
        SVehicle_eventSuspensionHeavyShift_Parms Parms(EC_EventParm);
        Parms.Delta=Delta;
        ProcessEvent(FindFunctionChecked(ENGINE_SuspensionHeavyShift),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(ASVehicle,AVehicle,0|CLASS_Config|CLASS_NativeReplication,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// Actor interface.
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void PostNetReceiveLocation();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	// SVehicle interface.
	virtual void VehiclePackRBState();
	virtual void VehicleUnpackRBState();
	virtual FVector GetDampingForce(const FVector& InForce);

	// Physics interface
	virtual void AddForce(FVector Force);
	virtual void AddImpulse(FVector Impulse);
	virtual void AddTorque(FVector Torque);
	virtual UBOOL IsSleeping();

#if WITH_NOVODEX

    virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc,UPrimitiveComponent* PrimComp);
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
	virtual void PreTermRigidBody(NxActor* nActor);
	virtual void TermRBPhys(FRBPhysScene* Scene);
#endif

	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}
};

class ARB_ConstraintActor : public AActor
{
public:
    //## BEGIN PROPS RB_ConstraintActor
    class AActor* ConstraintActor1;
    class AActor* ConstraintActor2;
    class URB_ConstraintSetup* ConstraintSetup;
    class URB_ConstraintInstance* ConstraintInstance;
    BITFIELD bDisableCollision:1;
    BITFIELD bUpdateActor1RefFrame:1;
    BITFIELD bUpdateActor2RefFrame:1;
    class AActor* PulleyPivotActor1;
    class AActor* PulleyPivotActor2;
    //## END PROPS RB_ConstraintActor

    void SetDisableCollision(UBOOL NewDisableCollision);
    void InitConstraint(class AActor* Actor1,class AActor* Actor2,FName Actor1Bone=NAME_None,FName Actor2Bone=NAME_None,FLOAT BreakThreshold=0);
    void TermConstraint();
    DECLARE_FUNCTION(execSetDisableCollision)
    {
        P_GET_UBOOL(NewDisableCollision);
        P_FINISH;
        SetDisableCollision(NewDisableCollision);
    }
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(AActor,Actor1);
        P_GET_OBJECT(AActor,Actor2);
        P_GET_NAME_OPTX(Actor1Bone,NAME_None);
        P_GET_NAME_OPTX(Actor2Bone,NAME_None);
        P_GET_FLOAT_OPTX(BreakThreshold,0);
        P_FINISH;
        InitConstraint(Actor1,Actor2,Actor1Bone,Actor2Bone,BreakThreshold);
    }
    DECLARE_FUNCTION(execTermConstraint)
    {
        P_FINISH;
        TermConstraint();
    }
    DECLARE_ABSTRACT_CLASS(ARB_ConstraintActor,AActor,0,Engine)
	virtual void physRigidBody(FLOAT DeltaTime) {};
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void CheckForErrors(); // used for checking that this constraint is valid buring map build

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	void UpdateConstraintFramesFromActor();
};

class ARB_CylindricalForceActor : public AActor
{
public:
    //## BEGIN PROPS RB_CylindricalForceActor
    class UDrawCylinderComponent* RenderComponent;
    FLOAT RadialStrength;
    FLOAT RotationalStrength;
    FLOAT LiftStrength;
    FLOAT LiftFalloffHeight;
    FLOAT EscapeVelocity;
    FLOAT ForceRadius;
    FLOAT ForceTopRadius;
    FLOAT ForceHeight;
    FLOAT HeightOffset;
    BITFIELD bForceActive:1;
    BITFIELD bForceApplyToCloth:1;
    BITFIELD bForceApplyToFluid:1;
    BITFIELD bForceApplyToRigidBodies:1;
    BITFIELD bForceApplyToProjectiles:1;
    INT ForceFieldChannel;
    FRBCollisionChannelContainer CollideWithChannels;
    //## END PROPS RB_CylindricalForceActor

    DECLARE_CLASS(ARB_CylindricalForceActor,AActor,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_LineImpulseActor : public AActor
{
public:
    //## BEGIN PROPS RB_LineImpulseActor
    FLOAT ImpulseStrength;
    FLOAT ImpulseRange;
    BITFIELD bVelChange:1;
    BITFIELD bStopAtFirstHit:1;
    class UArrowComponent* Arrow;
    BYTE ImpulseCount;
    //## END PROPS RB_LineImpulseActor

    void FireLineImpulse();
    DECLARE_FUNCTION(execFireLineImpulse)
    {
        P_FINISH;
        FireLineImpulse();
    }
    DECLARE_CLASS(ARB_LineImpulseActor,AActor,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_RadialForceActor : public AActor
{
public:
    //## BEGIN PROPS RB_RadialForceActor
    class UDrawSphereComponent* RenderComponent;
    FLOAT ForceStrength;
    FLOAT ForceRadius;
    FLOAT SwirlStrength;
    FLOAT SpinTorque;
    BYTE ForceFalloff;
    BYTE RadialForceMode;
    BITFIELD bForceActive:1 GCC_BITFIELD_MAGIC;
    BITFIELD bForceApplyToCloth:1;
    BITFIELD bForceApplyToFluid:1;
    BITFIELD bForceApplyToRigidBodies:1;
    BITFIELD bForceApplyToProjectiles:1;
    INT ForceFieldChannel;
    FRBCollisionChannelContainer CollideWithChannels;
    //## END PROPS RB_RadialForceActor

    DECLARE_CLASS(ARB_RadialForceActor,AActor,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_RadialImpulseActor : public AActor
{
public:
    //## BEGIN PROPS RB_RadialImpulseActor
    class UDrawSphereComponent* RenderComponent;
    class URB_RadialImpulseComponent* ImpulseComponent;
    BYTE ImpulseCount;
    //## END PROPS RB_RadialImpulseActor

    DECLARE_CLASS(ARB_RadialImpulseActor,AActor,0,Engine)
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
};

class ARB_Thruster : public AActor
{
public:
    //## BEGIN PROPS RB_Thruster
    BITFIELD bThrustEnabled:1;
    FLOAT ThrustStrength;
    //## END PROPS RB_Thruster

    DECLARE_CLASS(ARB_Thruster,AActor,0,Engine)
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
};

class URB_ConstraintDrawComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_ConstraintDrawComponent
    class UMaterialInterface* LimitMaterial;
    //## END PROPS RB_ConstraintDrawComponent

    DECLARE_CLASS(URB_ConstraintDrawComponent,UPrimitiveComponent,0,Engine)
	// Primitive Component interface
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class URB_RadialImpulseComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_RadialImpulseComponent
    BYTE ImpulseFalloff;
    FLOAT ImpulseStrength;
    FLOAT ImpulseRadius;
    BITFIELD bVelChange:1;
    class UDrawSphereComponent* PreviewSphere;
    //## END PROPS RB_RadialImpulseComponent

    virtual void FireImpulse(FVector Origin);
    DECLARE_FUNCTION(execFireImpulse)
    {
        P_GET_STRUCT(FVector,Origin);
        P_FINISH;
        FireImpulse(Origin);
    }
    DECLARE_CLASS(URB_RadialImpulseComponent,UPrimitiveComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
public:
};

class URB_Handle : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Handle
    class UPrimitiveComponent* GrabbedComponent;
    FName GrabbedBoneName;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bRotationConstrained:1;
    class NxJoint* HandleData;
    class NxActor* KinActorData;
    FLOAT LinearDamping;
    FLOAT LinearStiffness;
    FLOAT AngularDamping;
    FLOAT AngularStiffness;
    FVector Destination;
    FVector StepSize;
    FVector Location;
    BITFIELD bInterpolating:1;
    //## END PROPS RB_Handle

    virtual void GrabComponent(class UPrimitiveComponent* Component,FName InBoneName,FVector GrabLocation,UBOOL bConstrainRotation);
    virtual void ReleaseComponent();
    virtual void SetLocation(FVector NewLocation);
    virtual void SetSmoothLocation(FVector NewLocation,FLOAT MoveTime);
    virtual void UpdateSmoothLocation(const FVector& NewLocation);
    virtual void SetOrientation(FQuat NewOrientation);
    virtual FQuat GetOrientation();
    DECLARE_FUNCTION(execGrabComponent)
    {
        P_GET_OBJECT(UPrimitiveComponent,Component);
        P_GET_NAME(InBoneName);
        P_GET_STRUCT(FVector,GrabLocation);
        P_GET_UBOOL(bConstrainRotation);
        P_FINISH;
        GrabComponent(Component,InBoneName,GrabLocation,bConstrainRotation);
    }
    DECLARE_FUNCTION(execReleaseComponent)
    {
        P_FINISH;
        ReleaseComponent();
    }
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        SetLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetSmoothLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_GET_FLOAT(MoveTime);
        P_FINISH;
        SetSmoothLocation(NewLocation,MoveTime);
    }
    DECLARE_FUNCTION(execUpdateSmoothLocation)
    {
        P_GET_STRUCT_REF(FVector,NewLocation);
        P_FINISH;
        UpdateSmoothLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetOrientation)
    {
        P_GET_STRUCT(FQuat,NewOrientation);
        P_FINISH;
        SetOrientation(NewOrientation);
    }
    DECLARE_FUNCTION(execGetOrientation)
    {
        P_FINISH;
        *(FQuat*)Result=GetOrientation();
    }
    DECLARE_CLASS(URB_Handle,UActorComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach();
	virtual void Tick(FLOAT DeltaTime);
public:
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);

	// URB_Handle interface
};

class URB_Spring : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Spring
    class UPrimitiveComponent* Component1;
    FName BoneName1;
    class UPrimitiveComponent* Component2;
    FName BoneName2;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bEnableForceMassRatio:1;
    FPointer SpringData;
    FLOAT TimeSinceActivation;
    FLOAT MinBodyMass;
    FLOAT SpringSaturateDist;
    FLOAT SpringMaxForce;
    FLOAT MaxForceMassRatio;
    FInterpCurveFloat SpringMaxForceTimeScale;
    FLOAT DampSaturateVel;
    FLOAT DampMaxForce;
    //## END PROPS RB_Spring

    virtual void SetComponents(class UPrimitiveComponent* InComponent1,FName InBoneName1,FVector Position1,class UPrimitiveComponent* InComponent2,FName InBoneName2,FVector Position2);
    virtual void Clear();
    DECLARE_FUNCTION(execSetComponents)
    {
        P_GET_OBJECT(UPrimitiveComponent,InComponent1);
        P_GET_NAME(InBoneName1);
        P_GET_STRUCT(FVector,Position1);
        P_GET_OBJECT(UPrimitiveComponent,InComponent2);
        P_GET_NAME(InBoneName2);
        P_GET_STRUCT(FVector,Position2);
        P_FINISH;
        SetComponents(InComponent1,InBoneName1,Position1,InComponent2,InBoneName2,Position2);
    }
    DECLARE_FUNCTION(execClear)
    {
        P_FINISH;
        Clear();
    }
    DECLARE_CLASS(URB_Spring,UActorComponent,0,Engine)
	// ActorComponent interface

	virtual void Tick(FLOAT DeltaTime);
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);
};

class USVehicleSimBase : public UActorComponent
{
public:
    //## BEGIN PROPS SVehicleSimBase
    FLOAT WheelSuspensionStiffness;
    FLOAT WheelSuspensionDamping;
    FLOAT WheelSuspensionBias;
    FLOAT WheelLongExtremumSlip;
    FLOAT WheelLongExtremumValue;
    FLOAT WheelLongAsymptoteSlip;
    FLOAT WheelLongAsymptoteValue;
    FLOAT WheelLatExtremumSlip;
    FLOAT WheelLatExtremumValue;
    FLOAT WheelLatAsymptoteSlip;
    FLOAT WheelLatAsymptoteValue;
    FLOAT WheelInertia;
    BITFIELD bWheelSpeedOverride:1;
    BITFIELD bClampedFrictionModel:1;
    BITFIELD bAutoDrive:1;
    FLOAT AutoDriveSteer;
    //## END PROPS SVehicleSimBase

    DECLARE_CLASS(USVehicleSimBase,UActorComponent,0,Engine)
	virtual void ProcessCarInput(ASVehicle* Vehicle) {}
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}

#if WITH_NOVODEX
	virtual void SetNxWheelShapeParams(class NxWheelShape* WheelShape, USVehicleWheel* VW, FLOAT LongGripScale=1.f, FLOAT LatGripScale=1.f);
#endif

	/** Returns a float representative of the vehcile's engine output. */
	virtual FLOAT GetEngineOutput(ASVehicle* Vehicle) { return 0.0f; }
};

class USVehicleSimCar : public USVehicleSimBase
{
public:
    //## BEGIN PROPS SVehicleSimCar
    FLOAT ChassisTorqueScale;
    FInterpCurveFloat MaxSteerAngleCurve;
    FLOAT SteerSpeed;
    FLOAT ReverseThrottle;
    FLOAT EngineBrakeFactor;
    FLOAT MaxBrakeTorque;
    FLOAT StopThreshold;
    FLOAT SlopeLimitFactor;
    BITFIELD bIsDriving:1;
    FLOAT ActualSteering;
    FLOAT TimeSinceThrottle;
    //## END PROPS SVehicleSimCar

    DECLARE_CLASS(USVehicleSimCar,USVehicleSimBase,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateHandbrake(ASVehicle* Vehicle);
};

class USVehicleSimCarTransmission : public USVehicleSimCar
{
public:
    //## BEGIN PROPS SVehicleSimCarTransmission
    //## END PROPS SVehicleSimCarTransmission

    DECLARE_CLASS(USVehicleSimCarTransmission,USVehicleSimCar,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USVehicleSimCarTransmission)
};

class USVehicleSimTank : public USVehicleSimCar
{
public:
    //## BEGIN PROPS SVehicleSimTank
    FLOAT LeftTrackVel;
    FLOAT RightTrackVel;
    FLOAT LeftTrackTorque;
    FLOAT RightTrackTorque;
    FLOAT MaxEngineTorque;
    FLOAT EngineDamping;
    FLOAT InsideTrackTorqueFactor;
    FLOAT SteeringLatStiffnessFactor;
    FLOAT TurnInPlaceThrottle;
    BITFIELD bTurnInPlaceOnSteer:1;
    //## END PROPS SVehicleSimTank

    DECLARE_CLASS(USVehicleSimTank,USVehicleSimCar,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual void ApplyWheels(FLOAT InLeftTrackVel, FLOAT InRightTrackVel, ASVehicle* Vehicle);
};

class USVehicleWheel : public UComponent
{
public:
    //## BEGIN PROPS SVehicleWheel
    FLOAT Steer;
    FLOAT MotorTorque;
    FLOAT BrakeTorque;
    FLOAT ChassisTorque;
    BITFIELD bPoweredWheel:1;
    BITFIELD bHoverWheel:1;
    BITFIELD bIsSquealing:1;
    BITFIELD bWheelOnGround:1;
    FLOAT SteerFactor;
    FName SkelControlName;
    FName BoneName;
    FVector BoneOffset;
    FLOAT WheelRadius;
    FLOAT SuspensionTravel;
    FLOAT SuspensionSpeed;
    class UParticleSystem* WheelParticleSystem;
    BYTE Side;
    FLOAT LongSlipFactor;
    FLOAT LatSlipFactor;
    FLOAT HandbrakeLongSlipFactor;
    FLOAT HandbrakeLatSlipFactor;
    FLOAT ParkedSlipFactor;
    FVector WheelPosition;
    FLOAT SpinVel;
    FLOAT LongSlipRatio;
    FLOAT LatSlipAngle;
    FVector ContactNormal;
    FVector LongDirection;
    FVector LatDirection;
    FLOAT ContactForce;
    FLOAT LongImpulse;
    FLOAT LatImpulse;
    FLOAT DesiredSuspensionPosition;
    FLOAT SuspensionPosition;
    FLOAT CurrentRotation;
    FPointer WheelShape;
    INT WheelMaterialIndex;
    class UClass* WheelPSCClass;
    class UParticleSystemComponent* WheelParticleComp;
    FName SlipParticleParamName;
    //## END PROPS SVehicleWheel

    DECLARE_CLASS(USVehicleWheel,UComponent,0,Engine)
#if WITH_NOVODEX
	class NxWheelShape* GetNxWheelShape()
	{
		return (NxWheelShape*)WheelShape;
	}
#endif

	/** @return whether this wheel wants a particle component attached to it */
	virtual UBOOL WantsParticleComponent();
};

class URB_BodySetup : public UKMeshProps
{
public:
    //## BEGIN PROPS RB_BodySetup
    FName BoneName;
    BITFIELD bFixed:1;
    BITFIELD bNoCollision:1;
    BITFIELD bBlockZeroExtent:1;
    BITFIELD bBlockNonZeroExtent:1;
    BITFIELD bEnableContinuousCollisionDetection:1;
    BITFIELD bAlwaysFullAnimWeight:1;
    class UPhysicalMaterial* PhysMaterial;
    FLOAT MassScale;
    TArrayNoInit<FPointer> CollisionGeom;
    TArrayNoInit<FVector> CollisionGeomScale3D;
    TArrayNoInit<FVector> PreCachedPhysScale;
    TArrayNoInit<FKCachedConvexData> PreCachedPhysData;
    INT PreCachedPhysDataVersion;
    //## END PROPS RB_BodySetup

    DECLARE_CLASS(URB_BodySetup,UKMeshProps,0,Engine)
	// UObject interface.
	virtual void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void FinishDestroy();
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// URB_BodySetup interface.
	void	CopyBodyPropertiesFrom(class URB_BodySetup* fromSetup);
	void	ClearShapeCache();

	/** Pre-cache this mesh at all desired scales. */
	void PreCachePhysicsData();
};

class UPhysicalMaterial : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterial
    INT MaterialIndex;
    FLOAT Friction;
    FLOAT Restitution;
    BITFIELD bForceConeFriction:1;
    FLOAT Density;
    FLOAT AngularDamping;
    FLOAT LinearDamping;
    FLOAT MagneticResponse;
    FLOAT WindResponse;
    FLOAT ImpactThreshold;
    FLOAT ImpactReFireDelay;
    class UParticleSystem* ImpactEffect;
    class USoundCue* ImpactSound;
    FLOAT SlideThreshold;
    FLOAT SlideReFireDelay;
    class UParticleSystem* SlideEffect;
    class USoundCue* SlideSound;
    class UPhysicalMaterial* Parent;
    class UPhysicalMaterialPropertyBase* PhysicalMaterialProperty;
    //## END PROPS PhysicalMaterial

    DECLARE_CLASS(UPhysicalMaterial,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/**
     * This will fix any old PhysicalMaterials that were created in the PhysMaterial's outer instead
	 * of correctly inside the PhysMaterial.  This will allow "broken" PhysMaterials to be renamed.
	 **/
	virtual UBOOL Rename( const TCHAR* InName, UObject* NewOuter, ERenameFlags Flags );
};

class UPhysicalMaterialPropertyBase : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterialPropertyBase
    //## END PROPS PhysicalMaterialPropertyBase

    DECLARE_ABSTRACT_CLASS(UPhysicalMaterialPropertyBase,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPhysicalMaterialPropertyBase)
};

class UPhysicsAsset : public UObject
{
public:
    //## BEGIN PROPS PhysicsAsset
    class USkeletalMesh* DefaultSkelMesh;
    TArrayNoInit<class URB_BodySetup*> BodySetup;
    TArrayNoInit<class URB_ConstraintSetup*> ConstraintSetup;
    class UPhysicsAssetInstance* DefaultInstance;
    //## END PROPS PhysicsAsset

    DECLARE_CLASS(UPhysicsAsset,UObject,0,Engine)
	// UObject interface

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// Creates a Physics Asset using the supplied Skeletal Mesh as a starting point.
	UBOOL CreateFromSkeletalMesh( class USkeletalMesh* skelMesh, FPhysAssetCreateParams& Params );
	static void CreateCollisionFromBone( URB_BodySetup* bs, class USkeletalMesh* skelMesh, INT BoneIndex, FPhysAssetCreateParams& Params, TArray<struct FBoneVertInfo>& Infos );

	INT						FindControllingBodyIndex(class USkeletalMesh* skelMesh, INT BoneIndex);

	INT						FindBodyIndex(FName BodyName);
	INT						FindConstraintIndex(FName ConstraintName);
	FName					FindConstraintBoneName(INT ConstraintIndex);

	/** Utility for getting indices of all bodies below (and including) the one with the supplied name. */
	void					GetBodyIndicesBelow(TArray<INT>& OutBodyIndices, FName InBoneName, USkeletalMesh* InSkelMesh);

	FBox					CalcAABB(class USkeletalMeshComponent* SkelComp);
	UBOOL					LineCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Start, const FVector& End, const FVector& Extent);
	UBOOL					PointCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Location, const FVector& Extent);
	void					UpdateMassProps();

	// For PhAT only really...
	INT CreateNewBody(FName InBodyName);
	void DestroyBody(INT BodyIndex);

	INT CreateNewConstraint(FName InConstraintName, URB_ConstraintSetup* InConstraintSetup = NULL);
	void DestroyConstraint(INT ConstraintIndex);

	void BodyFindConstraints(INT BodyIndex, TArray<INT>& Constraints);
	void ClearShapeCaches();

	void UpdateBodyIndices();

	void WeldBodies(INT BaseBodyIndex, INT AddBodyIndex, USkeletalMeshComponent* SkelComp);

	void DrawCollision(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FMatrix>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);
	void DrawConstraints(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FMatrix>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);

	void FixOuters();
};

class UPhysicsAssetInstance : public UObject
{
public:
    //## BEGIN PROPS PhysicsAssetInstance
    class AActor* Owner;
    INT RootBodyIndex;
    TArrayNoInit<class URB_BodyInstance*> Bodies;
    TArrayNoInit<class URB_ConstraintInstance*> Constraints;
    TMap<FRigidBodyIndexPair,UBOOL> CollisionDisableTable;
    FLOAT LinearSpringScale;
    FLOAT LinearDampingScale;
    FLOAT LinearForceLimitScale;
    FLOAT AngularSpringScale;
    FLOAT AngularDampingScale;
    FLOAT AngularForceLimitScale;
    //## END PROPS PhysicsAssetInstance

    void SetLinearDriveScale(FLOAT InLinearSpringScale,FLOAT InLinearDampingScale,FLOAT InLinearForceLimitScale);
    void SetAngularDriveScale(FLOAT InAngularSpringScale,FLOAT InAngularDampingScale,FLOAT InAngularForceLimitScale);
    void SetAllMotorsAngularDriveStrength(FLOAT InAngularSpringStrength,FLOAT InAngularDampingStrength,FLOAT InAngularForceLimitStrength,class USkeletalMeshComponent* SkelMeshComp);
    FLOAT GetTotalMassBelowBone(FName InBoneName,class UPhysicsAsset* InAsset,class USkeletalMesh* InSkelMesh);
    void SetAllBodiesFixed(UBOOL bNewFixed);
    void SetNamedBodiesFixed(UBOOL bNewFixed,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetAllMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetNamedMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetAllMotorsAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetNamedRBBoneSprings(UBOOL bEnable,const TArray<FName>& BoneNames,FLOAT InBoneLinearSpring,FLOAT InBoneAngularSpring,class USkeletalMeshComponent* SkelMeshComp);
    void SetNamedBodiesBlockRigidBody(UBOOL bNewBlockRigidBody,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh);
    void SetFullAnimWeightBonesFixed(UBOOL bNewFixed,class USkeletalMeshComponent* SkelMesh);
    class URB_BodyInstance* FindBodyInstance(FName BodyName,class UPhysicsAsset* InAsset);
    class URB_ConstraintInstance* FindConstraintInstance(FName ConName,class UPhysicsAsset* InAsset);
    DECLARE_FUNCTION(execSetLinearDriveScale)
    {
        P_GET_FLOAT(InLinearSpringScale);
        P_GET_FLOAT(InLinearDampingScale);
        P_GET_FLOAT(InLinearForceLimitScale);
        P_FINISH;
        SetLinearDriveScale(InLinearSpringScale,InLinearDampingScale,InLinearForceLimitScale);
    }
    DECLARE_FUNCTION(execSetAngularDriveScale)
    {
        P_GET_FLOAT(InAngularSpringScale);
        P_GET_FLOAT(InAngularDampingScale);
        P_GET_FLOAT(InAngularForceLimitScale);
        P_FINISH;
        SetAngularDriveScale(InAngularSpringScale,InAngularDampingScale,InAngularForceLimitScale);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularDriveStrength)
    {
        P_GET_FLOAT(InAngularSpringStrength);
        P_GET_FLOAT(InAngularDampingStrength);
        P_GET_FLOAT(InAngularForceLimitStrength);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_FINISH;
        SetAllMotorsAngularDriveStrength(InAngularSpringStrength,InAngularDampingStrength,InAngularForceLimitStrength,SkelMeshComp);
    }
    DECLARE_FUNCTION(execGetTotalMassBelowBone)
    {
        P_GET_NAME(InBoneName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_GET_OBJECT(USkeletalMesh,InSkelMesh);
        P_FINISH;
        *(FLOAT*)Result=GetTotalMassBelowBone(InBoneName,InAsset,InSkelMesh);
    }
    DECLARE_FUNCTION(execSetAllBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        SetAllBodiesFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execSetNamedBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        SetNamedBodiesFixed(bNewFixed,BoneNames,SkelMesh,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        SetAllMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetNamedMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        SetNamedMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive,BoneNames,SkelMeshComp,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        SetAllMotorsAngularDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetNamedRBBoneSprings)
    {
        P_GET_UBOOL(bEnable);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_FLOAT(InBoneLinearSpring);
        P_GET_FLOAT(InBoneAngularSpring);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_FINISH;
        SetNamedRBBoneSprings(bEnable,BoneNames,InBoneLinearSpring,InBoneAngularSpring,SkelMeshComp);
    }
    DECLARE_FUNCTION(execSetNamedBodiesBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        SetNamedBodiesBlockRigidBody(bNewBlockRigidBody,BoneNames,SkelMesh);
    }
    DECLARE_FUNCTION(execSetFullAnimWeightBonesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        SetFullAnimWeightBonesFixed(bNewFixed,SkelMesh);
    }
    DECLARE_FUNCTION(execFindBodyInstance)
    {
        P_GET_NAME(BodyName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_BodyInstance**)Result=FindBodyInstance(BodyName,InAsset);
    }
    DECLARE_FUNCTION(execFindConstraintInstance)
    {
        P_GET_NAME(ConName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_ConstraintInstance**)Result=FindConstraintInstance(ConName,InAsset);
    }
    DECLARE_CLASS(UPhysicsAssetInstance,UObject,0,Engine)
	// UObject interface
	virtual void			Serialize(FArchive& Ar);

	// UPhysicsAssetInstance interface
	void					InitInstance(class USkeletalMeshComponent* SkelComp, class UPhysicsAsset* PhysAsset, UBOOL bFixed, FRBPhysScene* InRBScene);
	UBOOL					TermInstance(FRBPhysScene* Scene);

	void					DisableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
	void					EnableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
};

class URB_BodyInstance : public UObject
{
public:
    //## BEGIN PROPS RB_BodyInstance
    class UPrimitiveComponent* OwnerComponent;
    INT BodyIndex;
    FVector Velocity;
    FVector PreviousVelocity;
    INT SceneIndex;
    FPointer BodyData;
    FPointer BoneSpring;
    FPointer BoneSpringKinActor;
    BITFIELD bEnableBoneSpringLinear:1;
    BITFIELD bEnableBoneSpringAngular:1;
    BITFIELD bDisableOnOverextension:1;
    BITFIELD bTeleportOnOverextension:1;
    BITFIELD bUseKinActorForBoneSpring:1;
    BITFIELD bMakeSpringToBaseCollisionComponent:1;
    BITFIELD bOnlyCollideWithPawns:1;
    FLOAT BoneLinearSpring;
    FLOAT BoneLinearDamping;
    FLOAT BoneAngularSpring;
    FLOAT BoneAngularDamping;
    FLOAT OverextensionThreshold;
    FLOAT CustomGravityFactor;
    FLOAT LastEffectPlayedTime;
    class UPhysicalMaterial* PhysMaterialOverride;
    //## END PROPS RB_BodyInstance

    void SetFixed(UBOOL bNewFixed);
    UBOOL IsFixed();
    FVector GetUnrealWorldVelocity();
    FVector GetUnrealWorldAngularVelocity();
    void EnableBoneSpring(UBOOL bInEnableLinear,UBOOL bInEnableAngular,const FMatrix& InBoneTarget);
    void SetBoneSpringParams(FLOAT InLinearSpring,FLOAT InLinearDamping,FLOAT InAngularSpring,FLOAT InAngularDamping);
    void SetBoneSpringTarget(const FMatrix& InBoneTarget,UBOOL bTeleport);
    void SetBlockRigidBody(UBOOL bNewBlockRigidBody);
    void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
    DECLARE_FUNCTION(execSetFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        SetFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execIsFixed)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFixed();
    }
    DECLARE_FUNCTION(execGetUnrealWorldVelocity)
    {
        P_FINISH;
        *(FVector*)Result=GetUnrealWorldVelocity();
    }
    DECLARE_FUNCTION(execGetUnrealWorldAngularVelocity)
    {
        P_FINISH;
        *(FVector*)Result=GetUnrealWorldAngularVelocity();
    }
    DECLARE_FUNCTION(execEnableBoneSpring)
    {
        P_GET_UBOOL(bInEnableLinear);
        P_GET_UBOOL(bInEnableAngular);
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_FINISH;
        EnableBoneSpring(bInEnableLinear,bInEnableAngular,InBoneTarget);
    }
    DECLARE_FUNCTION(execSetBoneSpringParams)
    {
        P_GET_FLOAT(InLinearSpring);
        P_GET_FLOAT(InLinearDamping);
        P_GET_FLOAT(InAngularSpring);
        P_GET_FLOAT(InAngularDamping);
        P_FINISH;
        SetBoneSpringParams(InLinearSpring,InLinearDamping,InAngularSpring,InAngularDamping);
    }
    DECLARE_FUNCTION(execSetBoneSpringTarget)
    {
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_GET_UBOOL(bTeleport);
        P_FINISH;
        SetBoneSpringTarget(InBoneTarget,bTeleport);
    }
    DECLARE_FUNCTION(execSetBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_FINISH;
        SetBlockRigidBody(bNewBlockRigidBody);
    }
    DECLARE_FUNCTION(execSetPhysMaterialOverride)
    {
        P_GET_OBJECT(UPhysicalMaterial,NewPhysMaterial);
        P_FINISH;
        SetPhysMaterialOverride(NewPhysMaterial);
    }
    DECLARE_CLASS(URB_BodyInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_BodyInstance interface
	void InitBody(class URB_BodySetup* setup, const FMatrix& transform, const FVector& Scale3D, UBOOL bFixed, UPrimitiveComponent* PrimComp, FRBPhysScene* InRBScene);
	UBOOL TermBody(FRBPhysScene* Scene);

	UBOOL IsValidBodyInstance();
	FMatrix GetUnrealWorldTM();

	FVector GetCOMPosition();
	FLOAT GetBodyMass();
	void DrawCOMPosition( FPrimitiveDrawInterface* PDI, FLOAT COMRenderSize, const FColor& COMRenderColor );

	/** Utility for copying properties from one BodyInstance to another. */
	void CopyBodyInstancePropertiesFrom(URB_BodyInstance* FromInst);

	UPhysicalMaterial* GetPhysicalMaterial();

#if WITH_NOVODEX
	class NxActor* GetNxActor();
	void UpdatePhysMaterialOverride();
#endif
};

class URB_ConstraintInstance : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintInstance
    class AActor* Owner;
    class UPrimitiveComponent* OwnerComponent;
    INT ConstraintIndex;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bLinearXPositionDrive:1;
    BITFIELD bLinearXVelocityDrive:1;
    BITFIELD bLinearYPositionDrive:1;
    BITFIELD bLinearYVelocityDrive:1;
    BITFIELD bLinearZPositionDrive:1;
    BITFIELD bLinearZVelocityDrive:1;
    BITFIELD bSwingPositionDrive:1;
    BITFIELD bSwingVelocityDrive:1;
    BITFIELD bTwistPositionDrive:1;
    BITFIELD bTwistVelocityDrive:1;
    BITFIELD bAngularSlerpDrive:1;
    BITFIELD bTerminated:1;
    class NxJoint* ConstraintData;
    FVector LinearPositionTarget;
    FVector LinearVelocityTarget;
    FLOAT LinearDriveSpring;
    FLOAT LinearDriveDamping;
    FLOAT LinearDriveForceLimit;
    FQuat AngularPositionTarget;
    FVector AngularVelocityTarget;
    FLOAT AngularDriveSpring;
    FLOAT AngularDriveDamping;
    FLOAT AngularDriveForceLimit;
    FPointer DummyKinActor;
    //## END PROPS RB_ConstraintInstance

    void InitConstraint(class UPrimitiveComponent* PrimComp1,class UPrimitiveComponent* PrimComp2,class URB_ConstraintSetup* Setup,FLOAT Scale,class AActor* InOwner,class UPrimitiveComponent* InPrimComp,UBOOL bMakeKinForBody1);
    FVector GetConstraintLocation();
    void SetLinearPositionDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetLinearVelocityDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetLinearPositionTarget(FVector InPosTarget);
    void SetLinearVelocityTarget(FVector InVelTarget);
    void SetLinearDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularPositionTarget(FQuat InPosTarget);
    void SetAngularVelocityTarget(FVector InVelTarget);
    void SetAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularDOFLimitScale(FLOAT InSwing1LimitScale,FLOAT InSwing2LimitScale,FLOAT InTwistLimitScale,class URB_ConstraintSetup* InSetup);
    void SetLinearLimitSize(FLOAT NewLimitSize);
    void MoveKinActorTransform(FMatrix& NewTM);
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(UPrimitiveComponent,PrimComp1);
        P_GET_OBJECT(UPrimitiveComponent,PrimComp2);
        P_GET_OBJECT(URB_ConstraintSetup,Setup);
        P_GET_FLOAT(Scale);
        P_GET_OBJECT(AActor,InOwner);
        P_GET_OBJECT(UPrimitiveComponent,InPrimComp);
        P_GET_UBOOL(bMakeKinForBody1);
        P_FINISH;
        InitConstraint(PrimComp1,PrimComp2,Setup,Scale,InOwner,InPrimComp,bMakeKinForBody1);
    }
    DECLARE_FUNCTION(execTermConstraint);
    DECLARE_FUNCTION(execGetConstraintLocation)
    {
        P_FINISH;
        *(FVector*)Result=GetConstraintLocation();
    }
    DECLARE_FUNCTION(execSetLinearPositionDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        SetLinearPositionDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetLinearVelocityDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        SetLinearVelocityDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        SetAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        SetAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetLinearPositionTarget)
    {
        P_GET_STRUCT(FVector,InPosTarget);
        P_FINISH;
        SetLinearPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetLinearVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        SetLinearVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetLinearDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        SetLinearDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularPositionTarget)
    {
        P_GET_STRUCT(FQuat,InPosTarget);
        P_FINISH;
        SetAngularPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetAngularVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        SetAngularVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        SetAngularDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularDOFLimitScale)
    {
        P_GET_FLOAT(InSwing1LimitScale);
        P_GET_FLOAT(InSwing2LimitScale);
        P_GET_FLOAT(InTwistLimitScale);
        P_GET_OBJECT(URB_ConstraintSetup,InSetup);
        P_FINISH;
        SetAngularDOFLimitScale(InSwing1LimitScale,InSwing2LimitScale,InTwistLimitScale,InSetup);
    }
    DECLARE_FUNCTION(execSetLinearLimitSize)
    {
        P_GET_FLOAT(NewLimitSize);
        P_FINISH;
        SetLinearLimitSize(NewLimitSize);
    }
    DECLARE_FUNCTION(execMoveKinActorTransform)
    {
        P_GET_STRUCT_REF(FMatrix,NewTM);
        P_FINISH;
        MoveKinActorTransform(NewTM);
    }
    DECLARE_CLASS(URB_ConstraintInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_ConstraintInstance interface

	UBOOL TermConstraint(FRBPhysScene* Scene, UBOOL bFireBrokenEvent);

	void CopyInstanceParamsFrom(class URB_ConstraintInstance* fromInstance);
};

struct FLinearDOFSetup
{
    BYTE bLimited;
    FLOAT LimitSize;
};

class URB_ConstraintSetup : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintSetup
    FName JointName;
    FName ConstraintBone1;
    FName ConstraintBone2;
    FVector Pos1;
    FVector PriAxis1;
    FVector SecAxis1;
    FVector Pos2;
    FVector PriAxis2;
    FVector SecAxis2;
    FVector PulleyPivot1;
    FVector PulleyPivot2;
    struct FLinearDOFSetup LinearXSetup;
    struct FLinearDOFSetup LinearYSetup;
    struct FLinearDOFSetup LinearZSetup;
    BITFIELD bLinearLimitSoft:1;
    BITFIELD bLinearBreakable:1;
    BITFIELD bSwingLimited:1;
    BITFIELD bTwistLimited:1;
    BITFIELD bSwingLimitSoft:1;
    BITFIELD bTwistLimitSoft:1;
    BITFIELD bAngularBreakable:1;
    BITFIELD bIsPulley:1;
    BITFIELD bMaintainMinDistance:1;
    FLOAT LinearLimitStiffness;
    FLOAT LinearLimitDamping;
    FLOAT LinearBreakThreshold;
    FLOAT Swing1LimitAngle;
    FLOAT Swing2LimitAngle;
    FLOAT TwistLimitAngle;
    FLOAT SwingLimitStiffness;
    FLOAT SwingLimitDamping;
    FLOAT TwistLimitStiffness;
    FLOAT TwistLimitDamping;
    FLOAT AngularBreakThreshold;
    FLOAT PulleyRatio;
    //## END PROPS RB_ConstraintSetup

    DECLARE_CLASS(URB_ConstraintSetup,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// Get/SetRefFrameMatrix only used in PhAT
	FMatrix GetRefFrameMatrix(INT BodyIndex);
	void SetRefFrameMatrix(INT BodyIndex, const FMatrix& RefFrame);

	void CopyConstraintGeometryFrom(class URB_ConstraintSetup* fromSetup);
	void CopyConstraintParamsFrom(class URB_ConstraintSetup* fromSetup);

	void DrawConstraint(class FPrimitiveDrawInterface* PDI, 
		FLOAT Scale, UBOOL bDrawLimits, UBOOL bDrawSelected, UMaterialInterface* LimitMaterial,
		const FMatrix& Con1Frame, const FMatrix& Con2Frame, UBOOL bDrawAsPoint);
};

class URB_BSJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_BSJointSetup
    //## END PROPS RB_BSJointSetup

    DECLARE_CLASS(URB_BSJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_BSJointSetup)
};

class URB_DistanceJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_DistanceJointSetup
    //## END PROPS RB_DistanceJointSetup

    DECLARE_CLASS(URB_DistanceJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_DistanceJointSetup)
};

class URB_HingeSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_HingeSetup
    //## END PROPS RB_HingeSetup

    DECLARE_CLASS(URB_HingeSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_HingeSetup)
};

class URB_PrismaticSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PrismaticSetup
    //## END PROPS RB_PrismaticSetup

    DECLARE_CLASS(URB_PrismaticSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PrismaticSetup)
};

class URB_PulleyJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PulleyJointSetup
    //## END PROPS RB_PulleyJointSetup

    DECLARE_CLASS(URB_PulleyJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PulleyJointSetup)
};

class URB_SkelJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_SkelJointSetup
    //## END PROPS RB_SkelJointSetup

    DECLARE_CLASS(URB_SkelJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_SkelJointSetup)
};

class URB_StayUprightSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_StayUprightSetup
    //## END PROPS RB_StayUprightSetup

    DECLARE_CLASS(URB_StayUprightSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_StayUprightSetup)
};

#endif // !INCLUDED_ENGINE_PHYSICS_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AKActor,-1,execResolveRBState);
AUTOGENERATE_FUNCTION(AKActor,-1,execGetKActorPhysMaterial);
AUTOGENERATE_FUNCTION(AKActorSpawnable,-1,execResetComponents);
AUTOGENERATE_FUNCTION(AKAsset,-1,execSetAssetPhysicsState);
AUTOGENERATE_FUNCTION(AKAsset,-1,execGetAssetPhysicsState);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindConstraintInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindBodyInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetFullAnimWeightBonesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesBlockRigidBody);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedRBBoneSprings);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularDriveParams);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execGetTotalMassBelowBone);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularDriveStrength);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAngularDriveScale);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetLinearDriveScale);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetPhysMaterialOverride);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBlockRigidBody);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringTarget);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringParams);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execEnableBoneSpring);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldAngularVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execIsFixed);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetFixed);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execInitConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execSetDisableCollision);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execMoveKinActorTransform);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearLimitSize);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDOFLimitScale);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execGetConstraintLocation);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execInitConstraint);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execUpdateSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execReleaseComponent);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGrabComponent);
AUTOGENERATE_FUNCTION(ARB_LineImpulseActor,-1,execFireLineImpulse);
AUTOGENERATE_FUNCTION(URB_RadialImpulseComponent,-1,execFireImpulse);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execClear);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execSetComponents);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execHasWheelsOnGround);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execInitVehicleRagdoll);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execSetWheelCollision);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PHYSICS_NATIVE_DEFS
#define ENGINE_PHYSICS_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,AKActor);
DECLARE_NATIVE_TYPE(Engine,AKActorSpawnable);
DECLARE_NATIVE_TYPE(Engine,AKAsset);
DECLARE_NATIVE_TYPE(Engine,UPhysicalMaterial);
DECLARE_NATIVE_TYPE(Engine,UPhysicalMaterialPropertyBase);
DECLARE_NATIVE_TYPE(Engine,UPhysicsAsset);
DECLARE_NATIVE_TYPE(Engine,UPhysicsAssetInstance);
DECLARE_NATIVE_TYPE(Engine,URB_BodyInstance);
DECLARE_NATIVE_TYPE(Engine,URB_BodySetup);
DECLARE_NATIVE_TYPE(Engine,URB_BSJointSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_ConstraintActor);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintDrawComponent);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintInstance);
DECLARE_NATIVE_TYPE(Engine,URB_ConstraintSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_CylindricalForceActor);
DECLARE_NATIVE_TYPE(Engine,URB_DistanceJointSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_ForceFieldExcludeVolume);
DECLARE_NATIVE_TYPE(Engine,URB_Handle);
DECLARE_NATIVE_TYPE(Engine,URB_HingeSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_LineImpulseActor);
DECLARE_NATIVE_TYPE(Engine,URB_PrismaticSetup);
DECLARE_NATIVE_TYPE(Engine,URB_PulleyJointSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_RadialForceActor);
DECLARE_NATIVE_TYPE(Engine,ARB_RadialImpulseActor);
DECLARE_NATIVE_TYPE(Engine,URB_RadialImpulseComponent);
DECLARE_NATIVE_TYPE(Engine,URB_SkelJointSetup);
DECLARE_NATIVE_TYPE(Engine,URB_Spring);
DECLARE_NATIVE_TYPE(Engine,URB_StayUprightSetup);
DECLARE_NATIVE_TYPE(Engine,ARB_Thruster);
DECLARE_NATIVE_TYPE(Engine,ASVehicle);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimBase);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimCar);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimCarTransmission);
DECLARE_NATIVE_TYPE(Engine,USVehicleSimTank);
DECLARE_NATIVE_TYPE(Engine,USVehicleWheel);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PHYSICS \
	AKActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAKActorNative; \
	AKActorSpawnable::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAKActorSpawnableNative; \
	AKAsset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAKAssetNative; \
	UPhysicalMaterial::StaticClass(); \
	UPhysicalMaterialPropertyBase::StaticClass(); \
	UPhysicsAsset::StaticClass(); \
	UPhysicsAssetInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPhysicsAssetInstanceNative; \
	URB_BodyInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_BodyInstanceNative; \
	URB_BodySetup::StaticClass(); \
	URB_BSJointSetup::StaticClass(); \
	ARB_ConstraintActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_ConstraintActorNative; \
	URB_ConstraintDrawComponent::StaticClass(); \
	URB_ConstraintInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_ConstraintInstanceNative; \
	URB_ConstraintSetup::StaticClass(); \
	ARB_CylindricalForceActor::StaticClass(); \
	URB_DistanceJointSetup::StaticClass(); \
	ARB_ForceFieldExcludeVolume::StaticClass(); \
	URB_Handle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_HandleNative; \
	URB_HingeSetup::StaticClass(); \
	ARB_LineImpulseActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_LineImpulseActorNative; \
	URB_PrismaticSetup::StaticClass(); \
	URB_PulleyJointSetup::StaticClass(); \
	ARB_RadialForceActor::StaticClass(); \
	ARB_RadialImpulseActor::StaticClass(); \
	URB_RadialImpulseComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_RadialImpulseComponentNative; \
	URB_SkelJointSetup::StaticClass(); \
	URB_Spring::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_SpringNative; \
	URB_StayUprightSetup::StaticClass(); \
	ARB_Thruster::StaticClass(); \
	ASVehicle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineASVehicleNative; \
	USVehicleSimBase::StaticClass(); \
	USVehicleSimCar::StaticClass(); \
	USVehicleSimCarTransmission::StaticClass(); \
	USVehicleSimTank::StaticClass(); \
	USVehicleWheel::StaticClass(); \

#endif // ENGINE_PHYSICS_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AKActor) GEngineAKActorNatives[] = 
{ 
	MAP_NATIVE(AKActor,execResolveRBState)
	MAP_NATIVE(AKActor,execGetKActorPhysMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AKActor);

NATIVE_INFO(AKActorSpawnable) GEngineAKActorSpawnableNatives[] = 
{ 
	MAP_NATIVE(AKActorSpawnable,execResetComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AKActorSpawnable);

NATIVE_INFO(AKAsset) GEngineAKAssetNatives[] = 
{ 
	MAP_NATIVE(AKAsset,execSetAssetPhysicsState)
	MAP_NATIVE(AKAsset,execGetAssetPhysicsState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AKAsset);

NATIVE_INFO(UPhysicsAssetInstance) GEngineUPhysicsAssetInstanceNatives[] = 
{ 
	MAP_NATIVE(UPhysicsAssetInstance,execFindConstraintInstance)
	MAP_NATIVE(UPhysicsAssetInstance,execFindBodyInstance)
	MAP_NATIVE(UPhysicsAssetInstance,execSetFullAnimWeightBonesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedBodiesBlockRigidBody)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedRBBoneSprings)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularDriveParams)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance,execSetNamedBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance,execGetTotalMassBelowBone)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAllMotorsAngularDriveStrength)
	MAP_NATIVE(UPhysicsAssetInstance,execSetAngularDriveScale)
	MAP_NATIVE(UPhysicsAssetInstance,execSetLinearDriveScale)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPhysicsAssetInstance);

NATIVE_INFO(URB_BodyInstance) GEngineURB_BodyInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_BodyInstance,execSetPhysMaterialOverride)
	MAP_NATIVE(URB_BodyInstance,execSetBlockRigidBody)
	MAP_NATIVE(URB_BodyInstance,execSetBoneSpringTarget)
	MAP_NATIVE(URB_BodyInstance,execSetBoneSpringParams)
	MAP_NATIVE(URB_BodyInstance,execEnableBoneSpring)
	MAP_NATIVE(URB_BodyInstance,execGetUnrealWorldAngularVelocity)
	MAP_NATIVE(URB_BodyInstance,execGetUnrealWorldVelocity)
	MAP_NATIVE(URB_BodyInstance,execIsFixed)
	MAP_NATIVE(URB_BodyInstance,execSetFixed)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_BodyInstance);

NATIVE_INFO(ARB_ConstraintActor) GEngineARB_ConstraintActorNatives[] = 
{ 
	MAP_NATIVE(ARB_ConstraintActor,execTermConstraint)
	MAP_NATIVE(ARB_ConstraintActor,execInitConstraint)
	MAP_NATIVE(ARB_ConstraintActor,execSetDisableCollision)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_ConstraintActor);

NATIVE_INFO(URB_ConstraintInstance) GEngineURB_ConstraintInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_ConstraintInstance,execMoveKinActorTransform)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearLimitSize)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularDOFLimitScale)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularDriveParams)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearDriveParams)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetAngularPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance,execSetLinearPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance,execGetConstraintLocation)
	MAP_NATIVE(URB_ConstraintInstance,execTermConstraint)
	MAP_NATIVE(URB_ConstraintInstance,execInitConstraint)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_ConstraintInstance);

NATIVE_INFO(URB_Handle) GEngineURB_HandleNatives[] = 
{ 
	MAP_NATIVE(URB_Handle,execGetOrientation)
	MAP_NATIVE(URB_Handle,execSetOrientation)
	MAP_NATIVE(URB_Handle,execUpdateSmoothLocation)
	MAP_NATIVE(URB_Handle,execSetSmoothLocation)
	MAP_NATIVE(URB_Handle,execSetLocation)
	MAP_NATIVE(URB_Handle,execReleaseComponent)
	MAP_NATIVE(URB_Handle,execGrabComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Handle);

NATIVE_INFO(ARB_LineImpulseActor) GEngineARB_LineImpulseActorNatives[] = 
{ 
	MAP_NATIVE(ARB_LineImpulseActor,execFireLineImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_LineImpulseActor);

NATIVE_INFO(URB_RadialImpulseComponent) GEngineURB_RadialImpulseComponentNatives[] = 
{ 
	MAP_NATIVE(URB_RadialImpulseComponent,execFireImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_RadialImpulseComponent);

NATIVE_INFO(URB_Spring) GEngineURB_SpringNatives[] = 
{ 
	MAP_NATIVE(URB_Spring,execClear)
	MAP_NATIVE(URB_Spring,execSetComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Spring);

NATIVE_INFO(ASVehicle) GEngineASVehicleNatives[] = 
{ 
	MAP_NATIVE(ASVehicle,execHasWheelsOnGround)
	MAP_NATIVE(ASVehicle,execInitVehicleRagdoll)
	MAP_NATIVE(ASVehicle,execSetWheelCollision)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ASVehicle);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,KActor,ImpactEffectComponent)
VERIFY_CLASS_OFFSET_NODIE(A,KActor,InitialRotation)
VERIFY_CLASS_SIZE_NODIE(AKActor)
VERIFY_CLASS_SIZE_NODIE(AKActorSpawnable)
VERIFY_CLASS_OFFSET_NODIE(A,KAsset,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,KAsset,RigidBodyStates)
VERIFY_CLASS_SIZE_NODIE(AKAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicalMaterial,MaterialIndex)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicalMaterial,PhysicalMaterialProperty)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterial)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterialPropertyBase)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultSkelMesh)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultInstance)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,AngularForceLimitScale)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodyInstance,OwnerComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodyInstance,PhysMaterialOverride)
VERIFY_CLASS_SIZE_NODIE(URB_BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,BoneName)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,PreCachedPhysDataVersion)
VERIFY_CLASS_SIZE_NODIE(URB_BodySetup)
VERIFY_CLASS_SIZE_NODIE(URB_BSJointSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_ConstraintActor,ConstraintActor1)
VERIFY_CLASS_OFFSET_NODIE(A,RB_ConstraintActor,PulleyPivotActor2)
VERIFY_CLASS_SIZE_NODIE(ARB_ConstraintActor)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintDrawComponent,LimitMaterial)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintDrawComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintInstance,DummyKinActor)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintSetup,JointName)
VERIFY_CLASS_OFFSET_NODIE(U,RB_ConstraintSetup,PulleyRatio)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_CylindricalForceActor,RenderComponent)
VERIFY_CLASS_OFFSET_NODIE(A,RB_CylindricalForceActor,CollideWithChannels)
VERIFY_CLASS_SIZE_NODIE(ARB_CylindricalForceActor)
VERIFY_CLASS_SIZE_NODIE(URB_DistanceJointSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_ForceFieldExcludeVolume,ForceFieldChannel)
VERIFY_CLASS_SIZE_NODIE(ARB_ForceFieldExcludeVolume)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Handle,GrabbedComponent)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Handle,Location)
VERIFY_CLASS_SIZE_NODIE(URB_Handle)
VERIFY_CLASS_SIZE_NODIE(URB_HingeSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_LineImpulseActor,ImpulseStrength)
VERIFY_CLASS_OFFSET_NODIE(A,RB_LineImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_LineImpulseActor)
VERIFY_CLASS_SIZE_NODIE(URB_PrismaticSetup)
VERIFY_CLASS_SIZE_NODIE(URB_PulleyJointSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialForceActor,RenderComponent)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialForceActor,CollideWithChannels)
VERIFY_CLASS_SIZE_NODIE(ARB_RadialForceActor)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialImpulseActor,RenderComponent)
VERIFY_CLASS_OFFSET_NODIE(A,RB_RadialImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_RadialImpulseActor)
VERIFY_CLASS_OFFSET_NODIE(U,RB_RadialImpulseComponent,ImpulseFalloff)
VERIFY_CLASS_OFFSET_NODIE(U,RB_RadialImpulseComponent,PreviewSphere)
VERIFY_CLASS_SIZE_NODIE(URB_RadialImpulseComponent)
VERIFY_CLASS_SIZE_NODIE(URB_SkelJointSetup)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Spring,Component1)
VERIFY_CLASS_OFFSET_NODIE(U,RB_Spring,DampMaxForce)
VERIFY_CLASS_SIZE_NODIE(URB_Spring)
VERIFY_CLASS_SIZE_NODIE(URB_StayUprightSetup)
VERIFY_CLASS_OFFSET_NODIE(A,RB_Thruster,ThrustStrength)
VERIFY_CLASS_SIZE_NODIE(ARB_Thruster)
VERIFY_CLASS_OFFSET_NODIE(A,SVehicle,SimObj)
VERIFY_CLASS_OFFSET_NODIE(A,SVehicle,RadialImpulseScaling)
VERIFY_CLASS_SIZE_NODIE(ASVehicle)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimBase,WheelSuspensionStiffness)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimBase,AutoDriveSteer)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimBase)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimCar,ChassisTorqueScale)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimCar,TimeSinceThrottle)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimCar)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimCarTransmission)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimTank,LeftTrackVel)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleSimTank,TurnInPlaceThrottle)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimTank)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleWheel,Steer)
VERIFY_CLASS_OFFSET_NODIE(U,SVehicleWheel,SlipParticleParamName)
VERIFY_CLASS_SIZE_NODIE(USVehicleWheel)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
