/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "EngineUIPrivateGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_UIPRIVATE_ENUMS
#define INCLUDED_ENGINE_UIPRIVATE_ENUMS 1

enum EFadeType
{
    EFT_None                =0,
    EFT_Fading              =1,
    EFT_Pulsing             =2,
    EFT_MAX                 =3,
};
enum EProviderAccessType
{
    ACCESS_ReadOnly         =0,
    ACCESS_WriteAll         =1,
    ACCESS_MAX              =2,
};
enum EStatsFetchType
{
    SFT_Player              =0,
    SFT_CenteredOnPlayer    =1,
    SFT_Friends             =2,
    SFT_TopRankings         =3,
    SFT_MAX                 =4,
};
enum EFrameBoxImage
{
    FBI_TopLeft             =0,
    FBI_Top                 =1,
    FBI_TopRight            =2,
    FBI_CenterLeft          =3,
    FBI_Center              =4,
    FBI_CenterRight         =5,
    FBI_BottomLeft          =6,
    FBI_Bottom              =7,
    FBI_BottomRight         =8,
    FBI_MAX                 =9,
};
enum ESafeRegionType
{
    ESRT_FullRegion         =0,
    ESRT_TextSafeRegion     =1,
    ESRT_MAX                =2,
};
enum EEditBoxCharacterSet
{
    CHARSET_All             =0,
    CHARSET_NoSpecial       =1,
    CHARSET_AlphaOnly       =2,
    CHARSET_NumericOnly     =3,
    CHARSET_MAX             =4,
};
enum EListWrapBehavior
{
    LISTWRAP_None           =0,
    LISTWRAP_Smooth         =1,
    LISTWRAP_Jump           =2,
    LISTWRAP_MAX            =3,
};
enum ECellLinkType
{
    LINKED_None             =0,
    LINKED_Rows             =1,
    LINKED_Columns          =2,
    LINKED_MAX              =3,
};
enum ECellAutoSizeMode
{
    CELLAUTOSIZE_None       =0,
    CELLAUTOSIZE_Uniform    =1,
    CELLAUTOSIZE_Constrain  =2,
    CELLAUTOSIZE_AdjustList =3,
    CELLAUTOSIZE_MAX        =4,
};
enum EContextMenuItemType
{
    CMIT_Normal             =0,
    CMIT_Submenu            =1,
    CMIT_Separator          =2,
    CMIT_Check              =3,
    CMIT_Radio              =4,
    CMIT_MAX                =5,
};
enum EUITabAutosizeType
{
    TAST_Manual             =0,
    TAST_Fill               =1,
    TAST_Auto               =2,
    TAST_MAX                =3,
};

#endif // !INCLUDED_ENGINE_UIPRIVATE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(ActivateNextPage)
AUTOGENERATE_NAME(ActivatePage)
AUTOGENERATE_NAME(ActivatePreviousPage)
AUTOGENERATE_NAME(ActivateToolTip)
AUTOGENERATE_NAME(AddedChild)
AUTOGENERATE_NAME(CalculateInputMask)
AUTOGENERATE_NAME(CanShowToolTips)
AUTOGENERATE_NAME(ClearMenuItems)
AUTOGENERATE_NAME(ClearUIAnimation)
AUTOGENERATE_NAME(CreateCustomComboButton)
AUTOGENERATE_NAME(CreateCustomComboEditbox)
AUTOGENERATE_NAME(CreateCustomComboList)
AUTOGENERATE_NAME(CreateCustomDecrementButton)
AUTOGENERATE_NAME(CreateCustomIncrementButton)
AUTOGENERATE_NAME(CreateGame)
AUTOGENERATE_NAME(CreateTabButton)
AUTOGENERATE_NAME(DeactivateToolTip)
AUTOGENERATE_NAME(DisablePlayerInput)
AUTOGENERATE_NAME(EnableAutoSizing)
AUTOGENERATE_NAME(EnablePlayerInput)
AUTOGENERATE_NAME(EnableTabPage)
AUTOGENERATE_NAME(FindMenuItemIndex)
AUTOGENERATE_NAME(GenerateFillerData)
AUTOGENERATE_NAME(GenerateScriptMarkupString)
AUTOGENERATE_NAME(GetAllMenuItems)
AUTOGENERATE_NAME(GetCaption)
AUTOGENERATE_NAME(GetCurrentGameSearch)
AUTOGENERATE_NAME(GetCurrentGameSettings)
AUTOGENERATE_NAME(GetCurrentProvider)
AUTOGENERATE_NAME(GetCustomPropertyValue)
AUTOGENERATE_NAME(GetFieldValue)
AUTOGENERATE_NAME(GetMenuItem)
AUTOGENERATE_NAME(GetSceneInputMode)
AUTOGENERATE_NAME(GetSearchResultFromIndex)
AUTOGENERATE_NAME(GetSupportedScriptFields)
AUTOGENERATE_NAME(GetSupportedUIActionKeyNames)
AUTOGENERATE_NAME(HideList)
AUTOGENERATE_NAME(Initialized)
AUTOGENERATE_NAME(InsertMenuItem)
AUTOGENERATE_NAME(InsertPage)
AUTOGENERATE_NAME(IsActivationAllowed)
AUTOGENERATE_NAME(IsProviderDisabled)
AUTOGENERATE_NAME(IsValidDataSourceClass)
AUTOGENERATE_NAME(LinkToTabButton)
AUTOGENERATE_NAME(LogDockingStack)
AUTOGENERATE_NAME(MoveToNext)
AUTOGENERATE_NAME(MoveToPrevious)
AUTOGENERATE_NAME(NotifyActiveSkinChanged)
AUTOGENERATE_NAME(NotifyActiveStateChanged)
AUTOGENERATE_NAME(NotifyPositionChanged)
AUTOGENERATE_NAME(NotifyPropertyChanged)
AUTOGENERATE_NAME(NotifyResolutionChanged)
AUTOGENERATE_NAME(NotifyVisibilityChanged)
AUTOGENERATE_NAME(OnButtonDragged)
AUTOGENERATE_NAME(OnClicked)
AUTOGENERATE_NAME(OnClickedScrollZone)
AUTOGENERATE_NAME(OnCloseContextMenu)
AUTOGENERATE_NAME(OnContextMenuItemSelected)
AUTOGENERATE_NAME(OnCreate)
AUTOGENERATE_NAME(OnDataProviderPropertyChange)
AUTOGENERATE_NAME(OnDoubleClick)
AUTOGENERATE_NAME(OnFadeComplete)
AUTOGENERATE_NAME(OnListElementsSorted)
AUTOGENERATE_NAME(OnOpenContextMenu)
AUTOGENERATE_NAME(OnPageActivated)
AUTOGENERATE_NAME(OnPageInserted)
AUTOGENERATE_NAME(OnPageRemoved)
AUTOGENERATE_NAME(OnPressed)
AUTOGENERATE_NAME(OnPressRelease)
AUTOGENERATE_NAME(OnPressRepeat)
AUTOGENERATE_NAME(OnProcessInputAxis)
AUTOGENERATE_NAME(OnProcessInputKey)
AUTOGENERATE_NAME(OnQueryToolTip)
AUTOGENERATE_NAME(OnRawInputAxis)
AUTOGENERATE_NAME(OnRawInputKey)
AUTOGENERATE_NAME(OnRefreshDataFieldValue)
AUTOGENERATE_NAME(OnRefreshDataStore)
AUTOGENERATE_NAME(OnRegister)
AUTOGENERATE_NAME(OnSceneActivated)
AUTOGENERATE_NAME(OnSceneDeactivated)
AUTOGENERATE_NAME(OnScrollActivity)
AUTOGENERATE_NAME(OnSubmitSelection)
AUTOGENERATE_NAME(OnSubmitText)
AUTOGENERATE_NAME(OnTopSceneChanged)
AUTOGENERATE_NAME(OnUIAnimEnd)
AUTOGENERATE_NAME(OnUnregister)
AUTOGENERATE_NAME(OnValueChanged)
AUTOGENERATE_NAME(PlayUIAnimation)
AUTOGENERATE_NAME(PostInitialize)
AUTOGENERATE_NAME(PrivateActivatePage)
AUTOGENERATE_NAME(ProviderClientBound)
AUTOGENERATE_NAME(ProviderClientUnbound)
AUTOGENERATE_NAME(ProviderInstanceBound)
AUTOGENERATE_NAME(ProviderInstanceUnbound)
AUTOGENERATE_NAME(RefreshStats)
AUTOGENERATE_NAME(RefreshSubscribers)
AUTOGENERATE_NAME(RegisterDelegates)
AUTOGENERATE_NAME(Registered)
AUTOGENERATE_NAME(RemovedChild)
AUTOGENERATE_NAME(RemovedFromParent)
AUTOGENERATE_NAME(RemoveMenuItem)
AUTOGENERATE_NAME(RemoveMenuItemAtIndex)
AUTOGENERATE_NAME(RemovePage)
AUTOGENERATE_NAME(ReplacePage)
AUTOGENERATE_NAME(SaveProfileData)
AUTOGENERATE_NAME(SceneActivated)
AUTOGENERATE_NAME(SceneDeactivated)
AUTOGENERATE_NAME(SetAutoSizePadding)
AUTOGENERATE_NAME(SetCurrentByIndex)
AUTOGENERATE_NAME(SetCurrentByName)
AUTOGENERATE_NAME(SetFieldValue)
AUTOGENERATE_NAME(SetInputMask)
AUTOGENERATE_NAME(SetMenuItems)
AUTOGENERATE_NAME(SetVisibility)
AUTOGENERATE_NAME(ShowGamercard)
AUTOGENERATE_NAME(ShowHostGamercard)
AUTOGENERATE_NAME(ShowList)
AUTOGENERATE_NAME(StopUIAnimation)
AUTOGENERATE_NAME(SubmitGameSearch)
AUTOGENERATE_NAME(SubscriberAttached)
AUTOGENERATE_NAME(SubscriberDetached)
AUTOGENERATE_NAME(UIAnimEnd)
AUTOGENERATE_NAME(Unregistered)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_UIPRIVATE_CLASSES
#define INCLUDED_ENGINE_UIPRIVATE_CLASSES 1

class UUIComp_AutoAlignment : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_AutoAlignment
    BYTE Vertical;
    BYTE Horizontal;
    BYTE HorzAlignment;
    BYTE VertAlignment;
    //## END PROPS UIComp_AutoAlignment

    DECLARE_CLASS(UUIComp_AutoAlignment,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIObject)
	/**
	 * Adjusts the child widget's positions according to the specified autoalignment setting
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Converts the value of the Vertical and Horizontal alignment
	 */
	virtual void Serialize( FArchive& Ar );

protected:
	/**
	 *	Updates the horizontal position of child widgets according to the specified alignment setting
	 *
	 * @param	ContainerWidget			The widget to whose bounds the widgets will be aligned
	 * @param	HorizontalAlignment		The horizontal alignment setting
	 */
	void AlignWidgetsHorizontally( UUIObject* ContainerWidget, EUIAlignment HorizontalAlignment );

	/**
	 *	Updates the vertical position of child widgets according to the specified alignment setting
	 *
	 * @param	ContainerWidget			The widget to whose bounds the widgets will be aligned
	 * @param	VerticalAlignment		The vertical alignment setting
	 */
	void AlignWidgetsVertically( UUIObject* ContainerWidget, EUIAlignment VerticalAlignment );
};

struct UIComp_DrawComponents_eventOnFadeComplete_Parms
{
    class UUIComp_DrawComponents* Sender;
    UIComp_DrawComponents_eventOnFadeComplete_Parms(EEventParm)
    {
    }
};
class UUIComp_DrawComponents : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_DrawComponents
    BYTE FadeType;
    FLOAT FadeAlpha;
    FLOAT FadeTarget;
    FLOAT FadeTime;
    FLOAT LastRenderTime;
    FLOAT FadeRate;
    FScriptDelegate __OnFadeComplete__Delegate;
    //## END PROPS UIComp_DrawComponents

    void Fade(FLOAT FromAlpha,FLOAT ToAlpha,FLOAT TargetFadeTime);
    void Pulse(FLOAT MaxAlpha=1.000000,FLOAT MinAlpha=0.000000,FLOAT PulseRate=1.000000);
    void ResetFade();
    DECLARE_FUNCTION(execFade)
    {
        P_GET_FLOAT(FromAlpha);
        P_GET_FLOAT(ToAlpha);
        P_GET_FLOAT(TargetFadeTime);
        P_FINISH;
        Fade(FromAlpha,ToAlpha,TargetFadeTime);
    }
    DECLARE_FUNCTION(execPulse)
    {
        P_GET_FLOAT_OPTX(MaxAlpha,1.000000);
        P_GET_FLOAT_OPTX(MinAlpha,0.000000);
        P_GET_FLOAT_OPTX(PulseRate,1.000000);
        P_FINISH;
        Pulse(MaxAlpha,MinAlpha,PulseRate);
    }
    DECLARE_FUNCTION(execResetFade)
    {
        P_FINISH;
        ResetFade();
    }
    void delegateOnFadeComplete(class UUIComp_DrawComponents* Sender)
    {
        UIComp_DrawComponents_eventOnFadeComplete_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnFadeComplete,&__OnFadeComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIComp_DrawComponents,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIObject)
	/**
	 * @Returns true if an update is needed
	 * @Param	FadeValue - In: The current Alpha, Out: The New Alpha
	 */
	UBOOL UpdateFade(FLOAT& FadeAlpha);
};

class UUIDataStoreSubscriber : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStoreSubscriber,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStoreSubscriber)
};

class IUIDataStoreSubscriber
{
public:
	typedef UUIDataStoreSubscriber UClassType;
	virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber()=0;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1)=0;
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const=0;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1)=0;
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores)=0;
    virtual void ClearBoundDataStores()=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStoreSubscriber)
};

class UUIDataStorePublisher : public UUIDataStoreSubscriber
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStorePublisher,UUIDataStoreSubscriber,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStorePublisher)
};

class IUIDataStorePublisher : public IUIDataStoreSubscriber
{
public:
	typedef UUIDataStorePublisher UClassType;
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStorePublisher)
};

class UUIListElementCellProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementCellProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementCellProvider)
};

class IUIListElementCellProvider
{
public:
	typedef UUIListElementCellProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementCellProvider()=0;
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags )=0;

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )=0;

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )=0;
};

class UUIListElementProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementProvider)
};

class IUIListElementProvider
{
public:
	typedef UUIListElementProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementProvider()=0;
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags()=0;

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName )=0;

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements )=0;

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<const struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters )
	{
		return FALSE;
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName )=0;

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex )=0;
};

class UUIStringRenderer : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIStringRenderer,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIStringRenderer)
};

class IUIStringRenderer
{
public:
	typedef UUIStringRenderer UClassType;
	virtual UObject* GetUObjectInterfaceUIStringRenderer()=0;
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIStringRenderer)
};

class UUIStyleResolver : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIStyleResolver,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIStyleResolver)
};

class IUIStyleResolver
{
public:
	typedef UUIStyleResolver UClassType;
	virtual UObject* GetUObjectInterfaceUIStyleResolver()=0;
    virtual FName GetStyleResolverTag()=0;
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag)=0;
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIStyleResolver)
};

class UUIComp_DrawImage : public UUIComp_DrawComponents, public IUIStyleResolver, public ICustomPropertyItemHandler
{
public:
    //## BEGIN PROPS UIComp_DrawImage
    FName StyleResolverTag;
    class UUITexture* ImageRef;
    struct FUIImageStyleOverride StyleCustomization;
    struct FUIStyleReference ImageStyle;
private:
    struct FTextureCoordinates ImageCoordinates;
public:
    //## END PROPS UIComp_DrawImage

    void SetImage(class USurface* NewImage);
    void SetCoordinates(struct FTextureCoordinates NewCoordinates);
    void SetColor(FLinearColor NewColor);
    void SetOpacity(FLOAT NewOpacity);
    void SetFormatting(BYTE Orientation,struct FUIImageAdjustmentData NewFormattingData);
    void DisableCustomCoordinates();
    void DisableCustomColor();
    void DisableCustomOpacity();
    void DisableCustomFormatting();
    class USurface* GetImage() const;
    virtual FName GetStyleResolverTag();
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag);
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);
    DECLARE_FUNCTION(execGetAppliedImageStyle);
    DECLARE_FUNCTION(execSetImage)
    {
        P_GET_OBJECT(USurface,NewImage);
        P_FINISH;
        SetImage(NewImage);
    }
    DECLARE_FUNCTION(execSetCoordinates)
    {
        P_GET_STRUCT(struct FTextureCoordinates,NewCoordinates);
        P_FINISH;
        SetCoordinates(NewCoordinates);
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_FUNCTION(execSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        SetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execSetFormatting)
    {
        P_GET_BYTE(Orientation);
        P_GET_STRUCT(struct FUIImageAdjustmentData,NewFormattingData);
        P_FINISH;
        SetFormatting(Orientation,NewFormattingData);
    }
    DECLARE_FUNCTION(execDisableCustomCoordinates)
    {
        P_FINISH;
        DisableCustomCoordinates();
    }
    DECLARE_FUNCTION(execDisableCustomColor)
    {
        P_FINISH;
        DisableCustomColor();
    }
    DECLARE_FUNCTION(execDisableCustomOpacity)
    {
        P_FINISH;
        DisableCustomOpacity();
    }
    DECLARE_FUNCTION(execDisableCustomFormatting)
    {
        P_FINISH;
        DisableCustomFormatting();
    }
    DECLARE_FUNCTION(execGetImage)
    {
        P_FINISH;
        *(class USurface**)Result=GetImage();
    }
    DECLARE_FUNCTION(execGetStyleResolverTag)
    {
        P_FINISH;
        *(FName*)Result=GetStyleResolverTag();
    }
    DECLARE_FUNCTION(execSetStyleResolverTag)
    {
        P_GET_NAME(NewResolverTag);
        P_FINISH;
        *(UBOOL*)Result=SetStyleResolverTag(NewResolverTag);
    }
    DECLARE_FUNCTION(execNotifyResolveStyle)
    {
        P_GET_OBJECT(UUISkin,ActiveSkin);
        P_GET_UBOOL(bClearExistingValue);
        P_GET_OBJECT_OPTX(UUIState,CurrentMenuState,NULL);
        P_GET_NAME_OPTX(StylePropertyName,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=NotifyResolveStyle(ActiveSkin,bClearExistingValue,CurrentMenuState,StylePropertyName);
    }
    DECLARE_CLASS(UUIComp_DrawImage,UUIComp_DrawComponents,0,Engine)
    virtual UObject* GetUObjectInterfaceUIStyleResolver(){return this;}
    virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler(){return this;}
	/* === UIComp_DrawImage interface === */
	/**
	 * Renders the image.  The owning widget is responsible for applying any transformations to the canvas
	 * prior to rendering this component.
	 *
	 * @param	Canvas		the canvas to render the image to
	 * @param	Parameters	the bounds for the region that this texture can render to.
	 */
	virtual void RenderComponent( class FCanvas* Canvas, FRenderParameters Parameters );

	/**
	 * Returns TRUE if this component's UIStyleReference can be resolved into a valid UIStyle.
	 *
	 * @param	CurrentlyActiveSkin		the currently active skin; used for resolving the style reference's default style if it doesn't yet have a valid style id.
	 */
	virtual UBOOL HasValidStyleReference( class UUISkin* CurrentlyActiveSkin=NULL );

	/**
	 * Returns the image style data being used by this image rendering component.  If the component's ImageStyle is not set, the style data
	 * will be pulled from the owning widget's primary style.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not speicified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's image style; only relevant when the component's image style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the image style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's image style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the image style data used to render this component's image for the specified menu state.
	 */
	virtual class UUIStyle_Image* GetAppliedImageStyle( class UUIState* DesiredMenuState=NULL, class UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Initializes the combinedstyledata using the component's current image sytle, then applies any per-instance values
	 * which are intended to override values in the style.
	 *
	 * @param	CustomizedStyleData		struct which receives the per-instance style data configured for this component;
	 *									should be initialized using an image style prior to calling this function.
	 */
	void CustomizeAppliedStyle( struct FUICombinedStyleData& CustomizedStyleData ) const;

	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the component's image.
	 */
	void RefreshAppliedStyleData();

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.
	 *
	 * This version migrates the ImageCoordinates value over to the StyleCustomization member.
	 */
	virtual void PostLoad();

	/* === CustomPropertyItemHandler interface === */
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue );

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const UPropertyValue& PropertyValue );
};

struct UIComp_DrawString_eventSetAutoSizePadding_Parms
{
    BYTE Orientation;
    FLOAT NearValue;
    FLOAT FarValue;
    BYTE NearScaleType;
    BYTE FarScaleType;
    UIComp_DrawString_eventSetAutoSizePadding_Parms(EEventParm)
    {
    }
};
struct UIComp_DrawString_eventEnableAutoSizing_Parms
{
    BYTE Orientation;
    UBOOL bShouldEnable;
    UIComp_DrawString_eventEnableAutoSizing_Parms(EEventParm)
    {
    }
};
class UUIComp_DrawString : public UUIComp_DrawComponents, public IUIStyleResolver
{
public:
    //## BEGIN PROPS UIComp_DrawString
    TScriptInterface<class IUIDataStoreSubscriber> SubscriberOwner;
    FName StyleResolverTag;
    class UUIString* ValueString;
    class UClass* StringClass;
    struct FAutoSizeData AutoSizeParameters[2];
    struct FUITextStyleOverride TextStyleCustomization;
    struct FUIStyleReference StringStyle;
    BITFIELD bIgnoreMarkup:1;
    BITFIELD bRefreshString:1;
    BITFIELD bReapplyFormatting:1;
private:
    BYTE TextAlignmentHorizontal GCC_BITFIELD_MAGIC;
    BYTE TextAlignmentVertical;
    BYTE WrapMode;
    BYTE ClipAlignment;
public:
    //## END PROPS UIComp_DrawString

    virtual void SetValue(const FString& NewText);
    virtual FString GetValue(UBOOL bReturnProcessedText=TRUE) const;
    void RefreshValue();
    void SetColor(FLinearColor NewColor);
    void SetOpacity(FLOAT NewOpacity);
    void SetFont(class UFont* NewFont);
    void SetAttributes(struct FUITextAttributes NewAttributes);
    void SetAlignment(BYTE Orientation,BYTE NewAlignment);
    void SetWrapMode(BYTE NewClipMode);
    void SetClipAlignment(BYTE NewClipAlignment);
    void SetAutoScaling(BYTE NewAutoScaleMode,FLOAT NewMinScaleValue=-1.000000);
    void SetScale(BYTE Orientation,FLOAT NewScale);
    void DisableCustomColor();
    void DisableCustomOpacity();
    void DisableCustomFont();
    void DisableCustomAttributes();
    void DisableCustomAlignment();
    void DisableCustomClipMode();
    void DisableCustomClipAlignment();
    void DisableCustomAutoScaling();
    void DisableCustomScale();
    BYTE GetWrapMode() const;
    UBOOL GetFinalStringStyle(struct FUICombinedStyleData& FinalStyleData);
    virtual FName GetStyleResolverTag();
    virtual UBOOL SetStyleResolverTag(FName NewResolverTag);
    virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetValue(NewText);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnProcessedText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnProcessedText);
    }
    DECLARE_FUNCTION(execRefreshValue)
    {
        P_FINISH;
        RefreshValue();
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_FUNCTION(execSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        SetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execSetFont)
    {
        P_GET_OBJECT(UFont,NewFont);
        P_FINISH;
        SetFont(NewFont);
    }
    DECLARE_FUNCTION(execSetAttributes)
    {
        P_GET_STRUCT(struct FUITextAttributes,NewAttributes);
        P_FINISH;
        SetAttributes(NewAttributes);
    }
    DECLARE_FUNCTION(execSetAlignment)
    {
        P_GET_BYTE(Orientation);
        P_GET_BYTE(NewAlignment);
        P_FINISH;
        SetAlignment(Orientation,NewAlignment);
    }
    DECLARE_FUNCTION(execSetWrapMode)
    {
        P_GET_BYTE(NewClipMode);
        P_FINISH;
        SetWrapMode(NewClipMode);
    }
    DECLARE_FUNCTION(execSetClipAlignment)
    {
        P_GET_BYTE(NewClipAlignment);
        P_FINISH;
        SetClipAlignment(NewClipAlignment);
    }
    DECLARE_FUNCTION(execSetAutoScaling)
    {
        P_GET_BYTE(NewAutoScaleMode);
        P_GET_FLOAT_OPTX(NewMinScaleValue,-1.000000);
        P_FINISH;
        SetAutoScaling(NewAutoScaleMode,NewMinScaleValue);
    }
    DECLARE_FUNCTION(execSetScale)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewScale);
        P_FINISH;
        SetScale(Orientation,NewScale);
    }
    DECLARE_FUNCTION(execDisableCustomColor)
    {
        P_FINISH;
        DisableCustomColor();
    }
    DECLARE_FUNCTION(execDisableCustomOpacity)
    {
        P_FINISH;
        DisableCustomOpacity();
    }
    DECLARE_FUNCTION(execDisableCustomFont)
    {
        P_FINISH;
        DisableCustomFont();
    }
    DECLARE_FUNCTION(execDisableCustomAttributes)
    {
        P_FINISH;
        DisableCustomAttributes();
    }
    DECLARE_FUNCTION(execDisableCustomAlignment)
    {
        P_FINISH;
        DisableCustomAlignment();
    }
    DECLARE_FUNCTION(execDisableCustomClipMode)
    {
        P_FINISH;
        DisableCustomClipMode();
    }
    DECLARE_FUNCTION(execDisableCustomClipAlignment)
    {
        P_FINISH;
        DisableCustomClipAlignment();
    }
    DECLARE_FUNCTION(execDisableCustomAutoScaling)
    {
        P_FINISH;
        DisableCustomAutoScaling();
    }
    DECLARE_FUNCTION(execDisableCustomScale)
    {
        P_FINISH;
        DisableCustomScale();
    }
    DECLARE_FUNCTION(execGetWrapMode)
    {
        P_FINISH;
        *(BYTE*)Result=GetWrapMode();
    }
    DECLARE_FUNCTION(execGetAppliedStringStyle);
    DECLARE_FUNCTION(execGetFinalStringStyle)
    {
        P_GET_STRUCT_REF(struct FUICombinedStyleData,FinalStyleData);
        P_FINISH;
        *(UBOOL*)Result=GetFinalStringStyle(FinalStyleData);
    }
    DECLARE_FUNCTION(execGetStyleResolverTag)
    {
        P_FINISH;
        *(FName*)Result=GetStyleResolverTag();
    }
    DECLARE_FUNCTION(execSetStyleResolverTag)
    {
        P_GET_NAME(NewResolverTag);
        P_FINISH;
        *(UBOOL*)Result=SetStyleResolverTag(NewResolverTag);
    }
    DECLARE_FUNCTION(execNotifyResolveStyle)
    {
        P_GET_OBJECT(UUISkin,ActiveSkin);
        P_GET_UBOOL(bClearExistingValue);
        P_GET_OBJECT_OPTX(UUIState,CurrentMenuState,NULL);
        P_GET_NAME_OPTX(StylePropertyName,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=NotifyResolveStyle(ActiveSkin,bClearExistingValue,CurrentMenuState,StylePropertyName);
    }
    void eventSetAutoSizePadding(BYTE Orientation,FLOAT NearValue,FLOAT FarValue,BYTE NearScaleType,BYTE FarScaleType)
    {
        UIComp_DrawString_eventSetAutoSizePadding_Parms Parms(EC_EventParm);
        Parms.Orientation=Orientation;
        Parms.NearValue=NearValue;
        Parms.FarValue=FarValue;
        Parms.NearScaleType=NearScaleType;
        Parms.FarScaleType=FarScaleType;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAutoSizePadding),&Parms);
    }
    void eventEnableAutoSizing(BYTE Orientation,UBOOL bShouldEnable=TRUE)
    {
        UIComp_DrawString_eventEnableAutoSizing_Parms Parms(EC_EventParm);
        Parms.Orientation=Orientation;
        Parms.bShouldEnable=bShouldEnable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnableAutoSizing),&Parms);
    }
    DECLARE_CLASS(UUIComp_DrawString,UUIComp_DrawComponents,0,Engine)
    virtual UObject* GetUObjectInterfaceUIStyleResolver(){return this;}
	/**
	 * Initializes this component, creating the UIString needed for rendering text.
	 *
	 * @param	InSubscriberOwner	if this component is owned by a widget that implements the IUIDataStoreSubscriber interface,
	 *								the TScriptInterface containing the interface data for the owner.
	 */
	virtual void InitializeComponent( TScriptInterface<IUIDataStoreSubscriber>* InSubscriberOwner=NULL );

	/**
	 * Adds the specified face to the owning scene's DockingStack for the owning widget.  Takes wrap behavior and
	 * autosizing into account, ensuring that all widget faces are added to the scene's docking stack in the appropriate
	 * order.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value, and triggers the methods which apply
	 * formatting data to the string.
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Marks the Position for any faces dependent on the specified face, in this component's owning widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Returns TRUE if autosizing is enabled for the specified orientation.
	 *
	 * @param	Orientation		the orientation to check
	 *
	 * @return	TRUE if auto-sizing is enabled for the specified orientation
	 */
	UBOOL IsAutoSizeEnabled( BYTE Orientation ) const
	{
		checkSlow(Orientation<UIORIENT_MAX);
		return AutoSizeParameters[Orientation].bAutoSizeEnabled;
	}

	/**
	 * Changes the style for this UIString.
	 *
	 * @param	NewStringStyle	the new style to use for rendering the string
	 */
	void SetStringStyle( class UUIStyle_Combo* NewComboStyle );

	/**
	 * Returns TRUE if this component's UIStyleReference can be resolved into a valid UIStyle.
	 *
	 * @param	CurrentlyActiveSkin		the currently active skin; used for resolving the style reference's default style if it doesn't yet have a valid style id.
	 */
	virtual UBOOL HasValidStyleReference( class UUISkin* CurrentlyActiveSkin=NULL );

	/**
	 * Returns the combo style data being used by this string rendering component.  If the component's StringStyle is not set, the style data
	 * will be pulled from the owning widget's PrimaryStyle, if possible.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not specified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's combo style; only relevant when the component's combo style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the combo style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's combo style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the combo style data used to render this component's string for the specified menu state.
	 */
	virtual class UUIStyle_Combo* GetAppliedStringStyle( class UUIState* DesiredMenuState=NULL, class UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Initializes the CustomizedStyleData using the string current style, then applies any per-instance values
	 * which are intended to override values in the style.
	 *
	 * @param	CustomizedStyleData		struct which receives the per-instance style data configured for this component;
	 *									should be initialized using a combo style prior to calling this function.
	 */
	void CustomizeAppliedStyle( struct FUICombinedStyleData& CustomizedStyleData ) const;

	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the string.
	 */
	void RefreshAppliedStyleData();

	/**
	 * Calculate the rendering bounding region, adjust for alignment, and renders the string.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this string
	 */
	void Render_String( FCanvas* Canvas );

	/**
	 * Flags the component to be reformatted during the next scene update.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void ReapplyFormatting( UBOOL bDockingStackChanged=FALSE, UBOOL bPositionsChanged=TRUE, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated
	 * properties over to the style customization struct property.
	 */
	virtual void PostLoad();

	/**
	 * Retrieves a list of all data stores resolved by ValueString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by the UIString.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	virtual void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

protected:
	/**
	 * Initializes the render parameters that will be used for formatting the string.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use for formatting the string.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the string, taking into account the autosize settings.
	 */
	virtual UBOOL GetStringFormatParameters( EUIWidgetFace Face, struct FRenderParameters& out_Parameters ) const;

	/**
	 * Adjusts the owning widget's bounds according to the wrapping mode and autosize behaviors.
	 */
	virtual void UpdateOwnerBounds( struct FRenderParameters& Parameters );

	/**
	 * Wrapper method which applies final formatting to the string and resets the value of bReapplyFormatting.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 * @param	bIgnoreMarkup	@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyStringFormatting( struct FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Renders the string using the parameters specified.  Must have a different name than Render_String, or I can't call
	 * the other version, for some reason.
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );

	/**
	 * Handles unregistering the "RefreshSubscriberValue" callbacks for the data stores that were previously resolved by this
	 * component's UIString and registering the callbacks for the data stores currently resolved by the UIString.  Requires that
	 * the SubscriberOwner value be set.
	 *
	 * @param	RemovedDataStores	the list of data stores that were previously bound to this component's string.  SubscriberOwner
	 *								will be removed from each data store's "RefreshSubscriberValue" callback list.
	 * @param	AddedDataStores		the list of data stores that are now bound to this component's string.  SubscriberOwner
	 *								will be registered with each data store's "RefreshSubscriberValue" callback list.
	 */
	void UpdateSubscriberCallbacks( TArray<UUIDataStore*> RemovedDataStores, TArray<UUIDataStore*> AddedDataStores );
};

class UUIComp_DrawCaption : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawCaption
    //## END PROPS UIComp_DrawCaption

    DECLARE_CLASS(UUIComp_DrawCaption,UUIComp_DrawString,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_DrawCaption)
};

class UUIComp_DrawStringEditbox : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawStringEditbox
protected:
    FStringNoInit UserText;
public:
    struct FUIStringCaretParameters StringCaret;
    struct FUIStringNode_Image* CaretNode;
    INT FirstCharacterPosition;
    BITFIELD bRecalculateFirstCharacter:1;
    FLOAT CaretOffset;
    //## END PROPS UIComp_DrawStringEditbox

    UBOOL SetUserText(const FString& NewValue);
    INT GetUserTextLength() const;
    DECLARE_FUNCTION(execSetUserText)
    {
        P_GET_STR(NewValue);
        P_FINISH;
        *(UBOOL*)Result=SetUserText(NewValue);
    }
    DECLARE_FUNCTION(execGetUserTextLength)
    {
        P_FINISH;
        *(INT*)Result=GetUserTextLength();
    }
    DECLARE_CLASS(UUIComp_DrawStringEditbox,UUIComp_DrawString,0,Engine)
    DECLARE_WITHIN(UUIEditBox)
	// UIEditboxString needs direct access to UserText
	friend class UUIEditboxString;

	/* === UUIComp_DrawStringEditbox interface === */
	/**
	 * Requests a new UIStringNode_Image from the Images data store.  Initializes the image node
	 * and assigns it to the value of CaretNode.
	 *
	 * @param	bRecreateExisting	specifies what should happen if this component already has a valid CaretNode.  If
	 *								TRUE, the existing caret is deleted and a new one is created.
	 */
	void ResolveCaretImageNode( UBOOL bRecreateExisting=FALSE );

	/**
	 * Inserts the markup necessary to render the caret at the appropriate position in SourceText.
	 *
	 * @param	out_CaretMarkupString	a string containing markup code necessary for the caret image to be resolved into a UIStringNode_Image
	 *
	 * @return	TRUE if out_ProcessedString contains valid caret markup text.
	 *			FALSE if this component is configured to not render a caret, or the caret reference is invalid.
	 */
	UBOOL GenerateCaretMarkup( FString& out_CaretMarkupString );

	/**
	 * Retrieves the image style data associated with the caret's configured style from the currently active
	 * skin and applies that style data to the caret's UITexture.
	 *
	 * @param	CurrentWidgetStyle		the current state of the widget that owns this draw string component.  Used
	 *									for choosing which style data set [from the caret's style] to use for rendering.
	 *									If not specified, the current state of the widget that owns this component will be used.
	 */
	void ApplyCaretStyle( UUIState* CurrentWidgetState=NULL );

	/**
	 * Moves the caret to a new position in the text.
	 *
	 * @param	NewCaretPosition	the location to put the caret.  Should be a non-zero integer between 0 and the length
	 *								of UserText.  Values outside the valid range will be clamed.
	 *
	 * @return	TRUE if the string's new caret position is different than the string's previous caret position.
	 */
	UBOOL SetCaretPosition( INT NewCaretPosition );

	/**
	 * Updates the value of FirstCharacterPosition with the location of the first character of the string that is now visible.
	 */
	void UpdateFirstVisibleCharacter();

	/**
	 * Calculates the total width of the characters that precede the FirstCharacterPosition.
	 *
	 * @param	Parameters	@see UUIString::StringSize() (intentionally passed by value)
	 *
	 * @return	the width (in pixels) of a sub-string containing all characters up to FirstCharacterPosition.
	 */
	FLOAT CalculateFirstVisibleOffset( FRenderParameters Parameters ) const;

	/**
	 * Calculates the total width of the characters that precede the CaretPosition.
	 *
	 * @param	Parameters	@see UUIString::StringSize() (intentionally passed by value)
	 *
	 * @return	the width (in pixels) of a sub-string containing all characters up to StringCaret.CaretPosition.
	 */
	FLOAT CalculateCaretOffset( FRenderParameters Parameters ) const;

	/**
	 * Returns a reference to this editbox component's UserText variable (useful in cases where you need to work with the
	 * string but don't want to make a copy of it).
	 */
	const FString& GetUserTextRef() const { return UserText; }

	/**
	 * @return	the string being rendered in the editbox; equal to UserText unless the editbox is in password mode.
	 */
	FString GetDisplayString() const;

private:
	/**
	 * Deletes the existing caret node if one exists, and unregisters this component from the images data store.
	 */
	virtual void DeleteCaretNode();
public:

	/* === UUIComp_DrawString interface === */
	/**
	 * Initializes this component, creating the UIString needed for rendering text.
	 *
	 * @param	InSubscriberOwner	if this component is owned by a widget that implements the IUIDataStoreSubscriber interface,
	 *								the TScriptInterface containing the interface data for the owner.
	 */
	virtual void InitializeComponent( TScriptInterface<IUIDataStoreSubscriber>* InSubscriberOwner=NULL );

	/**
	 * Changes the text that will be parsed by the UIString, and updates UserText to the resolved value.
	 *
	 * @param	NewText		the new text that should be displayed
	 */
	virtual void SetValue( const FString& NewText );

	/**
	 * Retrieve the text value of this editbox.
	 *
	 * @param	bReturnInputText	specify TRUE to return the value of UserText; FALSE to return the raw text stored
	 *								in the UIString's node's SourceText
	 *
	 * @return	either the raw value of this editbox string component or the text that the user entered
	 */
	virtual FString GetValue( UBOOL bReturnInputText=TRUE ) const;

	/**
	 * Retrieves a list of all data stores resolved by ValueString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by the UIString.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	virtual void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

	/**
	 * Flags the component to be reformatted during the next scene update, and flags the editbox to recalculate its
	 * first visible character, if necessary.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void ReapplyFormatting( UBOOL bDockingStackChanged=FALSE, UBOOL bPositionsChanged=TRUE, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Resolves the combo style for this string rendering component.
	 *
	 * This version also resolves the caret image style.
	 *
	 * @param	ActiveSkin			the skin the use for resolving the style reference.
	 * @param	bClearExistingValue	if TRUE, style references will be invalidated first.
	 * @param	CurrentMenuState	the menu state to use for resolving the style data; if not specified, uses the current
	 *								menu state of the owning widget.
	 * @param	StyleProperty		if specified, only the style reference corresponding to the specified property
	 *								will be resolved; otherwise, all style references will be resolved.
	 */
	virtual UBOOL NotifyResolveStyle( class UUISkin* ActiveSkin, UBOOL bClearExistingValue, class UUIState* CurrentMenuState=NULL, const FName StylePropertyName=NAME_None );

protected:
	/**
	 * Wrapper for calling ApplyFormatting on the string.  Resets the value of bReapplyFormatting and bRecalculateFirstCharacter.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 * @param	bIgnoreMarkup	@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyStringFormatting( struct FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Renders the string using the parameters specified.
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );

public:
	/* === UObject interface === */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void FinishDestroy();

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIComp_DrawStringSlider : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_DrawStringSlider
    //## END PROPS UIComp_DrawStringSlider

    DECLARE_CLASS(UUIComp_DrawStringSlider,UUIComp_DrawString,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_DrawStringSlider)
};

class UUIComp_ListComponentBase : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_ListComponentBase
    //## END PROPS UIComp_ListComponentBase

    DECLARE_ABSTRACT_CLASS(UUIComp_ListComponentBase,UUIComponent,0,Engine)
    DECLARE_WITHIN(UUIList)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListComponentBase)
};

struct FUIListSortingParameters
{
    INT PrimaryIndex;
    INT SecondaryIndex;
    BITFIELD bReversePrimarySorting:1;
    BITFIELD bReverseSecondarySorting:1;
    BITFIELD bCaseSensitive:1;

	/** Constructor */
	FUIListSortingParameters( INT InPrimaryIndex, INT InSecondaryIndex, UBOOL bReversePrimary, UBOOL bReverseSecondary, UBOOL bInCaseSensitive )
	: PrimaryIndex(InPrimaryIndex), SecondaryIndex(InSecondaryIndex)
	, bReversePrimarySorting(bReversePrimary), bReverseSecondarySorting(bReverseSecondary), bCaseSensitive(bInCaseSensitive)
	{}

};

class UUIComp_ListElementSorter : public UUIComp_ListComponentBase
{
public:
    //## BEGIN PROPS UIComp_ListElementSorter
    BITFIELD bAllowCompoundSorting:1;
    INT InitialSortColumn;
    INT InitialSecondarySortColumn;
    INT PrimarySortColumn;
    INT SecondarySortColumn;
    BITFIELD bReversePrimarySorting:1;
    BITFIELD bReverseSecondarySorting:1;
    //## END PROPS UIComp_ListElementSorter

    void ResetSortColumns(UBOOL bResort=TRUE);
    UBOOL SortItems(INT ColumnIndex,UBOOL bSecondarySort=FALSE,UBOOL bCaseSensitive=FALSE);
    UBOOL ResortItems(UBOOL bCaseSensitive=FALSE);
    DECLARE_FUNCTION(execResetSortColumns)
    {
        P_GET_UBOOL_OPTX(bResort,TRUE);
        P_FINISH;
        ResetSortColumns(bResort);
    }
    DECLARE_FUNCTION(execSortItems)
    {
        P_GET_INT(ColumnIndex);
        P_GET_UBOOL_OPTX(bSecondarySort,FALSE);
        P_GET_UBOOL_OPTX(bCaseSensitive,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SortItems(ColumnIndex,bSecondarySort,bCaseSensitive);
    }
    DECLARE_FUNCTION(execResortItems)
    {
        P_GET_UBOOL_OPTX(bCaseSensitive,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ResortItems(bCaseSensitive);
    }
    DECLARE_CLASS(UUIComp_ListElementSorter,UUIComp_ListComponentBase,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListElementSorter)
};

struct FUIListElementCell
{
    struct FUIListItem* ContainerElement;
    class UUIList* OwnerList;
    class UUIListString* ValueString;
    FLOAT Padding[4];
    FLOAT Scaling[2];
    struct FUIStyleReference CellStyle[4];

	/** Script Constructors */
	FUIListElementCell() {}
	FUIListElementCell(EEventParm);

	/**
	 * Called when this cell is created while populating the elements for the owning list. Creates the cell's UIListString.
	 */
	void OnCellCreated( struct FUIListItem* InContainerElement, class UUIList* inOwnerList );

	/**
	 * Resolves the value of the specified tag from the DataProvider and assigns the result to this cell's ValueString.
	 *
	 * @param	DataSource		the data source to use for populating this cell's data
	 * @param	CellBindingTag	the tag (from the list supported by DataProvider) that should be associated with this
	 *							UIListElementCell.
	 *
	 * @note: even though this method is overridden in FUIListElementCellTemplate, it is intended to be non-virtual!
	 */
	void AssignBinding( struct FUIListItemDataBinding& DataSource, FName CellBindingTag );

	/**
	 * Resolves the CellStyle for the specified element state using the currently active skin.  This function is called
	 * anytime the cached cell style no longer is out of date, such as when the currently active skin has been changed.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	void ResolveCellStyles( EUIListElementState ElementState );

	/**
	 * Propagates the style data for the current menu state and element state to each cell .  This function is called anytime
	 * the style data that is applied to each cell is no longer valid, such as when the cell's CellState changes or when the
	 * owning list's menu state is changed.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	void ApplyCellStyleData( EUIListElementState ElementState );

};

struct FUIListElementCellTemplate : public FUIListElementCell
{
    FName CellDataField;
    FStringNoInit ColumnHeaderText;
    struct FUIScreenValue_Extent CellSize;
    FLOAT CellPosition;

	/** Script Constructor */
	FUIListElementCellTemplate() {}
	FUIListElementCellTemplate(EEventParm);

	/**
	 * Called when this cell is created while populating the elements for the owning list. Creates the cell's UIListString.
	 */
	void OnCellCreated( class UUIList* inOwnerList );

	/**
	 * Initializes the specified cell based on this cell template.
	 *
	 * @param	DataSource		the information about the data source for this element
	 * @param	TargetCell		the cell to initialize.
	 */
	void InitializeCell( struct FUIListItemDataBinding& DataSource, struct FUIListElementCell& TargetCell );

	/**
	 * Resolves the value of the specified tag from the DataProvider and assigns the result to this cell's ValueString.
	 *
	 * @param	DataProvider	the object which contains the data for this element cell.
	 * @param	CellBindingTag	the tag (from the list supported by DataProvider) that should be associated with this
	 *							UIListElementCell.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 */
	void AssignBinding( TScriptInterface<class IUIListElementCellProvider> DataProvider, FName CellBindingTag, const FString& ColumnHeader );

	/**
	 * Applies the resolved style data for the column header style to the schema cells' strings.  This function is called anytime
	 * the header style data that is applied to the schema cells is no longer valid, such as when the owning list's menu state is changed.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 */
	void ApplyHeaderStyleData( UUIStyle* ResolvedStyle );

};

struct FUIListItemDataBinding
{
    TScriptInterface<class IUIListElementCellProvider> DataSourceProvider;
    FName DataSourceTag;
    INT DataSourceIndex;

	/** Constructors */
	FUIListItemDataBinding() {}
	FUIListItemDataBinding(EEventParm)
	{
		appMemzero(this, sizeof(FUIListItemDataBinding));
	}

	FUIListItemDataBinding( TScriptInterface<class IUIListElementCellProvider> InDataSource, FName DataTag, INT InIndex )
	: DataSourceProvider(InDataSource)
	, DataSourceTag(DataTag)
	, DataSourceIndex(InIndex)
	{}

};

struct FUIListItem
{
    struct FUIListItemDataBinding DataSource;
    TArrayNoInit<struct FUIListElementCell> Cells;
    BYTE ElementState;

	/** Script Constructors */
	FUIListItem() {}
	FUIListItem(EEventParm)
	{
		appMemzero(this, sizeof(FUIListItem));
	}

	/** Standard ctor */
	FUIListItem( const struct FUIListItemDataBinding& InDataSource );

	/**
	 * Changes the ElementState for this element and refreshes its cell's cached style references based on the new cell state
	 *
	 * @param	NewElementState	the new element state to use.
	 *
	 * @return	TRUE if the element state actually changed.
	 */
	UBOOL SetElementState( EUIListElementState NewElementState );

};

struct FUIElementCellSchema
{
    TArrayNoInit<struct FUIListElementCellTemplate> Cells;

	/** Script Constructors */
	FUIElementCellSchema() {}
	FUIElementCellSchema(EEventParm)
	{
		appMemzero(this, sizeof(FUIElementCellSchema));
	}

};

class UUIComp_ListPresenter : public UUIComp_ListComponentBase
{
public:
    //## BEGIN PROPS UIComp_ListPresenter
    struct FUIElementCellSchema ElementSchema;
    TArray<struct FUIListItem> ListItems;
    class UUITexture* SelectionOverlay;
    struct FTextureCoordinates SelectionOverlayCoordinates;
    class UUITexture* ListItemOverlay[4];
    struct FTextureCoordinates ListItemOverlayCoordinates[4];
private:
    BITFIELD bDisplayColumnHeaders:1;
public:
    BITFIELD bReapplyFormatting:1;
    //## END PROPS UIComp_ListPresenter

    void EnableColumnHeaderRendering(UBOOL bShouldRenderColHeaders=TRUE);
    UBOOL ShouldRenderColumnHeaders() const;
    UBOOL ShouldAdjustListBounds(BYTE Orientation) const;
    TScriptInterface<class IUIListElementCellProvider> GetCellSchemaProvider() const;
    INT FindElementIndex(INT DataSourceIndex) const;
    DECLARE_FUNCTION(execEnableColumnHeaderRendering)
    {
        P_GET_UBOOL_OPTX(bShouldRenderColHeaders,TRUE);
        P_FINISH;
        EnableColumnHeaderRendering(bShouldRenderColHeaders);
    }
    DECLARE_FUNCTION(execShouldRenderColumnHeaders)
    {
        P_FINISH;
        *(UBOOL*)Result=ShouldRenderColumnHeaders();
    }
    DECLARE_FUNCTION(execShouldAdjustListBounds)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(UBOOL*)Result=ShouldAdjustListBounds(Orientation);
    }
    DECLARE_FUNCTION(execGetCellSchemaProvider)
    {
        P_FINISH;
        *(TScriptInterface<class IUIListElementCellProvider>*)Result=GetCellSchemaProvider();
    }
    DECLARE_FUNCTION(execFindElementIndex)
    {
        P_GET_INT(DataSourceIndex);
        P_FINISH;
        *(INT*)Result=FindElementIndex(DataSourceIndex);
    }
    DECLARE_CLASS(UUIComp_ListPresenter,UUIComp_ListComponentBase,0,Engine)
	friend class UUIList;

	/**
	 * Called when a new element is added to the list that owns this component.  Creates a UIElementCellList for the specified element.
	 *
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	ElementValue		the index [into the data provider's collection] for the element that is being inserted into the list.
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT InsertIndex, INT ElementValue );

	/**
	 * Called when an element is removed from the list that owns this component.  Removes the UIElementCellList located at the
	 * specified index.
	 *
	 * @param	RemovalIndex	the index for the element that should be removed from the list
	 *
	 * @return	the index [into the ElementCells array] for the element that was removed, or INDEX_NONE if RemovalIndex was invalid
	 *			or that element couldn't be removed from this list.
	 */
	virtual INT RemoveElement( INT RemovalIndex );

	/**
	 * Swaps the values at the specified indexes, reversing their positions in the ListItems array.
	 *
	 * @param	IndexA	the index into the ListItems array for the first element to swap
	 * @param	IndexB	the index into the ListItems array for the second element to swap
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElements( INT IndexA, INT IndexB );

	/**
	 * Allows the list presenter to override the menu state that is used for rendering a specific element in the list.  Used for those
	 * lists which need to render some elements using the disabled state, for example.
	 *
	 * @param	ElementIndex		the index into the Elements array for the element to retrieve the menu state for.
	 * @param	out_OverrideState	receives the value of the menu state that should be used for rendering this element. if a specific
	 *								menu state is desired for the specified element, this value should be set to a child of UIState corresponding
	 *								to the menu state that should be used;  only used if the return value for this method is TRUE.
	 *
	 * @return	TRUE if the list presenter assigned a value to out_OverrideState, indicating that the element should be rendered using that menu
	 *			state, regardless of which menu state the list is currently in.  FALSE if the list presenter doesn't want to override the menu
	 *			state for this element.
	 */
	virtual UBOOL GetOverrideMenuState( INT ElementIndex, UClass*& out_OverrideState );

	/**
	 * Resolves the element schema provider based on the owning list's data source binding, and repopulates the element schema based on
	 * the available data fields in that element schema provider.
	 */
	virtual void RefreshElementSchema();

	/**
	 * Assigns the style for the cell specified and refreshes the cell's resolved style.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	ElementState	the list element state to set the element style for
	 * @param	CellIndex		indicates the column (if columns are linked) or row (if rows are linked) to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to the cell.
	 */
	virtual UBOOL SetCustomCellStyle( class UUIStyle* NewStyle, EUIListElementState ElementState, INT CellIndex );

	/**
	 * Applies the resolved style data for the column header style to the schema cells' strings.  This function is called anytime
	 * the header style data that is applied to the schema cells is no longer valid, such as when the owning list's menu state is changed.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 */
	virtual void ApplyColumnHeaderStyle( UUIStyle* ResolvedStyle );

	/**
	 * Notification that the list's style has been changed.  Updates the cached cell styles for all elements for the specified
	 * list element state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListStyleChanged( EUIListElementState ElementState );

	/**
	 * Notification that the list's menu state has changed.  Reapplies the specified cell style for all elements based on the
	 * new menu state.
	 *
	 * @param	ElementState	the list element state to update the element style for
	 */
	virtual void OnListMenuStateChanged( EUIListElementState ElementState );

	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas );

	/**
	 * Notifies the owning widget that the formatting and render parameters for the list need to be updated.
	 */
	virtual void ReapplyFormatting();

	/**
	 * Adds the specified face to the owning scene's DockingStack for the owning widget.  Takes list configuration into account,
	 * ensuring that all widget faces are added to the scene's docking stack in the appropriate order.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Adjusts the owning widget's bounds
	 * according to the wrapping mode and autosize behaviors.
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Returns the number of rows the list can dislay
	 */
	INT GetMaxNumVisibleRows() const;

	/**
	 * Returns the number of columns the list can display
	 */
	INT GetMaxNumVisibleColumns() const;

	/**
	 * Returns the total number of rows in this list.
	 */
	INT GetTotalRowCount() const;

	/**
	 * Returns the total number of columns in this list.
	 */
	INT GetTotalColumnCount() const;

	/**
	 * Changes the cell state for the specified element.
	 *
	 * @param	ElementIndex	the index of the element to change states for
	 * @param	NewElementState	the new state to place the element in
	 *
	 * @return	TRUE if the new state was successfully applied to the new element, FALSE otherwise.
	 */
	UBOOL SetElementState( INT ElementIndex, EUIListElementState NewElementState );

	/**
	 * Returns whether element size is determined by the elements themselves.  For lists with linked columns, returns whether
	 * the item height is autosized; for lists with linked rows, returns whether item width is autosized.
	 */
	UBOOL IsElementAutoSizingEnabled() const;

protected:
	/**
	 * Determines the maximum number of elements which can be rendered given the owning list's bounding region.
	 */
	virtual void CalculateVisibleElements( struct FRenderParameters& Parameters );

	/**
	 * Initializes the render parameters that will be used for formatting the list elements.
	 *
	 * @param	Face			the face that was being resolved
	 * @param	out_Parameters	[out] the formatting parameters to use when calling ApplyFormatting.
	 *
	 * @return	TRUE if the formatting data is ready to be applied to the list elements, taking into account the autosize settings.
	 */
	virtual UBOOL GetListRenderParameters( EUIWidgetFace Face, FRenderParameters& out_Parameters ) const;

	/**
	 * Adjusts the owning widget's bounds according to the autosize settings.
	 */
	virtual void UpdateOwnerBounds( struct FRenderParameters& Parameters );

	/**
	 * Calculates the maximum number of visible elements and calls ApplyElementFormatting for all elements.
	 *
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyListFormatting( struct FRenderParameters& Parameters );

	/**
	 * Updates the formatting parameters for all cells of the specified element.
	 *
	 * @param	ElementIndex	the list element to apply formatting for.
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyElementFormatting( INT ElementIndex, struct FRenderParameters& Parameters );

	/**
	 * Wrapper for applying formatting to the schema cells.
	 */
	void FormatSchemaCells( struct FRenderParameters& Parameters );

	/**
	 * Updates the formatting parameters for all cells of the specified element.
	 *
	 * @param	Cells			the list of cells to render
	 * @param	Parameters		@see UUIString::ApplyFormatting())
	 */
	virtual void ApplyCellFormatting( TArray<struct FUIListElementCell*> Cells, struct FRenderParameters& Parameters );

	/**
	 * Renders the list element specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the list element to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the pixel location of the start of the horizontal bounding region that should be used for
	 *												rendering this element
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the pixel Y location of the bounding region that should be used for rendering this list element.
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering this element.  This is the Y position for rendering
	 *												the next element should be rendered
	 *							DrawXL:		[in]	specifies the pixel location of the end of the horizontal bounding region that should be used for rendering this element.
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in pixels.  If this value is not large enough to render the specified element,
	 *												the element will not be rendered.
	 *										[out]	Will be reduced by the height of the element that was rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the element
	 */
	virtual void Render_ListElement( FCanvas* Canvas, INT ElementIndex, struct FRenderParameters& Parameters );

	/**
	 * Renders the list element cells specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	Cells			the list of cells to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the location of the start of the horizontal bounding region that should be used for
	 *												rendering the cells, in absolute screen pixels
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the location of the start of the vertical bounding region that should be used for rendering
	 *												the cells, in absolute screen pixels
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering all cells.
	 *							DrawXL:		[in]	specifies the location of the end of the horizontal bounding region that should be used for rendering this element, in absolute screen pixels
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in absolute screen pixels.  If this value is not large enough to render the cells, they will not be
	 *												rendered
	 *										[out]	Will be reduced by the height of the cells that were rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the cells
	 */
	virtual void Render_Cells( FCanvas* Canvas, const TArray<struct FUIListElementCell*> Cells, struct FRenderParameters& CellParameters );

	/**
	 * Changes the data binding for the specified cell index.
	 *
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader		the string that should be displayed in the column header for this cell.
	 * @param	BindingIndex		the column or row to bind this data field to.  If BindingIndex is greater than the number
	 *								schema cells, empty schema cells will be added to meet the number required to place the data
	 *								at BindingIndex.
	 *								If a value of INDEX_NONE is specified, the cell binding will only occur if there are no other
	 *								schema cells bound to that data field.  In this case, a new schema cell will be appended and
	 *								it will be bound to the data field specified.
	 */
	virtual UBOOL SetCellBinding( FName CellDataBinding, const FString& ColumnHeader, INT BindingIndex );

	/**
	 * Inserts a new schema cell at the specified index and assigns the data binding.
	 *
	 * @param	InsertIndex			the column/row to insert the schema cell; must be a valid index.
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 *
	 * @return	TRUE if the schema cell was successfully inserted into the list
	 */
	virtual UBOOL InsertSchemaCell( INT InsertIndex, FName CellDataBinding, const FString& ColumnHeader );

	/**
	 * Removes all schema cells which are bound to the specified data field.
	 *
	 * @return	TRUE if one or more schema cells were successfully removed.
	 */
	virtual UBOOL ClearCellBinding( FName CellDataBinding );

	/**
	 * Removes schema cells at the location specified.  If the list's columns are linked, this index should correspond to
	 * the column that should be removed; if the list's rows are linked, this index should correspond to the row that should
	 * be removed.
	 *
	 * @return	TRUE if the schema cell at BindingIndex was successfully removed.
	 */
	virtual UBOOL ClearCellBinding( INT BindingIndex );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.  When the data source for the cell schema is changed,
	 * refreshes the list's data.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Copies the value of the deprecated SelectionOverlay/Coordinates into the appropriate element of the ItemOverlay array.
	 */
	virtual void PostLoad();
};

class UUIComp_ListPresenterCascade : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_ListPresenterCascade
    //## END PROPS UIComp_ListPresenterCascade

    DECLARE_CLASS(UUIComp_ListPresenterCascade,UUIComp_ListPresenter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListPresenterCascade)
};

class UUIComp_ContextMenuListPresenter : public UUIComp_ListPresenterCascade
{
public:
    //## BEGIN PROPS UIComp_ContextMenuListPresenter
    //## END PROPS UIComp_ContextMenuListPresenter

    DECLARE_CLASS(UUIComp_ContextMenuListPresenter,UUIComp_ListPresenterCascade,0,Engine)
    DECLARE_WITHIN(UUIContextMenu)
	/**
	 * Resolves the element schema provider based on the owning list's data source binding, and repopulates the element schema based on
	 * the available data fields in that element schema provider.
	 */
	virtual void RefreshElementSchema();
};

class UUIComp_ListPresenterTree : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_ListPresenterTree
    //## END PROPS UIComp_ListPresenterTree

    DECLARE_CLASS(UUIComp_ListPresenterTree,UUIComp_ListPresenter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIComp_ListPresenterTree)
};

class UUIAnimationSeq : public UUIAnimation
{
public:
    //## BEGIN PROPS UIAnimationSeq
    FName SeqName;
    FLOAT SeqDuration;
    TArrayNoInit<struct FUIAnimTrack> Tracks;
    BITFIELD bAbsolutePositioning:1;
    //## END PROPS UIAnimationSeq

    virtual void ApplyAnimation(class UUIObject* TargetWidget,INT TrackIndex,FLOAT Position,INT LFI,INT NFI,struct FUIAnimSeqRef AnimRefInst);
    DECLARE_FUNCTION(execApplyAnimation)
    {
        P_GET_OBJECT(UUIObject,TargetWidget);
        P_GET_INT(TrackIndex);
        P_GET_FLOAT(Position);
        P_GET_INT(LFI);
        P_GET_INT(NFI);
        P_GET_STRUCT(struct FUIAnimSeqRef,AnimRefInst);
        P_FINISH;
        ApplyAnimation(TargetWidget,TrackIndex,Position,LFI,NFI,AnimRefInst);
    }
    DECLARE_CLASS(UUIAnimationSeq,UUIAnimation,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimationSeq)
};

struct FUIDataProviderField
{
    FName FieldTag;
    BYTE FieldType;
private:
    TArray<class UUIDataProvider*> FieldProviders;
public:

	/** Constructors */
	FUIDataProviderField() {}

	FUIDataProviderField( FName InFieldTag, EUIDataProviderFieldType InFieldType=DATATYPE_Property, class UUIDataProvider* InFieldProvider=NULL );
	FUIDataProviderField( FName InFieldTag, const TArray<class UUIDataProvider*>& InFieldProviders );

	/**
	 * Retrieves the list of providers contained by this data provider field.
	 *
	 * @return	FALSE if the FieldType for this provider field is not DATATYPE_Provider/ProviderCollection
	 */
	UBOOL GetProviders( TArray<class UUIDataProvider*>& out_Providers ) const;

};

struct UIDataProvider_eventGenerateFillerData_Parms
{
    FString DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateFillerData_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGenerateScriptMarkupString_Parms
{
    FName DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateScriptMarkupString_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventSetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventSetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventGetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventGetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventGetSupportedScriptFields_Parms
{
    TArray<struct FUIDataProviderField> out_Fields;
    UIDataProvider_eventGetSupportedScriptFields_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventNotifyPropertyChanged_Parms
{
    FName PropTag;
    UIDataProvider_eventNotifyPropertyChanged_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventOnDataProviderPropertyChange_Parms
{
    FName PropTag;
    UIDataProvider_eventOnDataProviderPropertyChange_Parms(EEventParm)
    {
    }
};
class UUIDataProvider : public UUIRoot
{
public:
    //## BEGIN PROPS UIDataProvider
    BYTE WriteAccessType;
    TArrayNoInit<FScriptDelegate> ProviderChangedNotifies;
    FScriptDelegate __OnDataProviderPropertyChange__Delegate;
    //## END PROPS UIDataProvider

    FString eventGenerateFillerData(const FString& DataTag)
    {
        UIDataProvider_eventGenerateFillerData_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateFillerData),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGenerateScriptMarkupString(FName DataTag)
    {
        UIDataProvider_eventGenerateScriptMarkupString_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateScriptMarkupString),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetFieldValue(const FString& FieldName,const struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventSetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetFieldValue),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetFieldValue(const FString& FieldName,struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventGetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFieldValue),&Parms);
        FieldValue=Parms.FieldValue;
        return Parms.ReturnValue;
    }
    void eventGetSupportedScriptFields(TArray<struct FUIDataProviderField>& out_Fields)
    {
        UIDataProvider_eventGetSupportedScriptFields_Parms Parms(EC_EventParm);
        Parms.out_Fields=out_Fields;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedScriptFields),&Parms);
        out_Fields=Parms.out_Fields;
    }
    void eventNotifyPropertyChanged(FName PropTag=NAME_None)
    {
        UIDataProvider_eventNotifyPropertyChanged_Parms Parms(EC_EventParm);
        Parms.PropTag=PropTag;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPropertyChanged),&Parms);
    }
    void delegateOnDataProviderPropertyChange(FName PropTag=NAME_None)
    {
        UIDataProvider_eventOnDataProviderPropertyChange_Parms Parms(EC_EventParm);
        Parms.PropTag=PropTag;
        ProcessDelegate(ENGINE_OnDataProviderPropertyChange,&__OnDataProviderPropertyChange__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider,UUIRoot,0|CLASS_Transient,Engine)
protected:
	/**
	 * Returns the data tag associated with the specified provider.
	 *
	 * @return	the data field tag associated with the provider specified, or NAME_None if the provider specified is not
	 *			contained by this data store.
	 */
	virtual FName GetProviderDataTag( class UUIDataProvider* Provider );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventGetFieldValue(FieldName, out_FieldValue, ArrayIndex);
	}

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventSetFieldValue(FieldName, FieldValue, ArrayIndex);
	}

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue );

	/**
	 * Parses the data store reference and publishes the value specified to that location.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	FieldValue		contains the value that should be published to the location specified by MarkupString.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL SetDataStoreValue( const FString& MarkupString, const struct FUIProviderScriptFieldValue& FieldValue );

	/**
	 * For data stores that are responsible for applying inline style modifications (such as the font, style, and attribute data stores),
	 * parses the data store reference and applies the appropriate style changes.
	 *
	 * @param	MarkupString	a markup string representing a style modification that this data store is aware of; i.e. the name of the font,
	 *							style, or attribute.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if this data store applied a change to StyleData based on the value of MarkupString, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& MarkupString, struct FUIStringNodeModifier& StyleData ) { return FALSE; }

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider() { return this; }

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );


	// NON VIRTUALS
	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex );

	/**
	 * Returns whether the specified provider is contained by this data provider.
	 *
	 * @param	Provider			the provider to search for
	 * @param	out_ProviderOwner	will contain the UIDataProvider that contains the field tag which corresonds to the
	 *								Provider being searched for.
	 *
	 * @return	TRUE if Provider can be accessed through this data provider.
	 */
	UBOOL ContainsProvider( class UUIDataProvider* Provider, class UUIDataProvider*& out_ProviderOwner );

	/**
	 * Generates a data store path to the specified provider.
	 *
	 * @param	Provider			the data store provider to generate a path name to
	 * @param	out_DataStorePath	will be filled in with the path name necessary to access the specified provider,
	 *								including any trailing dots or colons
	 */
	void GetPathToProvider(class UUIDataStore* ContainerDataStore, class UUIDataProvider* Provider, FString& out_DataStorePath );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTag				the tag corresponding to the data field that we want a path to
	 *
	 * @return		a string containing the complete path name required to access the specified data field
	 */
	FString BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const FName& DataTag );

	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTag				the data field tag to generate the markup string for
	 *
	 * @return	a datastore markup string which resolves to the datastore field associated with DataTag, in the format:
	 *			<DataStoreTag:DataFieldTag>
	 */
	FString GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, FName DataTag );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * This is a bulk version of the BuildDataFieldPath function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTags			Array of tags to build paths for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Paths			Array of generated paths, one for each of the datatags passed in.
	 */
	void BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Paths );


	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * This is a bulk version of the GenerateDataMarkupString function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTags			array of tags to generate the markup string for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Markup			Array of strings of generated markup, one for each tag passed in.
	 */
	void GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Markup );


	/**
	 * Determines if the specified data tag is supported by this data provider
	 *
	 * @param	DataTag		the tag corresponding to the data field that we want to check for
	 *
	 * @return	TRUE if the data tag specified is supported by this data provider.
	 */
	UBOOL IsDataTagSupported( FName DataTag );

	/**
	 * Retrieves the field type for the specified field
	 *
	 * @param	DataTag					the tag corresponding to the data field that we want the field type for
	 * @param	out_ProviderFieldType	will receive the fieldtype for the data field specified; if DataTag isn't supported
	 *									by this provider, this value will not be modified.
	 *
	 * @return	TRUE if the field specified is supported and out_ProviderFieldType was changed to the correct type.
	 */
	UBOOL GetProviderFieldType( FString DataTag, EUIDataProviderFieldType& out_ProviderFieldType );

	/**
	 * Parses the specified markup string to get the data tag that should be evaluated by this data provider.
	 *
	 * @param	MarkupString	a string that contains a markup reference (either in whole, or in part), e.g. CurrentGame:Players;1.PlayerName.
	 *							if successfully parsed, after parsing,
	 * @param	out_NextDataTag	a string representing the data tag for the next portion of the data store path reference, including any
	 *							any array delimiters.
	 *
	 * @return	TRUE if the a data tag was successfully parsed.
	 */
	UBOOL ParseNextDataTag( FString& MarkupString, FString& out_NextDataTag ) const;

	/**
	 * Parses the string specified, separating the array index portion from the data field tag.
	 *
	 * @param	DataTag		the data tag that possibly contains an array index
	 *
	 * @return	the array index that was parsed from DataTag, or INDEX_NONE if there was no array index in the string specified.
	 */
	INT ParseArrayDelimiter( FString& DataTag ) const;

	/**
	 * Encapsulates the construction of a UITexture wrapper for the specified USurface.
	 *
	 * @param	SourceImage		the texture or material instance to apply to the newly created wrapper
	 *
	 * @return	a pointer to a UITexture instance which wraps the SourceImage passed in, or NULL if SourceImage was invalid
	 *			or the wrapper couldn't be created for some reason.
	 */
	static class UUITexture* CreateTextureWrapper( class USurface* SourceImage );

	/**
	 * Creates the appropriate type of string node for the NodeValue specified.  If NodeValue.CustomStringNode is set, returns
	 * that node; If NodeValue.StringValue is set, creates and initializes a UIStringNode_Text; if NodeValue.ImageValue is
	 * set, creates and initializes a UIStringNode_Image.
	 *
	 * @param	SourceText	the text to assign as the SourceText in the returned node
	 * @param	NodeValue	the value to use for initiailizing the string node that is returned
	 *
	 * @return	a pointer to either a UIStringNode of the appropriate type (Text or Image) that has been initialized from the
	 *			NodeValue specified.  The caller is responsible for cleaning up the memory for this return value.
	 */
	static struct FUIStringNode* CreateStringNode( const FString& SourceText, const struct FUIProviderFieldValue& NodeValue );
};

class UUIConfigProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIConfigProvider
    //## END PROPS UIConfigProvider

    DECLARE_ABSTRACT_CLASS(UUIConfigProvider,UUIDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIConfigProvider)
};

class UUIConfigFileProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigFileProvider
    TArrayNoInit<class UUIConfigSectionProvider*> Sections;
    //## END PROPS UIConfigFileProvider

    DECLARE_CLASS(UUIConfigFileProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
	/** the name of the config file associated with this data provider */
	FFilename	ConfigFileName;

	/* === UIConfigFileProvider interface === */
	/**
	 * Initializes this config file provider, creating the section data providers for each of the sections contained
	 * within the ConfigFile specified.
	 *
	 * @param	ConfigFile	the config file to associated with this data provider
	 */
	void InitializeProvider( class FConfigFile* ConfigFile );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIConfigSectionProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigSectionProvider
    FStringNoInit SectionName;
    //## END PROPS UIConfigSectionProvider

    DECLARE_CLASS(UUIConfigSectionProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIConfigFileProvider)
	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms
{
    UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayerDataBase
    class ULocalPlayer* Player;
    //## END PROPS UIDataProvider_OnlinePlayerDataBase

    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider_OnlinePlayerDataBase,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Provides the data provider with the player they were just bound to
	 *
	 * @param Player the local player associated with this player settings provider
	 */
	virtual void OnRegister(ULocalPlayer* InPlayer)
	{
		eventOnRegister(InPlayer);
	}

	/**
	 * Tells the provider that the player is no longer valid
	 */
	virtual void OnUnregister(void)
	{
		eventOnUnregister();
	}
};

class UUIDataProvider_OnlineClanMates : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineClanMates
    //## END PROPS UIDataProvider_OnlineClanMates

    DECLARE_CLASS(UUIDataProvider_OnlineClanMates,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineClanMate
	 *
	 * @see OnlineClanMate structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags )
	{
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		return FALSE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ClanMates")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}
};

class UUIDataProvider_OnlineFriends : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineFriends
    TArrayNoInit<struct FOnlineFriend> FriendsList;
    //## END PROPS UIDataProvider_OnlineFriends

    DECLARE_CLASS(UUIDataProvider_OnlineFriends,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags )
	{
		//@fixme - localize the column header strings
		out_CellTags.Set(FName(TEXT("NickName")),TEXT("NickName"));
		out_CellTags.Set(FName(TEXT("PresenceInfo")),TEXT("PresenceInfo"));
		out_CellTags.Set(FName(TEXT("bIsOnline")),TEXT("bIsOnline"));
		out_CellTags.Set(FName(TEXT("bIsPlaying")),TEXT("bIsPlaying"));
		out_CellTags.Set(FName(TEXT("bIsPlayingThisGame")),TEXT("bIsPlayingThisGame"));
		out_CellTags.Set(FName(TEXT("bIsJoinable")),TEXT("bIsJoinable"));
		out_CellTags.Set(FName(TEXT("bHasVoiceSupport")),TEXT("bHasVoiceSupport"));
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Friends")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_OnlinePlayers : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayers
    //## END PROPS UIDataProvider_OnlinePlayers

    DECLARE_CLASS(UUIDataProvider_OnlinePlayers,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlinePlayer
	 *
	 * @see OnlinePlayer structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags )
	{
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		return FALSE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Players")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return FALSE;
	}
};

struct FProfileSettingsArrayProvider
{
    INT ProfileSettingsId;
    FName ProfileSettingsName;
    class UUIDataProvider_OnlineProfileSettingsArray* Provider;
};

struct UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms
{
    UBOOL ReturnValue;
    UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlineProfileSettings : public UUIDataProvider_OnlinePlayerDataBase
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineProfileSettings
    class UOnlineProfileSettings* Profile;
    FName ProviderName;
    BITFIELD bWasErrorLastRead:1;
    TArrayNoInit<struct FProfileSettingsArrayProvider> ProfileSettingsArrayProviders;
    //## END PROPS UIDataProvider_OnlineProfileSettings

    UBOOL eventSaveProfileData()
    {
        UIDataProvider_OnlineProfileSettings_eventSaveProfileData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_SaveProfileData),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIDataProvider_OnlineProfileSettings,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
	/**
	 * Tells the provider the settings object it is resposible for exposing to
	 * the UI
	 *
	 * @param InSettings the settings object to expose
	 */
	virtual void BindProfileSettings(UOnlineProfileSettings* InSettings);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );
};

class UUIDataProvider_OnlineProfileSettingsArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineProfileSettingsArray
    class UOnlineProfileSettings* ProfileSettings;
    INT ProfileSettingId;
    FName ProfileSettingsName;
    TArrayNoInit<FName> Values;
    //## END PROPS UIDataProvider_OnlineProfileSettingsArray

    DECLARE_CLASS(UUIDataProvider_OnlineProfileSettingsArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new profile object and id to this provider.
	 *
	 * @param NewProfile the new object to bind
	 * @param NewProfileSettingsId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(UOnlineProfileSettings* NewProfile,INT NewProfileSettingsId);

	/**
	 * Binds the new profile object and id to this provider.
	 *
	 * @param NewProfile the new object to bind
	 * @param PropertyId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(UOnlineProfileSettings* NewProfile,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

class UUIDataProvider_SettingsArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_SettingsArray
    class USettings* Settings;
    INT SettingsId;
    FName SettingsName;
    TArrayNoInit<FName> Values;
    //## END PROPS UIDataProvider_SettingsArray

    DECLARE_CLASS(UUIDataProvider_SettingsArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new settings object and id to this provider.
	 *
	 * @param NewSettings the new object to bind
	 * @param NewSettingsId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(USettings* NewSettings,INT NewSettingsId);

	/**
	 * Binds the property id as an array item. Requires that the property
	 * has a mapping type of PVMT_PredefinedValues
	 *
	 * @param NewSettings the new object to bind
	 * @param PropertyId the id of the property to expose as an array
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(USettings* NewSettings,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_eventRefreshSubscribers_Parms
{
    UIDataStore_eventRefreshSubscribers_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberDetached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberDetached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberAttached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberAttached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventUnregistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventUnregistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventRegistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventRegistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventOnRefreshDataStore_Parms
{
    INT Unused;
    UBOOL ReturnValue;
    UIDataStore_eventOnRefreshDataStore_Parms(EEventParm)
    {
    }
};
class UUIDataStore : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataStore
    FName Tag;
    TArrayNoInit<FScriptDelegate> RefreshSubscriberNotifies;
    FScriptDelegate __OnRefreshDataStore__Delegate;
    //## END PROPS UIDataStore

    virtual void OnCommit();
    DECLARE_FUNCTION(execOnCommit)
    {
        P_FINISH;
        OnCommit();
    }
    void eventRefreshSubscribers()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshSubscribers),NULL);
    }
    void eventSubscriberDetached(TScriptInterface<class IUIDataStoreSubscriber> Subscriber)
    {
        UIDataStore_eventSubscriberDetached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberDetached),&Parms);
    }
    void eventSubscriberAttached(TScriptInterface<class IUIDataStoreSubscriber> Subscriber)
    {
        UIDataStore_eventSubscriberAttached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberAttached),&Parms);
    }
    void eventUnregistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventUnregistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Unregistered),&Parms);
    }
    void eventRegistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventRegistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Registered),&Parms);
    }
    UBOOL delegateOnRefreshDataStore(INT Unused=-1)
    {
        UIDataStore_eventOnRefreshDataStore_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Unused=Unused;
        ProcessDelegate(ENGINE_OnRefreshDataStore,&__OnRefreshDataStore__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Allows each data store the chance to load any dependent classes
	 */
	virtual void LoadDependentClasses(void)
	{
	}

	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/**
	 * Called when this data store is removed from the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnUnregister( class ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName ) { return TScriptInterface<IUIListElementProvider>(); }

	/**
	 * Retrieves the tag used for referencing this data store.  Normally corresponds to Tag, but may be different for some special
	 * data stores.
	 */
	virtual FName GetDataStoreID() const { return Tag; }
};

class USceneDataStore : public UUIDataStore, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS SceneDataStore
    class UUIScene* OwnerScene;
    class UUIDynamicFieldProvider* SceneDataProvider;
    //## END PROPS SceneDataStore

    DECLARE_CLASS(USceneDataStore,UUIDataStore,0,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UIDataStore interface === */
	/**
	 * Creates the data provider for this scene data store.
	 */
	virtual void InitializeDataStore();

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();


	/** === IUIListElementProviderInterface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );


	/* === IUIListElementCellProvider === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataStore_Color : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Color
    //## END PROPS UIDataStore_Color

    DECLARE_CLASS(UUIDataStore_Color,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataProvider interface === */

	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Attempst to load the font specified and if successful changes the style data's DrawFont.
	 *
	 * @param	MarkupString	a string corresponding to the name of a font.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if a font was found matching the specified FontName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& ColorParams, struct FUIStringNodeModifier& StyleData );
};

class UUIDataStore_Fonts : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Fonts
    //## END PROPS UIDataStore_Fonts

    DECLARE_CLASS(UUIDataStore_Fonts,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataProvider interface === */
	/**
	 * Gets the list of font names available through this data store.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Attempst to load the font specified and if successful changes the style data's DrawFont.
	 *
	 * @param	MarkupString	a string corresponding to the name of a font.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if a font was found matching the specified FontName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& FontName, struct FUIStringNodeModifier& StyleData );
};

struct FGameResourceDataProvider
{
    FName ProviderTag;
    FStringNoInit ProviderClassName;
    class UClass* ProviderClass;

    /** Constructors */
    FGameResourceDataProvider() {}
    FGameResourceDataProvider(EEventParm)
    {
        appMemzero(this, sizeof(FGameResourceDataProvider));
    }
};

class UUIDataStore_GameResource : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_GameResource
    TArrayNoInit<struct FGameResourceDataProvider> ElementProviderTypes;
    TMultiMap<FName,class UUIResourceDataProvider*> ListElementProviders;
    //## END PROPS UIDataStore_GameResource

    DECLARE_CLASS(UUIDataStore_GameResource,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the index for the GameResourceDataProvider with a tag matching ProviderTag.
	 *
	 * @return	the index into the ElementProviderTypes array for the GameResourceDataProvider element that has the
	 *			tag specified, or INDEX_NONE if there are no elements of the ElementProviderTypes array that have that tag.
	 */
	INT FindProviderTypeIndex( FName ProviderTag );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Initializes the ListElementProviders map
	 */
	virtual void InitializeDataStore();

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );
};

struct UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms
{
    UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms(EEventParm)
    {
    }
};
class UUIDataStore_GameState : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_GameState
    FScriptDelegate __OnRefreshDataFieldValue__Delegate;
    //## END PROPS UIDataStore_GameState

    void delegateOnRefreshDataFieldValue()
    {
        ProcessDelegate(ENGINE_OnRefreshDataFieldValue,&__OnRefreshDataFieldValue__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_GameState,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_GameState)
};

struct FGameDataProviderTypes
{
    class UClass* GameDataProviderClass;
    class UClass* PlayerDataProviderClass;
    class UClass* TeamDataProviderClass;
};

class UCurrentGameDataStore : public UUIDataStore_GameState
{
public:
    //## BEGIN PROPS CurrentGameDataStore
    struct FGameDataProviderTypes ProviderTypes;
    class UGameInfoDataProvider* GameData;
    TArrayNoInit<class UPlayerDataProvider*> PlayerData;
    TArrayNoInit<class UTeamDataProvider*> TeamData;
    //## END PROPS CurrentGameDataStore

    DECLARE_CLASS(UCurrentGameDataStore,UUIDataStore_GameState,0|CLASS_Transient,Engine)
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();
};

struct FPlayerDataProviderTypes
{
    class UClass* PlayerOwnerDataProviderClass;
    class UClass* CurrentWeaponDataProviderClass;
    class UClass* WeaponDataProviderClass;
    class UClass* PowerupDataProviderClass;
};

class UPlayerOwnerDataStore : public UUIDataStore_GameState
{
public:
    //## BEGIN PROPS PlayerOwnerDataStore
    struct FPlayerDataProviderTypes ProviderTypes;
    class UPlayerOwnerDataProvider* PlayerData;
    class UCurrentWeaponDataProvider* CurrentWeapon;
    TArrayNoInit<class UWeaponDataProvider*> WeaponList;
    TArrayNoInit<class UPowerupDataProvider*> PowerupList;
    //## END PROPS PlayerOwnerDataStore

    DECLARE_CLASS(UPlayerOwnerDataStore,UUIDataStore_GameState,0|CLASS_Transient,Engine)
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataStore_Gamma : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Gamma
    //## END PROPS UIDataStore_Gamma

    DECLARE_CLASS(UUIDataStore_Gamma,UUIDataStore,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

private:
	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE );

	/**
	 * Tells the D3D device to flush it's INI settings to disk to save the gamma value
	 */
	void OnCommit(void);
};

class UUIDataStore_Images : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Images
    //## END PROPS UIDataStore_Images

    DECLARE_CLASS(UUIDataStore_Images,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataStore interface === */
	/**
	 * Retrieves the tag used for referencing this data store.  Loc data store is always referenced using the special tag "Strings"
	 */
	virtual FName GetDataStoreID() const { return NAME_Images; }

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString, out_FieldValue);
	}
};

class UUIDataStore_Registry : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Registry
    class UUIDynamicFieldProvider* RegistryDataProvider;
    //## END PROPS UIDataStore_Registry

    DECLARE_CLASS(UUIDataStore_Registry,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataStore interface === */
	/**
	 * Creates the data provider for this registry data store.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but in this data store, the data fields are pulled from an internal provider but presented as though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();

	/**
	 * Notifies the data store that all values bound to this data store in the current scene have been saved.  Provides data stores which
	 * perform buffered or batched data transactions with a way to determine when the UI system has finished writing data to the data store.
	 */
	virtual void OnCommit();
};

class UUIDataStore_Remote : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Remote
    //## END PROPS UIDataStore_Remote

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Remote,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Remote)
};

struct FGameSearchCfg
{
    class UClass* GameSearchClass;
    class UClass* DefaultGameSettingsClass;
    class UClass* SearchResultsProviderClass;
    class UUIDataProvider_Settings* DesiredSettingsProvider;
    TArrayNoInit<class UUIDataProvider_Settings*> SearchResults;
    class UOnlineGameSearch* Search;
    FName SearchName;

    /** Constructors */
    FGameSearchCfg() {}
    FGameSearchCfg(EEventParm)
    {
        appMemzero(this, sizeof(FGameSearchCfg));
    }
};

struct UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms
{
    UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventMoveToNext_Parms
{
    UIDataStore_OnlineGameSearch_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms
{
    FName SearchName;
    UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms
{
    class UOnlineGameSearch* ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms
{
    BYTE ControllerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms
{
    INT ListIndex;
    struct FOnlineGameSearchResult Result;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms
{
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventInit_Parms
{
    UIDataStore_OnlineGameSearch_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSearch
    FName SearchResultsName;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> GameInterface;
    TArrayNoInit<struct FGameSearchCfg> GameSearchCfgList;
    INT SelectedIndex;
    //## END PROPS UIDataStore_OnlineGameSearch

    virtual void BuildSearchResults();
    DECLARE_FUNCTION(execBuildSearchResults)
    {
        P_FINISH;
        BuildSearchResults();
    }
    void eventMoveToPrevious()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),NULL);
    }
    void eventMoveToNext()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),NULL);
    }
    void eventSetCurrentByName(FName SearchName)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SearchName=SearchName;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UOnlineGameSearch* eventGetCurrentGameSearch()
    {
        UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShowHostGamercard(BYTE ControllerIndex,INT ListIndex)
    {
        UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerIndex=ControllerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowHostGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetSearchResultFromIndex(INT ListIndex,struct FOnlineGameSearchResult& Result)
    {
        UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ListIndex=ListIndex;
        Parms.Result=Result;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSearchResultFromIndex),&Parms);
        Result=Parms.Result;
        return Parms.ReturnValue;
    }
    UBOOL eventSubmitGameSearch(BYTE ControllerIndex)
    {
        UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SubmitGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSearch,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms
{
    UBOOL ReturnValue;
    UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventRegisterDelegates_Parms
{
    UIDataStore_OnlinePlayerData_eventRegisterDelegates_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnUnregister_Parms
{
    UIDataStore_OnlinePlayerData_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataStore_OnlinePlayerData_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlinePlayerData
    class UUIDataProvider_OnlineFriends* FriendsProvider;
    class UUIDataProvider_OnlinePlayers* PlayersProvider;
    class UUIDataProvider_OnlineClanMates* ClanMatesProvider;
    class ULocalPlayer* Player;
    FStringNoInit PlayerNick;
    INT NumNewDownloads;
    INT NumTotalDownloads;
    FStringNoInit ProfileSettingsClassName;
    class UClass* ProfileSettingsClass;
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    //## END PROPS UIDataStore_OnlinePlayerData

    UBOOL eventSaveProfileData()
    {
        UIDataStore_OnlinePlayerData_eventSaveProfileData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_SaveProfileData),&Parms);
        return Parms.ReturnValue;
    }
    void eventRegisterDelegates()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RegisterDelegates),NULL);
    }
    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataStore_OnlinePlayerData_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_CLASS(UUIDataStore_OnlinePlayerData,UUIDataStore_Remote,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
/* === UIDataStore interface === */

	/**
	 * Loads the game specific OnlineProfileSettings class
	 */
	virtual void LoadDependentClasses(void);

	/**
	 * Creates the data providers exposed by this data store
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Forwards the calls to the data providers so they can do their start up
	 *
	 * @param Player the player that will be associated with this DataStore
	 */
	virtual void OnRegister(ULocalPlayer* Player);

	/**
	 * Tells all of the child providers to clear their player data
	 *
	 * @param Player ignored
	 */
	virtual void OnUnregister(ULocalPlayer*);

	/**
	 * Gets the list of data fields exposed by this data provider
	 *
	 * @param OutFields Filled in with the list of fields supported by its aggregated providers
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

/* === IUIListElementProvider interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

struct UIDataStore_OnlineStats_eventShowGamercard_Parms
{
    BYTE ConrollerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventShowGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventRefreshStats_Parms
{
    BYTE ConrollerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventRefreshStats_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventInit_Parms
{
    UIDataStore_OnlineStats_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineStats : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineStats
    TArrayNoInit<class UClass*> StatsReadClasses;
    FName StatsReadName;
    FName PlayerNickName;
    FName RankName;
    FName TotalRowsName;
    TArrayNoInit<class UOnlineStatsRead*> StatsReadObjects;
    class UOnlineStatsRead* StatsRead;
    BYTE CurrentReadType;
    TScriptInterface<class IInterface> StatsInterface;
    TScriptInterface<class IInterface> PlayerInterface;
    //## END PROPS UIDataStore_OnlineStats

    virtual void SortResultsByRank();
    DECLARE_FUNCTION(execSortResultsByRank)
    {
        P_FINISH;
        SortResultsByRank();
    }
    UBOOL eventShowGamercard(BYTE ConrollerIndex,INT ListIndex)
    {
        UIDataStore_OnlineStats_eventShowGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ConrollerIndex=ConrollerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRefreshStats(BYTE ConrollerIndex)
    {
        UIDataStore_OnlineStats_eventRefreshStats_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ConrollerIndex=ConrollerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshStats),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineStats,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered stats read object
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Returns the stats read results as a collection
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields)
	{
		OutFields.Empty();
		new(OutFields)FUIDataProviderField(StatsReadName,DATATYPE_Collection);
		new(OutFields)FUIDataProviderField(TotalRowsName);
	}

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE)
	{
		if (FName(*FieldName) == TotalRowsName)
		{
			OutFieldValue.PropertyType = DATATYPE_Property;
			OutFieldValue.StringValue = FString::Printf(TEXT("%d"),StatsRead ? StatsRead->TotalRowsInView : 0);
			return TRUE;
		}
		return FALSE;
	}

	/**
	 * Returns the list element provider for the specified proprety name
	 *
	 * @param PropertyName the name of the property to look up
	 *
	 * @return pointer to the interface or null if the property name is invalid
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName)
	{
		if (FName(*PropertyName) == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementProvider>();
	}

// IUIListElement interface

	/**
	 * Returns the names of the columns that can be bound to
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param CellTag the tag for the element cell to get the field type for
	 * @param OutCellFieldType receives the field type for the specified cell (property)
	 *
	 * @return TRUE if the cell tag is valid, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldType(const FName& CellTag,BYTE& OutCellFieldType);

	/**
	 * Finds the value for the specified column in a row (if valid)
	 *
	 * @param CellTag the tag for the element cell to resolve the value for
	 * @param ListIndex the index into the stats read results array
	 * @param OutFieldValue the out value that holds the cell's value
	 * @param ArrayIndex ignored
	 *
	 * @return TRUE if the cell value was found, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldValue(const FName& CellTag,INT ListIndex,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

// IUIListElementProvider interface

	/**
	 * Fetches the column names that can be bound
	 *
	 * @return the list of tags supported
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of rows in the data set
	 *
	 * @param DataTag the name of the collection that is being queried
	 *
	 * @return the number of items in the list
	 */
	virtual INT GetElementCount(FName DataTag)
	{
		check(StatsRead);
		return StatsRead->Rows.Num();
	}

	/**
	 * Returns the list of indices for the list items
	 *
	 * @param	FieldName		the name of the property to get the indices for
	 * @param	OutElements		will be filled with the indices into the list
	 *
	 * @return	TRUE if the field name is valid, FALSE otherwise
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Fetches the interface that allows the UI to query for column names
	 *
	 * @param DataTag the tag of the list needed
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}

	/**
	 * Fetches the interface that allows the UI to query for column values
	 *
	 * @param FieldName the tag of the list that needs the interface
	 * @param ListIndex ignored
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}
};

class UUIDataStore_Settings : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Settings
    //## END PROPS UIDataStore_Settings

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Settings,UUIDataStore,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Settings)
};

struct FGameSettingsCfg
{
    class UClass* GameSettingsClass;
    class UUIDataProvider_Settings* Provider;
    class UOnlineGameSettings* GameSettings;
    FName SettingsName;
};

struct UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventMoveToNext_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms
{
    FName SettingsName;
    UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms
{
    class UUIDataProvider_Settings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms
{
    class UOnlineGameSettings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventCreateGame_Parms
{
    class AWorldInfo* WorldInfo;
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSettings_eventCreateGame_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSettings
    TArrayNoInit<struct FGameSettingsCfg> GameSettingsCfgList;
    INT SelectedIndex;
    //## END PROPS UIDataStore_OnlineGameSettings

    void eventMoveToPrevious()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),NULL);
    }
    void eventMoveToNext()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),NULL);
    }
    void eventSetCurrentByName(FName SettingsName)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SettingsName=SettingsName;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UUIDataProvider_Settings* eventGetCurrentProvider()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentProvider),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineGameSettings* eventGetCurrentGameSettings()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSettings),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCreateGame(class AWorldInfo* WorldInfo,BYTE ControllerIndex)
    {
        UIDataStore_OnlineGameSettings_eventCreateGame_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.WorldInfo=WorldInfo;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateGame),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSettings,UUIDataStore_Settings,0|CLASS_Transient,Engine)
private:
	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);
};

class UUIDataStore_PlayerSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_PlayerSettings
    TArrayNoInit<FString> PlayerSettingsProviderClassNames;
    TArrayNoInit<class UClass*> PlayerSettingsProviderClasses;
    TArrayNoInit<class UPlayerSettingsProvider*> PlayerSettings;
    INT PlayerIndex;
    //## END PROPS UIDataStore_PlayerSettings

    class ULocalPlayer* GetPlayerOwner() const;
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner();
    }
    DECLARE_CLASS(UUIDataStore_PlayerSettings,UUIDataStore_Settings,0|CLASS_Transient|CLASS_Config,Engine)
	/* === UIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIDataStore_SessionSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_SessionSettings
    TArrayNoInit<FString> SessionSettingsProviderClassNames;
    TArrayNoInit<class UClass*> SessionSettingsProviderClasses;
    TArrayNoInit<class USessionSettingsProvider*> SessionSettings;
    //## END PROPS UIDataStore_SessionSettings

    DECLARE_CLASS(UUIDataStore_SessionSettings,UUIDataStore_Settings,0|CLASS_Transient|CLASS_Config,Engine)
	/* === UIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct FUIMenuInputMap
{
    FName FieldName;
    FName Set;
    FStringNoInit MappedText;

    /** Constructors */
    FUIMenuInputMap() {}
    FUIMenuInputMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIMenuInputMap));
    }
};

class UUIDataStore_StringAliasMap : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_StringAliasMap
    TArrayNoInit<struct FUIMenuInputMap> MenuInputMapArray;
    TMap<FName, TMap<FName, INT> > MenuInputSets;
    INT PlayerIndex;
    //## END PROPS UIDataStore_StringAliasMap

    class ULocalPlayer* GetPlayerOwner() const;
    INT FindMappingWithFieldName(const FString& FieldName=TEXT(""),const FString& SetName=TEXT(""));
    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner();
    }
    DECLARE_FUNCTION(execFindMappingWithFieldName)
    {
        P_GET_STR_OPTX(FieldName,TEXT(""));
        P_GET_STR_OPTX(SetName,TEXT(""));
        P_FINISH;
        *(INT*)Result=FindMappingWithFieldName(FieldName,SetName);
    }
    DECLARE_FUNCTION(execGetStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_FINISH;
        *(INT*)Result=GetStringWithFieldName(FieldName,MappedString);
    }
    DECLARE_CLASS(UUIDataStore_StringAliasMap,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	* Called when this data store is added to the data store manager's list of active data stores.
	*
	* @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	*							associated with a particular player; NULL if this is a global data store.
	*/
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/**
	 * For data stores that are responsible for applying inline style modifications (such as the font, style, and attribute data stores),
	 * parses the data store reference and applies the appropriate style changes.
	 *
	 * @param	MarkupString	a markup string representing a style modification that this data store is aware of; i.e. the name of the font,
	 *							style, or attribute.
	 * @param	StyleData		the style data to apply the changes to.
	 *
	 * @return	TRUE if this data store applied a change to StyleData based on the value of MarkupString, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& MarkupString, struct FUIStringNodeModifier& StyleData ) { return TRUE; }

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
	
	/* === UIDataStore_MenuStringMap interface === */
public:
	/** Return the string representation of the field being queried */
	virtual FString GetStringFromIndex( INT MapArrayIndex );
};

class UUIDataStore_Strings : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Strings
    TArrayNoInit<class UUIConfigFileProvider*> LocFileProviders;
    //## END PROPS UIDataStore_Strings

    DECLARE_CLASS(UUIDataStore_Strings,UUIDataStore,0|CLASS_Transient,Engine)
protected:
	/* === UUIDataStore_Strings interface === */
	/**
	 * Creates an UIConfigFileProvider instance for the loc file specified by FilePathName.
	 *
	 * @return	a pointer to a newly allocated UUIConfigFileProvider instance that contains the data for the specified
	 *			loc file.
	 */
	class UUIConfigFileProvider* CreateLocProvider( const FFilename& FilePathName );

public:
	/* === UIDataStore interface === */
	/**
	 * Loads all .int files and creates UIConfigProviders for each loc file that was loaded.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString, out_FieldValue);
	}

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct FUISoundCue
{
    FName SoundName;
    class USoundCue* SoundToPlay;

	/** Constructors */
	FUISoundCue() {}
	FUISoundCue(EEventParm)
	{
		appMemzero(this,sizeof(FUISoundCue));
	}

};

class UUISkin : public UUIDataStore
{
public:
    //## BEGIN PROPS UISkin
protected:
    TArrayNoInit<class UUIStyle*> Styles;
    TArrayNoInit<FString> StyleGroups;
    TArrayNoInit<struct FUISoundCue> SoundCues;
public:
    TMap< struct FSTYLE_ID,class UUIStyle* > StyleLookupTable;
    TMap< FName,class UUIStyle* > StyleNameMap;
    TLookupMap<FString> StyleGroupMap;
    TMap< FName,struct FUIMouseCursor > CursorMap;
    TMap< FName,class USoundCue* > SoundCueMap;
    //## END PROPS UISkin

    void GetAvailableStyles(TArray<class UUIStyle*>& out_Styles,UBOOL bIncludeInheritedStyles=TRUE);
    class UUITexture* GetCursorResource(FName CursorName);
    UBOOL AddUISoundCue(FName SoundCueName,class USoundCue* SoundToPlay);
    UBOOL RemoveUISoundCue(FName SoundCueName);
    UBOOL GetUISoundCue(FName SoundCueName,class USoundCue*& out_UISoundCue);
    void GetSkinSoundCues(TArray<struct FUISoundCue>& out_SoundCues);
    UBOOL IsInheritedGroupName(const FString& StyleGroupName) const;
    UBOOL AddStyleGroupName(const FString& StyleGroupName);
    UBOOL RemoveStyleGroupName(const FString& StyleGroupName);
    UBOOL RenameStyleGroup(const FString& OldStyleGroupName,const FString& NewStyleGroupName);
    FString GetStyleGroupAtIndex(INT Index) const;
    INT FindStyleGroupIndex(const FString& StyleGroupName) const;
    void GetStyleGroups(TArray<FString>& StyleGroupArray,UBOOL bIncludeInheritedGroups=TRUE) const;
    DECLARE_FUNCTION(execGetAvailableStyles)
    {
        P_GET_TARRAY_REF(class UUIStyle*,out_Styles);
        P_GET_UBOOL_OPTX(bIncludeInheritedStyles,TRUE);
        P_FINISH;
        GetAvailableStyles(out_Styles,bIncludeInheritedStyles);
    }
    DECLARE_FUNCTION(execGetCursorResource)
    {
        P_GET_NAME(CursorName);
        P_FINISH;
        *(class UUITexture**)Result=GetCursorResource(CursorName);
    }
    DECLARE_FUNCTION(execAddUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_GET_OBJECT(USoundCue,SoundToPlay);
        P_FINISH;
        *(UBOOL*)Result=AddUISoundCue(SoundCueName,SoundToPlay);
    }
    DECLARE_FUNCTION(execRemoveUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_FINISH;
        *(UBOOL*)Result=RemoveUISoundCue(SoundCueName);
    }
    DECLARE_FUNCTION(execGetUISoundCue)
    {
        P_GET_NAME(SoundCueName);
        P_GET_OBJECT_REF(USoundCue,out_UISoundCue);
        P_FINISH;
        *(UBOOL*)Result=GetUISoundCue(SoundCueName,out_UISoundCue);
    }
    DECLARE_FUNCTION(execGetSkinSoundCues)
    {
        P_GET_TARRAY_REF(struct FUISoundCue,out_SoundCues);
        P_FINISH;
        GetSkinSoundCues(out_SoundCues);
    }
    DECLARE_FUNCTION(execIsInheritedGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=IsInheritedGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execAddStyleGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=AddStyleGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execRemoveStyleGroupName)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=RemoveStyleGroupName(StyleGroupName);
    }
    DECLARE_FUNCTION(execRenameStyleGroup)
    {
        P_GET_STR(OldStyleGroupName);
        P_GET_STR(NewStyleGroupName);
        P_FINISH;
        *(UBOOL*)Result=RenameStyleGroup(OldStyleGroupName,NewStyleGroupName);
    }
    DECLARE_FUNCTION(execGetStyleGroupAtIndex)
    {
        P_GET_INT(Index);
        P_FINISH;
        *(FString*)Result=GetStyleGroupAtIndex(Index);
    }
    DECLARE_FUNCTION(execFindStyleGroupIndex)
    {
        P_GET_STR(StyleGroupName);
        P_FINISH;
        *(INT*)Result=FindStyleGroupIndex(StyleGroupName);
    }
    DECLARE_FUNCTION(execGetStyleGroups)
    {
        P_GET_TARRAY_REF(FString,StyleGroupArray);
        P_GET_UBOOL_OPTX(bIncludeInheritedGroups,TRUE);
        P_FINISH;
        GetStyleGroups(StyleGroupArray,bIncludeInheritedGroups);
    }
    DECLARE_CLASS(UUISkin,UUIDataStore,0,Engine)
	/* === UUISkin interface === */
	/**
	 * Called when this skin is set to be the UI's active skin.  Initializes all styles and builds the lookup tables.
	 */
	void Initialize();

	/**
	 * Fills the values of the specified maps with the styles contained by this skin and all this skin's archetypes.
	 */
	virtual void InitializeLookupTables( TMap<struct FSTYLE_ID,class UUIStyle*>& out_StyleIdMap, TMap<FName,class UUIStyle*>& out_StyleNameMap, TMap<FName,class USoundCue*>& out_SoundCueMap, TLookupMap<FString>& out_GroupNameMap );

	/**
	 * Creates a new style within this skin.
	 *
	 * @param	StyleClass		the class to use for the new style
	 * @param	StyleTag		the unique tag to use for creating the new style
	 * @param	StyleTemplate	the template to use for the new style
	 * @param	bAddToSkin		TRUE to automatically add this new style to this skin's list of styles
	 */
	virtual UUIStyle* CreateStyle( UClass* StyleClass, FName StyleTag, class UUIStyle* StyleTemplate=NULL, UBOOL bAddToSkin=TRUE );

	/**
	 * Creates a new style using the template provided and replaces its entry in the style lookup tables.
	 * This only works if the outer of the style template is a archetype of the this skin.
	 *
	 * @param	StyleTemplate	the template to use for the new style
	 * @return	Pointer to the style that was created to replace the archetype's style.
	 */
	virtual UUIStyle* ReplaceStyle( class UUIStyle* StyleTemplate );

	/**
	 * Deletes the specified style and replaces its entry in the lookup table with this skin's archetype style.
	 * This only works if the provided style's outer is this skin.
	 *
	 * @return	TRUE if the style was successfully removed.
	 */
	virtual UBOOL DeleteStyle( class UUIStyle* InStyle );

	/**that
	 * Adds the specified style to this skin's list of styles.
	 *
	 * @return	TRUE if the style was successfully added to this skin.
	 */
	virtual UBOOL AddStyle( class UUIStyle* NewStyle );

	/**
	 * Retrieve the style ID associated with a particular style name
	 */
	FSTYLE_ID FindStyleID( FName StyleName ) const;

	/**
	 * Retrieve the style associated with a particular style name
	 */
	UUIStyle* FindStyle( FName StyleName ) const;

	/**
	 * Determines whether the specified style is contained in this skin
	 *
	 * @param	bIncludeInheritedStyles		if FALSE, only returns true if the specified style is in this skin's Styles
	 *										array; otherwise, also returns TRUE if the specified style is contained by
	 *										any base skins of this one.
	 *
	 * @return	TRUE if the specified style is contained by this skin, or one of its base skins
	 */
	UBOOL ContainsStyle( UUIStyle* StyleToSearchFor, UBOOL bIncludeInheritedStyles=FALSE ) const;

	/**
	 * Adds a new mouse cursor resource to this skin.
	 *
	 * @param	CursorTag			the name to use for the mouse cursor.  this will be the name that must be used to retrieve
	 *								this mouse cursor via GetCursorResource()
	 * @param	CursorResource		the mouse cursor to add
	 *
	 * @return	TRUE if the cursor was successfully added to the skin.  FALSE if the resource was invalid or there is already
	 *			another cursor using the specified tag.
	 */
	UBOOL AddCursorResource( FName CursorTag, const FUIMouseCursor& CursorResource );

	/**
	 * Makes any necessary internal changes when this style has been modified
	 *
	 * @param	Style	style in this skin which data has been modified
	 */
	void NotifyStyleModified( class UUIStyle* Style );

	enum EDerivedType
	{
		DERIVETYPE_DirectOnly,
		DERIVETYPE_All,
	};

	enum EStyleSearchType
	{
		SEARCH_SameSkinOnly,
		SEARCH_AnySkin,
	};

	/**
	 * Generate a list of UISkin objects in memory that are derived from the specified skin.
	 */
	static void GetDerivedSkins( const UUISkin* ParentSkin, TArray<UUISkin*>& out_DerivedSkins, EDerivedType DeriveFilter=DERIVETYPE_All );

	/**
	 * Obtains a list of styles that derive from the ParentStyle (i.e. have ParentStyle in their archetype chain)
	 *
	 * @param	ParentStyle		the style to search for archetype references to
	 * @param	DerivedStyles	[out] An array that will be filled with pointers to the derived styles
	 * @param	DeriveType		if DERIVETYPE_DirectOnly, only styles that have ParentStyle as the value for ObjectArchetype will added
	 *							out_DerivedStyles. if DERIVETYPE_All, any style that has ParentStyle anywhere in its archetype chain
	 *							will be added to the list.
	 * @param	SearchType		if SEARCH_SameSkinOnly, only styles contained by this skin will be considered.  if SEARCH_AnySkin, all loaded styles will be considered.
	 */
	void GetDerivedStyles( const UUIStyle* ParentStyle, TArray<UUIStyle*>& out_DerivedStyles, EDerivedType DeriveType, EStyleSearchType SearchType=SEARCH_AnySkin );

	/**
     * Checks if this Tag name is currently used in this Skin
     *
     * @param	Tag		checks if this tag exists in the skin
     */
    UBOOL IsUniqueTag( const FName & Tag);

	/* === UIDataStore interface === */

	/**
	 * Retrieves the tag used for referencing this data store.  Normally corresponds to Tag, but may be different for some special
	 * data stores.
	 *
	 * Always returns "Scenes" in case the skin's Tag is changed.
	 */
	virtual FName GetDataStoreID() const { return TEXT("Styles"); }

	/* === UIDataProvider interface === */
	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }

	/**
	 * Searches for the Style specified and if found changes the node modifier's
	 *
	 * @param	StyleName	the name of the style to apply - must match the StyleTag of a style in this skin (or a base skin).
	 * @param	StyleData	the style data to apply the changes to.
	 *
	 * @return	TRUE if a style was found with the specified StyleName, FALSE otherwise.
	 */
	virtual UBOOL ParseStringModifier( const FString& StyleName, struct FUIStringNodeModifier& StyleData );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		this data provider cannot generate string nodes, so the return value is always an empty string.
	 */
	virtual FString GenerateFillerData( const FString& DataTag ) { return TEXT(""); }

	/* === UObject interface === */
	/**
	 * I/O function
	 */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& Objects );

	/**
	 * Called when this object is loaded from an archive.  Fires a callback which notifies the UI editor that this skin
	 * should be re-initialized if it's the active skin.
	 */
	virtual void PostLoad();
};

class UUICustomSkin : public UUISkin
{
public:
    //## BEGIN PROPS UICustomSkin
    TMap< FWIDGET_ID,FSTYLE_ID > WidgetStyleMap;
    //## END PROPS UICustomSkin

    DECLARE_CLASS(UUICustomSkin,UUISkin,0,Engine)

	/**
	 * Deletes the specified style and replaces its entry in the lookup table with this skin's archetype style.
	 * This only works if the provided style's outer is this skin.
	 *
	 * This version of DeleteStyle goes through the WidgetStyleMap and changes any widgets bound to the style being deleted,
	 * to be bound to the archetype's style instead.
	 *
	 * @return	TRUE if the style was successfully removed.
	 */
	virtual UBOOL DeleteStyle( class UUIStyle* InStyle );

	/**
	 * Assigns the style specified to the widget and stores that mapping in the skin's persistent style list.
	 *
	 * @param	Widget		the widget to apply the style to.
	 * @param	StyleID		the STYLEID for the style that should be assigned to the widget
	 */
	void StoreWidgetStyleMapping( class UUIObject* Widget, const struct FSTYLE_ID& StyleID );
};

class UUIDynamicFieldProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDynamicFieldProvider
protected:
    TArrayNoInit<struct FUIProviderScriptFieldValue> PersistentDataFields;
    TArrayNoInit<struct FUIProviderScriptFieldValue> RuntimeDataFields;
    TMap< FName, TLookupMap<FString> > PersistentCollectionData;
    TMap< FName, TLookupMap<FString> > RuntimeCollectionData;
public:
    //## END PROPS UIDynamicFieldProvider

    virtual UBOOL RemoveField(FName FieldName);
    virtual INT FindFieldIndex(FName FieldName,UBOOL bSearchPersistentFields=FALSE) const;
    virtual UBOOL ClearFields(UBOOL bReinitializeRuntimeFields=TRUE);
    virtual void SavePersistentProviderData();
    virtual UBOOL SetCollectionValueArray(FName FieldName,const TArray<FString>& CollectionValues,UBOOL bClearExisting=TRUE,INT InsertIndex=-1,UBOOL bPersistent=FALSE);
    virtual UBOOL InsertCollectionValue(FName FieldName,const FString& NewValue,INT InsertIndex=-1,UBOOL bPersistent=FALSE,UBOOL bAllowDuplicateValues=FALSE);
    virtual UBOOL RemoveCollectionValue(FName FieldName,const FString& ValueToRemove,UBOOL bPersistent=FALSE);
    virtual UBOOL RemoveCollectionValueByIndex(FName FieldName,INT ValueIndex,UBOOL bPersistent=FALSE);
    virtual UBOOL ReplaceCollectionValue(FName FieldName,const FString& CurrentValue,const FString& NewValue,UBOOL bPersistent=FALSE);
    virtual UBOOL ReplaceCollectionValueByIndex(FName FieldName,INT ValueIndex,const FString& NewValue,UBOOL bPersistent=FALSE);
    virtual UBOOL ClearCollectionValueArray(FName FieldName,UBOOL bPersistent=FALSE);
    virtual UBOOL GetCollectionValue(FName FieldName,INT ValueIndex,FString& out_Value,UBOOL bPersistent=FALSE) const;
    virtual INT FindCollectionValueIndex(FName FieldName,const FString& ValueToFind,UBOOL bPersistent=FALSE) const;
    DECLARE_FUNCTION(execAddField);
    DECLARE_FUNCTION(execRemoveField)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(UBOOL*)Result=RemoveField(FieldName);
    }
    DECLARE_FUNCTION(execFindFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bSearchPersistentFields,FALSE);
        P_FINISH;
        *(INT*)Result=FindFieldIndex(FieldName,bSearchPersistentFields);
    }
    DECLARE_FUNCTION(execClearFields)
    {
        P_GET_UBOOL_OPTX(bReinitializeRuntimeFields,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ClearFields(bReinitializeRuntimeFields);
    }
    DECLARE_FUNCTION(execGetField);
    DECLARE_FUNCTION(execSetField);
    DECLARE_FUNCTION(execSavePersistentProviderData)
    {
        P_FINISH;
        SavePersistentProviderData();
    }
    DECLARE_FUNCTION(execGetCollectionValueArray);
    DECLARE_FUNCTION(execSetCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FString,CollectionValues);
        P_GET_UBOOL_OPTX(bClearExisting,TRUE);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetCollectionValueArray(FieldName,CollectionValues,bClearExisting,InsertIndex,bPersistent);
    }
    DECLARE_FUNCTION(execInsertCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(NewValue);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_UBOOL_OPTX(bAllowDuplicateValues,FALSE);
        P_FINISH;
        *(UBOOL*)Result=InsertCollectionValue(FieldName,NewValue,InsertIndex,bPersistent,bAllowDuplicateValues);
    }
    DECLARE_FUNCTION(execRemoveCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToRemove);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=RemoveCollectionValue(FieldName,ValueToRemove,bPersistent);
    }
    DECLARE_FUNCTION(execRemoveCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=RemoveCollectionValueByIndex(FieldName,ValueIndex,bPersistent);
    }
    DECLARE_FUNCTION(execReplaceCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(CurrentValue);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ReplaceCollectionValue(FieldName,CurrentValue,NewValue,bPersistent);
    }
    DECLARE_FUNCTION(execReplaceCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ReplaceCollectionValueByIndex(FieldName,ValueIndex,NewValue,bPersistent);
    }
    DECLARE_FUNCTION(execClearCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ClearCollectionValueArray(FieldName,bPersistent);
    }
    DECLARE_FUNCTION(execGetCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(out_Value);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=GetCollectionValue(FieldName,ValueIndex,out_Value,bPersistent);
    }
    DECLARE_FUNCTION(execFindCollectionValueIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToFind);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(INT*)Result=FindCollectionValueIndex(FieldName,ValueToFind,bPersistent);
    }
    DECLARE_CLASS(UUIDynamicFieldProvider,UUIDataProvider,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UIDynamicFieldProvider interface === */
	/**
	 * Copies the elements from the PersistentDataFields array into the RuntimeDataFields array.  Should only be called once when the provider
	 * is initialized.
	 */
	virtual void InitializeRuntimeFields();

	/**
	 * Adds a new data field to the list of supported fields.
	 *
	 * @param	FieldName			the name to give the new field
	 * @param	FieldType			the type of data field being added
	 * @param	bPersistent			specify TRUE to add the field to the PersistentDataFields array as well.
	 * @param	out_InsertPosition	allows the caller to find out where the element was inserted
	 *
	 * @return	TRUE if the field was successfully added to the list; FALSE if the a field with that name already existed
	 *			or the specified name was invalid.
	 */
	virtual UBOOL AddField( FName FieldName, BYTE FieldType=0, UBOOL bPersistent=FALSE, INT* out_InsertPosition=NULL );

	/**
	 * Gets the data value source array for the specified data field.
	 *
	 * @param	FieldName			the name of the data field the source data should be associated with.
	 * @param	out_DataValueArray	receives the array of data values available for FieldName.
	 * @param	bPersistent			specify TRUE to ensure that the PersistentCollectionData is used, even if it otherwise
	 *								wouldn't be.
	 *
	 * @return	TRUE if the array containing possible values for the FieldName data field was successfully located and copied
	 *			into the out_DataValueArray variable.
	 */
	virtual UBOOL GetCollectionValueArray( FName FieldName, TArray<FString>& out_DataValueArray, UBOOL bPersistent=FALSE );

	/* === UUIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UObject interface === */
	/**
	 * Serializes the value of the PersistentCollectionData and RuntimeCollectionData members, since they are not supported
	 * by script serialization.
	 */
	virtual void Serialize( FArchive& Ar );
};

struct UIPropertyDataProvider_eventGetCustomPropertyValue_Parms
{
    struct FUIProviderScriptFieldValue PropertyValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIPropertyDataProvider_eventGetCustomPropertyValue_Parms(EEventParm)
    : PropertyValue(EC_EventParm)
    {
    }
};
class UUIPropertyDataProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIPropertyDataProvider
    TArrayNoInit<class UClass*> ComplexPropertyTypes;
    //## END PROPS UIPropertyDataProvider

    UBOOL eventGetCustomPropertyValue(struct FUIProviderScriptFieldValue& PropertyValue,INT ArrayIndex=-1)
    {
        UIPropertyDataProvider_eventGetCustomPropertyValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PropertyValue=PropertyValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCustomPropertyValue),&Parms);
        PropertyValue=Parms.PropertyValue;
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIPropertyDataProvider,UUIDataProvider,0|CLASS_Transient,Engine)
	/* === UUIPropertyDataProvider interface === */
	/**
	 * Returns whether the specified property type is renderable in the UI.
	 *
	 * @return	TRUE if this property type is something that can be rendered in the UI.
	 */
	virtual UBOOL IsValidProperty( UProperty* Property ) const;

	/**
	 * Builds a list of UProperties that are flagged for exposure to data stores from the specified class.
	 *
	 * @param	SourceClass		a pointer to a UClass that contains properties which are marked with the "databinding" keyword.
	 *							Must be a child of the class assigned as the value for DataClass.
	 * @param	out_Properties	will contain pointers to the properties of SourceClass which can be exposed to the data store system.
	 */
	void GetProviderDataBindings( UClass* SourceClass, TArray<UProperty*>& out_Properties );

protected:
	/**
	 * Creates a UIStringNode_Text using the source and render text specified.
	 *
	 * @param	PropertyPathName	the path name for the property this text node will represent.  This value is set as the
	 *								source text for the text node.
	 * @param	RenderString		the text that should will be rendered by this text node.
	 *
	 * @return	a pointer to UIStringNode_Text which will render the string specified.
	 */
	FUIStringNode_Text* CreateTextNode( const FString& PropertyPathName, const TCHAR* RenderString ) const;

	/**
	 * Creates a UIStringNode_Text using the source and render text specified.
	 *
	 * @param	PropertyPathName	the path name for the property this image node will represent.  This value is set as the
	 *								source text for the image node.
	 * @param	RenderImage			the image that should be rendered by this image node.
	 *
	 * @return	a pointer to UIStringNode_Image which will render the image specified.
	 */
	FUIStringNode_Image* CreateImageNode( const FString& PropertyPathName, USurface* RenderImage ) const;
};

struct UIDynamicDataProvider_eventIsValidDataSourceClass_Parms
{
    class UClass* PotentialDataSourceClass;
    UBOOL ReturnValue;
    UIDynamicDataProvider_eventIsValidDataSourceClass_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceUnbound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceUnbound_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceBound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceBound_Parms(EEventParm)
    {
    }
};
class UUIDynamicDataProvider : public UUIPropertyDataProvider
{
public:
    //## BEGIN PROPS UIDynamicDataProvider
    class UClass* DataClass;
    class UObject* DataSource;
    //## END PROPS UIDynamicDataProvider

    UBOOL BindProviderInstance(class UObject* DataSourceInstance);
    UBOOL UnbindProviderInstance();
    DECLARE_FUNCTION(execBindProviderInstance)
    {
        P_GET_OBJECT(UObject,DataSourceInstance);
        P_FINISH;
        *(UBOOL*)Result=BindProviderInstance(DataSourceInstance);
    }
    DECLARE_FUNCTION(execUnbindProviderInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=UnbindProviderInstance();
    }
    UBOOL eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass)
    {
        UIDynamicDataProvider_eventIsValidDataSourceClass_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PotentialDataSourceClass=PotentialDataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidDataSourceClass),&Parms);
        return Parms.ReturnValue;
    }
    void eventProviderInstanceUnbound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceUnbound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceUnbound),&Parms);
    }
    void eventProviderInstanceBound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceBound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceBound),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDynamicDataProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
	/* === UUIDynamicDataProvider interface === */
	/**
	 * Determines whether the specified class should be represented by this dynamic data provider.
	 *
	 * @param	PotentialDataSourceClass	a pointer to a UClass that is being considered for binding by this provider.
	 *
	 * @return	TRUE to allow the databinding properties of PotentialDataSourceClass to be displayed in the UI editor's data store browser
	 *			under this data provider.
	 */
	UBOOL IsValidDataSourceClass( UClass* PotentialDataSourceClass );

	/**
	 * Builds an array of classes that are supported by this data provider.  Used in the editor to generate the list of
	 * supported data fields.  Since dynamic data providers are only created during the game, the editor needs a way to
	 * retrieve the list of data field tags that can be bound without requiring instances of this data provider's DataClass to exist.
	 *
	 * @note: only called in the editor!
	 */
	void GetSupportedClasses( TArray<UClass*>& out_Classes );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);
};

class UGameInfoDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS GameInfoDataProvider
    class AGameReplicationInfo* GameDataSource;
    //## END PROPS GameInfoDataProvider

    DECLARE_CLASS(UGameInfoDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UGameInfoDataProvider)
};

class UInventoryDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS InventoryDataProvider
    //## END PROPS InventoryDataProvider

    DECLARE_ABSTRACT_CLASS(UInventoryDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInventoryDataProvider)
};

class UPowerupDataProvider : public UInventoryDataProvider
{
public:
    //## BEGIN PROPS PowerupDataProvider
    //## END PROPS PowerupDataProvider

    DECLARE_CLASS(UPowerupDataProvider,UInventoryDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPowerupDataProvider)
};

class UWeaponDataProvider : public UInventoryDataProvider
{
public:
    //## BEGIN PROPS WeaponDataProvider
    //## END PROPS WeaponDataProvider

    DECLARE_CLASS(UWeaponDataProvider,UInventoryDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UWeaponDataProvider)
};

class UCurrentWeaponDataProvider : public UWeaponDataProvider
{
public:
    //## BEGIN PROPS CurrentWeaponDataProvider
    //## END PROPS CurrentWeaponDataProvider

    DECLARE_CLASS(UCurrentWeaponDataProvider,UWeaponDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCurrentWeaponDataProvider)
};

class UPickupDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS PickupDataProvider
    //## END PROPS PickupDataProvider

    DECLARE_CLASS(UPickupDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPickupDataProvider)
};

class UPlayerDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS PlayerDataProvider
    //## END PROPS PlayerDataProvider

    DECLARE_CLASS(UPlayerDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPlayerDataProvider)
};

class UPlayerOwnerDataProvider : public UPlayerDataProvider
{
public:
    //## BEGIN PROPS PlayerOwnerDataProvider
    class UPlayerDataProvider* PlayerData;
    //## END PROPS PlayerOwnerDataProvider

    DECLARE_CLASS(UPlayerOwnerDataProvider,UPlayerDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UTeamDataProvider : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS TeamDataProvider
    //## END PROPS TeamDataProvider

    DECLARE_CLASS(UTeamDataProvider,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UTeamDataProvider)
};

struct FSettingsArrayProvider
{
    INT SettingsId;
    FName SettingsName;
    class UUIDataProvider_SettingsArray* Provider;
};

class UUIDataProvider_Settings : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_Settings
    class USettings* Settings;
    TArrayNoInit<struct FSettingsArrayProvider> SettingsArrayProviders;
    BITFIELD bIsAListRow:1;
    //## END PROPS UIDataProvider_Settings

    DECLARE_CLASS(UUIDataProvider_Settings,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Generates filler data for a given tag. Uses the OnlineDataType to determine
	 * what the hardcoded filler data will look like
	 *
 	 * @param DataTag the tag to generate filler data for
 	 *
	 * @return a string containing example data
	 */
	virtual FString GenerateFillerData(const FString& DataTag);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

	/**
	 * Binds the new settings object to this provider. Sets the type to instance
	 *
	 * @param NewSettings the new object to bind
	 * @param bIsInList whether to use list handling or not
	 *
	 * @return TRUE if bound ok, FALSE otherwise
	 */
	UBOOL BindSettings(USettings* NewSettings,UBOOL bIsInList = FALSE);
};

struct UIResourceDataProvider_eventIsProviderDisabled_Parms
{
    UBOOL ReturnValue;
    UIResourceDataProvider_eventIsProviderDisabled_Parms(EEventParm)
    {
    }
};
class UUIResourceDataProvider : public UUIPropertyDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIResourceDataProvider
    //## END PROPS UIResourceDataProvider

    UBOOL eventIsProviderDisabled()
    {
        UIResourceDataProvider_eventIsProviderDisabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_IsProviderDisabled),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIResourceDataProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UUIResourceDataProvider interface === */

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUISettingsProvider : public UUIPropertyDataProvider
{
public:
    //## BEGIN PROPS UISettingsProvider
    FName ProviderTag;
    //## END PROPS UISettingsProvider

    DECLARE_ABSTRACT_CLASS(UUISettingsProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUISettingsProvider)
};

struct PlayerSettingsProvider_eventOnUnregister_Parms
{
    PlayerSettingsProvider_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct PlayerSettingsProvider_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    PlayerSettingsProvider_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UPlayerSettingsProvider : public UUISettingsProvider
{
public:
    //## BEGIN PROPS PlayerSettingsProvider
    //## END PROPS PlayerSettingsProvider

    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        PlayerSettingsProvider_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UPlayerSettingsProvider,UUISettingsProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIDataStore_PlayerSettings)
	/**
	 * Provides the data provider with the player they were just bound to
	 *
	 * @param Player the local player associated with this player settings provider
	 */
	virtual void OnRegister(ULocalPlayer* Player)
	{
		eventOnRegister(Player);
	}

	/**
	 * Tells the provider that the player is no longer valid
	 */
	virtual void OnUnregister(void)
	{
		eventOnUnregister();
	}
};

struct SessionSettingsProvider_eventIsValidDataSourceClass_Parms
{
    class UClass* PotentialDataSourceClass;
    UBOOL ReturnValue;
    SessionSettingsProvider_eventIsValidDataSourceClass_Parms(EEventParm)
    {
    }
};
struct SessionSettingsProvider_eventProviderClientUnbound_Parms
{
    class UClass* DataSourceClass;
    SessionSettingsProvider_eventProviderClientUnbound_Parms(EEventParm)
    {
    }
};
struct SessionSettingsProvider_eventProviderClientBound_Parms
{
    class UClass* DataSourceClass;
    SessionSettingsProvider_eventProviderClientBound_Parms(EEventParm)
    {
    }
};
class USessionSettingsProvider : public UUISettingsProvider
{
public:
    //## BEGIN PROPS SessionSettingsProvider
    class UClass* ProviderClientClass;
    class UClass* ProviderClientMetaClass;
    class UClass* ProviderClient;
    //## END PROPS SessionSettingsProvider

    UBOOL BindProviderClient(class UClass* DataSourceClass);
    UBOOL UnbindProviderClient();
    DECLARE_FUNCTION(execBindProviderClient)
    {
        P_GET_OBJECT(UClass,DataSourceClass);
        P_FINISH;
        *(UBOOL*)Result=BindProviderClient(DataSourceClass);
    }
    DECLARE_FUNCTION(execUnbindProviderClient)
    {
        P_FINISH;
        *(UBOOL*)Result=UnbindProviderClient();
    }
    UBOOL eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass)
    {
        SessionSettingsProvider_eventIsValidDataSourceClass_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PotentialDataSourceClass=PotentialDataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidDataSourceClass),&Parms);
        return Parms.ReturnValue;
    }
    void eventProviderClientUnbound(class UClass* DataSourceClass)
    {
        SessionSettingsProvider_eventProviderClientUnbound_Parms Parms(EC_EventParm);
        Parms.DataSourceClass=DataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderClientUnbound),&Parms);
    }
    void eventProviderClientBound(class UClass* DataSourceClass)
    {
        SessionSettingsProvider_eventProviderClientBound_Parms Parms(EC_EventParm);
        Parms.DataSourceClass=DataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderClientBound),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(USessionSettingsProvider,UUISettingsProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIDataStore_SessionSettings)
	/* === UUIDynamicDataProvider interface === */
	/**
	 * Determines whether the specified class should be represented by this settings data provider.
	 *
	 * @param	PotentialDataSourceClass	a pointer to a UClass that is being considered for binding by this provider.
	 *
	 * @return	TRUE to allow the databinding properties of PotentialDataSourceClass to be displayed in the UI editor's data store browser
	 *			under this data provider.
	 */
	UBOOL IsValidDataSourceClass( UClass* PotentialDataSourceClass );

	/**
	 * Builds an array of classes that are supported by this data provider.  Used in the editor to generate the list of
	 * supported data fields.  Since settings data providers are only created during the game, the editor needs a way to
	 * retrieve the list of data field tags that can be bound without requiring instances of this data provider's DataClass to exist.
	 *
	 * @note: only called in the editor!
	 */
	void GetSupportedClasses( TArray<UClass*>& out_Classes );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct GameUISceneClient_eventCanShowToolTips_Parms
{
    UBOOL ReturnValue;
    GameUISceneClient_eventCanShowToolTips_Parms(EEventParm)
    {
    }
};
struct GameUISceneClient_eventConditionalPause_Parms
{
    UBOOL bDesiredPauseState;
    GameUISceneClient_eventConditionalPause_Parms(EEventParm)
    {
    }
};
class UGameUISceneClient : public UUISceneClient
{
public:
    //## BEGIN PROPS GameUISceneClient
    TArrayNoInit<class UUIScene*> ActiveScenes;
    class UUITexture* CurrentMouseCursor;
    BITFIELD bRenderCursor:1;
    BITFIELD bUpdateInputProcessingStatus:1;
    BITFIELD bUpdateCursorRenderStatus:1;
    FLOAT LatestDeltaTime;
    FLOAT DoubleClickStartTime;
    FIntPoint DoubleClickStartPosition;
    class UTexture* DefaultUITexture[3];
    BITFIELD bRenderDebugInfo:1;
    TMap<INT,TArray<FName> > InitialPressedKeys;
    TArrayNoInit<class UUIAnimationSeq*> AnimSequencePool;
    TArrayNoInit<class UUIObject*> AnimSubscribers;
    //## END PROPS GameUISceneClient

    class UUIScene* GetTransientScene() const;
    class UUIObject* CreateTransientWidget(class UClass* WidgetClass,FName WidgetTag,class UUIObject* Owner=NULL);
    class UUIScene* FindSceneByTag(FName SceneTag,class ULocalPlayer* SceneOwner=NULL) const;
    void RequestInputProcessingUpdate();
    void RequestCursorRenderUpdate();
    UBOOL CanUnpauseInternalUI();
    virtual UBOOL SetActiveControl(class UUIObject* NewActiveControl);
    DECLARE_FUNCTION(execGetTransientScene)
    {
        P_FINISH;
        *(class UUIScene**)Result=GetTransientScene();
    }
    DECLARE_FUNCTION(execCreateScene);
    DECLARE_FUNCTION(execCreateTransientWidget)
    {
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_NAME(WidgetTag);
        P_GET_OBJECT_OPTX(UUIObject,Owner,NULL);
        P_FINISH;
        *(class UUIObject**)Result=CreateTransientWidget(WidgetClass,WidgetTag,Owner);
    }
    DECLARE_FUNCTION(execFindSceneByTag)
    {
        P_GET_NAME(SceneTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,SceneOwner,NULL);
        P_FINISH;
        *(class UUIScene**)Result=FindSceneByTag(SceneTag,SceneOwner);
    }
    DECLARE_FUNCTION(execRequestInputProcessingUpdate)
    {
        P_FINISH;
        RequestInputProcessingUpdate();
    }
    DECLARE_FUNCTION(execRequestCursorRenderUpdate)
    {
        P_FINISH;
        RequestCursorRenderUpdate();
    }
    DECLARE_FUNCTION(execCanUnpauseInternalUI)
    {
        P_FINISH;
        *(UBOOL*)Result=CanUnpauseInternalUI();
    }
    DECLARE_FUNCTION(execSetActiveControl)
    {
        P_GET_OBJECT(UUIObject,NewActiveControl);
        P_FINISH;
        *(UBOOL*)Result=SetActiveControl(NewActiveControl);
    }
    UBOOL eventCanShowToolTips()
    {
        GameUISceneClient_eventCanShowToolTips_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_CanShowToolTips),&Parms);
        return Parms.ReturnValue;
    }
    void eventConditionalPause(UBOOL bDesiredPauseState)
    {
        GameUISceneClient_eventConditionalPause_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ConditionalPause),&Parms);
    }
    DECLARE_CLASS(UGameUISceneClient,UUISceneClient,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIInteraction)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* === FCallbackEventDevice interface === */
	/**
	 * Called when the viewport has been resized.
	 */
	virtual void Send( ECallbackEventType InType, class FViewport* InViewport, UINT InMessage);

	/* =======================================
		UUISceneClient interface
	======================================= */
	/**
	 * Performs any initialization for the UISceneClient.
	 *
	 * @param	InitialSkin		UISkin that should be set to the initial ActiveSkin
	 */
	virtual void InitializeClient( UUISkin* InitialSkin );

	/**
	 * Changes the active skin to the skin specified, initializes the skin and performs all necessary cleanup and callbacks.
	 * This method should only be called from script.
	 *
	 * @param	NewActiveScene	The skin to activate
	 *
	 * @return	TRUE if the skin was successfully changed.
	 */
	virtual UBOOL ChangeActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin.
	 */
	virtual void OnActiveSkinChanged();

	/**
	 * Assigns the viewport that scenes will use for rendering.
	 *
	 * @param	inViewport	the viewport to use for rendering scenes
	 */
	virtual void SetRenderViewport( FViewport* SceneViewport );

	/**
	 * Retrieves the point of origin for the viewport for the scene specified.  This should always be 0,0 during the game,
	 * but may be different in the UI editor if the editor window is configured to have a gutter around the viewport.
	 *
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the starting point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin );

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen();

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UGameUISceneClient interface
	======================================= */
	/**
	 * Creates the scene that will be used to contain transient widgets that are created in unrealscript
	 */
	void CreateTransientScene();

	/**
	 * Creates a new instance of the scene class specified.
	 *
	 * @param	SceneTemplate	the template to use for the new scene
	 * @param	InOuter			the outer for the scene
	 * @param	SceneTag		if specified, the scene will be given this tag when created
	 *
	 * @return	a UIScene instance of the class specified
	 */
	 UUIScene* CreateScene( UUIScene* SceneTemplate, UObject* InOuter, FName SceneTag = NAME_None );

	/**
	 * Determines which widget is currently under the mouse cursor by performing hit tests against bounding regions.
	 */
	void UpdateActiveControl();

	/**
	 * Resets the time and mouse position values used for simulating double-click events to the current value or invalid values.
	 */
	void ResetDoubleClickTracking( UBOOL bClearValues );

	/**
	 * Checks the current time and mouse position to determine whether a double-click event should be simulated.
	 */
	UBOOL ShouldSimulateDoubleClick() const;

	/**
	 * Set the mouse position to the coordinates specified
	 *
	 * @param	NewX	the X position to move the mouse cursor to (in pixels)
	 * @param	NewY	the Y position to move the mouse cursor to (in pixels)
	 */
	virtual void SetMousePosition( INT NewMouseX, INT NewMouseY );

	/**
	 * Sets the values of MouseX & MouseY to the current position of the mouse
	 */
	virtual void UpdateMousePosition();

	/**
	 * Gets the size (in pixels) of the mouse cursor current in use.
	 *
	 * @return	TRUE if MouseXL/YL were filled in; FALSE if there is no mouse cursor or if the UI is configured to not render a mouse cursor.
	 */
	virtual UBOOL GetCursorSize( FLOAT& MouseXL, FLOAT& MouseYL );

	/**
	 * Called whenever a scene is added or removed from the list of active scenes.  Calls any functions that handle updating the
	 * status of various tracking variables, such as whether the UI is currently capable of processing input.
	 */
	virtual void SceneStackModified();

	/**
	 * Changes the resource that is currently being used as the mouse cursor.  Called by widgets as they changes states which
	 * affect the mouse cursor
	 *
	 * @param	CursorName	the name of the mouse cursor resource to use.  Should correspond to a name from the active UISkin's
	 *						MouseCursorMap
	 *
	 * @return	TRUE if the cursor was successfully changed.  FALSE if the cursor name was invalid or wasn't found in the current
	 *			skin's MouseCursorMap
	 */
	virtual UBOOL ChangeMouseCursor( FName CursorName );

	/**
	 * Adds the specified scene to the list of active scenes, loading the scene and performing initialization as necessary.
	 *
	 * @param	Scene			the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *							and the copy will be opened instead.
	 * @param	SceneOwner		the player that should be associated with the new scene.  Will be assigned to the scene's
	 *							PlayerOwner property.
	 * @param	OpenedScene		the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *							the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL );

	/**
	 * Removes the specified scene from the ActiveScenes array.
	 *
	 * @param	Scene	the scene to deactivate
	 *
	 * @return true if the scene was successfully removed from the ActiveScenes array
	 */
	virtual UBOOL CloseScene( UUIScene* Scene );

	/**
	 * Called once a frame to update the UI's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Render all the active scenes
	 */
	virtual void RenderScenes( FCanvas* Canvas );

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( class UUIScene* Sender );

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=0 ) const;

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const class UUIScene* Scene ) const;

protected:

	/**
	 * Gets the list of scenes that should be rendered.  Some active scenes might not be rendered if scenes later in the
	 * scene stack prevent it, for example.
	 */
	void GetScenesToRender( TArray<UUIScene*>& ScenesToRender );

	/**
	 * Adds the specified scene to the list of active scenes.
	 *
	 * @param	SceneToActivate		the scene to activate
	 */
	virtual void ActivateScene( UUIScene* SceneToActivate );

	/**
	 * Removes the specified scene from the list of active scenes.  If this scene is not the top-most scene, all
	 * scenes which occur after the specified scene in the ActiveScenes array will be deactivated as well.
	 *
	 * @param	SceneToDeactivate	the scene to remove
	 *
	 * @return	TRUE if the scene was successfully removed from the list of active scenes.
	 */
	virtual UBOOL DeactivateScene( UUIScene* SceneToDeactivate );

	/**
	 * Searches all scenes to determine if any are configured to display a cursor.  Sets the value of bRenderCursor accordingly.
	 */
	virtual void UpdateCursorRenderStatus();

	/**
	 * Updates the value of UIInteraction.bProcessingInput to reflect whether any scenes are capable of processing input.
	 */
	void UpdateInputProcessingStatus();

	/**
	 * Ensures that the game's paused state is appropriate considering the state of the UI.  If any scenes are active which require
	 * the game to be paused, pauses the game...otherwise, unpauses the game.
	 */
	virtual void UpdatePausedState();

	/**
	 * Clears the arrays of pressed keys for all local players in the game; used when the UI begins processing input.  Also
	 * updates the InitialPressedKeys maps for all players.
	 */
	void FlushPlayerInput();

	/**
	 * Renders debug information to the screen canvas.
	 */
	virtual void RenderDebugInfo( FCanvas* Canvas );

public:
};

struct UIScreenObject_eventGetSupportedUIActionKeyNames_Parms
{
    TArray<FName> out_KeyNames;
    UIScreenObject_eventGetSupportedUIActionKeyNames_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventSetInputMask_Parms
{
    BYTE NewInputMask;
    UBOOL bRecurse;
    UIScreenObject_eventSetInputMask_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventDisablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventDisablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventEnablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventEnablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventSetVisibility_Parms
{
    UBOOL bIsVisible;
    UIScreenObject_eventSetVisibility_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedFromParent_Parms
{
    class UUIScreenObject* WidgetOwner;
    UIScreenObject_eventRemovedFromParent_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* OldChild;
    TArray<class UUIObject*> ExclusionSet;
    UIScreenObject_eventRemovedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventAddedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* NewChild;
    UIScreenObject_eventAddedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventPostInitialize_Parms
{
    UIScreenObject_eventPostInitialize_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventInitialized_Parms
{
    UIScreenObject_eventInitialized_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyVisibilityChanged_Parms
{
    class UUIScreenObject* SourceWidget;
    UBOOL bIsVisible;
    UIScreenObject_eventNotifyVisibilityChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyActiveStateChanged_Parms
{
    class UUIScreenObject* Sender;
    INT PlayerIndex;
    class UUIState* NewlyActiveState;
    class UUIState* PreviouslyActiveState;
    UIScreenObject_eventNotifyActiveStateChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyResolutionChanged_Parms
{
    FVector2D OldViewportsize;
    FVector2D NewViewportSize;
    UIScreenObject_eventNotifyResolutionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyPositionChanged_Parms
{
    class UUIScreenObject* Sender;
    UIScreenObject_eventNotifyPositionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputAxis_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputKey_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputAxis_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputKey_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyActiveSkinChanged_Parms
{
    UIScreenObject_eventNotifyActiveSkinChanged_Parms(EEventParm)
    {
    }
};
class UUIScreenObject : public UUIRoot
{
public:
    //## BEGIN PROPS UIScreenObject
    struct FUIScreenValue_Bounds Position;
    FLOAT ZDepth;
private:
    BITFIELD bHidden:1;
public:
    BITFIELD bSupports3DPrimitives:1;
    BITFIELD bInitialized:1;
    TArrayNoInit<class UUIObject*> Children;
    TArrayNoInit<class UClass*> DefaultStates;
    class UClass* InitialState;
    TArrayNoInit<class UUIState*> InactiveStates;
    TArrayNoInit<class UUIState*> StateStack;
    TArrayNoInit<struct FPlayerInteractionData> FocusControls;
    TArrayNoInit<struct FUIFocusPropagationData> FocusPropagation;
    BYTE PlayerInputMask;
    FLOAT Opacity;
    class UUIComp_Event* EventProvider;
    FName FocusedCue;
    FName MouseEnterCue;
    FName NavigateUpCue;
    FName NavigateDownCue;
    FName NavigateLeftCue;
    FName NavigateRightCue;
    FScriptDelegate __NotifyActiveSkinChanged__Delegate;
    FScriptDelegate __OnRawInputKey__Delegate;
    FScriptDelegate __OnRawInputAxis__Delegate;
    FScriptDelegate __OnProcessInputKey__Delegate;
    FScriptDelegate __OnProcessInputAxis__Delegate;
    FScriptDelegate __NotifyPositionChanged__Delegate;
    FScriptDelegate __NotifyResolutionChanged__Delegate;
    FScriptDelegate __NotifyActiveStateChanged__Delegate;
    FScriptDelegate __NotifyVisibilityChanged__Delegate;
    //## END PROPS UIScreenObject

    virtual void CreatePlayerData(INT PlayerIndex,class ULocalPlayer* AddedPlayer);
    virtual void RemovePlayerData(INT PlayerIndex,class ULocalPlayer* RemovedPlayer);
    virtual void InitializePlayerTracking();
    class ULocalPlayer* GetPlayerOwner(INT PlayerIndex=-1);
    class UUIObject* CreateWidget(class UUIScreenObject* Owner,class UClass* WidgetClass,class UObject* WidgetArchetype=NULL,FName WidgetName=NAME_None);
    virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
    TArray<class UUIObject*> RemoveChildren(const TArray<class UUIObject*>& ChildrenToRemove);
    UBOOL ReplaceChild(class UUIObject* ExistingChild,class UUIObject* NewChild);
    class UUIObject* FindChild(FName WidgetName,UBOOL bRecurse=FALSE) const;
    class UUIObject* FindChildUsingID(struct FWIDGET_ID WidgetID,UBOOL bRecurse=FALSE) const;
    INT FindChildIndex(FName WidgetName) const;
    UBOOL ContainsChild(class UUIObject* Child,UBOOL bRecurse=TRUE) const;
    UBOOL ContainsChildOfClass(class UClass* SearchClass,UBOOL bRecurse=TRUE) const;
    INT GetObjectCount() const;
    virtual void RebuildNavigationLinks();
    UBOOL GetViewportOffset(FVector2D& out_ViewportOffset) const;
    FLOAT GetViewportScale() const;
    UBOOL GetViewportOrigin(FVector2D& out_ViewportOrigin) const;
    UBOOL GetViewportSize(FVector2D& out_ViewportSize) const;
    void FindEventsOfClass(class UClass* EventClassToFind,TArray<class UUIEvent*>& out_EventInstances,class UUIState* LimitScope=NULL,UBOOL bExactClass=FALSE);
    virtual UBOOL SetEnabled(UBOOL bEnabled,INT PlayerIndex=0);
    class UUIState* GetCurrentState(INT PlayerIndex=-1);
    virtual UBOOL ActivateState(class UUIState* StateToActivate,INT PlayerIndex);
    virtual UBOOL DeactivateState(class UUIState* StateToRemove,INT PlayerIndex);
    virtual UBOOL IsHoldingCtrl(INT ControllerId);
    virtual UBOOL IsHoldingAlt(INT ControllerId);
    virtual UBOOL IsHoldingShift(INT ControllerId);
    virtual UBOOL FocusFirstControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL FocusLastControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NextControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL PrevControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NavigateFocus(class UUIScreenObject* Sender,BYTE Direction,INT PlayerIndex=0);
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL CanPropagateFocusFor(class UUIObject* TestChild) const;
    virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL SetFocusToChild(class UUIObject* ChildToFocus=NULL,INT PlayerIndex=0);
    virtual UBOOL KillFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    class UUIObject* GetFocusedControl(UBOOL bRecurse=FALSE,INT PlayerIndex=0) const;
    class UUIObject* GetLastFocusedControl(UBOOL bRecurse=FALSE,INT PlayerIndex=0) const;
    UBOOL AcceptsPlayerInput(INT PlayerIndex) const;
    INT GetSupportedPlayerCount();
    INT GetBestPlayerIndex() const;
    void SetPosition(FLOAT NewValue,BYTE Face,BYTE InputType=3,UBOOL bZeroOrigin=FALSE);
    FLOAT GetPosition(BYTE Face,BYTE OutputType=0,UBOOL bZeroOrigin=FALSE,UBOOL bIgnoreDockPadding=FALSE) const;
    FLOAT GetBounds(BYTE Dimension,BYTE OutputType=0,UBOOL bIgnoreDockPadding=FALSE) const;
    FVector GetPositionVector(UBOOL bIncludeParentPosition=TRUE) const;
    void GetDockedWidgets(TArray<class UUIObject*>& out_DockedWidgets,BYTE SourceFace=4,BYTE TargetFace=4) const;
    FVector Project(const FVector& CanvasPosition) const;
    FVector DeProject(const FVector& PixelPosition) const;
    FVector4 CanvasToScreen(const FVector& CanvasPosition) const;
    FVector2D ScreenToPixel(const FVector4& ScreenPosition) const;
    FVector4 PixelToScreen(const FVector2D& PixelPosition) const;
    FVector ScreenToCanvas(const FVector4& ScreenPosition) const;
    FVector PixelToCanvas(const FVector2D& PixelPosition) const;
    FMatrix GetCanvasToScreen() const;
    FMatrix GetInverseCanvasToScreen() const;
    DECLARE_FUNCTION(execIsInitialized);
    DECLARE_FUNCTION(execCreatePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,AddedPlayer);
        P_FINISH;
        CreatePlayerData(PlayerIndex,AddedPlayer);
    }
    DECLARE_FUNCTION(execRemovePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,RemovedPlayer);
        P_FINISH;
        RemovePlayerData(PlayerIndex,RemovedPlayer);
    }
    DECLARE_FUNCTION(execInitializePlayerTracking)
    {
        P_FINISH;
        InitializePlayerTracking();
    }
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execPlayUISound);
    DECLARE_FUNCTION(execCreateWidget)
    {
        P_GET_OBJECT(UUIScreenObject,Owner);
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_OBJECT_OPTX(UObject,WidgetArchetype,NULL);
        P_GET_NAME_OPTX(WidgetName,NAME_None);
        P_FINISH;
        *(class UUIObject**)Result=CreateWidget(Owner,WidgetClass,WidgetArchetype,WidgetName);
    }
    DECLARE_FUNCTION(execInsertChild)
    {
        P_GET_OBJECT(UUIObject,NewChild);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bRenameExisting,TRUE);
        P_FINISH;
        *(INT*)Result=InsertChild(NewChild,InsertIndex,bRenameExisting);
    }
    DECLARE_FUNCTION(execRemoveChild);
    DECLARE_FUNCTION(execRemoveChildren)
    {
        P_GET_TARRAY(class UUIObject*,ChildrenToRemove);
        P_FINISH;
        *(TArray<class UUIObject*>*)Result=RemoveChildren(ChildrenToRemove);
    }
    DECLARE_FUNCTION(execReplaceChild)
    {
        P_GET_OBJECT(UUIObject,ExistingChild);
        P_GET_OBJECT(UUIObject,NewChild);
        P_FINISH;
        *(UBOOL*)Result=ReplaceChild(ExistingChild,NewChild);
    }
    DECLARE_FUNCTION(execFindChild)
    {
        P_GET_NAME(WidgetName);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(class UUIObject**)Result=FindChild(WidgetName,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildUsingID)
    {
        P_GET_STRUCT(struct FWIDGET_ID,WidgetID);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        *(class UUIObject**)Result=FindChildUsingID(WidgetID,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildIndex)
    {
        P_GET_NAME(WidgetName);
        P_FINISH;
        *(INT*)Result=FindChildIndex(WidgetName);
    }
    DECLARE_FUNCTION(execContainsChild)
    {
        P_GET_OBJECT(UUIObject,Child);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChild(Child,bRecurse);
    }
    DECLARE_FUNCTION(execContainsChildOfClass)
    {
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChildOfClass(SearchClass,bRecurse);
    }
    DECLARE_FUNCTION(execGetChildren);
    DECLARE_FUNCTION(execGetObjectCount)
    {
        P_FINISH;
        *(INT*)Result=GetObjectCount();
    }
    DECLARE_FUNCTION(execRequestSceneUpdate);
    DECLARE_FUNCTION(execRequestFormattingUpdate);
    DECLARE_FUNCTION(execRequestPrimitiveReview);
    DECLARE_FUNCTION(execRebuildNavigationLinks)
    {
        P_FINISH;
        RebuildNavigationLinks();
    }
    DECLARE_FUNCTION(execGetViewportOffset)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOffset);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOffset(out_ViewportOffset);
    }
    DECLARE_FUNCTION(execGetViewportScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetViewportScale();
    }
    DECLARE_FUNCTION(execGetViewportOrigin)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOrigin);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOrigin(out_ViewportOrigin);
    }
    DECLARE_FUNCTION(execGetViewportSize)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportSize);
        P_FINISH;
        *(UBOOL*)Result=GetViewportSize(out_ViewportSize);
    }
    DECLARE_FUNCTION(execActivateEventByClass);
    DECLARE_FUNCTION(execFindEventsOfClass)
    {
        P_GET_OBJECT(UClass,EventClassToFind);
        P_GET_TARRAY_REF(class UUIEvent*,out_EventInstances);
        P_GET_OBJECT_OPTX(UUIState,LimitScope,NULL);
        P_GET_UBOOL_OPTX(bExactClass,FALSE);
        P_FINISH;
        FindEventsOfClass(EventClassToFind,out_EventInstances,LimitScope,bExactClass);
    }
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bEnabled);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetEnabled(bEnabled,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetCurrentState)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class UUIState**)Result=GetCurrentState(PlayerIndex);
    }
    DECLARE_FUNCTION(execHasActiveStateOfClass);
    DECLARE_FUNCTION(execActivateState)
    {
        P_GET_OBJECT(UUIState,StateToActivate);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=ActivateState(StateToActivate,PlayerIndex);
    }
    DECLARE_FUNCTION(execActivateStateByClass);
    DECLARE_FUNCTION(execDeactivateState)
    {
        P_GET_OBJECT(UUIState,StateToRemove);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=DeactivateState(StateToRemove,PlayerIndex);
    }
    DECLARE_FUNCTION(execDeactivateStateByClass);
    DECLARE_FUNCTION(execIsHoldingCtrl)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingCtrl(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingAlt)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingAlt(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingShift)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingShift(ControllerId);
    }
    DECLARE_FUNCTION(execFocusFirstControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusFirstControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execFocusLastControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusLastControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNextControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=NextControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execPrevControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=PrevControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNavigateFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_BYTE(Direction);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=NavigateFocus(Sender,Direction,PlayerIndex);
    }
    DECLARE_FUNCTION(execCanAcceptFocus)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=CanAcceptFocus(PlayerIndex);
    }
    DECLARE_FUNCTION(execCanPropagateFocusFor)
    {
        P_GET_OBJECT(UUIObject,TestChild);
        P_FINISH;
        *(UBOOL*)Result=CanPropagateFocusFor(TestChild);
    }
    DECLARE_FUNCTION(execSetFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execSetFocusToChild)
    {
        P_GET_OBJECT_OPTX(UUIObject,ChildToFocus,NULL);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocusToChild(ChildToFocus,PlayerIndex);
    }
    DECLARE_FUNCTION(execKillFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=KillFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetLastFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetLastFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execIsEnabled);
    DECLARE_FUNCTION(execIsFocused);
    DECLARE_FUNCTION(execIsActive);
    DECLARE_FUNCTION(execIsPressed);
    DECLARE_FUNCTION(execAcceptsPlayerInput)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=AcceptsPlayerInput(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetActivePlayerCount);
    DECLARE_FUNCTION(execGetSupportedPlayerCount)
    {
        P_FINISH;
        *(INT*)Result=GetSupportedPlayerCount();
    }
    DECLARE_FUNCTION(execGetBestPlayerIndex)
    {
        P_FINISH;
        *(INT*)Result=GetBestPlayerIndex();
    }
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewValue);
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(InputType,3);
        P_GET_UBOOL_OPTX(bZeroOrigin,FALSE);
        P_FINISH;
        SetPosition(NewValue,Face,InputType,bZeroOrigin);
    }
    DECLARE_FUNCTION(execGetPosition)
    {
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(OutputType,0);
        P_GET_UBOOL_OPTX(bZeroOrigin,FALSE);
        P_GET_UBOOL_OPTX(bIgnoreDockPadding,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetPosition(Face,OutputType,bZeroOrigin,bIgnoreDockPadding);
    }
    DECLARE_FUNCTION(execGetBounds)
    {
        P_GET_BYTE(Dimension);
        P_GET_BYTE_OPTX(OutputType,0);
        P_GET_UBOOL_OPTX(bIgnoreDockPadding,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetBounds(Dimension,OutputType,bIgnoreDockPadding);
    }
    DECLARE_FUNCTION(execGetPositionVector)
    {
        P_GET_UBOOL_OPTX(bIncludeParentPosition,TRUE);
        P_FINISH;
        *(FVector*)Result=GetPositionVector(bIncludeParentPosition);
    }
    DECLARE_FUNCTION(execGetDockedWidgets)
    {
        P_GET_TARRAY_REF(class UUIObject*,out_DockedWidgets);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        GetDockedWidgets(out_DockedWidgets,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execProject)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector*)Result=Project(CanvasPosition);
    }
    DECLARE_FUNCTION(execDeProject)
    {
        P_GET_STRUCT_REF(FVector,PixelPosition);
        P_FINISH;
        *(FVector*)Result=DeProject(PixelPosition);
    }
    DECLARE_FUNCTION(execCanvasToScreen)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector4*)Result=CanvasToScreen(CanvasPosition);
    }
    DECLARE_FUNCTION(execScreenToPixel)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector2D*)Result=ScreenToPixel(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToScreen)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector4*)Result=PixelToScreen(PixelPosition);
    }
    DECLARE_FUNCTION(execScreenToCanvas)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector*)Result=ScreenToCanvas(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToCanvas)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector*)Result=PixelToCanvas(PixelPosition);
    }
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetWidgetPathName);
    void eventGetSupportedUIActionKeyNames(TArray<FName>& out_KeyNames)
    {
        UIScreenObject_eventGetSupportedUIActionKeyNames_Parms Parms(EC_EventParm);
        Parms.out_KeyNames=out_KeyNames;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedUIActionKeyNames),&Parms);
        out_KeyNames=Parms.out_KeyNames;
    }
    void eventSetInputMask(BYTE NewInputMask,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventSetInputMask_Parms Parms(EC_EventParm);
        Parms.NewInputMask=NewInputMask;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetInputMask),&Parms);
    }
    void eventDisablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventDisablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DisablePlayerInput),&Parms);
    }
    void eventEnablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventEnablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnablePlayerInput),&Parms);
    }
    void eventSetVisibility(UBOOL bIsVisible)
    {
        UIScreenObject_eventSetVisibility_Parms Parms(EC_EventParm);
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetVisibility),&Parms);
    }
    void eventRemovedFromParent(class UUIScreenObject* WidgetOwner)
    {
        UIScreenObject_eventRemovedFromParent_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedFromParent),&Parms);
    }
    void eventRemovedChild(class UUIScreenObject* WidgetOwner,class UUIObject* OldChild,const TArray<class UUIObject*>& ExclusionSet=TArray<class UUIObject*>())
    {
        UIScreenObject_eventRemovedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.OldChild=OldChild;
        Parms.ExclusionSet=ExclusionSet;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedChild),&Parms);
    }
    void eventAddedChild(class UUIScreenObject* WidgetOwner,class UUIObject* NewChild)
    {
        UIScreenObject_eventAddedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.NewChild=NewChild;
        ProcessEvent(FindFunctionChecked(ENGINE_AddedChild),&Parms);
    }
    void eventPostInitialize()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostInitialize),NULL);
    }
    void eventInitialized()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Initialized),NULL);
    }
    void delegateNotifyVisibilityChanged(class UUIScreenObject* SourceWidget,UBOOL bIsVisible)
    {
        UIScreenObject_eventNotifyVisibilityChanged_Parms Parms(EC_EventParm);
        Parms.SourceWidget=SourceWidget;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_NotifyVisibilityChanged,&__NotifyVisibilityChanged__Delegate,&Parms);
    }
    void delegateNotifyActiveStateChanged(class UUIScreenObject* Sender,INT PlayerIndex,class UUIState* NewlyActiveState,class UUIState* PreviouslyActiveState=NULL)
    {
        UIScreenObject_eventNotifyActiveStateChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        Parms.NewlyActiveState=NewlyActiveState;
        Parms.PreviouslyActiveState=PreviouslyActiveState;
        ProcessDelegate(ENGINE_NotifyActiveStateChanged,&__NotifyActiveStateChanged__Delegate,&Parms);
    }
    void delegateNotifyResolutionChanged(const FVector2D& OldViewportsize,const FVector2D& NewViewportSize)
    {
        UIScreenObject_eventNotifyResolutionChanged_Parms Parms(EC_EventParm);
        Parms.OldViewportsize=OldViewportsize;
        Parms.NewViewportSize=NewViewportSize;
        ProcessDelegate(ENGINE_NotifyResolutionChanged,&__NotifyResolutionChanged__Delegate,&Parms);
    }
    void delegateNotifyPositionChanged(class UUIScreenObject* Sender)
    {
        UIScreenObject_eventNotifyPositionChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_NotifyPositionChanged,&__NotifyPositionChanged__Delegate,&Parms);
    }
    UBOOL delegateOnProcessInputAxis(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputAxis,&__OnProcessInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnProcessInputKey(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputKey,&__OnProcessInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputAxis(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputAxis,&__OnRawInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputKey(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputKey,&__OnRawInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateNotifyActiveSkinChanged()
    {
        ProcessDelegate(ENGINE_NotifyActiveSkinChanged,&__NotifyActiveSkinChanged__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIScreenObject,UUIRoot,0,Engine)
	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const { return NULL; }

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const PURE_VIRTUAL(UUIScreenObject::GetOwner,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual UUIScene* GetScene() PURE_VIRTUAL(UUIScreenObject::GetScene,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual const UUIScene* GetScene() const PURE_VIRTUAL(const UUIScreenObject::GetScene,return NULL;);

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const PURE_VIRTUAL(UUIScreenObject::GetTag,return NAME_None;);

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const PURE_VIRTUAL(UUIScreenObject::GetWidgetPathName,return TEXT(""););

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/**
	 * Returns whether this screen object has been initialized
	 */
	UBOOL IsInitialized() const		{ return bInitialized; }

	/**
	 * Determines whether to change the Outer of this widget if the widget's Owner doesn't match it's Outer.
	 */
	virtual UBOOL RequiresParentForOuter() const { return TRUE; }

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged			if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE ) {}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate() PURE_VIRTUAL(UUIScreenObject::RequestFormattingUpdate,);

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage ) PURE_VIRTUAL(UUIScreenObject::RequestPrimitiveReview,);

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene() PURE_VIRTUAL(UUIScreenObject::UpdateScene,)

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Iterates through the DefaultStates array checking that InactiveStates contains at least one instance of each
	 * DefaultState.  If no instances are found, one is created and added to the InactiveStates array.
	 */
	virtual void CreateDefaultStates();

	/**
	 * Checks that this screen object has an InitialState and contains a UIState_Enabled (or child class) in its
	 * InactiveStates array.  If any of the required states are missing, creates them.
	 */
	virtual void ValidateRequiredStates();

	/**
	 * Returns only those states [from the InactiveStates array] which were instanced from an entry in the DefaultStates array.
	 */
	virtual void GetInstancedStates( TMap<UClass*,UUIState*>& out_Instances );

	/**
	 * Creates a new UIState instance based on the specified template and adds the new state to this widget's list of
	 * InactiveStates.
	 *
	 * @param	StateTemplate	the state to use as the template for the new state
	 */
	virtual void AddSupportedState( UUIState* StateTemplate );

	/**
	 * Activates the configured initial state for this widget.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player to activate this initial state for
	 */
	void ActivateInitialState( INT PlayerIndex );

	/**
	 * Determine whether there are any active states of the specified class
	 *
	 * @param	StateClass	the class to search for
	 * @param	PlayerIndex	the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 *
	 * @return	TRUE if there is at least one active state of the class specified
	 */
	UBOOL HasActiveStateOfClass( UClass* StateClass, INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Alternate version of ActivateState that activates the first state in the InactiveStates array with the specified class
	 * that isn't already in the StateStack
	 */
	UBOOL ActivateStateByClass(class UClass* StateToActivate,INT PlayerIndex,class UUIState** StateThatWasAdded=NULL);

	/**
	 * Returns TRUE if this widget has a UIState_Enabled object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsEnabled( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Focused object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsFocused( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Active object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsActive( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Pressed object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsPressed( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Changes the specified preview state on the screen object's StateStack.
	 *
	 * @param	StateToActivate		the new preview state
	 *
	 * @return	TRUE if the state was successfully changed to the new preview state.  FALSE if couldn't change
	 *			to the new state or the specified state already exists in the screen object's list of active states
	 */
	virtual UBOOL ActivatePreviewState(UUIState *StateToActivate);

	/**
	 * Alternate version of DeactivateState that deactivates the last state in the StateStack array that has the specified class.
	 */
	UBOOL DeactivateStateByClass(class UClass* StateToRemove,INT PlayerIndex,class UUIState** StateThatWasRemoved=NULL);

	/**
	 * Activate the event of the specified class.
	 *
	 * @param	PlayerIndex				the index of the player that activated this event
	 * @param	EventClassToActivate	specifies the event class that should be activated.  If there is more than one instance
	 *									of a particular event class in this screen object's list of events, all instances will
	 *									be activated in the order in which they occur in the event provider's list.
	 * @param	InEventActivator		an optional object that can be used for various purposes in UIEvents
	 * @param	bActivateImmediately	TRUE to activate the event immediately, causing its output operations to also be processed immediately.
	 * @param	IndicesToActivate		Indexes into this UIEvent's Output array to activate.  If not specified, all output links
	 *									will be activated
	 * @param	out_ActivatedEvents		filled with the event instances that were activated.
	 */
	void ActivateEventByClass(INT PlayerIndex,class UClass* EventClassToActivate,class UObject* InEventActivator=NULL,UBOOL bActivateImmediately=0,const TArray<INT>* IndicesToActivate=NULL,TArray<class UUIEvent*>* out_ActivatedEvents=NULL);

private:
	/**
	 * Wrapper for ActivateEventByClass; called when an event is activated by one of our children and is being propagated upwards.  In cases where
	 * there are multiple child classes of the specified class, only those event classes which have TRUE for the value of bPropagateEvents are
	 * activated.
	 *
	 * @param	PlayerIndex				the index of the player that activated this event
	 * @param	EventClassToActivate	specifies the event class that should be activated.  If there is more than one instance
	 *									of a particular event class in this screen object's list of events, all instances will
	 *									be activated in the order in which they occur in the event provider's list.
	 * @param	InEventActivator		the object that the event was originally generated for.
	 * @param	bActivateImmediately	TRUE to activate the event immediately, causing its output operations to also be processed immediately.
	 * @param	IndicesToActivate		Indexes into this UIEvent's Output array to activate.  If not specified, all output links
	 *									will be activated
	 * @param	out_ActivatedEvents		filled with the event instances that were activated.
	 */
	void ChildEventActivated( INT PlayerIndex,class UClass* EventClassToActivate,class UObject* InEventActivator,UBOOL bActivateImmediately=0,const TArray<INT>* IndicesToActivate=NULL,TArray<class UUIEvent*>* out_ActivatedEvents=NULL );

public:
	// Wrappers for primary menu states

	/**
	 * Returns TRUE if this widget is visible.
	 */
	FORCEINLINE UBOOL IsVisible() const { return !bHidden; }

	/**
	 * Returns TRUE if this widget is hidden.
	 */
	FORCEINLINE UBOOL IsHidden() const { return bHidden; }

	/**
	 * @return Returns TRUE if this widget can be resized, repositioned, or rotated, FALSE otherwise.
	 */
	virtual UBOOL IsTransformable() const
	{
		return TRUE;
	}

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const PURE_VIRTUAL(UUIScreenObject::GetNumResolvedFaces,return 0;);

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const PURE_VIRTUAL(UUIScreenObject::HasPositionBeenResolved,return FALSE;);

	/**
	 * Calculates the closes sibling widget for each face of this widget and sets that widget as the navigation target
	 * for that face.
	 */
	virtual void GenerateAutoNavigationLinks() {}

	/**
	 * Calculates the ideal tab index for all children of this widget and assigns the tab index to the child widget, unless
	 * that widget's tab index has been specifically set by the designer.
	 */
	virtual void GenerateAutomaticTabIndexes();

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 */
	virtual void RebuildKeyboardNavigationLinks();

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting() {}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Changes this widget's position to the specified value.
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=FALSE );

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Marks the position for the specified face as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	void InvalidatePosition( BYTE Face )
	{
		Position.InvalidatePosition(Face);
		InvalidatePositionDependencies(Face);
	}

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face ) PURE_VIRTUAL(UUIScreenObject::InvalidatePositionDependencies,);

public:
	/**
	 * Plays the sound cue associated with the specified name;  simple wrapper method for calling UIInteraction::PlayUISound
	 *
	 * @param	SoundCueName	the name of the UISoundCue to play; should corresond to one of the values of the UISoundCueNames array.
	 * @param	PlayerIndex		allows the caller to indicate which player controller should be used to play the sound cue.  For the most
	 *							part, all sounds can be played by the first player, regardless of who generated the play sound event.
	 *
	 * @return	TRUE if the sound cue specified was found in the currently active skin, even if there was no actual USoundCue associated
	 *			with that UISoundCue.
	 */
	static UBOOL PlayUISound( FName SoundCueName, INT PlayerIndex=0 );

	/**
	 * Routing event for the input we received.  This function first sees if there are any kismet actions that are bound to the
	 * input.  If not, it passes the input to the widget's default input event handler.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL HandleInputKeyEvent( const struct FInputEventParameters& EventParms );

	/**
	 * Remove an existing child widget from this widget's children
	 *
	 * @param	ExistingChild	the widget to remove
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 *
	 * @return	TRUE if the child was successfully removed from the list, or if the child was not contained by this widget
	 *			FALSE if the child could not be removed from this widget's child list.
	 */
	UBOOL RemoveChild(class UUIObject* ExistingChild, TArray<class UUIObject*>* ExclusionSet=NULL );

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreRenderCallback();

	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 */
	virtual void Render_Children( FCanvas* Canvas );

	/**
	 * Routes the call to UpdateWidgetPrimitives to all children of this widget.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateChildPrimitives( FCanvasScene* Canvas );

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	TArray<class UUIObject*> GetChildren( UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	out_Children	receives the list of child widgets.
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	void GetChildren( TArray<class UUIObject*>& out_Children, UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

protected:
	/**
	 * Wrapper for rendering a single child of this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	Child	the child to render
	 *
	 * @note: this method is non-virtual for speed.  If you need to override this method, feel free to make it virtual.
	 */
	void Render_Child( FCanvas* Canvas, class UUIObject* Child );

	/**
	 * Sees if there are any kismet actions that are responding to the input we received.  If so, execute the action
	 * that is currently bound to the event we just received.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessActions( const struct FInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified axis input event (mouse/joystick movement).
	 * If the widget is configured to respond to this axis input event, any actions associated with
	 * this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Activates any actions assigned to the specified character in this widget's input processor.
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, TCHAR Character );

	/**
	 * Converts an input key name (e.g. KEY_Enter) to a UI action key name (UIKEY_Clicked)
	 *
	 * @param	EventParms		the parameters for the input event
	 * @param	out_UIKeyName	will be set to the UI action key name that is mapped to the specified input key name.
	 *
	 * @return	TRUE if InputKeyName was successfully converted into a UI action key name.
	 */
	UBOOL TranslateKey( const struct FInputEventParameters& EventParms, FName& out_UIKeyName );

	/**
	 * Generates an array of indexes, which correspond to indexes into the Engine.GamePlayers array for the players that
	 * this control accepts input from.
	 */
	void GetInputMaskPlayerIndexes( TArray<INT>& out_Indexes );

	/**
	 * Generates a list of any children of this widget which are of a class that has been deprecated, recursively.
	 */
	void FindDeprecatedWidgets( TArray<UUIScreenObject*>& out_DeprecatedWidgets );

protected:
	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.  This version removes any NULL entries from the Children array.
	 */
	virtual void PostLoad();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UIPrefabInstance or a child of a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;

	/**
	 * Determines whether this UIScreenObject is contained by a UIPrefab.
	 *
	 * @param	OwningPrefab	if specified, will be filled in with a reference to the UIPrefab which contains this
	 *							widget, if this widget is in fact contained in a UIPrefab
	 */
	UBOOL IsInUIPrefab( class UUIPrefab** OwningPrefab=NULL ) const;
};

#define UCONST_CONTEXTMENU_BINDING_INDEX 101
#define UCONST_TOOLTIP_BINDING_INDEX 100
#define UCONST_FIRST_DEFAULT_DATABINDING_INDEX 100

struct UIObject_eventOnUIAnimEnd_Parms
{
    class UUIObject* AnimTarget;
    INT AnimIndex;
    class UUIAnimationSeq* AnimSeq;
    UIObject_eventOnUIAnimEnd_Parms(EEventParm)
    {
    }
};
struct UIObject_eventUIAnimEnd_Parms
{
    INT SeqIndex;
    UIObject_eventUIAnimEnd_Parms(EEventParm)
    {
    }
};
struct UIObject_eventClearUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeq;
    UIObject_eventClearUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventStopUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeq;
    UBOOL bFinalize;
    UIObject_eventStopUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventPlayUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeqTemplate;
    FLOAT PlaybackRate;
    UBOOL bLoop;
    FLOAT InitialPosition;
    UIObject_eventPlayUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnContextMenuItemSelected_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    INT ItemIndex;
    UIObject_eventOnContextMenuItemSelected_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCloseContextMenu_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnCloseContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnOpenContextMenu_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    class UUIContextMenu* CustomContextMenu;
    UBOOL ReturnValue;
    UIObject_eventOnOpenContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnQueryToolTip_Parms
{
    class UUIObject* Sender;
    class UUIToolTip* CustomToolTip;
    UBOOL ReturnValue;
    UIObject_eventOnQueryToolTip_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnDoubleClick_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnDoubleClick_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnClicked_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnClicked_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRelease_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRelease_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRepeat_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRepeat_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressed_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressed_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnValueChanged_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    UIObject_eventOnValueChanged_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCreate_Parms
{
    class UUIObject* CreatedWidget;
    class UUIScreenObject* CreatorContainer;
    UIObject_eventOnCreate_Parms(EEventParm)
    {
    }
};
class UUIObject : public UUIScreenObject
{
public:
    //## BEGIN PROPS UIObject
    struct FWIDGET_ID WidgetID;
    FName WidgetTag;
    class UUIObject* Owner;
    class UUIScene* OwnerScene;
    struct FUIStyleReference PrimaryStyle;
    struct FUINavigationData NavigationTargets;
    INT TabIndex;
    struct FUIDockingSet DockTargets;
    FLOAT RenderBounds[4];
    FVector2D RenderBoundsVertices[4];
    struct FUIRotation Rotation;
    FVector RenderOffset;
private:
    INT PrivateFlags;
public:
    struct FUIDataStoreBinding ToolTip;
    struct FUIDataStoreBinding ContextMenuData;
    class UUIObject* AnimationParent;
    FVector AnimationPosition;
    TArrayNoInit<struct FUIAnimSeqRef> AnimStack;
    TArrayNoInit<TScriptInterface<class IUIStyleResolver> > StyleSubscribers;
private:
    BITFIELD bEnableActiveCursorUpdates:1;
public:
    BITFIELD bSupportsPrimaryStyle:1;
    BITFIELD bDebugShowBounds:1;
    FColor DebugBoundsColor;
    FScriptDelegate __OnCreate__Delegate;
    FScriptDelegate __OnValueChanged__Delegate;
    FScriptDelegate __OnPressed__Delegate;
    FScriptDelegate __OnPressRepeat__Delegate;
    FScriptDelegate __OnPressRelease__Delegate;
    FScriptDelegate __OnClicked__Delegate;
    FScriptDelegate __OnDoubleClick__Delegate;
    FScriptDelegate __OnQueryToolTip__Delegate;
    FScriptDelegate __OnOpenContextMenu__Delegate;
    FScriptDelegate __OnCloseContextMenu__Delegate;
    FScriptDelegate __OnContextMenuItemSelected__Delegate;
    FScriptDelegate __OnUIAnimEnd__Delegate;
    //## END PROPS UIObject

    void SetDefaultDataBinding(const FString& MarkupText,INT BindingIndex);
    FString GetDefaultDataBinding(INT BindingIndex) const;
    UBOOL ResolveDefaultDataBinding(INT BindingIndex);
    void GetDefaultDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearDefaultDataBinding(INT BindingIndex);
    virtual FString GenerateSceneDataStoreMarkup(const FString& Group=TEXT("ContextMenuItems")) const;
    FString GetToolTipValue();
    UBOOL HasTransform(UBOOL bIncludeParentTransforms=TRUE) const;
    void SetAnchorPosition(FVector NewAnchorPosition,BYTE InputType=1);
    void RotateWidget(FRotator NewRotationAmount,UBOOL bAccumulateRotation=FALSE);
    void UpdateRotationMatrix();
    FVector GetAnchorPosition(UBOOL bRelativeToWidget=TRUE,UBOOL bPixelSpace=FALSE) const;
    FMatrix GenerateTransformMatrix(UBOOL bIncludeParentTransforms=TRUE) const;
    FMatrix GetRotationMatrix(UBOOL bIncludeParentRotations=TRUE) const;
    virtual void NotifyValueChanged(INT PlayerIndex=-1,INT NotifyFlags=0);
    UBOOL IsContainedBy(class UUIObject* TestWidget);
    virtual UBOOL SetDockTarget(BYTE SourceFace,class UUIScreenObject* Target,BYTE TargetFace);
    virtual UBOOL SetDockPadding(BYTE SourceFace,FLOAT PaddingValue,BYTE PaddingInputType=0,UBOOL bModifyPaddingScaleType=FALSE);
    UBOOL SetDockParameters(BYTE SourceFace,class UUIScreenObject* Target,BYTE TargetFace,FLOAT PaddingValue,BYTE PaddingInputType=0,UBOOL bModifyPaddingScaleType=FALSE);
    UBOOL IsDockedTo(const class UUIScreenObject* TargetWidget,BYTE SourceFace=4,BYTE TargetFace=4) const;
    UBOOL SetNavigationTarget(BYTE Face,class UUIObject* NewNavTarget);
    UBOOL SetForcedNavigationTarget(BYTE Face,class UUIObject* NavTarget,UBOOL bIsNullOverride=FALSE);
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL IsPrivateBehaviorSet(INT Behavior) const;
    void SetPrivateBehavior(INT Behavior,UBOOL Value,UBOOL bRecurse=FALSE);
    virtual void SetActiveCursorUpdate(UBOOL bShouldReceiveCursorUpdates);
    UBOOL NeedsActiveCursorUpdates() const;
    void GetPositionExtents(FLOAT& MinX,FLOAT& MaxX,FLOAT& MinY,FLOAT& MaxY,UBOOL bIncludeRotation=FALSE) const;
    FLOAT GetPositionExtent(BYTE Face,UBOOL bIncludeRotation=FALSE) const;
    void AddStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    void RemoveStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndex(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndexById(FName StyleSubscriberId);
    virtual void TickAnim(FLOAT DeltaTime);
    virtual void AnimSetOpacity(FLOAT NewOpacity);
    virtual void AnimSetVisibility(UBOOL bIsVisible);
    virtual void AnimSetColor(FLinearColor NewColor);
    virtual void AnimSetPosition(FVector NewPosition);
    virtual void AnimSetRelPosition(FVector NewPosition,FVector InitialPosition);
    virtual void AnimSetRotation(FRotator NewRotation);
    virtual void AnimSetScale(FLOAT NewScale);
    DECLARE_FUNCTION(execSetDefaultDataBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT(BindingIndex);
        P_FINISH;
        SetDefaultDataBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(FString*)Result=GetDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execResolveDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(UBOOL*)Result=ResolveDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetDefaultDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        ClearDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGenerateSceneDataStoreMarkup)
    {
        P_GET_STR_OPTX(Group,TEXT("ContextMenuItems"));
        P_FINISH;
        *(FString*)Result=GenerateSceneDataStoreMarkup(Group);
    }
    DECLARE_FUNCTION(execGetToolTipValue)
    {
        P_FINISH;
        *(FString*)Result=GetToolTipValue();
    }
    DECLARE_FUNCTION(execHasTransform)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(UBOOL*)Result=HasTransform(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execSetAnchorPosition)
    {
        P_GET_STRUCT(FVector,NewAnchorPosition);
        P_GET_BYTE_OPTX(InputType,1);
        P_FINISH;
        SetAnchorPosition(NewAnchorPosition,InputType);
    }
    DECLARE_FUNCTION(execRotateWidget)
    {
        P_GET_STRUCT(FRotator,NewRotationAmount);
        P_GET_UBOOL_OPTX(bAccumulateRotation,FALSE);
        P_FINISH;
        RotateWidget(NewRotationAmount,bAccumulateRotation);
    }
    DECLARE_FUNCTION(execUpdateRotationMatrix)
    {
        P_FINISH;
        UpdateRotationMatrix();
    }
    DECLARE_FUNCTION(execGetAnchorPosition)
    {
        P_GET_UBOOL_OPTX(bRelativeToWidget,TRUE);
        P_GET_UBOOL_OPTX(bPixelSpace,FALSE);
        P_FINISH;
        *(FVector*)Result=GetAnchorPosition(bRelativeToWidget,bPixelSpace);
    }
    DECLARE_FUNCTION(execGenerateTransformMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GenerateTransformMatrix(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execGetRotationMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentRotations,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GetRotationMatrix(bIncludeParentRotations);
    }
    DECLARE_FUNCTION(execNotifyValueChanged)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_GET_INT_OPTX(NotifyFlags,0);
        P_FINISH;
        NotifyValueChanged(PlayerIndex,NotifyFlags);
    }
    DECLARE_FUNCTION(execIsContainedBy)
    {
        P_GET_OBJECT(UUIObject,TestWidget);
        P_FINISH;
        *(UBOOL*)Result=IsContainedBy(TestWidget);
    }
    DECLARE_FUNCTION(execSetDockTarget)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_BYTE(TargetFace);
        P_FINISH;
        *(UBOOL*)Result=SetDockTarget(SourceFace,Target,TargetFace);
    }
    DECLARE_FUNCTION(execSetDockPadding)
    {
        P_GET_BYTE(SourceFace);
        P_GET_FLOAT(PaddingValue);
        P_GET_BYTE_OPTX(PaddingInputType,0);
        P_GET_UBOOL_OPTX(bModifyPaddingScaleType,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetDockPadding(SourceFace,PaddingValue,PaddingInputType,bModifyPaddingScaleType);
    }
    DECLARE_FUNCTION(execSetDockParameters)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_BYTE(TargetFace);
        P_GET_FLOAT(PaddingValue);
        P_GET_BYTE_OPTX(PaddingInputType,0);
        P_GET_UBOOL_OPTX(bModifyPaddingScaleType,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetDockParameters(SourceFace,Target,TargetFace,PaddingValue,PaddingInputType,bModifyPaddingScaleType);
    }
    DECLARE_FUNCTION(execIsDockedTo)
    {
        P_GET_OBJECT(UUIScreenObject,TargetWidget);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        *(UBOOL*)Result=IsDockedTo(TargetWidget,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execSetNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NewNavTarget);
        P_FINISH;
        *(UBOOL*)Result=SetNavigationTarget(Face,NewNavTarget);
    }
    DECLARE_FUNCTION(execSetForcedNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NavTarget);
        P_GET_UBOOL_OPTX(bIsNullOverride,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetForcedNavigationTarget(Face,NavTarget,bIsNullOverride);
    }
    DECLARE_FUNCTION(execIsPrivateBehaviorSet)
    {
        P_GET_INT(Behavior);
        P_FINISH;
        *(UBOOL*)Result=IsPrivateBehaviorSet(Behavior);
    }
    DECLARE_FUNCTION(execSetPrivateBehavior)
    {
        P_GET_INT(Behavior);
        P_GET_UBOOL(Value);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        SetPrivateBehavior(Behavior,Value,bRecurse);
    }
    DECLARE_FUNCTION(execSetActiveCursorUpdate)
    {
        P_GET_UBOOL(bShouldReceiveCursorUpdates);
        P_FINISH;
        SetActiveCursorUpdate(bShouldReceiveCursorUpdates);
    }
    DECLARE_FUNCTION(execNeedsActiveCursorUpdates)
    {
        P_FINISH;
        *(UBOOL*)Result=NeedsActiveCursorUpdates();
    }
    DECLARE_FUNCTION(execGetPositionExtents)
    {
        P_GET_FLOAT_REF(MinX);
        P_GET_FLOAT_REF(MaxX);
        P_GET_FLOAT_REF(MinY);
        P_GET_FLOAT_REF(MaxY);
        P_GET_UBOOL_OPTX(bIncludeRotation,FALSE);
        P_FINISH;
        GetPositionExtents(MinX,MaxX,MinY,MaxY,bIncludeRotation);
    }
    DECLARE_FUNCTION(execGetPositionExtent)
    {
        P_GET_BYTE(Face);
        P_GET_UBOOL_OPTX(bIncludeRotation,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetPositionExtent(Face,bIncludeRotation);
    }
    DECLARE_FUNCTION(execAddStyleSubscriber)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        AddStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execRemoveStyleSubscriber)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        RemoveStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndex)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndex(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndexById)
    {
        P_GET_NAME(StyleSubscriberId);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndexById(StyleSubscriberId);
    }
    DECLARE_FUNCTION(execTickAnim)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        TickAnim(DeltaTime);
    }
    DECLARE_FUNCTION(execAnimSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        AnimSetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execAnimSetVisibility)
    {
        P_GET_UBOOL(bIsVisible);
        P_FINISH;
        AnimSetVisibility(bIsVisible);
    }
    DECLARE_FUNCTION(execAnimSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        AnimSetColor(NewColor);
    }
    DECLARE_FUNCTION(execAnimSetPosition)
    {
        P_GET_STRUCT(FVector,NewPosition);
        P_FINISH;
        AnimSetPosition(NewPosition);
    }
    DECLARE_FUNCTION(execAnimSetRelPosition)
    {
        P_GET_STRUCT(FVector,NewPosition);
        P_GET_STRUCT(FVector,InitialPosition);
        P_FINISH;
        AnimSetRelPosition(NewPosition,InitialPosition);
    }
    DECLARE_FUNCTION(execAnimSetRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        AnimSetRotation(NewRotation);
    }
    DECLARE_FUNCTION(execAnimSetScale)
    {
        P_GET_FLOAT(NewScale);
        P_FINISH;
        AnimSetScale(NewScale);
    }
    void delegateOnUIAnimEnd(class UUIObject* AnimTarget,INT AnimIndex,class UUIAnimationSeq* AnimSeq)
    {
        UIObject_eventOnUIAnimEnd_Parms Parms(EC_EventParm);
        Parms.AnimTarget=AnimTarget;
        Parms.AnimIndex=AnimIndex;
        Parms.AnimSeq=AnimSeq;
        ProcessDelegate(ENGINE_OnUIAnimEnd,&__OnUIAnimEnd__Delegate,&Parms);
    }
    void eventUIAnimEnd(INT SeqIndex)
    {
        UIObject_eventUIAnimEnd_Parms Parms(EC_EventParm);
        Parms.SeqIndex=SeqIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_UIAnimEnd),&Parms);
    }
    void eventClearUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL)
    {
        UIObject_eventClearUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeq=AnimSeq;
        ProcessEvent(FindFunctionChecked(ENGINE_ClearUIAnimation),&Parms);
    }
    void eventStopUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL,UBOOL bFinalize=FALSE)
    {
        UIObject_eventStopUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeq=AnimSeq;
        Parms.bFinalize=bFinalize ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_StopUIAnimation),&Parms);
    }
    void eventPlayUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeqTemplate=NULL,FLOAT PlaybackRate=1.000000,UBOOL bLoop=FALSE,FLOAT InitialPosition=0.000000)
    {
        UIObject_eventPlayUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeqTemplate=AnimSeqTemplate;
        Parms.PlaybackRate=PlaybackRate;
        Parms.bLoop=bLoop ? FIRST_BITFIELD : FALSE;
        Parms.InitialPosition=InitialPosition;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayUIAnimation),&Parms);
    }
    void delegateOnContextMenuItemSelected(class UUIContextMenu* ContextMenu,INT PlayerIndex,INT ItemIndex)
    {
        UIObject_eventOnContextMenuItemSelected_Parms Parms(EC_EventParm);
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        Parms.ItemIndex=ItemIndex;
        ProcessDelegate(ENGINE_OnContextMenuItemSelected,&__OnContextMenuItemSelected__Delegate,&Parms);
    }
    UBOOL delegateOnCloseContextMenu(class UUIContextMenu* ContextMenu,INT PlayerIndex)
    {
        UIObject_eventOnCloseContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnCloseContextMenu,&__OnCloseContextMenu__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnOpenContextMenu(class UUIObject* Sender,INT PlayerIndex,class UUIContextMenu*& CustomContextMenu)
    {
        UIObject_eventOnOpenContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        Parms.CustomContextMenu=CustomContextMenu;
        ProcessDelegate(ENGINE_OnOpenContextMenu,&__OnOpenContextMenu__Delegate,&Parms);
        CustomContextMenu=Parms.CustomContextMenu;
        return Parms.ReturnValue;
    }
    UBOOL delegateOnQueryToolTip(class UUIObject* Sender,class UUIToolTip*& CustomToolTip)
    {
        UIObject_eventOnQueryToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.CustomToolTip=CustomToolTip;
        ProcessDelegate(ENGINE_OnQueryToolTip,&__OnQueryToolTip__Delegate,&Parms);
        CustomToolTip=Parms.CustomToolTip;
        return Parms.ReturnValue;
    }
    void delegateOnDoubleClick(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnDoubleClick_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnDoubleClick,&__OnDoubleClick__Delegate,&Parms);
    }
    UBOOL delegateOnClicked(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnClicked_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnClicked,&__OnClicked__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnPressRelease(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRelease_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRelease,&__OnPressRelease__Delegate,&Parms);
    }
    void delegateOnPressRepeat(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRepeat_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRepeat,&__OnPressRepeat__Delegate,&Parms);
    }
    void delegateOnPressed(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressed_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressed,&__OnPressed__Delegate,&Parms);
    }
    void delegateOnValueChanged(class UUIObject* Sender,INT PlayerIndex)
    {
        UIObject_eventOnValueChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnValueChanged,&__OnValueChanged__Delegate,&Parms);
    }
    void delegateOnCreate(class UUIObject* CreatedWidget,class UUIScreenObject* CreatorContainer)
    {
        UIObject_eventOnCreate_Parms Parms(EC_EventParm);
        Parms.CreatedWidget=CreatedWidget;
        Parms.CreatorContainer=CreatorContainer;
        ProcessDelegate(ENGINE_OnCreate,&__OnCreate__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIObject,UUIScreenObject,0,Engine)
	/* === UUIObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}

	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene ) {}

	/**
	 * Allow the widget to do any special rendering after its children have been rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void PostRender_Widget( FCanvas* Canvas );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 * Child classes should override this method when objects need to be added to the StyleSubscribers array
	 */
	virtual void InitializeStyleSubscribers() {}

	/**
	 * Assigns the style for this widget for the property provided and refreshes the widget's styles.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	StyleProperty	The style property we are modifying.
	 * @param	ArrayIndex		if the style property corresponds to an array index, specified the array index to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to this widget.
	 */
	UBOOL SetWidgetStyle( class UUIStyle* NewStyle, struct FStyleReferenceId StyleProperty=FStyleReferenceId(), INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the style references contained by this widget from the currently active skin.
	 *
	 * @param	bClearExistingValue		if TRUE, style references will be invalidated first.
	 * @param	StyleProperty			if specified, only the style reference corresponding to the specified property
	 *									will be resolved; otherwise, all style references will be resolved.
	 *
	 * @return	TRUE if all style references were successfully resolved.
	 */
	UBOOL ResolveStyles( UBOOL bClearExistingValue, struct FStyleReferenceId StyleProperty=FStyleReferenceId() );

protected:
	friend class UUISkin;

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( class UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:
	/**
	 * Retrieves the list of UIStyleReferences contained by this widget class.  Used to refresh the style data for all style
	 * references contained by this widget whenever the active skin or menu state is changed.
	 *
	 * @param	out_StyleReferences		a map of style property references to UIStyleReference values for the style references contained by this class and
	 *									its StyleSubscribers
	 * @param	TargetStyleRef			if specified, only style references associated with the value specified will be added to the map.
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferences( TMultiMap<struct FStyleReferenceId,struct FUIStyleReference*>& out_StyleReferences, FStyleReferenceId TargetStyleRef=FStyleReferenceId(), UObject* SearchObject=NULL );

	/**
	 * Retrieves the list of UIStyleReference properties contained by this widget class.
	 *
	 * @param	out_StyleReferences		a list of the style references contained by this class
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferenceProperties( TArray<struct FStyleReferenceId>& out_StyleProperties, UObject* SearchObject=NULL );

	/**
	 * Retrieves the list of data store bindings contained by this widget class.
	 *
	 * @param	out_DataBindings		a map of data binding property name to UIDataStoreBinding values for the data bindings contained by this class
	 * @param	TargetPropertyName		if specified, only data bindings associated with the property specified will be added to the map.
	 */
	void GetDataBindings( TMultiMap<FName,struct FUIDataStoreBinding*>& out_DataBindings, const FName TargetPropertyName=NAME_None );

	/**
	 * Retrieves the list of UIDataStoreBinding properties contained by this widget class.
	 *
	 * @param	out_DataBindingProperties	a list of the data store binding properties contained by this class
	 */
	void GetDataBindingProperties( TArray<class UProperty*>& out_DataBindingProperties );

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState=NULL );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/**
	 * Verifies that this widget has a valid WIDGET_ID, and generates one if it doesn't.
	 */
	void ValidateWidgetID();

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Projects the vertices made from all faces of this widget and stores the results in the RenderBoundsVertices array.
	 *
	 * @param	bRecursive	specify TRUE to propagate this call to all children of this widget.
	 */
	void UpdateRenderBoundsVertices( UBOOL bRecursive=TRUE );

	/* === UUIScreenObject interface === */
	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const
	{
		return Owner != NULL ? Owner : (UUIScreenObject*)OwnerScene;
	}

	/**
	 * Returns the UIObject that owns this widget.
	 */
	virtual UUIObject* GetOwner() const			{ return Owner; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual UUIScene* GetScene() 				{ return OwnerScene; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual const UUIScene* GetScene() const	{ return OwnerScene; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return WidgetTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const;

	/** get the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Notification that this widget's parent is about to remove this widget from its children array.  Allows the widget
	 * to clean up any references to the old parent.
	 *
	 * @param	WidgetOwner		the screen object that this widget was removed from.
	 * @param	ExclusionSet	allows the caller to specify a group of widgets which should not have inter-references (i.e. references
	 *							to other objects in the set)
	 */
	virtual void NotifyRemovedFromParent( UUIScreenObject* WidgetOwner, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Called from UGameUISceneClient::UpdateMousePosition; provides a hook for widgets to respond to the precise cursor
	 * position.  Only called on the scene's ActiveControl if the ActiveControl's bEnableActiveCursorUpdates is TRUE and
	 * the mouse is currently over the widget.
	 *
	 * @param	MousePos	the current position of the mouse, in absolute screen pixels.
	 */
	virtual void NotifyMouseOver( const FVector2D& MousePos ) {}

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate();

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
	 * Calculates the closes sibling widget for each face of this widget and sets that widget as the navigation target
	 * for that face.
	 */
	virtual void GenerateAutoNavigationLinks();

	/**
	 * Sets the actual navigation target for the specified face.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	Face			the face to set the navigation link for
	 * @param	NewNavTarget	the widget to set as the link for the specified face
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
	 * the designer-specified navigation target will always override any auto-calculated targets.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	Face				the face to set the navigation link for
	 * @param	NavTarget			the widget to set as the link for the specified face
	 * @param	bIsNullOverride		if NavTarget is NULL, specify TRUE to indicate that this face's nav target should not
	 *								be automatically calculated.
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetForcedNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
	 * that object is returned.
	 *
	 * @param	Face		the face to get the nav target for
	 * @param	LinkType	specifies which navigation link type to return.
	 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
	 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
	 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
	 *
	 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
	 *			no nav target for that face.
	 */
	UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

	/**
	 * Determines if the specified widget is a valid candidate for being the nav target for the specified face of this widget.
	 *
	 * @param	Face			the face that we'd be assigning NewNavTarget to
	 * @param	NewNavTarget	the widget that we'd like to make the nav target for that face
	 *
	 * @return	TRUE if NewNavTarget is allowed to be the navigation target for the specified face of this widget.
	 */
	virtual UBOOL IsValidNavigationTarget( EUIWidgetFace Face, UUIObject* NewNavTarget ) const;

	/**
	 * Determines whether the specified widget can be set as a docking target for the specified face.
	 *
	 * @param	SourceFace		the face on this widget that the potential dock source
	 * @param	Target			the potential docking target
	 * @param	TargetFace		the face on the target widget that we want to check for
	 *
	 * @return	TRUE if a docking link can be safely established between SourceFace and TargetFace.
	 */
	UBOOL IsValidDockTarget( EUIWidgetFace SourceFace, UUIObject* Target, EUIWidgetFace TargetFace );

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene();

	/**
	 * Adds docking nodes for all faces of this widget to the specified scene
	 *
	 * @param	DockingStack	the docking stack to add this widget's docking.  Generally the scene's DockingStack.
	 *
	 * @return	TRUE if docking nodes were successfully added for all faces of this widget.
	 */
	virtual UBOOL AddDockingLink( TArray<struct FUIDockingNode>& DockingStack );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const;

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return DockTargets.bResolved[Face] != 0;
	}

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Adds the specified state to the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new state for the widget
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivateState( class UUIState* StateToActivate, INT PlayerIndex );

	/**
	 * Changes the specified preview state on the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new preview state for the widget to apply within the Editor
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new preview state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivatePreviewState( class UUIState* StateToActivate );

	/**
	 * Removes the specified state from the screen object's state stack and refreshes the widget's style using the new state.
	 *
	 * @param	StateToRemove	the state to be removed
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the state was successfully removed, or if the state didn't exist in the widget's list of states;
	 *			false if the state overrode the request to be removed
	 */
	virtual UBOOL DeactivateState( class UUIState* StateToRemove, INT PlayerIndex );

	/**
	 * Activates the tooltip associated with this widget.  Called when this widget (or one of its Children) becomes
	 * the scene client's ActiveControl.  If this widget doesn't support tool-tips or does not have a valid tool-tip
	 * binding, the call is propagated upwards to the parent widget.
	 *
	 * @return	a pointer to the tool-tip that was activated.  This value will be stored in the scene's ActiveToolTip member.
	 */
	class UUIToolTip* ActivateToolTip();

	/**
	 * Activates the context menu for this widget, if it has one.  Called when the user right-clicks (or whatever input key
	 * is configured to activate the ShowContextMenu UI input alias) while this widget (or one of its Children) is the
	 * scene client's ActiveControl.
	 *
	 * @return	a pointer to the context menu that was activated.  This value will be stored in the scene's ActiveContextMenu member.
	 */
	class UUIContextMenu* ActivateContextMenu( INT PlayerIndex );

	/**
	 * Decide if we need to apply this animation
	 *
	 * @Param DeltaTime			How much time since the last call
	 * @Param AnimSeqRef		*OUTPUT* The AnimSeq begin applied
	 *
	 * @Returns true if the animation has reached the end.
	 */
	 virtual UBOOL TickSequence( FLOAT DeltaTime, struct FUIAnimSeqRef& AnimSeqRef );

	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version converts the deprecated PRIVATE_DisallowReparenting flag to PRIVATE_EditorNoReparent, if set.
	 */
	virtual void PostLoad();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Called after this widget is renamed; ensures that the widget's tag matches the name of the widget.
	 */
	virtual void PostRename();
};

#define UCONST_ConsolePromptText TEXT("(> ")

class UConsoleEntry : public UUIObject
{
public:
    //## BEGIN PROPS ConsoleEntry
    class UUILabel* ConsolePromptLabel;
    class UUIImage* ConsolePromptBackground;
    class UUIEditBox* InputBox;
    class UUIImage* LowerConsoleBorder;
    class UUIImage* UpperConsoleBorder;
    INT CursorPosition;
    BITFIELD bRenderCursor:1;
    //## END PROPS ConsoleEntry

    DECLARE_CLASS(UConsoleEntry,UUIObject,0,Engine)
	/**
	 * Initializes the button and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}	// do nothing

	/**
	 * Perform any additional rendering after this widget's children have been rendered.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void PostRender_Widget( FCanvas* Canvas );
};

class UUIButton : public UUIObject
{
public:
    //## BEGIN PROPS UIButton
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUITexture* ButtonBackground;
    struct FTextureCoordinates Coordinates;
    FName ClickedCue;
    //## END PROPS UIButton

    DECLARE_CLASS(UUIButton,UUIObject,0,Engine)
	/* === UIButton interface === */
	/**
	 * Changes the background image for this button, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetImage( class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	/**
	 * Handles input events for this button.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated ButtonBackground,
	 * Coordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUICheckbox : public UUIButton, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UICheckbox
    struct FUIDataStoreBinding ValueDataSource;
    class UUIComp_DrawImage* CheckedImageComponent;
    class UUITexture* CheckedImage;
    struct FTextureCoordinates CheckCoordinates;
    struct FUIStyleReference CheckStyle;
    BITFIELD bIsChecked:1;
    //## END PROPS UICheckbox

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_UBOOL(bShouldBeChecked);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        SetValue(bShouldBeChecked,PlayerIndex);
    }
    DECLARE_CLASS(UUICheckbox,UUIButton,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Render this checkbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Changes the checked image for this checkbox, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetCheckImage( class USurface* NewImage );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the CheckedImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

protected:

	/**
	 * Handles input events for this checkbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated CheckedImage,
	 * CheckCoordinates, and CheckedStyle properties over to the CheckedImageComponent.
	 */
	virtual void PostLoad();
};

struct UILabelButton_eventGetCaption_Parms
{
    FString ReturnValue;
    UILabelButton_eventGetCaption_Parms(EEventParm)
    {
    }
};
class UUILabelButton : public UUIButton, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UILabelButton
    struct FUIDataStoreBinding CaptionDataSource;
    class UUIComp_DrawString* StringRenderComponent;
    //## END PROPS UILabelButton

    virtual void SetCaption(const FString& NewText);
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetCaption)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetCaption(NewText);
    }
    DECLARE_FUNCTION(execSetTextAlignment)
    {
        P_GET_BYTE(Horizontal);
        P_GET_BYTE(Vertical);
        P_FINISH;
        SetTextAlignment(Horizontal,Vertical);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    FString eventGetCaption()
    {
        UILabelButton_eventGetCaption_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetCaption),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUILabelButton,UUIButton,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bZeroOrigin, bClampValues);
	}

	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates the PrimaryStyle for this label over to the label's component.
	 */
	virtual void PostLoad();
};

struct UITabButton_eventIsActivationAllowed_Parms
{
    class UUITabButton* Sender;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UITabButton_eventIsActivationAllowed_Parms(EEventParm)
    {
    }
};
class UUITabButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UITabButton
    class UUITabPage* TabPage;
    FScriptDelegate __IsActivationAllowed__Delegate;
    //## END PROPS UITabButton

    virtual UBOOL CanActivateButton(INT PlayerIndex);
    DECLARE_FUNCTION(execCanActivateButton)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=CanActivateButton(PlayerIndex);
    }
    DECLARE_FUNCTION(execIsTargeted);
    UBOOL delegateIsActivationAllowed(class UUITabButton* Sender,INT PlayerIndex)
    {
        UITabButton_eventIsActivationAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_IsActivationAllowed,&__IsActivationAllowed__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUITabButton,UUILabelButton,0,Engine)
	/* === UUITabButton interface === */
	/**
	 * Returns TRUE if this widget has a UIState_TargetedTab object in its StateStack
	 *
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsTargeted( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/* === UUIScreenObject interface === */
	/**
	 * Called when this widget is created.  Copies the style data from the owning tab control into this button's
	 * string and image rendering components, then calls InitializeStyleSubscribers.  This is necessary because tab control
	 * manages the styles for tab buttons - initialization of the style data is handled by the tab control for existing tab
	 * buttons, but for new tab buttons being added to the tab control we need to perform this step ourselves.
	 */
	virtual void Created( UUIScreenObject* Creator );
};

class UUIToggleButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UIToggleButton
    struct FUIDataStoreBinding ValueDataSource;
    BITFIELD bIsChecked:1;
    class UUIComp_DrawString* CheckedStringRenderComponent;
    class UUIComp_DrawImage* CheckedBackgroundImageComponent;
    //## END PROPS UIToggleButton

    virtual void SetCaption(const FString& NewText);
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_UBOOL(bShouldBeChecked);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        SetValue(bShouldBeChecked,PlayerIndex);
    }
    DECLARE_CLASS(UUIToggleButton,UUILabelButton,0,Engine)
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

protected:

	/**
	 * Handles input events for this checkbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUINumericEditBoxButton : public UUIButton
{
public:
    //## BEGIN PROPS UINumericEditBoxButton
    //## END PROPS UINumericEditBoxButton

    DECLARE_CLASS(UUINumericEditBoxButton,UUIButton,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUINumericEditBoxButton)
};

class UUIOptionListButton : public UUIButton
{
public:
    //## BEGIN PROPS UIOptionListButton
    //## END PROPS UIOptionListButton

    void UpdateButtonState(INT PlayerIndex=-1);
    DECLARE_FUNCTION(execUpdateButtonState)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        UpdateButtonState(PlayerIndex);
    }
    DECLARE_CLASS(UUIOptionListButton,UUIButton,0,Engine)
    DECLARE_WITHIN(UUIOptionListBase)
    NO_DEFAULT_CONSTRUCTOR(UUIOptionListButton)
};

class UUIScrollbarButton : public UUIButton
{
public:
    //## BEGIN PROPS UIScrollbarButton
    //## END PROPS UIScrollbarButton

    DECLARE_CLASS(UUIScrollbarButton,UUIButton,0,Engine)
    DECLARE_WITHIN(UUIScrollbar)
    NO_DEFAULT_CONSTRUCTOR(UUIScrollbarButton)
};

struct UIScrollbarMarkerButton_eventOnButtonDragged_Parms
{
    class UUIScrollbarMarkerButton* Sender;
    INT PlayerIndex;
    UIScrollbarMarkerButton_eventOnButtonDragged_Parms(EEventParm)
    {
    }
};
class UUIScrollbarMarkerButton : public UUIScrollbarButton
{
public:
    //## BEGIN PROPS UIScrollbarMarkerButton
    FScriptDelegate __OnButtonDragged__Delegate;
    //## END PROPS UIScrollbarMarkerButton

    void delegateOnButtonDragged(class UUIScrollbarMarkerButton* Sender,INT PlayerIndex)
    {
        UIScrollbarMarkerButton_eventOnButtonDragged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnButtonDragged,&__OnButtonDragged__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIScrollbarMarkerButton,UUIScrollbarButton,0,Engine)
	/* === UUIScreenObject interface === */
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/**
	 * Determines whether this widget should process the specified axis input event (mouse/joystick movement).
	 * If the widget is configured to respond to this axis input event, any actions associated with
	 * this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );
};

#define UCONST_INDEX_CHANGED_NOTIFY_MASK 0x2
#define UCONST_TEXT_CHANGED_NOTIFY_MASK 0x1

struct UIComboBox_eventHideList_Parms
{
    INT PlayerIndex;
    UIComboBox_eventHideList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventShowList_Parms
{
    INT PlayerIndex;
    UIComboBox_eventShowList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboList_Parms
{
    class UUIComboBox* ListOwner;
    class UUIList* ReturnValue;
    UIComboBox_eventCreateCustomComboList_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboButton_Parms
{
    class UUIComboBox* ButtonOwner;
    class UUIToggleButton* ReturnValue;
    UIComboBox_eventCreateCustomComboButton_Parms(EEventParm)
    {
    }
};
struct UIComboBox_eventCreateCustomComboEditbox_Parms
{
    class UUIComboBox* EditboxOwner;
    class UUIEditBox* ReturnValue;
    UIComboBox_eventCreateCustomComboEditbox_Parms(EEventParm)
    {
    }
};
class UUIComboBox : public UUIObject, public IUIDataStoreSubscriber
{
public:
    //## BEGIN PROPS UIComboBox
    class UClass* ComboEditboxClass;
    class UClass* ComboButtonClass;
    class UClass* ComboListClass;
    class UUIEditBox* ComboEditbox;
    class UUIToggleButton* ComboButton;
    class UUIList* ComboList;
    class UUIComp_DrawCaption* CaptionRenderComponent;
    class UUIComp_DrawImage* BackgroundRenderComponent;
    struct FUIDataStoreBinding CaptionDataSource;
    FName OpenList;
    FName DecrementCue;
    BITFIELD bLockSelectedItem:1;
    FScriptDelegate __CreateCustomComboEditbox__Delegate;
    FScriptDelegate __CreateCustomComboButton__Delegate;
    FScriptDelegate __CreateCustomComboList__Delegate;
    //## END PROPS UIComboBox

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    void eventHideList(INT PlayerIndex=0)
    {
        UIComboBox_eventHideList_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_HideList),&Parms);
    }
    void eventShowList(INT PlayerIndex=0)
    {
        UIComboBox_eventShowList_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowList),&Parms);
    }
    class UUIList* delegateCreateCustomComboList(class UUIComboBox* ListOwner)
    {
        UIComboBox_eventCreateCustomComboList_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ListOwner=ListOwner;
        ProcessDelegate(ENGINE_CreateCustomComboList,&__CreateCustomComboList__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIToggleButton* delegateCreateCustomComboButton(class UUIComboBox* ButtonOwner)
    {
        UIComboBox_eventCreateCustomComboButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomComboButton,&__CreateCustomComboButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIEditBox* delegateCreateCustomComboEditbox(class UUIComboBox* EditboxOwner)
    {
        UIComboBox_eventCreateCustomComboEditbox_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EditboxOwner=EditboxOwner;
        ProcessDelegate(ENGINE_CreateCustomComboEditbox,&__CreateCustomComboEditbox__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIComboBox,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIComboBox interface === */
	/**
	 * Creates the support controls which make up the combo box - the list, button, and editbox.
	 */
	virtual void CreateInternalControls();

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Called whenever the selected item is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

protected:
	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/**
	 * Activates the focused state for this widget and sets it to be the focused control of its parent (if applicable)
	 *
	 * @param	Sender		Control that called SetFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the specified child of this widget.
	 *
	 * @param	ChildToFocus	the child to set focus to.  If not specified, attempts to set focus to the most elibible child,
	 *							as determined by navigation links and FocusPropagation values.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocusToChild(class UUIObject* ChildToFocus=NULL,INT PlayerIndex=0);

	/**
	 * Deactivates the focused state for this widget.
	 *
	 * @param	Sender			the control that called KillFocus.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL KillFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);


	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * Creates the components of this combobox, if necessary.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 */
	virtual void RebuildKeyboardNavigationLinks();

	/**
	 * Adds the specified face to the DockingStack, along with any dependencies that face might have.
	 *
	 * This version routes the call to the CaptionRenderComponent, if applicable.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Render this widget.  This version routes the render call to the draw components, if applicable.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

protected:
	/**
	 * Handles input events for this slider.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIContainer : public UUIObject
{
public:
    //## BEGIN PROPS UIContainer
    class UUIComp_AutoAlignment* AutoAlignment;
    //## END PROPS UIContainer

    DECLARE_CLASS(UUIContainer,UUIObject,0,Engine)
	/* === UUIScreenObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) {}

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct FCornerSizes
{
    FLOAT TopLeft[2];
    FLOAT TopRight[2];
    FLOAT BottomLeft[2];
    FLOAT BottomRight[2];
    FLOAT TopHeight;
    FLOAT BottomHeight;
    FLOAT CenterLeftWidth;
    FLOAT CenterRightWidth;
};

class UUIFrameBox : public UUIContainer
{
public:
    //## BEGIN PROPS UIFrameBox
    class UUIComp_DrawImage* BackgroundImageComponent[9];
    struct FCornerSizes BackgroundCornerSizes;
    //## END PROPS UIFrameBox

    DECLARE_CLASS(UUIFrameBox,UUIContainer,0,Engine)
	/* === UIPanel interface === */
	/**
	 * Changes the background image for one of the image components.
	 *
	 * @param	ImageToSet		The image component we are going to set the image for.
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( EFrameBoxImage ImageToSet, class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Render this button.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUIPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UIPanel
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUITexture* PanelBackground;
    struct FTextureCoordinates Coordinates;
    //## END PROPS UIPanel

    DECLARE_CLASS(UUIPanel,UUIContainer,0,Engine)
	/* === UIPanel interface === */
	/**
	 * Changes the background image for this button, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( class USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Render this button.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated PanelBackground,
	 * Coordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUISafeRegionPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UISafeRegionPanel
    BYTE RegionType;
    TArrayNoInit<FLOAT> RegionPercentages;
    BITFIELD bForce4x3AspectRatio:1;
    BITFIELD bUseFullRegionIn4x3:1;
    BITFIELD bHideBounds:1;
    //## END PROPS UISafeRegionPanel

    DECLARE_CLASS(UUISafeRegionPanel,UUIContainer,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Initializes the panel and sets its position to match the safe region.
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * @return Returns TRUE if this widget can be resized, repositioned, or rotated, FALSE otherwise.
	 */
	virtual UBOOL IsTransformable() const
	{
		return FALSE;
	}

	/**
	 * Performs the actual alignment
	 */
	virtual void AlignPanel();

	/**
	 * Update the Panel
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Draw the bounds
	 */
	virtual void Render_Widget( FCanvas* Canvas );
};

class UUIScrollFrame : public UUIContainer
{
public:
    //## BEGIN PROPS UIScrollFrame
    class UUIComp_DrawImage* StaticBackgroundImage;
    class UUIScrollbar* ScrollbarHorizontal;
    class UUIScrollbar* ScrollbarVertical;
    struct FUIScreenValue_Extent HorizontalClientRegion;
    struct FUIScreenValue_Extent VerticalClientRegion;
private:
    FVector2D ClientRegionPosition;
    FLOAT FrameBounds[4];
public:
    BITFIELD bRefreshScrollbars:1;
    BITFIELD bRecalculateClientRegion:1;
    //## END PROPS UIScrollFrame

    void RefreshScrollbars(UBOOL bImmediately=FALSE);
    void ReapplyFormatting(UBOOL bImmediately=FALSE);
    UBOOL ScrollRegion(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE);
    UBOOL SetClientRegionPosition(BYTE Orientation,FLOAT NewPosition);
    UBOOL SetClientRegionPositionVector(FVector2D NewPosition);
    FLOAT GetClientRegionPosition(BYTE Orientation) const;
    FLOAT GetClientRegionSize(BYTE Orientation) const;
    FVector2D GetClientRegionPositionVector() const;
    FVector2D GetClientRegionSizeVector() const;
    virtual void GetClipRegion(FLOAT& MinX,FLOAT& MinY,FLOAT& MaxX,FLOAT& MaxY) const;
    FLOAT GetVisibleRegionPercentage(BYTE Orientation) const;
    DECLARE_FUNCTION(execRefreshScrollbars)
    {
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        RefreshScrollbars(bImmediately);
    }
    DECLARE_FUNCTION(execReapplyFormatting)
    {
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        ReapplyFormatting(bImmediately);
    }
    DECLARE_FUNCTION(execScrollRegion)
    {
        P_GET_OBJECT(UUIScrollbar,Sender);
        P_GET_FLOAT(PositionChange);
        P_GET_UBOOL_OPTX(bPositionMaxed,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ScrollRegion(Sender,PositionChange,bPositionMaxed);
    }
    DECLARE_FUNCTION(execSetClientRegionPosition)
    {
        P_GET_BYTE(Orientation);
        P_GET_FLOAT(NewPosition);
        P_FINISH;
        *(UBOOL*)Result=SetClientRegionPosition(Orientation,NewPosition);
    }
    DECLARE_FUNCTION(execSetClientRegionPositionVector)
    {
        P_GET_STRUCT(FVector2D,NewPosition);
        P_FINISH;
        *(UBOOL*)Result=SetClientRegionPositionVector(NewPosition);
    }
    DECLARE_FUNCTION(execGetClientRegionPosition)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetClientRegionPosition(Orientation);
    }
    DECLARE_FUNCTION(execGetClientRegionSize)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetClientRegionSize(Orientation);
    }
    DECLARE_FUNCTION(execGetClientRegionPositionVector)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegionPositionVector();
    }
    DECLARE_FUNCTION(execGetClientRegionSizeVector)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegionSizeVector();
    }
    DECLARE_FUNCTION(execGetClipRegion)
    {
        P_GET_FLOAT_REF(MinX);
        P_GET_FLOAT_REF(MinY);
        P_GET_FLOAT_REF(MaxX);
        P_GET_FLOAT_REF(MaxY);
        P_FINISH;
        GetClipRegion(MinX,MinY,MaxX,MaxY);
    }
    DECLARE_FUNCTION(execGetVisibleRegionPercentage)
    {
        P_GET_BYTE(Orientation);
        P_FINISH;
        *(FLOAT*)Result=GetVisibleRegionPercentage(Orientation);
    }
    DECLARE_CLASS(UUIScrollFrame,UUIContainer,0,Engine)
	/* === UUIScrollFrame interface === */
	/**
	 * Changes the background image for this scroll frame, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the scroll frame's background image
	 */
	void SetBackgroundImage( USurface* NewBackgroundImage );

	/**
	 * Determines the size of the region necessary to contain all children of this widget
	 *
	 * @param	RegionSize	if specified, will be set to the size of the client region (in pixels) post-calculation.
	 *
	 * @note: OK to make virtual if necessary
	 */
	void CalculateClientRegion( FVector2D* RegionSize=NULL );

protected:

	/**
	 * Calculates and applies scrollbar positions, visibility, marker size, etc.
	 */
	void ResolveScrollbars();

public:

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/* === UUIScreenObject interface === */
	/**
	 * Initializes the buttons and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Insert a widget at the specified location.  This version routes the call to the ClientPanel if the widget is not
	 * eligible to be a child of this scroll frame.
	 *
	 * @param	NewChild		the widget to insert
	 * @param	InsertIndex		the position to insert the widget.  If not specified, the widget is insert at the end of
	 *							the list
	 * @param	bRenameExisting	controls what happens if there is another widget in this widget's Children list with the same tag as NewChild.
	 *							if TRUE, renames the existing widget giving a unique transient name.
	 *							if FALSE, does not add NewChild to the list and returns FALSE.
	 *
	 * @return	the position that that the child was inserted in, or INDEX_NONE if the widget was not inserted
	 */
	virtual INT InsertChild( class UUIObject* NewChild, INT InsertIndex=INDEX_NONE, UBOOL bRenameExisting=TRUE );

#if 0
// only need to enable these two methods if we're going to allow the scrollframe itself to become the focused
// control (similar to UITabControl), so that the user can scroll the client region using the arrow keys for example)
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

protected:

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
#endif

	/**
	 * Render this scroll frame.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * This version sets a clip mask on the canvas while the children are being rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 */
	virtual void Render_Children( FCanvas* Canvas );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated Background,
	 * BackgroundCoordinates, and PrimaryStyle properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

#define UCONST_DESCRIPTION_DATABINDING_INDEX 2
#define UCONST_TOOLTIP_DATABINDING_INDEX 1
#define UCONST_CAPTION_DATABINDING_INDEX 0

struct UITabPage_eventLinkToTabButton_Parms
{
    class UUITabButton* NewButton;
    class UUITabControl* TabControl;
    UBOOL ReturnValue;
    UITabPage_eventLinkToTabButton_Parms(EEventParm)
    {
    }
};
struct UITabPage_eventCreateTabButton_Parms
{
    class UUITabControl* TabControl;
    class UUITabButton* ReturnValue;
    UITabPage_eventCreateTabButton_Parms(EEventParm)
    {
    }
};
struct UITabPage_eventActivatePage_Parms
{
    INT PlayerIndex;
    UBOOL bActivate;
    UBOOL bTakeFocus;
    UBOOL ReturnValue;
    UITabPage_eventActivatePage_Parms(EEventParm)
    {
    }
};
class UUITabPage : public UUIContainer, public IUIDataStoreSubscriber
{
public:
    //## BEGIN PROPS UITabPage
    class UClass* ButtonClass;
    class UUITabButton* TabButton;
    struct FUIDataStoreBinding ButtonCaption;
    struct FUIDataStoreBinding ButtonToolTip;
    struct FUIDataStoreBinding PageDescription;
    //## END PROPS UITabPage

    class UUITabControl* GetOwnerTabControl() const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    DECLARE_FUNCTION(execGetOwnerTabControl)
    {
        P_FINISH;
        *(class UUITabControl**)Result=GetOwnerTabControl();
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    UBOOL eventLinkToTabButton(class UUITabButton* NewButton,class UUITabControl* TabControl)
    {
        UITabPage_eventLinkToTabButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.NewButton=NewButton;
        Parms.TabControl=TabControl;
        ProcessEvent(FindFunctionChecked(ENGINE_LinkToTabButton),&Parms);
        return Parms.ReturnValue;
    }
    class UUITabButton* eventCreateTabButton(class UUITabControl* TabControl)
    {
        UITabPage_eventCreateTabButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TabControl=TabControl;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateTabButton),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePage(INT PlayerIndex,UBOOL bActivate,UBOOL bTakeFocus=TRUE)
    {
        UITabPage_eventActivatePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bActivate=bActivate ? FIRST_BITFIELD : FALSE;
        Parms.bTakeFocus=bTakeFocus ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePage),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUITabPage,UUIContainer,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UIScreenObject interface === */
	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

struct UIEditBox_eventOnSubmitText_Parms
{
    class UUIEditBox* Sender;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIEditBox_eventOnSubmitText_Parms(EEventParm)
    {
    }
};
class UUIEditBox : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIEditBox
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawStringEditbox* StringRenderComponent;
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUITexture* EditBoxBackground;
    struct FTextureCoordinates Coordinates;
    FStringNoInit InitialValue;
    BITFIELD bReadOnly:1;
    BITFIELD bPasswordMode:1;
    INT MaxCharacters;
    BYTE CharacterSet;
    FScriptDelegate __OnSubmitText__Delegate;
    //## END PROPS UIEditBox

    void SetValue(const FString& NewText,INT PlayerIndex=0,UBOOL bSkipNotification=FALSE);
    FString GetValue(UBOOL bReturnUserText=TRUE);
    UBOOL DeleteCharacter(INT PlayerIndex=0);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        SetValue(NewText,PlayerIndex,bSkipNotification);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnUserText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnUserText);
    }
    DECLARE_FUNCTION(execDeleteCharacter)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=DeleteCharacter(PlayerIndex);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    UBOOL delegateOnSubmitText(class UUIEditBox* Sender,INT PlayerIndex)
    {
        UIEditBox_eventOnSubmitText_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnSubmitText,&__OnSubmitText__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIEditBox,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIEditBox interface === */
	/**
	 * Changes the background image for this widget, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetBackgroundImage( class USurface* NewImage );

	/**
	 * Called whenever the user presses enter while this editbox is focused.  Activated the SubmitText kismet event and calls the
	 * OnSubmitText delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 */
	virtual void NotifySubmitText( INT PlayerIndex=INDEX_NONE );

protected:
	/**
	 * Processes special characters that affect the editbox but aren't displayed in the text field, such
	 * as arrow keys, backspace, delete, etc.
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Character key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE if the character was processed, FALSE if it wasn't one a special character.
	 */
	virtual UBOOL ProcessControlChar( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Determine whether the specified character should be displayed in the text field.
	 */
	virtual UBOOL IsValidCharacter( TCHAR Character ) const;

	/**
	 * Calculates the position of the first non-alphanumeric character that appears before the specified caret position.
	 *
	 * @param	StartingPosition	the location [index into UserText] to start searching.  If not specified, the
	 *								current caret position is used.  The character located at StartingPosition will
	 *								NOT be considered in the search.
	 *
	 * @return	an index into UserText for the location of the first non-alphanumeric character that appears
	 *			before the current caret position, or 0 if the beginning of the string is reached first.
	 */
	virtual INT FindPreviousCaretJumpPosition( INT StartingPosition=INDEX_NONE ) const;

	/**
	 * Calculates the position of the first non-alphanumeric character that appears after the current caret position.
	 *
	 * @param	StartingPosition	the location [index into UserText] to start searching.  If not specified, the
	 *								current caret position is used.  The character located at StartingPosition will
	 *								NOT be considered in the search.
	 *
	 * @return	an index into UserText for the location of the first non-alphanumeric character that appears
	 *			after the current caret position, or the length of the string if the end of the string is reached first.
	 */
	virtual INT FindNextCaretJumpPosition( INT StartingPosition=INDEX_NONE ) const;

public:
	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the BackgroundImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Called whenever the editbox's text is modified.  Activates the TextValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Render this editbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	void Render_Widget( FCanvas* Canvas );

protected:
	/* === UUIScreenObject interface === */
	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:

	/**
	 * Initializes the button and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bZeroOrigin, bClampValues);
	}

	/**
	 * Adds the specified character to the editbox's text field, if the text field is currently eligible to receive
	 * new characters
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, TCHAR Character );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated EditBoxBackground
	 * and Coordinates properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUINumericEditBox : public UUIEditBox
{
public:
    //## BEGIN PROPS UINumericEditBox
    struct FUIStyleReference IncrementStyle;
    struct FUIStyleReference DecrementStyle;
    class UUINumericEditBoxButton* IncrementButton;
    class UUINumericEditBoxButton* DecrementButton;
    struct FUIRangeData NumericValue;
    INT DecimalPlaces;
    struct FUIScreenValue_Bounds IncButton_Position;
    struct FUIScreenValue_Bounds DecButton_Position;
    //## END PROPS UINumericEditBox

    void IncrementValue(class UUIScreenObject* Sender,INT PlayerIndex);
    void DecrementValue(class UUIScreenObject* Sender,INT PlayerIndex);
    UBOOL SetNumericValue(FLOAT NewValue,UBOOL bForceRefreshString=FALSE);
    FLOAT GetNumericValue() const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execIncrementValue)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        IncrementValue(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDecrementValue)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DecrementValue(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execSetNumericValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bForceRefreshString,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetNumericValue(NewValue,bForceRefreshString);
    }
    DECLARE_FUNCTION(execGetNumericValue)
    {
        P_FINISH;
        *(FLOAT*)Result=GetNumericValue();
    }
    DECLARE_CLASS(UUINumericEditBox,UUIEditBox,0,Engine)
	/**
	 * Initializes the buttons and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Render this editbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	void Render_Widget( FCanvas* Canvas );

	/**
	 * Called whenever the user presses enter while this editbox is focused.  Activated the SubmitText kismet event and calls the
	 * OnSubmitText delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 */
	virtual void NotifySubmitText( INT PlayerIndex=INDEX_NONE );

	/**
	 * Evaluates the value string of the string component to verify that it is a legit numeric value.
	 */
	UBOOL ValidateNumericInputString();

protected:

	/**
	 * Determine whether the specified character should be displayed in the text field.
	 */
	virtual UBOOL IsValidCharacter( TCHAR Character ) const;

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );
};

class UUIImage : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIImage
    struct FUIDataStoreBinding ImageDataSource;
    class UUIComp_DrawImage* ImageComponent;
    class UUITexture* Image;
    struct FTextureCoordinates Coordinates;
    //## END PROPS UIImage

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_CLASS(UUIImage,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/*=== UUIImage interface === */
	/**
	 * Changes this UIImage's Image to the specified surface, creating a wrapper for the surface
	 * (if necessary) and applies the current ImageStyle to the new wrapper.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetValue( USurface* NewImage );

	/* === UIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the ImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	// UUIScreenObject interface.
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated Image & Coordinates
	 * properties over to the ImageComponent.
	 */
	virtual void PostLoad();

	/**
	 * We overload AnimSetColor to set the color override
	 */
	virtual void AnimSetColor(FLinearColor NewColor);

};

class UUILabel : public UUIObject, public IUIDataStoreSubscriber, public IUIStringRenderer
{
public:
    //## BEGIN PROPS UILabel
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawString* StringRenderComponent;
    class UUIComp_DrawImage* LabelBackground;
    //## END PROPS UILabel

    void SetValue(const FString& NewText);
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(NewText);
        P_FINISH;
        SetValue(NewText);
    }
    DECLARE_FUNCTION(execSetTextAlignment)
    {
        P_GET_BYTE(Horizontal);
        P_GET_BYTE(Vertical);
        P_FINISH;
        SetTextAlignment(Horizontal,Vertical);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_CLASS(UUILabel,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
    virtual UObject* GetUObjectInterfaceUIStringRenderer(){return this;}
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bZeroOrigin, bClampValues);
	}

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates the PrimaryStyle for this label over to the label's component.
	 */
	virtual void PostLoad();

	/**
	 * We overload AnimSetColor to set the color override
	 */
	virtual void AnimSetColor(FLinearColor NewColor);


};

struct UIToolTip_eventDeactivateToolTip_Parms
{
    UBOOL ReturnValue;
    UIToolTip_eventDeactivateToolTip_Parms(EEventParm)
    {
    }
};
struct UIToolTip_eventActivateToolTip_Parms
{
    class UUIToolTip* ReturnValue;
    UIToolTip_eventActivateToolTip_Parms(EEventParm)
    {
    }
};
class UUIToolTip : public UUILabel
{
public:
    //## BEGIN PROPS UIToolTip
    BITFIELD bPendingPositionUpdate:1;
    BITFIELD bResolveToolTipPosition:1;
    FLOAT SecondsActive;
    BITFIELD bFollowCursor:1;
    BITFIELD bAutoHideOnInput:1;
    FScriptDelegate __ActivateToolTip__Delegate;
    FScriptDelegate __DeactivateToolTip__Delegate;
    //## END PROPS UIToolTip

    class UUIToolTip* BeginTracking();
    UBOOL EndTracking();
    void UpdateToolTipPosition();
    DECLARE_FUNCTION(execBeginTracking)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=BeginTracking();
    }
    DECLARE_FUNCTION(execEndTracking)
    {
        P_FINISH;
        *(UBOOL*)Result=EndTracking();
    }
    DECLARE_FUNCTION(execUpdateToolTipPosition)
    {
        P_FINISH;
        UpdateToolTipPosition();
    }
    UBOOL delegateDeactivateToolTip()
    {
        UIToolTip_eventDeactivateToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessDelegate(ENGINE_DeactivateToolTip,&__DeactivateToolTip__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIToolTip* delegateActivateToolTip()
    {
        UIToolTip_eventActivateToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessDelegate(ENGINE_ActivateToolTip,&__ActivateToolTip__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIToolTip,UUILabel,0,Engine)
	/** === UUIToolTip interface === */
	/**
	 * Updates SecondsActive, hiding or showing the tooltip when appropriate.
	 */
	virtual void TickToolTip( FLOAT DeltaTime );

	/**
	 * Sets this tool-tip's displayed text to the resolved value of the specified data store binding.
	 */
	virtual void LinkBinding( struct FUIDataStoreBinding* ToolTipBinding );

	/**
	 * Resolves the tool tip's Position values into pixel values and formats the tool tip string, if bPendingPositionUpdate is TRUE.
	 */
	virtual void ResolveToolTipPosition();

	/**
	 * Determines the best X position for the tooltip, based on the tool-tip's width and the current mouse position
	 */
	FLOAT GetIdealLeft() const;

	/**
	 * Determines the best Y position for the tooltip, based on the tool-tip's height and the current mouse position
	 */
	FLOAT GetIdealTop() const;

	/**
	 * Calculates the best possible Y location for the tool-tip, ensuring this position is above the current mouse position.
	 */
	FLOAT CalculateBestPositionAboveCursor() const;

	/**
	 * Calculates the best possible Y location for the tool-tip, ensuring this position is below the current mouse position.
	 */
	FLOAT CalculateBestPositionBelowCursor() const;

	/** === UUIScreenObject interface === */
	/**
	 * Overridden to prevent any of this widget's inherited methods or components from triggering a scene update, as tooltip
	 * positions are updated differently.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );
};

struct FCellHitDetectionInfo
{
    INT HitColumn;
    INT HitRow;
    INT ResizeColumn;
    INT ResizeRow;

	/** Constructors */
	FCellHitDetectionInfo() {}
	FCellHitDetectionInfo(EEventParm)
	{
		appMemzero(this, sizeof(FCellHitDetectionInfo));
	}

};

#define UCONST_ResizeBufferPixels 5

struct UIList_eventOnListElementsSorted_Parms
{
    class UUIList* Sender;
    UIList_eventOnListElementsSorted_Parms(EEventParm)
    {
    }
};
struct UIList_eventOnSubmitSelection_Parms
{
    class UUIList* Sender;
    INT PlayerIndex;
    UIList_eventOnSubmitSelection_Parms(EEventParm)
    {
    }
};
class UUIList : public UUIObject, public IUIDataStorePublisher, public ICustomPropertyItemHandler
{
public:
    //## BEGIN PROPS UIList
    struct FUIScreenValue_Extent RowHeight;
    struct FUIScreenValue_Extent ColumnWidth;
    struct FUIScreenValue_Extent CellSpacing;
    struct FUIScreenValue_Extent CellPadding;
    INT Index;
    INT TopIndex;
    INT MaxVisibleItems;
protected:
    INT ColumnCount;
    INT RowCount;
public:
    BYTE ColumnAutoSizeMode;
    BYTE RowAutoSizeMode;
    BYTE CellLinkType;
    BYTE WrapType;
    BITFIELD bEnableMultiSelect:1 GCC_BITFIELD_MAGIC;
    BITFIELD bEnableVerticalScrollbar:1;
    BITFIELD bInitializeScrollbars:1;
    BITFIELD bAllowDisabledItemSelection:1;
    BITFIELD bSingleClickSubmission:1;
private:
    BITFIELD bUpdateItemUnderCursor:1;
public:
    class UUIScrollbar* VerticalScrollbar;
    struct FUIStyleReference GlobalCellStyle[4];
    struct FUIStyleReference ColumnHeaderStyle;
    struct FUIStyleReference SelectionOverlayStyle;
    struct FUIStyleReference ItemOverlayStyle[4];
    BITFIELD bDisplayDataBindings:1;
    INT ResizeColumn;
    BITFIELD bSortingList:1;
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    TArrayNoInit<INT> Items;
private:
    TArrayNoInit<INT> SelectedItems;
public:
    class UUIComp_ListElementSorter* SortComponent;
    class UUIComp_ListPresenter* CellDataComponent;
    FName SubmitDataSuccessCue;
    FName SubmitDataFailedCue;
    FName DecrementIndexCue;
    FName IncrementIndexCue;
    FName SortAscendingCue;
    FName SortDescendingCue;
    FScriptDelegate __OnSubmitSelection__Delegate;
    FScriptDelegate __OnListElementsSorted__Delegate;
    //## END PROPS UIList

    UBOOL ScrollVertical(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE);
    virtual INT RemoveElement(INT ElementToRemove);
    virtual INT GetItemCount() const;
    virtual INT GetMaxVisibleElementCount() const;
    INT GetMaxNumVisibleRows() const;
    INT GetMaxNumVisibleColumns() const;
    INT GetTotalRowCount() const;
    INT GetTotalColumnCount() const;
    void SetColumnCount(INT NewColumnCount);
    void SetRowCount(INT NewRowCount);
    FLOAT GetColumnWidth(INT ColumnIndex=-1) const;
    virtual FLOAT GetRowHeight(INT RowIndex=-1) const;
    virtual FVector2D GetClientRegion() const;
    virtual INT CalculateIndexFromCursorLocation(UBOOL bRequireValidIndex=TRUE) const;
    TArray<INT> GetSelectedItems() const;
    INT GetCurrentItem() const;
    FString GetElementValue(INT ElementIndex,INT CellIndex=-1) const;
    virtual UBOOL SetIndex(INT NewIndex,UBOOL bClampValue=TRUE,UBOOL bSkipNotification=FALSE);
    virtual UBOOL SetTopIndex(INT NewTopIndex,UBOOL bClampValue=TRUE);
    UBOOL IsElementEnabled(INT ElementIndex);
    UBOOL CanSelectElement(INT ElementIndex);
    void SetHotTracking(UBOOL bShouldUpdateItemUnderCursor);
    UBOOL IsHotTrackingEnabled() const;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    UBOOL IsElementAutoSizingEnabled() const;
    DECLARE_FUNCTION(execScrollVertical)
    {
        P_GET_OBJECT(UUIScrollbar,Sender);
        P_GET_FLOAT(PositionChange);
        P_GET_UBOOL_OPTX(bPositionMaxed,FALSE);
        P_FINISH;
        *(UBOOL*)Result=ScrollVertical(Sender,PositionChange,bPositionMaxed);
    }
    DECLARE_FUNCTION(execRemoveElement)
    {
        P_GET_INT(ElementToRemove);
        P_FINISH;
        *(INT*)Result=RemoveElement(ElementToRemove);
    }
    DECLARE_FUNCTION(execGetItemCount)
    {
        P_FINISH;
        *(INT*)Result=GetItemCount();
    }
    DECLARE_FUNCTION(execGetMaxVisibleElementCount)
    {
        P_FINISH;
        *(INT*)Result=GetMaxVisibleElementCount();
    }
    DECLARE_FUNCTION(execGetMaxNumVisibleRows)
    {
        P_FINISH;
        *(INT*)Result=GetMaxNumVisibleRows();
    }
    DECLARE_FUNCTION(execGetMaxNumVisibleColumns)
    {
        P_FINISH;
        *(INT*)Result=GetMaxNumVisibleColumns();
    }
    DECLARE_FUNCTION(execGetTotalRowCount)
    {
        P_FINISH;
        *(INT*)Result=GetTotalRowCount();
    }
    DECLARE_FUNCTION(execGetTotalColumnCount)
    {
        P_FINISH;
        *(INT*)Result=GetTotalColumnCount();
    }
    DECLARE_FUNCTION(execSetColumnCount)
    {
        P_GET_INT(NewColumnCount);
        P_FINISH;
        SetColumnCount(NewColumnCount);
    }
    DECLARE_FUNCTION(execSetRowCount)
    {
        P_GET_INT(NewRowCount);
        P_FINISH;
        SetRowCount(NewRowCount);
    }
    DECLARE_FUNCTION(execGetColumnWidth)
    {
        P_GET_INT_OPTX(ColumnIndex,-1);
        P_FINISH;
        *(FLOAT*)Result=GetColumnWidth(ColumnIndex);
    }
    DECLARE_FUNCTION(execGetRowHeight)
    {
        P_GET_INT_OPTX(RowIndex,-1);
        P_FINISH;
        *(FLOAT*)Result=GetRowHeight(RowIndex);
    }
    DECLARE_FUNCTION(execGetClientRegion)
    {
        P_FINISH;
        *(FVector2D*)Result=GetClientRegion();
    }
    DECLARE_FUNCTION(execCalculateIndexFromCursorLocation)
    {
        P_GET_UBOOL_OPTX(bRequireValidIndex,TRUE);
        P_FINISH;
        *(INT*)Result=CalculateIndexFromCursorLocation(bRequireValidIndex);
    }
    DECLARE_FUNCTION(execGetResizeColumn);
    DECLARE_FUNCTION(execGetSelectedItems)
    {
        P_FINISH;
        *(TArray<INT>*)Result=GetSelectedItems();
    }
    DECLARE_FUNCTION(execGetCurrentItem)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentItem();
    }
    DECLARE_FUNCTION(execGetElementValue)
    {
        P_GET_INT(ElementIndex);
        P_GET_INT_OPTX(CellIndex,-1);
        P_FINISH;
        *(FString*)Result=GetElementValue(ElementIndex,CellIndex);
    }
    DECLARE_FUNCTION(execSetIndex)
    {
        P_GET_INT(NewIndex);
        P_GET_UBOOL_OPTX(bClampValue,TRUE);
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetIndex(NewIndex,bClampValue,bSkipNotification);
    }
    DECLARE_FUNCTION(execSetTopIndex)
    {
        P_GET_INT(NewTopIndex);
        P_GET_UBOOL_OPTX(bClampValue,TRUE);
        P_FINISH;
        *(UBOOL*)Result=SetTopIndex(NewTopIndex,bClampValue);
    }
    DECLARE_FUNCTION(execIsElementEnabled)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(UBOOL*)Result=IsElementEnabled(ElementIndex);
    }
    DECLARE_FUNCTION(execCanSelectElement)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(UBOOL*)Result=CanSelectElement(ElementIndex);
    }
    DECLARE_FUNCTION(execSetHotTracking)
    {
        P_GET_UBOOL(bShouldUpdateItemUnderCursor);
        P_FINISH;
        SetHotTracking(bShouldUpdateItemUnderCursor);
    }
    DECLARE_FUNCTION(execIsHotTrackingEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsHotTrackingEnabled();
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execIsElementAutoSizingEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=IsElementAutoSizingEnabled();
    }
    void delegateOnListElementsSorted(class UUIList* Sender)
    {
        UIList_eventOnListElementsSorted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_OnListElementsSorted,&__OnListElementsSorted__Delegate,&Parms);
    }
    void delegateOnSubmitSelection(class UUIList* Sender,INT PlayerIndex=0)
    {
        UIList_eventOnSubmitSelection_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnSubmitSelection,&__OnSubmitSelection__Delegate,&Parms);
    }
    DECLARE_CLASS(UUIList,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
    virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler(){return this;}
	friend class UUIComp_ListPresenter;

	/* === UUIList interface === */
	/**
	 * Resolves DataSource into the list element provider that it references.
	 *
	 * @return	a pointer to the list element provider indicated by DataSource, or NULL if it couldn't be resolved.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider();

	/**
	 * Changes the data binding for the specified cell index.
	 *
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader		the string that should be displayed in the column header for this cell.
	 * @param	BindingIndex		the column or row to bind this data field to.  If BindingIndex is greater than the number
	 *								schema cells, empty schema cells will be added to meet the number required to place the data
	 *								at BindingIndex.
	 *								If a value of INDEX_NONE is specified, the cell binding will only occur if there are no other
	 *								schema cells bound to that data field.  In this case, a new schema cell will be appended and
	 *								it will be bound to the data field specified.
	 */
	UBOOL SetCellBinding( FName CellDataBinding, const FString& ColumnHeader, INT BindingIndex );

	/**
	 * Inserts a new schema cell at the specified index and assigns the data binding.
	 *
	 * @param	InsertIndex			the column/row to insert the schema cell; must be a valid index.
	 * @param	CellDataBinding		a name corresponding to a tag from the UIListElementProvider currently bound to this list.
	 * @param	ColumnHeader	the string that should be displayed in the column header for this cell.
	 *
	 * @return	TRUE if the schema cell was successfully inserted into the list
	 */
	UBOOL InsertSchemaCell( INT InsertIndex, FName CellDataBinding, const FString& ColumnHeader );

	/**
	 * Removes all schema cells which are bound to the specified data field.
	 *
	 * @return	TRUE if one or more schema cells were successfully removed.
	 */
	UBOOL ClearCellBinding( FName CellDataBinding );

	/**
	 * Removes schema cells at the location specified.  If the list's columns are linked, this index should correspond to
	 * the column that should be removed; if the list's rows are linked, this index should correspond to the row that should
	 * be removed.
	 *
	 * @return	TRUE if the schema cell at BindingIndex was successfully removed.
	 */
	UBOOL ClearCellBinding( INT BindingIndex );

	/**
	 * Returns the menu state that should be used for rendering the specified element.  By default, returns the list's current
	 * menu state, but might return a different menu state in some special cases (for example, when specific elements should be
	 * rendered as though they were disabled)
	 *
	 * @param	ElementIndex	the index into the Items array for the element to retrieve the menu state for.
	 *
	 * @return	a pointer to the menu state that should be used for rendering the specified element; should correspond to one of the elements
	 *			of the UIList's InactiveStates array.
	 */
	UUIState* GetElementMenuState( INT ElementIndex );

	/**
	 * Refreshes the data for this list from the data store bound via DataSource.
	 *
	 * @param	bResolveDataSource	if TRUE, re-resolves DataSource into DataProvider prior to refilling the list's data
	 *
	 * @return	TRUE if the list data was successfully loaded; FALSE if the data source couldn't be resolved or it didn't
	 *			contain the data indicated by SourceData
	 */
	virtual UBOOL RefreshListData( UBOOL bResolveDataSource=FALSE );

	/**
	 * Retrieves the list of elements from the data provider and adds them to the list.
	 *
	 * @return	TRUE if the list was successfully populated.
	 */
	virtual UBOOL PopulateListElements();

	/**
	 * Inserts a new element into the list at the specified index
	 *
	 * @param	ElementToInsert		the index [into the data provider's data source array] of the element to insert.
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the element.  If the value is
	 *								not a valid index, the element will be added to the end of the list.
	 * @param	bSkipSorting		specify TRUE to prevent the list from being resorted after this element is added (useful when
	 *								adding items in bulk).
	 *
	 * @return	the index where the new element was inserted, or INDEX_NONE if the element wasn't added to the list.
	 */
	virtual INT InsertElement( INT ElementToInsert, INT InsertIndex=INDEX_NONE, UBOOL bSkipSorting=FALSE );

	/**
	 * Removes the element located at the specified index from the list.
	 *
	 * @param	RemovalIndex	the index for the element that should be removed from the list
	 *
	 * @return	the index [into the Items array] for the element that was removed, or INDEX_NONE if the element wasn't
	 *			part of the list.
	 */
	virtual INT RemoveElementAtIndex( INT RemovalIndex );

	/**
	 * Inserts multiple elements into the list at the specified index
	 *
	 * @param	ElementsToInsert	the elements to insert into the list
	 * @param	InsertIndex			an index in the range of 0 - Items.Num() to use for inserting the elements.  If the value is
	 *								not a valid index, the elements will be added to the end of the list.  Elements will be added
	 *								in the order they appear in the array, so ElementsToInsert(0) will be inserted at InsertIndex,
	 *								ElementsToInsert(1) will be inserted at InsertIndex+1, etc.
	 * @param	bSkipSorting		specify TRUE to prevent the list from being resorted after this element is added (useful when
	 *								adding items in bulk).
	 *
	 * @return	the number of elements that were added to the list
	 */
	virtual INT InsertElements( const TArray<INT>& ElementsToInsert, INT InsertIndex=INDEX_NONE, UBOOL bSkipSorting=FALSE );

	/**
	 * Removes the specified elements from the list.
	 *
	 * @param	ElementsToRemove	the elements to remove from the list (make sure this parameter creates a copy of the array, so
	 *								that the removal algorithm works correctly; i.e. don't change this to a const& for performance or something)
	 *
	 * @return	the number of elements that were removed from the list
	 */
	virtual INT RemoveElements( const TArray<INT>& ElementsToRemove );

	/**
	 * Clears all elements from the list.
	 */
	virtual void ClearElements();

	/**
	 * Moves the specified element by the specified number of items.
	 *
	 * @param	ElementToMove	the element to move. This is not an index into the Items array; rather, it is the value of an element
	 *							in the Items array, which corresponds to an index into data store collection this list is bound to.
	 * @param	MoveCount		the number of items to move the element.
	 *
	 * @param	TRUE if the element was moved successfully; FALSE otherwise
	 */
	virtual UBOOL MoveElement( INT ElementToMove, INT MoveCount );

	/**
	 * Moves the element at the specified index by the specified number of items.
	 *
	 * @param	ElementIndex	the index for the element to move.
	 * @param	MoveCount		the number of items to move the element.
	 *
	 * @param	TRUE if the element was moved successfully; FALSE otherwise
	 */
	virtual UBOOL MoveElementAtIndex( INT ElementIndex, INT MoveCount );

	/**
	 * Swaps the elements specified, reversing their positions in the Items array.
	 *
	 * @param	ElementA	the first element to swap. This is not an index into the Items array; rather, it is the value of an element
	 *						in the Items array, which corresponds to an index into data store collection this list is bound to.
	 * @param	ElementB	the second element to swap. This is not an index into the Items array; rather, it is the value of an element
	 *						in the Items array, which corresponds to an index into data store collection this list is bound to.
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElementsByValue( INT ElementA, INT ElementB );

	/**
	 * Swaps the values at the specified indexes, reversing their positions in the Items array.
	 *
	 * @param	IndexA	the index into the Items array for the first element to swap
	 * @param	IndexB	the index into the Items array for the second element to swap
	 *
	 * @param	TRUE if the swap was successful
	 */
	virtual UBOOL SwapElementsByIndex( INT IndexA, INT IndexB );

	/**
	 * Finds the index for the element specified
	 *
	 * @param	ElementToFind	the element to search for
	 *
	 * @return	the index [into the Items array] for the element specified, or INDEX_NONE if the element wasn't
	 *			part of the list.
	 */
	virtual INT FindElementIndex( INT ElementToFind ) const;

	/**
	 * Calculates the row/column location of the cursor.
	 *
	 * @param	HitLocation		the point to use for calculating the hit information.
	 * @param	out_HitInfo		receives the results of the calculation.  The row/column that was hit does not necessarily
	 *							correspond to an actual item in the list (i.e. the row/column may be higher than the actual
	 *							number of rows or columns).
	 *
	 * @return	TRUE if HitLocation was located inside this list.
	 */
	virtual UBOOL CalculateCellFromPosition( const FIntPoint& HitLocation, struct FCellHitDetectionInfo& out_HitInfo ) const;

	/**
	 * If the mouse is over a column boundary, returns the index of the column that would be resized, or INDEX_NONE if the mouse is not
	 * hovering over a column boundary.
	 *
	 * @param	CellHitDetectionInfo	will be filled with information about which cells the cursor is currently over
	 *
	 * @return	if the cursor is within ResizeBufferPixels of a column boundary, the index of the column the left of the cursor; INDEX_NONE
	 *			otherwise.
	 */
	virtual INT GetResizeColumn( struct FCellHitDetectionInfo* CellHitDetectionInfo=NULL ) const;


	/**
	 *	Initializes the vertical and horizontal scrollbars for the current state of the List
	 */
	void InitializeScrollbars();

	/**
	 *	Sets up the positions of scrollbar markers according to which items are currently visible
	 */
	void UpdateScrollbars();

protected:
	/**
	 * Utility function for modifying the index in response to keyboard or gamepad input.
	 *
	 * @param	bIncrementIndex		TRUE if the index should be increased, FALSE if the index should be decreased
	 * @param	bFullPage			TRUE to change the index by a full page, FALSE to change the index by 1
	 * @param	bHorizontalNavigation	TRUE if the user pressed right or left, FALSE if the user pressed up or down.
	 *
	 * @return	TRUE if the index was successfully changed
	 */
	virtual UBOOL NavigateIndex( UBOOL bIncrementIndex, UBOOL bFullPage, UBOOL bHorizontalNavigation );

public:
	/**
	 * Determines whether elements should render the names of the fields they're bound to.
	 *
	 * @return	TRUE if list elements should render the names for the data fields they're bound to, FALSE
	 *			if list elements should render the actual data for the list element they're associated with.
	 */
	UBOOL ShouldRenderDataBindings() const;

	/**
	 * Sets the selection state of the specified element.
	 *
	 * @param	ElementIndex	the index of the element to change selection state for
	 * @param	bSelected		TRUE to select the element, FALSE to unselect the element.
	 */
	void SelectElement( INT ElementIndex, UBOOL bSelected=TRUE );

	/**
	 * Called when the list's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	virtual void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );

	/**
	 * Called when the list's top item has changed
	 *
	 * @param	PreviousIndex	the list's TopIndex before it was changed
	 * @param	PlayerIndex		the index of the player that generated this change
	 */
	void NotifyTopIndexChanged( INT PreviousTopIndex, INT PlayerIndex );

	/**
	 * Called when the number of elements in this list is changed.
	 *
	 * @param	PreviousNumberOfItems	the number of items previously in the list
	 * @param	PlayerIndex				the index of the player that generated this change.
	 */
	void NotifyItemCountChanged( INT PreviousNumberOfItems, INT PlayerIndex );

	/**
	 * Called whenever the user chooses an item while this list is focused.  Activates the SubmitSelection kismet event and calls
	 * the OnSubmitSelection delegate.
	 */
	virtual void NotifySubmitSelection( INT PlayerIndex );

	/**
	 * Called after this list's elements have been sorted.  Synchronizes the list's Items array to the data component's elements array.
	 */
	virtual void NotifyListElementsSorted();

	/**
	 * Changes whether this list renders colum headers or not.  Only applicable if the owning list's CellLinkType is LINKED_Columns
	 */
	void EnableColumnHeaderRendering(UBOOL bShouldRenderColHeaders=TRUE)
	{
		if ( CellDataComponent != NULL )
		{
			CellDataComponent->EnableColumnHeaderRendering(bShouldRenderColHeaders);
		}
	}

	/**
	 * Returns whether this list should render column headers
	 */
	UBOOL ShouldRenderColumnHeaders() const
	{
		if ( CellDataComponent != NULL )
		{
			return CellDataComponent->ShouldRenderColumnHeaders();
		}

		return FALSE;
	}

	/* === UUIObject interface === */
	/**
	 * Render this list.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Called from UGameUISceneClient::UpdateMousePosition; provides a hook for widgets to respond to the precise cursor
	 * position.  Only called on the scene's ActiveControl if the ActiveControl's bEnableActiveCursorUpdates is TRUE and
	 * the mouse is currently over the widget.
	 *
	 * This version ensures that the element under the mouse is in the proper cell state, if bTrackMouse is true.
	 */
	virtual void NotifyMouseOver( const FVector2D& MousePos );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Change the value of bEnableActiveCursorUpdates to the specified value.
	 */
	virtual void SetActiveCursorUpdate( UBOOL bShouldReceiveCursorUpdates );

protected:

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( class UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState=NULL );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * Initializes the value of bDisplayDataBindings based on whether we're in the game or not.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( class UUIScene* inOwnerScene, class UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Removes the specified state from the screen object's state stack.
	 *
	 * @param	StateToRemove	the state to be removed
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the state was successfully removed, or if the state didn't exist in the widget's list of states;
	 *			false if the state overrode the request to be removed
	 */
	virtual UBOOL DeactivateState( UUIState* StateToRemove, INT PlayerIndex );

protected:
	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Processes input axis movement. Only called while the list is in the pressed state; resizes a column if ResizeColumn
	 * is a valid value.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Copies the values from the deprecated SelectionOverlayStyle property into the appropriate element of the ItemOverlayStyle array.
	 */
	virtual void PostLoad();

	/* === CustomPropertyItemHandler interface === */
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue );

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const UPropertyValue& PropertyValue );
};

struct FContextMenuItem
{
    class UUIContextMenu* OwnerMenu;
    struct FContextMenuItem* ParentItem;
    BYTE ItemType;
    FString ItemText;
    INT ItemId;

    /** Constructors */
    FContextMenuItem()
    : OwnerMenu(NULL)
    , ItemType(0)
    , ItemId(0)
    {}
    FContextMenuItem(EEventParm)
    {
        appMemzero(this, sizeof(FContextMenuItem));
    }
};

struct UIContextMenu_eventFindMenuItemIndex_Parms
{
    class UUIObject* Widget;
    FString ItemToFind;
    INT ReturnValue;
    UIContextMenu_eventFindMenuItemIndex_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventGetMenuItem_Parms
{
    class UUIObject* Widget;
    INT IndexToGet;
    FString out_MenuItem;
    UBOOL ReturnValue;
    UIContextMenu_eventGetMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventGetAllMenuItems_Parms
{
    class UUIObject* Widget;
    TArray<FString> out_MenuItems;
    UBOOL ReturnValue;
    UIContextMenu_eventGetAllMenuItems_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventRemoveMenuItemAtIndex_Parms
{
    class UUIObject* Widget;
    INT IndexToRemove;
    UBOOL ReturnValue;
    UIContextMenu_eventRemoveMenuItemAtIndex_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventRemoveMenuItem_Parms
{
    class UUIObject* Widget;
    FString ItemToRemove;
    UBOOL ReturnValue;
    UIContextMenu_eventRemoveMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventClearMenuItems_Parms
{
    class UUIObject* Widget;
    UBOOL ReturnValue;
    UIContextMenu_eventClearMenuItems_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventInsertMenuItem_Parms
{
    class UUIObject* Widget;
    FString Item;
    INT InsertIndex;
    UBOOL bAllowDuplicates;
    UBOOL ReturnValue;
    UIContextMenu_eventInsertMenuItem_Parms(EEventParm)
    {
    }
};
struct UIContextMenu_eventSetMenuItems_Parms
{
    class UUIObject* Widget;
    TArray<FString> NewMenuItems;
    UBOOL bClearExisting;
    INT InsertIndex;
    UBOOL ReturnValue;
    UIContextMenu_eventSetMenuItems_Parms(EEventParm)
    {
    }
};
class UUIContextMenu : public UUIList
{
public:
    //## BEGIN PROPS UIContextMenu
    class UUIObject* InvokingWidget;
    TArrayNoInit<struct FContextMenuItem> MenuItems;
    BITFIELD bResolvePosition:1;
    //## END PROPS UIContextMenu

    UBOOL IsActiveContextMenu() const;
    UBOOL Open(INT PlayerIndex=0);
    UBOOL Close(INT PlayerIndex=0);
    DECLARE_FUNCTION(execIsActiveContextMenu)
    {
        P_FINISH;
        *(UBOOL*)Result=IsActiveContextMenu();
    }
    DECLARE_FUNCTION(execOpen)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=Open(PlayerIndex);
    }
    DECLARE_FUNCTION(execClose)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=Close(PlayerIndex);
    }
    INT eventFindMenuItemIndex(class UUIObject* Widget,const FString& ItemToFind)
    {
        UIContextMenu_eventFindMenuItemIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.ItemToFind=ItemToFind;
        ProcessEvent(FindFunctionChecked(ENGINE_FindMenuItemIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetMenuItem(class UUIObject* Widget,INT IndexToGet,FString& out_MenuItem)
    {
        UIContextMenu_eventGetMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.IndexToGet=IndexToGet;
        Parms.out_MenuItem=out_MenuItem;
        ProcessEvent(FindFunctionChecked(ENGINE_GetMenuItem),&Parms);
        out_MenuItem=Parms.out_MenuItem;
        return Parms.ReturnValue;
    }
    UBOOL eventGetAllMenuItems(class UUIObject* Widget,TArray<FString>& out_MenuItems)
    {
        UIContextMenu_eventGetAllMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.out_MenuItems=out_MenuItems;
        ProcessEvent(FindFunctionChecked(ENGINE_GetAllMenuItems),&Parms);
        out_MenuItems=Parms.out_MenuItems;
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveMenuItemAtIndex(class UUIObject* Widget,INT IndexToRemove)
    {
        UIContextMenu_eventRemoveMenuItemAtIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.IndexToRemove=IndexToRemove;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveMenuItemAtIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemoveMenuItem(class UUIObject* Widget,const FString& ItemToRemove)
    {
        UIContextMenu_eventRemoveMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.ItemToRemove=ItemToRemove;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveMenuItem),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventClearMenuItems(class UUIObject* Widget)
    {
        UIContextMenu_eventClearMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        ProcessEvent(FindFunctionChecked(ENGINE_ClearMenuItems),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInsertMenuItem(class UUIObject* Widget,const FString& Item,INT InsertIndex=-1,UBOOL bAllowDuplicates=FALSE)
    {
        UIContextMenu_eventInsertMenuItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.Item=Item;
        Parms.InsertIndex=InsertIndex;
        Parms.bAllowDuplicates=bAllowDuplicates ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertMenuItem),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetMenuItems(class UUIObject* Widget,const TArray<FString>& NewMenuItems,UBOOL bClearExisting=TRUE,INT InsertIndex=-1)
    {
        UIContextMenu_eventSetMenuItems_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Widget=Widget;
        Parms.NewMenuItems=NewMenuItems;
        Parms.bClearExisting=bClearExisting ? FIRST_BITFIELD : FALSE;
        Parms.InsertIndex=InsertIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMenuItems),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIContextMenu,UUIList,0,Engine)
	/**
	 * Resolves this context menu's position into actual pixel values.
	 */
	virtual void ResolveContextMenuPosition();

	/** === UUIList interface === */
	/**
	 * Called whenever the user chooses an item while this list is focused.  Activates the SubmitSelection kismet event and calls
	 * the OnSubmitSelection delegate.
	 */
	virtual void NotifySubmitSelection( INT PlayerIndex );

	/* === UIObject interface === */
protected:
	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Handles input events for this context menu.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/** === UUIScreenObject interface === */
	/**
	 * Overridden to prevent any of this widget's inherited methods or components from triggering a scene update, as context menu
	 * positions are updated differently.
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );
};

class UUIMeshWidget : public UUIObject
{
public:
    //## BEGIN PROPS UIMeshWidget
    class UStaticMeshComponent* Mesh;
    //## END PROPS UIMeshWidget

    DECLARE_CLASS(UUIMeshWidget,UUIObject,0,Engine)
	/* === UUIObject interface === */
	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene );

	/* === UUIScreenObject interface === */
	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );
};

#define UCONST_UIKEY_MoveCursorRight UIKEY_MoveCursorRight
#define UCONST_UIKEY_MoveCursorLeft UIKEY_MoveCursorLeft

struct UIOptionListBase_eventCreateCustomIncrementButton_Parms
{
    class UUIOptionListBase* ButtonOwner;
    class UUIOptionListButton* ReturnValue;
    UIOptionListBase_eventCreateCustomIncrementButton_Parms(EEventParm)
    {
    }
};
struct UIOptionListBase_eventCreateCustomDecrementButton_Parms
{
    class UUIOptionListBase* ButtonOwner;
    class UUIOptionListButton* ReturnValue;
    UIOptionListBase_eventCreateCustomDecrementButton_Parms(EEventParm)
    {
    }
};
class UUIOptionListBase : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIOptionListBase
    struct FUIStyleReference DecrementStyle;
    struct FUIStyleReference IncrementStyle;
    class UUIOptionListButton* DecrementButton;
    class UUIOptionListButton* IncrementButton;
    class UClass* OptionListButtonClass;
    struct FUIScreenValue_Extent ButtonSpacing;
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawString* StringRenderComponent;
    FName IncrementCue;
    FName DecrementCue;
    BITFIELD bWrapOptions:1;
    struct FUIDataStoreBinding DataSource;
    FScriptDelegate __CreateCustomDecrementButton__Delegate;
    FScriptDelegate __CreateCustomIncrementButton__Delegate;
    //## END PROPS UIOptionListBase

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    virtual UBOOL HasPrevValue() const;
    virtual UBOOL HasNextValue() const;
    virtual void OnMoveSelectionLeft(INT PlayerIndex);
    virtual void OnMoveSelectionRight(INT PlayerIndex);
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execHasPrevValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasPrevValue();
    }
    DECLARE_FUNCTION(execHasNextValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasNextValue();
    }
    DECLARE_FUNCTION(execOnMoveSelectionLeft)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        OnMoveSelectionLeft(PlayerIndex);
    }
    DECLARE_FUNCTION(execOnMoveSelectionRight)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        OnMoveSelectionRight(PlayerIndex);
    }
    class UUIOptionListButton* delegateCreateCustomIncrementButton(class UUIOptionListBase* ButtonOwner)
    {
        UIOptionListBase_eventCreateCustomIncrementButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomIncrementButton,&__CreateCustomIncrementButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    class UUIOptionListButton* delegateCreateCustomDecrementButton(class UUIOptionListBase* ButtonOwner)
    {
        UIOptionListBase_eventCreateCustomDecrementButton_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ButtonOwner=ButtonOwner;
        ProcessDelegate(ENGINE_CreateCustomDecrementButton,&__CreateCustomDecrementButton__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIOptionListBase,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
protected:
	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent() PURE_VIRTUAL(UUIOptionListBase::UpdateStringComponent,);

public:
	/**
	 * Creates the support controls which make up the list button - the left button and the right button.
	 */
	virtual void CreateInternalControls();

	/**
	 * Sends the appropriate event when the NotifyValueChanged function is called.
	 */
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags ) {}

	/* === UUIObject interface === */
	/**
	 * Called whenever the value of the slider is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/* === UUIScreenObject interface === */
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UObject interface === */
	/**
	 * Called just before just object is saved to disk.  Clears all references to the internal buttons.
	 */
	virtual void PreSave();

	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UUINumericOptionList : public UUIOptionListBase
{
public:
    //## BEGIN PROPS UINumericOptionList
    struct FUIRangeData RangeValue;
    //## END PROPS UINumericOptionList

    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUINumericOptionList,UUIOptionListBase,0,Engine)
protected:
	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent();

public:
	/**
	 * @return	TRUE if the user is allowed to decrement the value of this widget
	 */
	virtual UBOOL HasPrevValue() const;
	/**
	 * @return	TRUE if the user is allowed to increment the value of this widget
	 */
	virtual UBOOL HasNextValue() const;

	/** Moves the current selection to the left. */
	virtual void OnMoveSelectionLeft(INT PlayerIndex);

	/** Moves the current selection to the right. */
	virtual void OnMoveSelectionRight(INT PlayerIndex);

	/**
	* Sends the appropriate event when the NotifyValueChanged function is called.
	*/
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/* === UUIDataStoreSubscriber interface === */
	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/* === UUIDataStorePublisher interface === */
	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);
};

class UUIOptionList : public UUIOptionListBase
{
public:
    //## BEGIN PROPS UIOptionList
    INT CurrentIndex;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    //## END PROPS UIOptionList

    UBOOL GetListValue(INT ListIndex,FString& OutValue);
    virtual void SetPrevValue();
    virtual void SetNextValue();
    virtual INT GetCurrentIndex() const;
    virtual void SetCurrentIndex(INT NewIndex);
    DECLARE_FUNCTION(execGetListValue)
    {
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetListValue(ListIndex,OutValue);
    }
    DECLARE_FUNCTION(execSetPrevValue)
    {
        P_FINISH;
        SetPrevValue();
    }
    DECLARE_FUNCTION(execSetNextValue)
    {
        P_FINISH;
        SetNextValue();
    }
    DECLARE_FUNCTION(execGetCurrentIndex)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentIndex();
    }
    DECLARE_FUNCTION(execSetCurrentIndex)
    {
        P_GET_INT(NewIndex);
        P_FINISH;
        SetCurrentIndex(NewIndex);
    }
    DECLARE_CLASS(UUIOptionList,UUIOptionListBase,0,Engine)
	/**
	 * Resolves DataSource into the list element provider that it references.
	 */
	virtual void ResolveListElementProvider();

protected:
	/* === UUIOptionList interface === */
	/** @return Returns the number of possible values for the field we are bound to. */
	INT GetNumValues() const;

	/* === UUIOptionListBase interface === */
	/**
	 * Updates the string component with the current value of the optionlist.
	 */
	virtual void UpdateStringComponent();

public:
	/**
	 * @return	TRUE if the user is allowed to decrement the value of this widget
	 */
	virtual UBOOL HasPrevValue() const;
	/**
	 * @return	TRUE if the user is allowed to increment the value of this widget
	 */
	virtual UBOOL HasNextValue() const;

	/** Moves the current selection to the left. */
	virtual void OnMoveSelectionLeft(INT PlayerIndex);

	/** Moves the current selection to the right. */
	virtual void OnMoveSelectionRight(INT PlayerIndex);

	/**
	* Sends the appropriate event when the NotifyValueChanged function is called.
	*/
	virtual void ActivateEventOnNotifyValueChanged( INT PlayerIndex, INT NotifyFlags );

	/* === UUIDataStoreSubscriber interface === */
	/**
	 * Resolves this subscriber's data store binding and updates the subscriber with the current value from the data store.
	 *
	 * @return	TRUE if this subscriber successfully resolved and applied the updated value.
	 */
	virtual UBOOL RefreshSubscriberValue(INT BindingIndex=INDEX_NONE);

	/* === UUIDataStorePublisher interface === */
	/**
	 * Resolves this subscriber's data store binding and publishes this subscriber's value to the appropriate data store.
	 *
	 * @param	out_BoundDataStores	contains the array of data stores that widgets have saved values to.  Each widget that
	 *								implements this method should add its resolved data store to this array after data values have been
	 *								published.  Once SaveSubscriberValue has been called on all widgets in a scene, OnCommit will be called
	 *								on all data stores in this array.
	 * @param	BindingIndex		optional parameter for indicating which data store binding is being requested for those
	 *								objects which have multiple data store bindings.  How this parameter is used is up to the
	 *								class which implements this interface, but typically the "primary" data store will be index 0.
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=INDEX_NONE);
};

struct FArchetypeInstancePair
{
    class UUIObject* WidgetArchetype;
    class UUIObject* WidgetInstance;
    FLOAT ArchetypeBounds[4];
    FLOAT InstanceBounds[4];

	/** Constructors */
	FArchetypeInstancePair()
	: WidgetArchetype(NULL), WidgetInstance(NULL)
	{
		appMemzero(ArchetypeBounds, sizeof(ArchetypeBounds));
		appMemzero(InstanceBounds, sizeof(InstanceBounds));
	}

	FArchetypeInstancePair( UUIObject* InArchetype, UUIObject* InInstance )
	: WidgetArchetype(InArchetype), WidgetInstance(InInstance)
	{
		appMemzero(ArchetypeBounds, sizeof(ArchetypeBounds));
		appMemzero(InstanceBounds, sizeof(InstanceBounds));
	}

	/** Comparison operators */
	inline UBOOL operator==( const FArchetypeInstancePair& Other ) const
	{
		return appMemcmp(this, &Other, sizeof(FArchetypeInstancePair)) == 0;
	}
	inline UBOOL operator!=( const FArchetypeInstancePair& Other ) const
	{
		return appMemcmp(this, &Other, sizeof(FArchetypeInstancePair)) != 0;
	}

	/** To allow this struct to be used as the key in a TMap */
	friend inline DWORD GetTypeHash( const FArchetypeInstancePair& Pair )
	{
		return PointerHash(Pair.WidgetArchetype, PointerHash(Pair.WidgetInstance));
	}

};

class UUIPrefab : public UUIObject
{
public:
    //## BEGIN PROPS UIPrefab
    INT PrefabVersion;
private:
    INT InternalPrefabVersion;
public:
    class UTexture2D* PrefabPreview;
    INT ModificationCounter;
    //## END PROPS UIPrefab

    DECLARE_CLASS(UUIPrefab,UUIObject,0,Engine)
	/* === UUIPrefab interface === */
	/**
	 * Creates archetypes for the specified widgets and adds the archetypes to this UIPrefab.
	 *
	 * @param	WidgetPairs				[in]	the widgets to create archetypes for, along with their screen positions (in pixels)
	 *									[out]	receives the list of archetypes that were created from the WidgetInstances
	 *
	 * @return	TRUE if archetypes were created and added to this UI archetype successfully.  FALSE if this UIPrefab
	 *			is not an archetype, if the widgets specified are already archetypes, or couldn't other
	 *			be created.
	 */
	UBOOL CreateWidgetArchetypes( TArray<struct FArchetypeInstancePair>& WidgetPairs, const FBox& BoundingRegion );

	/**
	 * Generates a name for the widget specified in the format 'WidgetClass_Arc_##', where ## corresponds to the number of widgets of that
	 * class already contained by this wrapper (though not completely representative, since other widget of that class may have been previously
	 * removed).
	 *
	 * @param	WidgetTypeCounts	contains the number of widgets of each class contained by this wrapper
	 * @param	WidgetInstance		the widget class to generate a unique archetype name for
	 *
	 * @return	a widget archetype name guaranteed to be unique within the scope of this wrapper.
	 */
	FName GenerateUniqueArchetypeName( TMap<UClass*,INT>& WidgetTypeCounts, UClass* WidgetClass ) const;

	/**
	 * Creates an instance of this UIPrefab; does NOT add the new UIPrefabInstance to the specified DestinationOwner's
	 * Children array.
	 *
	 * @param	DestinationOwner	the widget to use as the parent for the new PrefabInstance
	 * @param	DestinationName		the name to use for the new PrefabInstance.
	 *
	 * @return	a pointer to a UIPrefabInstance created from this UIPrefab
	 */
	class UUIPrefabInstance* InstancePrefab( UUIScreenObject* DestinationOwner, FName DestinationName );

	/**
	 * Notifies all instances of this UIPrefab to serialize their current property values against this UIPrefab.
	 * Called just before something is modified in a widget contained in this UIPrefab.
	 */
	void SavePrefabInstances();

	/**
	 * Notifies all instances of this UIPrefab to re-initialize and reload their property data.  Called just after
	 * something is modified in a widget contained in this UIPrefab.
	 */
	void LoadPrefabInstances();

	/**
	 * Remaps object references within the specified set of objects.  Iterates through the specified map, applying an
	 * FReplaceObjectReferences archive to each value in the map, using the map itself as the replacement map.
	 *
	 * @param	ReplacementMap		map of archetype => instances or instances => archetypes to use for replacing object
	 *								references
	 * @param	bNullPrivateRefs	should we null references to any private objects
	 * @param	SourceObjects		if specified, applies the replacement archive on these objects instead of the values (objects)
	 *								in the ReplacementMap.
	 */
	static void ConvertObjectReferences( TMap<UObject*,UObject*>& ReplacementMap, UBOOL bNullPrivateRefs, TArray<UObject*>* SourceObjects=NULL );

	/* === UIObject interface === */
	/**
	 * UIPrefabs don't render anything.
	 */
	virtual void Render_Widget(FCanvas*) {}

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Determines whether to change the Outer of this widget if the widget's Owner doesn't match it's Outer.
	 */
	virtual UBOOL RequiresParentForOuter() const { return FALSE; }

	/* === UObject interface === */
	/**
	 * Called just before just object is saved to disk.  Updates the value of InternalPrefabVersion to match PrefabVersion,
	 * and prevents the sequence objects contained in this prefab from being marked RF_NotForServer|RF_NotForClient.
	 */
	virtual void PreSave();

	/**
	 * Note that the object has been modified.  If we are currently recording into the
	 * transaction buffer (undo/redo), save a copy of this object into the buffer and
	 * marks the package as needing to be saved.
	 *
	 * @param	bAlwaysMarkDirty	if TRUE, marks the package dirty even if we aren't
	 *								currently recording an active undo/redo transaction
	 */
	virtual void Modify( UBOOL bAlwaysMarkDirty=FALSE );

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser.
	 *
	 * This version prints the number of widgets contained in this prefab.
	 */
	virtual FString GetDesc();

	/**
	 * Builds a list of UIPrefabInstances which have this UIPrefab as their SourcePrefab.
	 *
	 * @param	Instances	receives the list of UIPrefabInstances which have this UIPrefab as their SourcePrefab.
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Increments the value of ModificationCounter.  If the previous value was 0, calls SavePrefabInstances.
	 * Called just before something is modified in a widget contained in this UIPrefab.
	 *
	 * @param	AffectedObjects		ignored
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Decrements the value of ModificationCounter.  If the new value is 0, calls LoadPrefabInstances.
	 * Called just after something is modified in a widget contained in this UIPrefab.
	 *
	 * @param	AffectedObjects		ignored
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );
};

class UUIPrefabInstance : public UUIObject
{
public:
    //## BEGIN PROPS UIPrefabInstance
    class UUIPrefab* SourcePrefab;
    INT PrefabInstanceVersion;
    TMap< UObject*,UObject* > ArchetypeToInstanceMap;
    INT PI_PackageVersion;
    INT PI_LicenseePackageVersion;
    INT PI_DataOffset;
    TArrayNoInit<BYTE> PI_Bytes;
    TArrayNoInit<class UObject*> PI_CompleteObjects;
    TArrayNoInit<class UObject*> PI_ReferencedObjects;
    TArrayNoInit<FString> PI_SavedNames;
    TMap< UObject*,INT > PI_ObjectMap;
    //## END PROPS UIPrefabInstance

    void DetachFromSourcePrefab();
    DECLARE_FUNCTION(execDetachFromSourcePrefab)
    {
        P_FINISH;
        DetachFromSourcePrefab();
    }
    DECLARE_CLASS(UUIPrefabInstance,UUIObject,0,Engine)
	/* === UIPrefabInstance interface === */
	/**
	 * Convert this prefab instance to look like the Prefab archetype version of it (by changing object refs to archetype refs and
	 * converting positions to local space). Then serialise it, so we only get things that are unique to this instance. We store this
	 * archive in the PrefabInstance.
	 */
	void SavePrefabDifferences();

private:
	/**
	 * Generates a list of all widget and sequence archetypes contained in the specified parent which have never been instanced into this
	 * UIPrefabInstance (and thus, have been newly added since this UIPrefabInstance was last saved), recursively.
	 *
	 * @param	ParentArchetype			a pointer to a widget archetype; must be contained within this UIPrefabInstance's SourcePrefab.
	 * @param	NewWidgetArchetypes		receives the list of archetype widgets contained within ParentArchetype which have never been instanced into this
	 *									UIPrefabInstance.
	 * @param	NewSequenceArchetypes	receives the list of sequence object archetypes contained within ParentArchetype which do not exist in this UIPrefabInstance;
	 *									will not include sequence objects contained in widgets that are also newly added.
	 */
	void FindNewArchetypes( class UUIObject* ParentArchetype, TArray<class UUIObject*>& NewWidgetArchetypes, TArray<class USequenceObject*>& NewSequenceArchetypes );

	/**
	 * Helper method for recursively finding sequence archetype objects which have been added since this UIPrefabInstance was last updated.
	 *
	 * @param	ParentArchetype			a pointer to a widget archetype; must be contained within this UIPrefabInstance's SourcePrefab.
	 * @param	SequenceToCheck			the sequence to search for new archetypes in
	 * @param	NewSequenceArchetypes	receives the list of sequence object archetypes which do not exist in this UIPrefabInstance
	 */
	void FindNewSequenceArchetypes( class UUIObject* ParentArchetype, class USequence* SequenceToCheck, TArray<class USequenceObject*>& NewSequenceArchetypes );

public:

	/**
	 * Reinitializes this UIPrefabInstance against its SourcePrefab.  The main purpose of this function (over standard archetype propagation)
	 * is to convert all inter-object references within the PrefabInstance into references to their archetypes.  This is the only way that
	 * changes to object references in a UIPrefab can be propagated to UIPrefabInstances, since otherwise the UIPrefabInstance would serialize
	 * those object references.
	 *
	 * This will destroy/create objects as necessary.
	 */
	void UpdateUIPrefabInstance();

	/**
	 * Iterates through the ArchetypeToInstanceMap and verifies that the archetypes for each of this PrefabInstance's actors exist.
	 * For any actors contained by this PrefabInstance that do not have a corresponding archetype, removes the actor from the
	 * ArchetypeToInstanceMap.  This is normally caused by adding a new actor to a PrefabInstance, updating the source Prefab, then loading
	 * a new map without first saving the package containing the updated Prefab.  When the original map is reloaded, though it contains
	 * an entry for the newly added actor, the source Prefab's linker does not contain an entry for the corresponding archetype.
	 *
	 * @return	TRUE if one or more archetypes were NULL; FALSE if each pair in the ArchetypeToInstanceMap was a valid 'Key'
	 */
	UBOOL HasMissingArchetypes();

	/** Copy information to a FUIPrefabUpdateArc from this PrefabInstance for updating a PrefabInstance with. */
	void CopyToArchive(FUIPrefabUpdateArc* InArc);

	/** Copy information from a FUIPrefabUpdateArc into this PrefabInstance for saving etc. */
	void CopyFromArchive( const FUIPrefabUpdateArc* InArc );

	/* === UIObject interface === */
	/**
	 * UIArchetype wrappers don't render anything.
	 */
	virtual void Render_Widget(FCanvas*) {}

	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UObject interface === */
	virtual void			Serialize(FArchive& Ar);
	virtual void			PreSave();

	/**
	 * Serializes the unrealscript property data located at Data.  When saving, only saves those properties which differ from the corresponding
	 * value in the specified 'DiffObject' (usually the object's archetype).
	 *
	 * @param	Ar				the archive to use for serialization
	 * @param	DiffObject		the object to use for determining which properties need to be saved (delta serialization);
	 *							if not specified, the ObjectArchetype is used
	 * @param	DefaultsCount	maximum number of bytes to consider for delta serialization; any properties which have an Offset+ElementSize greater
	 *							that this value will NOT use delta serialization when serializing data;
	 *							if not specified, the result of DiffObject->GetClass()->GetPropertiesSize() will be used.
	 */
	virtual void SerializeScriptProperties( FArchive& Ar, UObject* DiffObject=NULL, INT DiffCount=0 ) const;

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );
};

class UUIProgressBar : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UIProgressBar
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawImage* FillImageComponent;
    class UUIComp_DrawImage* OverlayImageComponent;
private:
    class UUITexture* Background;
    class UUITexture* BarFill;
    class UUITexture* Overlay;
    struct FTextureCoordinates BackgroundCoordinates;
    struct FTextureCoordinates BarFillCoordinates;
    struct FTextureCoordinates OverlayCoordinates;
    struct FUIStyleReference FillStyle;
    struct FUIStyleReference OverlayStyle;
public:
    BITFIELD bDrawOverlay:1;
    struct FUIDataStoreBinding DataSource;
    struct FUIRangeData ProgressBarValue;
    BYTE ProgressBarOrientation;
    //## END PROPS UIProgressBar

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUIProgressBar,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIProgressBar interface === */
	/**
	 * Changes the background image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the progressbar's background image
	 */
	void SetBackgroundImage( class USurface* NewBarImage );

	/**
	 * Changes the fill image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewFillImage		the new surface to use for the progressbar's marker
	 */
	void SetFillImage( class USurface* NewFillImage );

	/**
	 * Changes the overlay image for this progressbar, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewOverlayImage		the new surface to use for the progressbar's overlay image
	 */
	void SetOverlayImage( class USurface* NewOverlayImage );

	/**
	 * Returns the pixel extent of the progressbar fill based on the current progressbar value
	 */
	FLOAT GetBarFillExtent();

	/* === UIObject interface === */
	/**
	 * Called whenever the value of the progressbar is modified.  Activates the ProgressBarValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Render this progressbar.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated image values
	 * over to the corresponding components.
	 */
	virtual void PostLoad();
};

struct UIScrollbar_eventOnClickedScrollZone_Parms
{
    class UUIScrollbar* Sender;
    FLOAT PositionPerc;
    INT PlayerIndex;
    UIScrollbar_eventOnClickedScrollZone_Parms(EEventParm)
    {
    }
};
struct UIScrollbar_eventOnScrollActivity_Parms
{
    class UUIScrollbar* Sender;
    FLOAT PositionChange;
    UBOOL bPositionMaxed;
    UBOOL ReturnValue;
    UIScrollbar_eventOnScrollActivity_Parms(EEventParm)
    {
    }
};
class UUIScrollbar : public UUIObject
{
public:
    //## BEGIN PROPS UIScrollbar
    class UUIComp_DrawImage* BackgroundImageComponent;
private:
    class UUITexture* Background;
    struct FTextureCoordinates BackgroundCoordinates;
public:
    class UUIScrollbarButton* IncrementButton;
    class UUIScrollbarButton* DecrementButton;
    class UUIScrollbarMarkerButton* MarkerButton;
    struct FUIStyleReference IncrementStyle;
    struct FUIStyleReference DecrementStyle;
    struct FUIStyleReference MarkerStyle;
private:
    FLOAT NudgeValue;
public:
    FLOAT NudgeMultiplier;
private:
    FLOAT NudgePercent;
    FLOAT MarkerPosPercent;
    FLOAT MarkerSizePercent;
public:
    struct FUIScreenValue_Extent BarWidth;
    struct FUIScreenValue_Extent MinimumMarkerSize;
    struct FUIScreenValue_Extent ButtonsExtent;
    BYTE ScrollbarOrientation;
    BITFIELD bAddCornerPadding:1 GCC_BITFIELD_MAGIC;
    struct FUIScreenValue_Position MousePosition;
    FLOAT MousePositionDelta;
    BITFIELD bInitializeMarker:1;
    FScriptDelegate __OnScrollActivity__Delegate;
    FScriptDelegate __OnClickedScrollZone__Delegate;
    //## END PROPS UIScrollbar

    FLOAT GetMarkerButtonPosition() const;
    FLOAT GetScrollZoneWidth() const;
    void SetMarkerSize(FLOAT SizePercentage);
    void SetMarkerPosition(FLOAT PositionPercentage);
    void SetNudgeSizePercent(FLOAT NudgePercentage);
    void SetNudgeSizePixels(FLOAT NudgePixels);
    void EnableCornerPadding(UBOOL FlagValue);
    void ScrollIncrement(class UUIScreenObject* Sender,INT PlayerIndex);
    void ScrollDecrement(class UUIScreenObject* Sender,INT PlayerIndex);
    void DragScrollBegin(class UUIScreenObject* Sender,INT PlayerIndex);
    UBOOL DragScrollEnd(class UUIScreenObject* Sender,INT PlayerIndex);
    void DragScroll(class UUIScrollbarMarkerButton* Sender,INT PlayerIndex);
    DECLARE_FUNCTION(execGetMarkerButtonPosition)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMarkerButtonPosition();
    }
    DECLARE_FUNCTION(execGetScrollZoneExtent);
    DECLARE_FUNCTION(execGetScrollZoneWidth)
    {
        P_FINISH;
        *(FLOAT*)Result=GetScrollZoneWidth();
    }
    DECLARE_FUNCTION(execSetMarkerSize)
    {
        P_GET_FLOAT(SizePercentage);
        P_FINISH;
        SetMarkerSize(SizePercentage);
    }
    DECLARE_FUNCTION(execSetMarkerPosition)
    {
        P_GET_FLOAT(PositionPercentage);
        P_FINISH;
        SetMarkerPosition(PositionPercentage);
    }
    DECLARE_FUNCTION(execSetNudgeSizePercent)
    {
        P_GET_FLOAT(NudgePercentage);
        P_FINISH;
        SetNudgeSizePercent(NudgePercentage);
    }
    DECLARE_FUNCTION(execSetNudgeSizePixels)
    {
        P_GET_FLOAT(NudgePixels);
        P_FINISH;
        SetNudgeSizePixels(NudgePixels);
    }
    DECLARE_FUNCTION(execEnableCornerPadding)
    {
        P_GET_UBOOL(FlagValue);
        P_FINISH;
        EnableCornerPadding(FlagValue);
    }
    DECLARE_FUNCTION(execScrollIncrement)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        ScrollIncrement(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execScrollDecrement)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        ScrollDecrement(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScrollBegin)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DragScrollBegin(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScrollEnd)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=DragScrollEnd(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDragScroll)
    {
        P_GET_OBJECT(UUIScrollbarMarkerButton,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DragScroll(Sender,PlayerIndex);
    }
    void delegateOnClickedScrollZone(class UUIScrollbar* Sender,FLOAT PositionPerc,INT PlayerIndex)
    {
        UIScrollbar_eventOnClickedScrollZone_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PositionPerc=PositionPerc;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnClickedScrollZone,&__OnClickedScrollZone__Delegate,&Parms);
    }
    UBOOL delegateOnScrollActivity(class UUIScrollbar* Sender,FLOAT PositionChange,UBOOL bPositionMaxed=FALSE)
    {
        UIScrollbar_eventOnScrollActivity_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.PositionChange=PositionChange;
        Parms.bPositionMaxed=bPositionMaxed ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnScrollActivity,&__OnScrollActivity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIScrollbar,UUIObject,0,Engine)
	/* === UUIScrollbar interface === */
	/**
	 * Changes the background image for this slider.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's background image
	 */
	void SetBackgroundImage( USurface* NewBackgroundImage );

	/**
	 * Returns the size of the scroll-zone (the region between the decrement and increment buttons), along the same orientation as the scrollbar.
	 *
	 * @param	ScrollZoneStart	receives the value of the location of the beginning of the scroll zone, in pixels relative to the scrollbar.
	 *
	 * @return	the height (if the scrollbar's orientation is vertical) or width (if horizontal) of the region between the
	 *			increment and decrement buttons, in pixels.
	 *
	 * @note: noexport for handling the optional out parameter correctly.
	 */
	FLOAT GetScrollZoneExtent( FLOAT* ScrollZoneStart=NULL ) const;

	/**
	 * Verifies that marker can be moved by the given PositionChange value. If the PositionChange is too large
	 * and would cause the marker to extend beyond the increment or decrement buttons, then it will be clamped to a
	 * value by which will the marker can move and not extend beyond its bar region
	 */
	FLOAT GetClampedPositionChange(FLOAT PositionChange);

	/** Simple accessors */
	FLOAT GetNudgeValue() const			{ return NudgeValue; }
	FLOAT GetNudgePercent() const		{ return NudgePercent; }
	FLOAT GetMarkerPosPercent() const	{ return MarkerPosPercent; }
	FLOAT GetMarkerSizePercent() const	{ return MarkerSizePercent; }

	/**
	 * Returns TRUE if the inner faces of the decrement and increment buttons have both been resolved.
	 */
	UBOOL CanResolveScrollZoneExtent() const;

	/**
	 * Calls RefreshMarker() if the increment/decrement buttons' positions aren't up-to-date.
	 *
	 * @return	TRUE if RefreshMarker() was called.
	 */
	UBOOL ConditionalRefreshMarker();

	/**
	 * Sets a private flag to refresh the bound of the scrollbar
	 */
	void RefreshMarker();

	/**
	 *	Shifts the position of the marker button by the amount specified, clamps the PositionChange if it would extend the marker pass the increment/decrement buttons
	 *  the direction of shift is based on the sign of the PositionChange and the ScrollbarOrientation setting
	 *
	 *  @param	PositionChange	the amount of pixels that the marker widget will be shifted by, supply
	 *                          negative value to shift marker in opposite direction
	 */
	void UpdateMarkerPosition(FLOAT PositionChange);

	/**
	 * Sets up marker button position based on the value of MarkerPosPercent
	 */
	void ResolveMarkerPosition();

	/**
	 * Sets up marker button bounds based on the value of MarkerSizePercent
	 */
	void ResolveMarkerSize();

	/**
	 * Resolves the NudgeValue into actual pixels
	 */
	void ResolveNudgeSize();

	/**
	 * Responsible for handling of the marker dragging, it reads mouse position and slides the marker in the
	 * appropriate direction
	 */
	void ProcessDragging();

	/**
	 * Responsible for handling paging which is invoked by mouse clicks on the empty bar space
	 */
	void ScrollZoneClicked( const struct FInputEventParameters& EventParms );

	/**
	 * Function overwritten to autoposition the scrollbar within the owner widget
	 *
	 * @param	Face	the face that should be resolved
	 */
	void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Render this scrollbar.
	 *
	 * @param	RI	the FRenderInterface to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreRenderCallback();

protected:

	/**
	 * Initializes the button and creates the bar image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Sets up dock links between the scrollbar and its owner widget as well as child buttons of scrollbar.
	 * Docking links are used as a mechanism to autoposition the UUIScrollbar within its owner widget
	 *
	 * @param	bResetLinks		seting flag to TRUE will cause all existing links to be refreshed
	 */
	void SetupDocLinks( UBOOL bResetLinks = FALSE );

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated background
	 * image properties over to the BackgroundImageComponent.
	 */
	virtual void PostLoad();
};

class UUISlider : public UUIObject, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UISlider
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawImage* SliderBarImageComponent;
    class UUIComp_DrawImage* MarkerImageComponent;
private:
    class UUITexture* Background;
    class UUITexture* SliderBar;
    class UUITexture* Marker;
    struct FTextureCoordinates BackgroundCoordinates;
    struct FTextureCoordinates BarCoordinates;
    struct FTextureCoordinates MarkerCoordinates;
    struct FUIStyleReference BarStyle;
    struct FUIStyleReference MarkerStyle;
public:
    struct FUIDataStoreBinding DataSource;
    class UUIComp_DrawStringSlider* CaptionRenderComponent;
    struct FUIRangeData SliderValue;
private:
    FLOAT MinValue;
    FLOAT MaxValue;
    FLOAT CurrentValue;
    FLOAT NudgeValue;
    BITFIELD bIntValuesOnly:1;
public:
    BITFIELD bRenderCaption:1;
    BYTE SliderOrientation GCC_BITFIELD_MAGIC;
    struct FUIScreenValue_Extent BarSize;
    struct FUIScreenValue_Extent MarkerHeight;
    struct FUIScreenValue_Extent MarkerWidth;
    FName IncrementCue;
    FName DecrementCue;
    //## END PROPS UISlider

    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    UBOOL SetValue(FLOAT NewValue,UBOOL bPercentageValue=FALSE);
    FLOAT GetValue(UBOOL bPercentageValue=FALSE) const;
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_FLOAT(NewValue);
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetValue(NewValue,bPercentageValue);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bPercentageValue,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetValue(bPercentageValue);
    }
    DECLARE_CLASS(UUISlider,UUIObject,0,Engine)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUISlider interface === */
	/**
	 * Changes the background image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's background image
	 */
	void SetBackgroundImage( class USurface* NewBarImage );

	/**
	 * Changes the bar image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewBarImage		the new surface to use for the slider's bar image
	 */
	void SetBarImage( class USurface* NewBarImage );

	/**
	 * Changes the marker image for this slider, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewMarkerImage		the new surface to use for the slider's marker
	 */
	void SetMarkerImage( class USurface* NewMarkerImage );

	/**
	 * Returns the screen location (along the axis of the slider) for the marker, in absolute pixels.
	 */
	FLOAT GetMarkerPosition();

	/**
	 * Retrieves the location of the mouse within the bounding region of this slider, in percentage of the
	 * slider width (if orientation is horizontal) or height (if vertical).
	 *
	 * @param	out_Percentage	a value between 0.0 and 1.0 representing the percentage of the slider's size for the current
	 *							position of the mouse cursor.
	 *
	 * @return	TRUE if the cursor is within the bounding region of this slider.
	 */
	UBOOL GetCursorPosition( FLOAT& out_Percentage );

	/* === UUIObject interface === */
	/**
	 * Called whenever the value of the slider is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the image components (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/* === UUIScreenObject interface === */
	/**
	 * Initializes the button and creates the bar image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Render this slider.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	/**
	 * Handles input events for this slider.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Processes input axis movement. Only called while the slider is in the pressed state; handles adjusting the slider
	 * value and moving the marker to the appropriate position.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Transfers the old individual range values to the new UIRangeData struct and migrates values for the deprecated image values
	 * over to the corresponding components.
	 */
	virtual void PostLoad();
};

struct UITabControl_eventEnableTabPage_Parms
{
    class UUITabPage* PageToEnable;
    INT PlayerIndex;
    UBOOL bEnablePage;
    UBOOL bActivatePage;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventEnableTabPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivatePreviousPage_Parms
{
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL bAllowWrapping;
    UBOOL ReturnValue;
    UITabControl_eventActivatePreviousPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivateNextPage_Parms
{
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL bAllowWrapping;
    UBOOL ReturnValue;
    UITabControl_eventActivateNextPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventActivatePage_Parms
{
    class UUITabPage* PageToActivate;
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventActivatePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventReplacePage_Parms
{
    class UUITabPage* ExistingPage;
    class UUITabPage* NewPage;
    INT PlayerIndex;
    UBOOL bFocusPage;
    UBOOL ReturnValue;
    UITabControl_eventReplacePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventRemovePage_Parms
{
    class UUITabPage* PageToRemove;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UITabControl_eventRemovePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventInsertPage_Parms
{
    class UUITabPage* PageToInsert;
    INT PlayerIndex;
    INT InsertIndex;
    UBOOL bActivateImmediately;
    UBOOL ReturnValue;
    UITabControl_eventInsertPage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventPrivateActivatePage_Parms
{
    class UUITabPage* PageToActivate;
    INT PlayerIndex;
    UITabControl_eventPrivateActivatePage_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageRemoved_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* OldPage;
    INT PlayerIndex;
    UITabControl_eventOnPageRemoved_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageInserted_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* NewPage;
    INT PlayerIndex;
    UITabControl_eventOnPageInserted_Parms(EEventParm)
    {
    }
};
struct UITabControl_eventOnPageActivated_Parms
{
    class UUITabControl* Sender;
    class UUITabPage* NewlyActivePage;
    INT PlayerIndex;
    UITabControl_eventOnPageActivated_Parms(EEventParm)
    {
    }
};
class UUITabControl : public UUIObject
{
public:
    //## BEGIN PROPS UITabControl
protected:
    TArrayNoInit<class UUITabPage*> Pages;
public:
    class UUITabPage* ActivePage;
    class UUITabPage* PendingPage;
    BYTE TabDockFace;
    BYTE TabSizeMode;
    struct FUIScreenValue_Extent TabButtonSize;
    struct FUIScreenValue_Extent TabButtonPadding;
    struct FUIStyleReference TabButtonBackgroundStyle;
    struct FUIStyleReference TabButtonCaptionStyle;
    BITFIELD bAllowPagePreviews:1;
    FName ActivateTabCue;
    BITFIELD bUpdateLayout:1;
    FScriptDelegate __OnPageActivated__Delegate;
    FScriptDelegate __OnPageInserted__Delegate;
    FScriptDelegate __OnPageRemoved__Delegate;
    //## END PROPS UITabControl

    void RequestLayoutUpdate();
    INT GetPageCount() const;
    class UUITabPage* GetPageAtIndex(INT PageIndex) const;
    class UUITabButton* FindTargetedTab(INT PlayerIndex) const;
    virtual class UUITabPage* CreateTabPage(class UClass* TabPageClass,class UUITabPage* PagePrefab=NULL);
    DECLARE_FUNCTION(execRequestLayoutUpdate)
    {
        P_FINISH;
        RequestLayoutUpdate();
    }
    DECLARE_FUNCTION(execGetPageCount)
    {
        P_FINISH;
        *(INT*)Result=GetPageCount();
    }
    DECLARE_FUNCTION(execGetPageAtIndex)
    {
        P_GET_INT(PageIndex);
        P_FINISH;
        *(class UUITabPage**)Result=GetPageAtIndex(PageIndex);
    }
    DECLARE_FUNCTION(execFindTargetedTab)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(class UUITabButton**)Result=FindTargetedTab(PlayerIndex);
    }
    DECLARE_FUNCTION(execCreateTabPage)
    {
        P_GET_OBJECT(UClass,TabPageClass);
        P_GET_OBJECT_OPTX(UUITabPage,PagePrefab,NULL);
        P_FINISH;
        *(class UUITabPage**)Result=CreateTabPage(TabPageClass,PagePrefab);
    }
    UBOOL eventEnableTabPage(class UUITabPage* PageToEnable,INT PlayerIndex,UBOOL bEnablePage=TRUE,UBOOL bActivatePage=FALSE,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventEnableTabPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PageToEnable=PageToEnable;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bEnablePage=bEnablePage ? FIRST_BITFIELD : FALSE;
        Parms.bActivatePage=bActivatePage ? FIRST_BITFIELD : FALSE;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_EnableTabPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePreviousPage(INT PlayerIndex,UBOOL bFocusPage=TRUE,UBOOL bAllowWrapping=TRUE)
    {
        UITabControl_eventActivatePreviousPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        Parms.bAllowWrapping=bAllowWrapping ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePreviousPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivateNextPage(INT PlayerIndex,UBOOL bFocusPage=TRUE,UBOOL bAllowWrapping=TRUE)
    {
        UITabControl_eventActivateNextPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        Parms.bAllowWrapping=bAllowWrapping ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateNextPage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivatePage(class UUITabPage* PageToActivate,INT PlayerIndex,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventActivatePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PageToActivate=PageToActivate;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivatePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventReplacePage(class UUITabPage* ExistingPage,class UUITabPage* NewPage,INT PlayerIndex,UBOOL bFocusPage=TRUE)
    {
        UITabControl_eventReplacePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ExistingPage=ExistingPage;
        Parms.NewPage=NewPage;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bFocusPage=bFocusPage ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplacePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemovePage(class UUITabPage* PageToRemove,INT PlayerIndex)
    {
        UITabControl_eventRemovePage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PageToRemove=PageToRemove;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovePage),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInsertPage(class UUITabPage* PageToInsert,INT PlayerIndex,INT InsertIndex=-1,UBOOL bActivateImmediately=TRUE)
    {
        UITabControl_eventInsertPage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PageToInsert=PageToInsert;
        Parms.PlayerIndex=PlayerIndex;
        Parms.InsertIndex=InsertIndex;
        Parms.bActivateImmediately=bActivateImmediately ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertPage),&Parms);
        return Parms.ReturnValue;
    }
    void eventPrivateActivatePage(class UUITabPage* PageToActivate,INT PlayerIndex)
    {
        UITabControl_eventPrivateActivatePage_Parms Parms(EC_EventParm);
        Parms.PageToActivate=PageToActivate;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_PrivateActivatePage),&Parms);
    }
    void delegateOnPageRemoved(class UUITabControl* Sender,class UUITabPage* OldPage,INT PlayerIndex)
    {
        UITabControl_eventOnPageRemoved_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.OldPage=OldPage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageRemoved,&__OnPageRemoved__Delegate,&Parms);
    }
    void delegateOnPageInserted(class UUITabControl* Sender,class UUITabPage* NewPage,INT PlayerIndex)
    {
        UITabControl_eventOnPageInserted_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.NewPage=NewPage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageInserted,&__OnPageInserted__Delegate,&Parms);
    }
    void delegateOnPageActivated(class UUITabControl* Sender,class UUITabPage* NewlyActivePage,INT PlayerIndex)
    {
        UITabControl_eventOnPageActivated_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.NewlyActivePage=NewlyActivePage;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPageActivated,&__OnPageActivated__Delegate,&Parms);
    }
    DECLARE_CLASS(UUITabControl,UUIObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UITabControl interface === */
	/**
	 * Positions and resizes the tab buttons according the tab control's configuration.
	 */
	virtual void ReapplyLayout();

private:
	/**
	 * Set up the docking links between the tab control, buttons, and pages, based on the TabDockFace.
	 */
	void SetupDockingRelationships();

public:
	/* === UIObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Adds docking nodes for all faces of this widget to the specified scene
	 *
	 * @param	DockingStack	the docking stack to add this widget's docking.  Generally the scene's DockingStack.
	 *
	 * @return	TRUE if docking nodes were successfully added for all faces of this widget.
	 */
	virtual UBOOL AddDockingLink( TArray<struct FUIDockingNode>& DockingStack );

	/**
	 * Adds the specified face to the DockingStack for the specified widget.
	 *
	 * This version ensures that the tab buttons faces (and thus, the size of their captions) have already been resolved
	 * Only relevant when the TabSizeMode is TAST_Fill, because we must make sure that all buttons are at least wide enough
	 * to fit the largest caption of the group.
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Called when a style reference is resolved successfully.  Applies the TabButtonCaptionStyle and TabButtonBackgroundStyle
	 * to the tab buttons.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StylePropertyId			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StylePropertyId, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:
	/* === UUIScreenObject interface === */
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames( TArray<FName>& out_KeyNames );

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 *
	 * This version clears the navigation links between the tab buttons so that
	 */
	virtual void RebuildKeyboardNavigationLinks();

	/**
	 * Activates the focused state for this widget and sets it to be the focused control of its parent (if applicable)
	 *
	 * @param	Sender		Control that called SetFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the first focus target within this container.
	 *
	 * @param	Sender	the widget that generated the focus change.  if NULL, this widget generated the focus change.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if focus was successfully propagated to the first focus target within this container.
	 */
	virtual UBOOL FocusFirstControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the last focus target within this container.
	 *
	 * @param	Sender			the widget that generated the focus change.  if NULL, this widget generated the focus change.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if focus was successfully propagated to the last focus target within this container.
	 */
	virtual UBOOL FocusLastControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the next control in the tab order (relative to Sender) for widget.  If Sender is the last control in
	 * the tab order, propagates the call upwards to this widget's parent widget.
	 *
	 * @param	Sender			the widget to use as the base for determining which control to focus next
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if we successfully set focus to the next control in tab order.  FALSE if Sender was the last eligible
	 *			child of this widget or we couldn't otherwise set focus to another control.
	 */
	virtual UBOOL NextControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the previous control in the tab order (relative to Sender) for widget.  If Sender is the first control in
	 * the tab order, propagates the call upwards to this widget's parent widget.
	 *
	 * @param	Sender			the widget to use as the base for determining which control to focus next
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if we successfully set focus to the previous control in tab order.  FALSE if Sender was the first eligible
	 *			child of this widget or we couldn't otherwise set focus to another control.
	 */
	virtual UBOOL PrevControl(class UUIScreenObject* Sender,INT PlayerIndex=0);

	/**
	 * Sets focus to the widget bound to the navigation link for specified direction of the Sender.  This function
	 * is used for navigation between controls in scenes that support unbound (i.e. any direction) navigation.
	 *
	 * @param	Sender		Control that called NavigateFocus.  Possible values are:
	 *						-	if NULL is specified, it indicates that this is the first step in a focus change.  The widget will
	 *							attempt to set focus to its most eligible child widget.  If there are no eligible child widgets, this
	 *							widget will enter the focused state and start propagating the focus chain back up through the Owner chain
	 *							by calling SetFocus on its Owner widget.
	 *						-	if Sender is the widget's owner, it indicates that we are in the middle of a focus change.  Everything else
	 *							proceeds the same as if the value for Sender was NULL.
	 *						-	if Sender is a child of this widget, it indicates that focus has been successfully changed, and the focus is now being
	 *							propagated upwards.  This widget will now enter the focused state and continue propagating the focus chain upwards through
	 *							the owner chain.
	 * @param	Direction 		the direction to navigate focus.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 *
	 * @return	TRUE if the next child widget in the navigation network for the specified direction successfully received focus.
	 */
	virtual UBOOL NavigateFocus(class UUIScreenObject* Sender,BYTE Direction,INT PlayerIndex=0);

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

protected:
	/**
	 * Handles input events for this widget.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:

	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

struct UIScene_eventLogDockingStack_Parms
{
    UIScene_eventLogDockingStack_Parms(EEventParm)
    {
    }
};
struct UIScene_eventCalculateInputMask_Parms
{
    UIScene_eventCalculateInputMask_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneDeactivated_Parms
{
    UIScene_eventSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneActivated_Parms
{
    UBOOL bInitialActivation;
    UIScene_eventSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnTopSceneChanged_Parms
{
    class UUIScene* NewTopScene;
    UIScene_eventOnTopSceneChanged_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneDeactivated_Parms
{
    class UUIScene* DeactivatedScene;
    UIScene_eventOnSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneActivated_Parms
{
    class UUIScene* ActivatedScene;
    UBOOL bInitialActivation;
    UIScene_eventOnSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventGetSceneInputMode_Parms
{
    BYTE ReturnValue;
    UIScene_eventGetSceneInputMode_Parms(EEventParm)
    {
    }
};
class UUIScene : public UUIScreenObject
{
public:
    //## BEGIN PROPS UIScene
    FName SceneTag;
    class UUISceneClient* SceneClient;
    class USceneDataStore* SceneData;
    class ULocalPlayer* PlayerOwner;
private:
    class UUIToolTip* ActiveToolTip;
    class UUIToolTip* StandardToolTip;
public:
    class UClass* DefaultToolTipClass;
    class UUIContextMenu* ActiveContextMenu;
private:
    class UUIContextMenu* StandardContextMenu;
public:
    class UClass* DefaultContextMenuClass;
    TArrayNoInit<struct FUIDockingNode> DockingStack;
    TArrayNoInit<class UUIObject*> RenderStack;
    TMap< FName, TArray<struct FInputEventSubscription> > InputSubscriptions;
    INT LastPlayerIndex;
    BITFIELD bUpdateDockingStack:1;
    BITFIELD bUpdateScenePositions:1;
    BITFIELD bUpdateNavigationLinks:1;
    BITFIELD bUpdatePrimitiveUsage:1;
    BITFIELD bRefreshWidgetStyles:1;
    BITFIELD bRefreshStringFormatting:1;
    BITFIELD bIssuedPreRenderCallback:1;
    BITFIELD bUsesPrimitives:1;
    BITFIELD bDisplayCursor:1;
    BITFIELD bRenderParentScenes:1;
    BITFIELD bAlwaysRenderScene:1;
    BITFIELD bPauseGameWhileActive:1;
    BITFIELD bExemptFromAutoClose:1;
    BITFIELD bCloseOnLevelChange:1;
    BITFIELD bSaveSceneValuesOnClose:1;
    BITFIELD bEnableScenePostProcessing:1;
    class UTexture2D* ScenePreview;
    BYTE SceneInputMode;
    BYTE SceneRenderMode;
    FVector2D CurrentViewportSize;
    FName SceneOpenedCue;
    FName SceneClosedCue;
    class UUILayerBase* SceneLayerRoot;
    FScriptDelegate __GetSceneInputMode__Delegate;
    FScriptDelegate __OnSceneActivated__Delegate;
    FScriptDelegate __OnSceneDeactivated__Delegate;
    FScriptDelegate __OnTopSceneChanged__Delegate;
    //## END PROPS UIScene

    void RebuildDockingStack();
    void ResolveScenePositions();
    class USceneDataStore* GetSceneDataStore();
    void LoadSceneDataValues();
    void SaveSceneDataValues(UBOOL bUnbindSubscribers=FALSE);
    void UnbindSubscribers();
    class UUIDataStore* ResolveDataStore(FName DataStoreTag,class ULocalPlayer* InPlayerOwner=NULL);
    class UUIScene* GetPreviousScene(UBOOL bRequireMatchingPlayerOwner=TRUE);
    void SetSceneInputMode(BYTE NewInputMode);
    virtual class AWorldInfo* GetWorldInfo();
    UBOOL IsSceneActive(UBOOL bTopmostScene=FALSE) const;
    class UUIToolTip* GetDefaultToolTip();
    class UUIContextMenu* GetDefaultContextMenu();
    class UUIToolTip* GetActiveToolTip() const;
    UBOOL SetActiveToolTip(class UUIToolTip* NewToolTip);
    class UUIContextMenu* GetActiveContextMenu() const;
    UBOOL SetActiveContextMenu(class UUIContextMenu* NewContextMenu,INT PlayerIndex);
    DECLARE_FUNCTION(execRebuildDockingStack)
    {
        P_FINISH;
        RebuildDockingStack();
    }
    DECLARE_FUNCTION(execResolveScenePositions)
    {
        P_FINISH;
        ResolveScenePositions();
    }
    DECLARE_FUNCTION(execGetSceneDataStore)
    {
        P_FINISH;
        *(class USceneDataStore**)Result=GetSceneDataStore();
    }
    DECLARE_FUNCTION(execLoadSceneDataValues)
    {
        P_FINISH;
        LoadSceneDataValues();
    }
    DECLARE_FUNCTION(execSaveSceneDataValues)
    {
        P_GET_UBOOL_OPTX(bUnbindSubscribers,FALSE);
        P_FINISH;
        SaveSceneDataValues(bUnbindSubscribers);
    }
    DECLARE_FUNCTION(execUnbindSubscribers)
    {
        P_FINISH;
        UnbindSubscribers();
    }
    DECLARE_FUNCTION(execResolveDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,InPlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=ResolveDataStore(DataStoreTag,InPlayerOwner);
    }
    DECLARE_FUNCTION(execGetPreviousScene)
    {
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousScene(bRequireMatchingPlayerOwner);
    }
    DECLARE_FUNCTION(execSetSceneInputMode)
    {
        P_GET_BYTE(NewInputMode);
        P_FINISH;
        SetSceneInputMode(NewInputMode);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_FUNCTION(execIsSceneActive)
    {
        P_GET_UBOOL_OPTX(bTopmostScene,FALSE);
        P_FINISH;
        *(UBOOL*)Result=IsSceneActive(bTopmostScene);
    }
    DECLARE_FUNCTION(execGetDefaultToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetDefaultToolTip();
    }
    DECLARE_FUNCTION(execGetDefaultContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetDefaultContextMenu();
    }
    DECLARE_FUNCTION(execGetActiveToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetActiveToolTip();
    }
    DECLARE_FUNCTION(execSetActiveToolTip)
    {
        P_GET_OBJECT(UUIToolTip,NewToolTip);
        P_FINISH;
        *(UBOOL*)Result=SetActiveToolTip(NewToolTip);
    }
    DECLARE_FUNCTION(execGetActiveContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetActiveContextMenu();
    }
    DECLARE_FUNCTION(execSetActiveContextMenu)
    {
        P_GET_OBJECT(UUIContextMenu,NewContextMenu);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=SetActiveContextMenu(NewContextMenu,PlayerIndex);
    }
    void eventLogDockingStack()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LogDockingStack),NULL);
    }
    void eventCalculateInputMask()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CalculateInputMask),NULL);
    }
    void eventSceneDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SceneDeactivated),NULL);
    }
    void eventSceneActivated(UBOOL bInitialActivation)
    {
        UIScene_eventSceneActivated_Parms Parms(EC_EventParm);
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SceneActivated),&Parms);
    }
    void delegateOnTopSceneChanged(class UUIScene* NewTopScene)
    {
        UIScene_eventOnTopSceneChanged_Parms Parms(EC_EventParm);
        Parms.NewTopScene=NewTopScene;
        ProcessDelegate(ENGINE_OnTopSceneChanged,&__OnTopSceneChanged__Delegate,&Parms);
    }
    void delegateOnSceneDeactivated(class UUIScene* DeactivatedScene)
    {
        UIScene_eventOnSceneDeactivated_Parms Parms(EC_EventParm);
        Parms.DeactivatedScene=DeactivatedScene;
        ProcessDelegate(ENGINE_OnSceneDeactivated,&__OnSceneDeactivated__Delegate,&Parms);
    }
    void delegateOnSceneActivated(class UUIScene* ActivatedScene,UBOOL bInitialActivation)
    {
        UIScene_eventOnSceneActivated_Parms Parms(EC_EventParm);
        Parms.ActivatedScene=ActivatedScene;
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnSceneActivated,&__OnSceneActivated__Delegate,&Parms);
    }
    BYTE delegateGetSceneInputMode()
    {
        UIScene_eventGetSceneInputMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessDelegate(ENGINE_GetSceneInputMode,&__GetSceneInputMode__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIScene,UUIScreenObject,0,Engine)
	// UUIScreenObject interface.

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const			{ return NULL; }

	/**
	 * Returns a pointer to this scene.
	 */
	virtual UUIScene* GetScene() 				{ return this; }

	/**
	 * Returns a const pointer to this scene.
	 */
	virtual const UUIScene* GetScene() const	{ return this; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return SceneTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const	{ return SceneTag.ToString(); }

	/** gets the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 *	Iterates over all widgets in the scene and forces them to update their style
	 */
	void RefreshWidgetStyles();

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Sets up the focus, input, and any other arrays which contain data that tracked uniquely for each active player.
	 * Ensures that the arrays responsible for managing focus chains are synched up with the Engine.GamePlayers array.
	 *
	 * This version also calls CalculateInputMask to initialize the scene's PlayerInputMask for use by the activation
	 * and initialization events that will be called as the scene is activated.
	 */
	virtual void InitializePlayerTracking();

	/**
	 * Called when a new player has been added to the list of active players (i.e. split-screen join) after the scene
	 * has been activated.
	 *
	 * This version updates the scene's PlayerInputMask to reflect the newly added player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was inserted
	 * @param	AddedPlayer		the player that was added
	 */
	virtual void CreatePlayerData( INT PlayerIndex, class ULocalPlayer* AddedPlayer );

	/**
	 * Called when a player has been removed from the list of active players (i.e. split-screen players)
	 *
	 * This version updates the scene's PlayerInputMask to reflect the removed player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was located
	 * @param	RemovedPlayer	the player that was removed
	 */
	virtual void RemovePlayerData( INT PlayerIndex, class ULocalPlayer* RemovedPlayer );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Creates and initializes this scene's data store.
	 */
	void CreateSceneDataStore();

	/** Called when this scene is about to be added to the active scenes array */
	void Activate();

	/** Called just after this scene is removed from the active scenes array */
	virtual void Deactivate();

	/**
	 * Notification that this scene becomes the active scene.  Called after other activation methods have been called
	 * and after focus has been set on the scene.
	 *
	 * @param	bInitialActivation		TRUE if this is the first time this scene is being activated; FALSE if this scene has become active
	 *									as a result of closing another scene or manually moving this scene in the stack.
	 */
	virtual void OnSceneActivated( UBOOL bInitialActivation );

	/**
	 * This notification is sent to the topmost scene when a different scene is about to become the topmost scene.
	 * Provides scenes with a single location to perform any cleanup for its children.
	 *
	 * @param	NewTopScene		the scene that is about to become the topmost scene.
	 */
	virtual void NotifyTopSceneChanged( UUIScene* NewTopScene );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const
	{
		return bUpdateScenePositions == TRUE ? 0 : UIFACE_MAX;
	}

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return bUpdateScenePositions == FALSE;
	}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/* == UUIScene interface == */

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE )
	{
		bUpdateDockingStack = bUpdateDockingStack || bDockingStackChanged;
		bUpdateScenePositions = bUpdateScenePositions || bPositionsChanged;
		bUpdateNavigationLinks = bUpdateNavigationLinks || bNavLinksOutdated;
		bRefreshWidgetStyles = bRefreshWidgetStyles || bWidgetStylesChanged;
	}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate()
	{
		bRefreshStringFormatting = TRUE;
	}

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene();

	/**
	 * Updates the value of bUsesPrimitives.
	 */
	virtual void UpdatePrimitiveUsage();

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * This version simulates a resolution change to propagate position conversions for any widgets which are using aspect ratio locking.
	 */
	virtual void PreRenderCallback();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Called once per frame to update the scene's state.
	 *
	 * @param	DeltaTime	the time since the last Tick call
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Updates the sequences for this scene and its child widgets.
	 *
	 * @param	DeltaTime	the time since the last call to TickSequence.
	 */
	void TickSequence( FLOAT DeltaTime );

	/**
	 * Renders this scene.
	 *
	 * @param	Canvas	the canvas to use for rendering the scene
	 */
	virtual void Render_Scene( FCanvas* Canvas );

	/**
	 * Renders all special overlays for this scene, such as context menus or tooltips.
	 *
	 * @param	Canvas	the canvas to use for rendering the overlays
	 */
	virtual void RenderSceneOverlays( FCanvas* Canvas );

	/**
	 * Updates all 3D primitives in this scene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateScenePrimitives( FCanvasScene* CanvasScene );

	/**
	 * Adds the specified widget to the list of subscribers for the specified input key
	 *
	 * @param	InputKey	the key that the widget wants to subscribe to
	 * @param	Handler		the widget to add to the list of subscribers
	 * @param	PlayerIndex	the index of the player to register the input events for
	 *
	 * @return	TRUE if the widget was successfully added to the subscribers list
	 */
	UBOOL SubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex );

	/**
	 * Removes the specified widget from the list of subscribers for the specified input key
	 *
	 * @param	InputKey	the key that the widget wants to unsubscribe for
	 * @param	Handler		the widget to remove from the list of subscribers
	 * @param	PlayerIndex	the index of the player to unregister the input events for
	 *
	 * @return	TRUE if the widget was successfully removed from the subscribers list
	 */
	UBOOL UnsubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex );

	/**
	 * Retrieve the list of input event subscribers for the specified input key and player index.
	 *
	 * @param	InputKey				the input key name to retrieve subscribers for
	 * @param	PlayerIndex				the index for the player to retrieve subscribed controls for
	 * @param	out_SubscribersList		filled with the controls that respond to the specified input key for the specified player
	 *
	 * @return	TRUE if an input subscription was found for the specified input key and player index, FALSE otherwise.
	 */
	UBOOL GetInputEventSubscribers( FName InputKey, INT PlayerIndex, struct FInputEventSubscription** out_SubscriberList );

protected:
	/**
	 * Wrapper function for converting the controller Id specified into a PlayerIndex and grabbing the scene's input mode.
	 *
	 * @param	ControllerId			the gamepad id of the player that generated the input event
	 * @param	out_ScreenInputMode		set to this scene's input mode
	 * @param	out_PlayerIndex			the Engine.GamePlayers index for the player with the gamepad id specified.
	 *
	 * @return	TRUE if this scene can process input for the gamepad id specified, or FALSE if this scene should ignore
	 *			and swallow this input
	 */
	UBOOL PreprocessInput( INT ControllerId, EScreenInputMode& out_ScreenInputMode, INT& out_PlayerIndex );

	/**
	 * Processes key events for the scene itself.
	 *
	 * Only called if this scene is in the InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Allow this scene the chance to respond to an input event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Event			the type of event which occured.
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Allow this scene the chance to respond to an input axis event (mouse movement)
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Delta 			the axis movement delta.
	 * @param	DeltaTime		seconds since the last axis update.
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad=FALSE);

	/**
	 * Allow this scene to respond to an input char event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	UBOOL InputChar(INT ControllerId,TCHAR Character);

	/**
	 * Determines whether the current docking relationships between the widgets in this scene are valid.
	 *
	 * @return	TRUE if all docking nodes were added to the list.  FALSE if any recursive docking relationships were detected.
	 */
	UBOOL ValidateDockingStack() const;

	/* === UObject interface === */
	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostEditImport();

	/**
	 * Called after this scene is renamed.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostRename();

	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostDuplicate();

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version determines determines which sequences in this scene contains sequence ops that are capable of executing logic,
	 * and marks sequence objects with the RF_NotForClient|RF_NotForServer if the op isn't linked to anything.
	 */
	virtual void PreSave();
};

class UUIPrefabScene : public UUIScene, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UIPrefabScene
    //## END PROPS UIPrefabScene

    DECLARE_CLASS(UUIPrefabScene,UUIScene,0|CLASS_Transient,Engine)
	/* === UUIScene interface === */
	/* === FCallbackEventDevice interface === */
	/**
	 * Handles validating that this scene's UIPrefab is still a valid widget after each undo is performed.
	 */
	virtual void Send( ECallbackEventType InType );

	/* === UUIScreenObject interface === */
	/**
	 * Notification that this scene becomes the active scene.  Called after other activation methods have been called
	 * and after focus has been set on the scene.
	 *
	 * This version registers this UIPrefabScene as an observer for CALLBACK_Undo events.
	 *
	 * @param	bInitialActivation		TRUE if this is the first time this scene is being activated; FALSE if this scene has become active
	 *									as a result of closing another scene or manually moving this scene in the stack.
	 */
	virtual void OnSceneActivated( UBOOL bInitialActivation );

	/**
	 * Called just after this scene is removed from the active scenes array; unregisters this scene as an observer for undo callbacks.
	 */
	virtual void Deactivate();

	/**
	 * Insert a widget at the specified location
	 *
	 * @param	NewChild		the widget to insert; it must be a UIPrefab.
	 * @param	InsertIndex		unused
	 * @param	bRenameExisting	unused
	 *
	 * @return	the position that that the child was inserted in, or INDEX_NONE if the widget was not inserted
	 */
	virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=INDEX_NONE,UBOOL bRenameExisting=TRUE);

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/* === UObject interface === */

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version overrides the UIScene version to NOT call CalculateSequenceLoadFlags (that's handled by each UIPrefab).
	 */
	virtual void PreSave();
};

class UUIState_Active : public UUIState
{
public:
    //## BEGIN PROPS UIState_Active
    //## END PROPS UIState_Active

    DECLARE_CLASS(UUIState_Active,UUIState,0,Engine)
	/**
	 * Activate this state for the specified target.  This version ensures that the StackPriority for the Active and
	 * Pressed states have been reset to their default values.
	 *
	 * @param	Target			the widget that is activating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be activated for the specified
	 *			Target or this state was already part of the Target's state stack.
	 */
	virtual UBOOL ActivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Deactivate this state for the specified target.  This version changes the StackPriority on the Active and Pressed states
	 * so that the widget uses the style data from whichever state the widget was previously in.
	 *
	 * @param	Target			the widget that is deactivating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be deactivated for the specified
	 *			Target or this state wasn't part of the Target's state stack.
	 */
	virtual UBOOL DeactivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );
};

class UUIState_Focused : public UUIState
{
public:
    //## BEGIN PROPS UIState_Focused
    //## END PROPS UIState_Focused

    DECLARE_CLASS(UUIState_Focused,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );
};

class UUIState_Pressed : public UUIState
{
public:
    //## BEGIN PROPS UIState_Pressed
    //## END PROPS UIState_Pressed

    DECLARE_CLASS(UUIState_Pressed,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * This version activates the focused state for the widget as well.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIState_TargetedTab : public UUIState
{
public:
    //## BEGIN PROPS UIState_TargetedTab
    //## END PROPS UIState_TargetedTab

    DECLARE_CLASS(UUIState_TargetedTab,UUIState,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIState_TargetedTab)
};

class UUIEditboxString : public UUIString
{
public:
    //## BEGIN PROPS UIEditboxString
    //## END PROPS UIEditboxString

    DECLARE_CLASS(UUIEditboxString,UUIString,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIEditBox)
	/* === UUIString interface === */
protected:
	/**
	 * Hook for adjusting the extents and render text of any nodes prior to applyig formatting data.
	 */
	virtual void AdjustNodeExtents( struct FNodeFormattingData& FormatData );

public:
	/**
	 * Parses a string containing optional markup (such as tokens and inline images) and stores the result in Nodes.
	 *
	 * This version replaces the RenderText in all nodes with asterisks if the editbox's bPasswordMode is enabled.
	 *
	 * @param	InputString		A string containing optional markup.
	 * @param	bIgnoreMarkup	if TRUE, does not attempt to process any markup and only one UITextNode is created
	 *
	 * @return	TRUE if the string was successfully parsed into the Nodes array.
	 */
	virtual UBOOL SetValue( const FString& InputString, UBOOL bIgnoreMarkup );
};

class UUIListString : public UUIString
{
public:
    //## BEGIN PROPS UIListString
    //## END PROPS UIListString

    DECLARE_CLASS(UUIListString,UUIString,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIList)
	/* === UIListString interface === */
	void SetValue( struct FUIStringNode* ValueNode );
};

class UUIStyle_Data : public UUIRoot
{
public:
    //## BEGIN PROPS UIStyle_Data
    FStringNoInit UIEditorControlClass;
    FLinearColor StyleColor;
    BITFIELD bEnabled:1;
    BITFIELD bDirty:1;
    //## END PROPS UIStyle_Data

    DECLARE_ABSTRACT_CLASS(UUIStyle_Data,UUIRoot,0,Engine)
	/**
	 * Called when this style data object is added to a style.
	 *
	 * @param	the menu state that this style data has been created for.
	 */
	virtual void Created( class UUIState* AssociatedState ) {}

	/**
	 * Resolves any references to other styles contained in this style data object.
	 *
	 * @param	OwnerSkin	the skin that is currently active.
	 */
	virtual void ResolveExternalReferences( class UUISkin* ActiveSkin ) {}

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 */
	virtual void ValidateStyleData() {}

	/** Returns the UIStyle object that contains this style data */
	class UUIStyle* GetOwnerStyle() const;

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @return	TRUE if this style's data has been modified, indicating that it should be reapplied to any subscribed widgets.
	 */
	virtual UBOOL IsDirty() const;

	/**
	 * Sets or clears the dirty flag for this style data.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 */
	virtual void SetDirtiness( UBOOL bIsDirty );

	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	StyleToCompare	the style to compare this style's values against
	 *
	 * @return	TRUE if StyleToCompare has different values for any style data properties.  FALSE if the specified style is
	 *			NULL, or if the specified style is the same as this one.
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/** Returns TRUE if this style data references specified style */
	virtual UBOOL IsReferencingStyle(const UUIStyle* Style) const { return FALSE; }

};

struct FStyleDataReference
{
private:
    class UUIStyle* OwnerStyle;
    struct FSTYLE_ID SourceStyleID;
    class UUIStyle* SourceStyle;
    class UUIState* SourceState;
    class UUIStyle_Data* CustomStyleData;
public:

	friend class UUIStyle_Combo;

	/** Constructors */
	FStyleDataReference();
	FStyleDataReference( class UUIStyle* InSourceStyle, class UUIState* InSourceState );

	/** Comparison */
	UBOOL operator ==( const FStyleDataReference& Other ) const;
	UBOOL operator !=( const FStyleDataReference& Other ) const;

	/**
	 * Resolves SourceStyleID from the specified skin and assigns the result to SourceStyle.
	 *
	 * @param	ActiveSkin	the currently active skin.
	 */
	void ResolveSourceStyle( class UUISkin* ActiveSkin );

	/**
	 *	Returns the value of OnwerStyle
	 */
	class UUIStyle* GetOwnerStyle() const { return OwnerStyle; }

	/**
	 * Returns the style data object linked to this reference, if SourceStyle or SourceState are NULL then CustomStyleData will be returned instead
	 */
	class UUIStyle_Data* GetStyleData() const;

	/**
	 * Returns the value of SourceStyle
	 */
	class UUIStyle* GetSourceStyle() const { return SourceStyle; }

	/**
	 * Returns the value of SourceState
	 */
	class UUIState* GetSourceState() const { return SourceState; }

	/**
	 * Returns the value of CustomStyleData
	 */
	class UUIStyle_Data* GetCustomStyleData() const { return CustomStyleData; }

	/**
	 * Changes OwnerStyle to be the style specified
	 */
	void SetOwnerStyle( class UUIStyle* NewStyle ){ OwnerStyle = NewStyle; }

	/**
	 *	Sets The SourceStyle reference, makes sure that SourceState is valid for this style
	 */
	void SafeSetStyle(UUIStyle* Style);

	/**
	 * 	Sets The SourceState reference, makes sure that SourceStyle contains this state
	 */
	void SafeSetState(UUIState* State);

	/**
	 * Changes SourceStyle to the style specified, without checking whether it is valid.
	 */
	void SetSourceStyle( class UUIStyle* NewStyle );

	/**
	 * Changes SourceState to the state specified, without checking whether it is valid.
	 */
	void SetSourceState( class UUIState* NewState );

	/**
	 * Sets CustomStyleData reference
	 */
	void SetCustomStyleData( UUIStyle_Data* CustomData ){ CustomStyleData = CustomData; }

	/**
	 * Enables or disables the custom style data if the OwnerStyle is the outer of the custom data
	 */
	void EnableCustomStyleData( UBOOL BoolFlag );

	/**
	 *	Determines if referenced custom style data is valid.
	 */
	UBOOL IsCustomStyleDataValid() const;

	/**
	 *	Determines if the custom style data is valid and enabled
	 */
	UBOOL IsCustomStyleDataEnabled() const;

	/**
	 * Returns whether the styles referenced are marked as dirty
	 */
	UBOOL IsDirty() const;

};

class UUIStyle_Combo : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Combo
    struct FStyleDataReference ImageStyle;
    struct FStyleDataReference TextStyle;
    //## END PROPS UIStyle_Combo

    DECLARE_CLASS(UUIStyle_Combo,UUIStyle_Data,0,Engine)
	/**
	 * Called when this style data object is added to a style.
	 *
	 * @param	the menu state that this style data has been created for.
	 */
	virtual void Created( class UUIState* AssociatedState );

	/**
	 * Resolves any references to other styles contained in this style data object.
	 *
	 * @param	OwnerSkin	the skin that is currently active.
	 */
	virtual void ResolveExternalReferences( class UUISkin* ActiveSkin );

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 */
	virtual void ValidateStyleData();

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @return	TRUE if this style's data has been modified, indicating that it should be reapplied to any subscribed widgets.
	 */
	virtual UBOOL IsDirty() const;

	/**
	 * Sets or clears the dirty flag for this style data.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 */
	virtual void SetDirtiness( UBOOL bIsDirty );

	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	StyleToCompare	the style to compare this style's values against
	 *
	 * @return	TRUE if StyleToCompare has different values for any style data properties.  FALSE if the specified style is
	 *			NULL, or if the specified style is the same as this one.
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/** Returns TRUE if this style data references specified style */
	virtual UBOOL IsReferencingStyle(const UUIStyle* Style) const;

	/* === UObject interface === */
	/**
	 * Assigns the SourceStyleID property for the style references contained by this combo style, if this style was saved
	 * prior to adding SourceStyleID to UIStyleDataReference
	 */
	virtual void PostLoad();
};

class UUIStyle_Image : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Image
    class USurface* DefaultImage;
    struct FTextureCoordinates Coordinates;
    struct FUIImageAdjustmentData AdjustmentType[2];
    //## END PROPS UIStyle_Image

    DECLARE_CLASS(UUIStyle_Image,UUIStyle_Data,0,Engine)
	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	StyleToCompare	the style to compare this style's values against
	 *
	 * @return	TRUE if StyleToCompare has different values for any style data properties.  FALSE if the specified style is
	 *			NULL, or if the specified style is the same as this one.
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

};

class UUIStyle_Text : public UUIStyle_Data
{
public:
    //## BEGIN PROPS UIStyle_Text
    class UFont* StyleFont;
    struct FUITextAttributes Attributes;
    BYTE Alignment[2];
    BYTE ClipMode;
    BYTE ClipAlignment;
    struct FTextAutoScaleValue AutoScaling;
    FVector2D Scale;
    //## END PROPS UIStyle_Text

    DECLARE_CLASS(UUIStyle_Text,UUIStyle_Data,0,Engine)
	/**
	 * Returns whether the values for this style data match the values from the style specified.
	 *
	 * @param	StyleToCompare	the style to compare this style's values against
	 *
	 * @return	TRUE if StyleToCompare has different values for any style data properties.  FALSE if the specified style is
	 *			NULL, or if the specified style is the same as this one.
	 */
	virtual UBOOL MatchesStyleData( class UUIStyle_Data* StyleToCompare ) const;

	/**
	 * Allows the style to verify that it contains valid data for all required fields.  Called when the owning style is being initialized, after
	 * external references have been resolved.
	 *
	 * This version verifies that this style has a valid font and if not sets the font reference to the default font.
	 */
	virtual void ValidateStyleData();

	/* === UObject interface. === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version propagates CLIP_Scaled and CLIP_ScaledBestFit ClipMode values to the new AutoScaling property
	 */
	virtual void PostLoad();
};

class UUITexture : public UUIRoot
{
public:
    //## BEGIN PROPS UITexture
private:
    struct FUICombinedStyleData ImageStyleData;
public:
    class USurface* ImageTexture;
    //## END PROPS UITexture

    void SetImageStyle(class UUIStyle_Image* NewImageStyle);
    UBOOL HasValidStyleData() const;
    DECLARE_FUNCTION(execSetImageStyle)
    {
        P_GET_OBJECT(UUIStyle_Image,NewImageStyle);
        P_FINISH;
        SetImageStyle(NewImageStyle);
    }
    DECLARE_FUNCTION(execHasValidStyleData)
    {
        P_FINISH;
        *(UBOOL*)Result=HasValidStyleData();
    }
    DECLARE_CLASS(UUITexture,UUIRoot,0,Engine)
	/**
	 * Fills in the extent with the size of this texture's material
	 *
	 * @param	Extent	[out] set to the width/height of this texture's material
	 */
	virtual void CalculateExtent( FVector2D& Extent ) const;

	/**
	 * Fills in the extent with the size of this texture's material
	 *
	 * @param	SizeX	[out] filled in with the width this texture's material
	 * @param	SizeY	[out] filled in with the height of this texture's material
	 */
	virtual void CalculateExtent( FLOAT& out_SizeX, FLOAT& out_SizeY ) const;

	/**
	 * Render this UITexture using the parameters specified.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this texture
	 * @param	Parameters	the bounds for the region that this texture can render to.
	 */
	virtual void Render_Texture( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Returns the surface associated with this UITexture.
	 */
	USurface* GetSurface() const { return ImageTexture; }

	/**
	 * Copies the style data specified to this UITexture's ImageStyleData.
	 */
	void SetImageStyle( const struct FUICombinedStyleData& NewStyleData );

	/**
	 * Provides read-only access to the style data assigned to this UITexture
	 */
	const struct FUICombinedStyleData& GetImageStyle() const { return ImageStyleData; }

	/**
	 * Utility function for rendering a texture to the screen using DrawTile.  Determines the appropriate overload of DrawTile
	 * to call, depending on the type of surface being rendered, and translates the UV values into percentages as this is what
	 * Canvas expects.
	 *
	 * @param	Canvas			the FCanvas to use for rendering this texture
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		this is [currently] only used when rendering UTexture surfaces to get the color to use for rendering
	 * @param	X				the horizontal screen location (in pixels) where the image should be rendered
	 * @param	Y				the vertical screen location (in pixels) where the image should be rendered
	 * @param	XL				the width of the region (in pixels) where this image will be rendered
	 * @param	YL				the height of the region (in pixels) where this image will be rendered
	 * @param	U				the horizontal location (in pixels) to begin sampling the texture data
	 * @param	V				the vertical location (in pixels) to begin sampling the texture data
	 * @param	UL				the width (in pixels) of the texture data sampling region
	 * @param	VL				the height (in pixels) of the texture data sampling region
	 */
	static void DrawTile( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData,
						 FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL );

	/**
	 * Render the specified image.  If the target region is larger than the image being rendered, the image is stretched by duplicating the pixels at the
	 * images midpoint to fill the additional space.  If the target region is smaller than the image being rendered, the image will be scaled to fit the region.
	 *
	 * @param	Canvas			the FCanvas to use for rendering this texture
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		used to determine which orientations can be stretched in the image
	 * @param	Parameters		describes the bounds and sample locations for rendering this tile.  See the documentation for DrawTile
	 *							for more details about each individual member.
	 */
	static void DrawTileStretched( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData, const FRenderParameters& Parameters );

	/**
	 * Render the specified image.  The protected regions of the image will not be scaled in the directions of their respective dimensions,
	 * i.e. the left protected region will not be scaled in the horizontal dimension with the rest of the image.  The protected regions are
	 * defined by a value that indicates the distance from their respective face to the opposite edge of the region.  The perpendicular
	 * faces of a given protected region extend to the edges of the full image.
	 *
	 * @param	RI				the render interface to use for rendering the image
	 * @param	Surface			the texture to be rendered
	 * @param	StyleData		used to determine which orientations can be stretched in the image
	 * @param	Parameters		describes the bounds and sample locations for rendering this tile.  See the documentation for DrawTile
	 *							for more details about each individual member.
	 */
	static void DrawTileProtectedRegions( FCanvas* Canvas, USurface* Surface, const struct FUICombinedStyleData& StyleData, const FRenderParameters& Parameters );

	/* === UObject interface === */
	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

#endif // !INCLUDED_ENGINE_UIPRIVATE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execSetActiveControl);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCanUnpauseInternalUI);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execRequestCursorRenderUpdate);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execRequestInputProcessingUpdate);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execFindSceneByTag);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCreateTransientWidget);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCreateScene);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetTransientScene);
AUTOGENERATE_FUNCTION(USessionSettingsProvider,-1,execUnbindProviderClient);
AUTOGENERATE_FUNCTION(USessionSettingsProvider,-1,execBindProviderClient);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execApplyAnimation);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUICheckbox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComboBox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execResetFade);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execPulse);
AUTOGENERATE_FUNCTION(UUIComp_DrawComponents,-1,execFade);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execNotifyResolveStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetImage);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomFormatting);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execDisableCustomCoordinates);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetFormatting);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetCoordinates);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execSetImage);
AUTOGENERATE_FUNCTION(UUIComp_DrawImage,-1,execGetAppliedImageStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execNotifyResolveStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetStyleResolverTag);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetFinalStringStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetAppliedStringStyle);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetWrapMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomScale);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAutoScaling);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomClipAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomClipMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomAttributes);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomFont);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execDisableCustomColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetScale);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAutoScaling);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetClipAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetWrapMode);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAlignment);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetAttributes);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetFont);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetOpacity);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetColor);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execRefreshValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawString,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execGetUserTextLength);
AUTOGENERATE_FUNCTION(UUIComp_DrawStringEditbox,-1,execSetUserText);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execResortItems);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execSortItems);
AUTOGENERATE_FUNCTION(UUIComp_ListElementSorter,-1,execResetSortColumns);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execFindElementIndex);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execGetCellSchemaProvider);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execShouldAdjustListBounds);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execShouldRenderColumnHeaders);
AUTOGENERATE_FUNCTION(UUIComp_ListPresenter,-1,execEnableColumnHeaderRendering);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execClose);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execOpen);
AUTOGENERATE_FUNCTION(UUIContextMenu,-1,execIsActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIDataStore,-1,execOnCommit);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineGameSearch,-1,execBuildSearchResults);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineStats,-1,execSortResultsByRank);
AUTOGENERATE_FUNCTION(UUIDataStore_PlayerSettings,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execFindMappingWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execUnbindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execBindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindCollectionValueIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execInsertCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSavePersistentProviderData);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearFields);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindFieldIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execAddField);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execDeleteCharacter);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIEditBox,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIImage,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIImage,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIImage,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIImage,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabel,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabel,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabel,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetTextAlignment);
AUTOGENERATE_FUNCTION(UUILabel,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetTextAlignment);
AUTOGENERATE_FUNCTION(UUILabelButton,-1,execSetCaption);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsElementAutoSizingEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIList,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsHotTrackingEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetHotTracking);
AUTOGENERATE_FUNCTION(UUIList,-1,execCanSelectElement);
AUTOGENERATE_FUNCTION(UUIList,-1,execIsElementEnabled);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetTopIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetIndex);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetElementValue);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetCurrentItem);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetSelectedItems);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetResizeColumn);
AUTOGENERATE_FUNCTION(UUIList,-1,execCalculateIndexFromCursorLocation);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetClientRegion);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetRowHeight);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetColumnWidth);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetRowCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execSetColumnCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetTotalColumnCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetTotalRowCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxNumVisibleColumns);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxNumVisibleRows);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetMaxVisibleElementCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execGetItemCount);
AUTOGENERATE_FUNCTION(UUIList,-1,execRemoveElement);
AUTOGENERATE_FUNCTION(UUIList,-1,execScrollVertical);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execGetNumericValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execSetNumericValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execDecrementValue);
AUTOGENERATE_FUNCTION(UUINumericEditBox,-1,execIncrementValue);
AUTOGENERATE_FUNCTION(UUINumericOptionList,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUINumericOptionList,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetScale);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetRotation);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetRelPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetColor);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetVisibility);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetOpacity);
AUTOGENERATE_FUNCTION(UUIObject,-1,execTickAnim);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndexById);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndex);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRemoveStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAddStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtent);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtents);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNeedsActiveCursorUpdates);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetActiveCursorUpdate);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetPrivateBehavior);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsPrivateBehaviorSet);
AUTOGENERATE_FUNCTION(UUIObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetForcedNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsDockedTo);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockParameters);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockPadding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsContainedBy);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNotifyValueChanged);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateTransformMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execUpdateRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRotateWidget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execHasTransform);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetToolTipValue);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateSceneDataStoreMarkup);
AUTOGENERATE_FUNCTION(UUIObject,-1,execClearDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataStores);
AUTOGENERATE_FUNCTION(UUIObject,-1,execResolveDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetCurrentIndex);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execGetCurrentIndex);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetNextValue);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execSetPrevValue);
AUTOGENERATE_FUNCTION(UUIOptionList,-1,execGetListValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execOnMoveSelectionRight);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execOnMoveSelectionLeft);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execHasNextValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execHasPrevValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIOptionListBase,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIOptionListButton,-1,execUpdateButtonState);
AUTOGENERATE_FUNCTION(UUIPrefabInstance,-1,execDetachFromSourcePrefab);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIProgressBar,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execIsSceneActive);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetSceneInputMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetPreviousScene);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execUnbindSubscribers);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSaveSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execLoadSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetSceneDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveScenePositions);
AUTOGENERATE_FUNCTION(UUIScene,-1,execRebuildDockingStack);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetWidgetPathName);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToPixel);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetDockedWidgets);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPositionVector);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBounds);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBestPlayerIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetSupportedPlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetActivePlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAcceptsPlayerInput);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsPressed);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsActive);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsFocused);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetLastFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execKillFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocusToChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanPropagateFocusFor);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNavigateFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPrevControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNextControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusLastControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusFirstControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingShift);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingAlt);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingCtrl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execHasActiveStateOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCurrentState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindEventsOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateEventByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportSize);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOrigin);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportScale);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOffset);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRebuildNavigationLinks);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestPrimitiveReview);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestFormattingUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestSceneUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetObjectCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChildOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildUsingID);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execReplaceChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInsertChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreateWidget);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInitializePlayerTracking);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemovePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreatePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsInitialized);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScroll);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScrollEnd);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execDragScrollBegin);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execScrollDecrement);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execScrollIncrement);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execEnableCornerPadding);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetNudgeSizePixels);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetNudgeSizePercent);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetMarkerPosition);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execSetMarkerSize);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetScrollZoneWidth);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetScrollZoneExtent);
AUTOGENERATE_FUNCTION(UUIScrollbar,-1,execGetMarkerButtonPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetVisibleRegionPercentage);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClipRegion);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionSizeVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionPositionVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionSize);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execGetClientRegionPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execSetClientRegionPositionVector);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execSetClientRegionPosition);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execScrollRegion);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execReapplyFormatting);
AUTOGENERATE_FUNCTION(UUIScrollFrame,-1,execRefreshScrollbars);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetStyleGroups);
AUTOGENERATE_FUNCTION(UUISkin,-1,execFindStyleGroupIndex);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetStyleGroupAtIndex);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRenameStyleGroup);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRemoveStyleGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execAddStyleGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execIsInheritedGroupName);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetSkinSoundCues);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execRemoveUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execAddUISoundCue);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetCursorResource);
AUTOGENERATE_FUNCTION(UUISkin,-1,execGetAvailableStyles);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUISlider,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUISlider,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUISlider,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUITabButton,-1,execIsTargeted);
AUTOGENERATE_FUNCTION(UUITabButton,-1,execCanActivateButton);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execCreateTabPage);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execFindTargetedTab);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execGetPageAtIndex);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execGetPageCount);
AUTOGENERATE_FUNCTION(UUITabControl,-1,execRequestLayoutUpdate);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUITabPage,-1,execGetOwnerTabControl);
AUTOGENERATE_FUNCTION(UUITexture,-1,execHasValidStyleData);
AUTOGENERATE_FUNCTION(UUITexture,-1,execSetImageStyle);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUIToggleButton,-1,execSetCaption);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execUpdateToolTipPosition);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execEndTracking);
AUTOGENERATE_FUNCTION(UUIToolTip,-1,execBeginTracking);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_UIPRIVATE_NATIVE_DEFS
#define ENGINE_UIPRIVATE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UConsoleEntry);
DECLARE_NATIVE_TYPE(Engine,UCurrentGameDataStore);
DECLARE_NATIVE_TYPE(Engine,UCurrentWeaponDataProvider);
DECLARE_NATIVE_TYPE(Engine,UGameInfoDataProvider);
DECLARE_NATIVE_TYPE(Engine,UGameUISceneClient);
DECLARE_NATIVE_TYPE(Engine,UInventoryDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPickupDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerOwnerDataProvider);
DECLARE_NATIVE_TYPE(Engine,UPlayerOwnerDataStore);
DECLARE_NATIVE_TYPE(Engine,UPlayerSettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UPowerupDataProvider);
DECLARE_NATIVE_TYPE(Engine,USceneDataStore);
DECLARE_NATIVE_TYPE(Engine,USessionSettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UTeamDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIAnimationSeq);
DECLARE_NATIVE_TYPE(Engine,UUIButton);
DECLARE_NATIVE_TYPE(Engine,UUICheckbox);
DECLARE_NATIVE_TYPE(Engine,UUIComboBox);
DECLARE_NATIVE_TYPE(Engine,UUIComp_AutoAlignment);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ContextMenuListPresenter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawCaption);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawComponents);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawImage);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawString);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawStringEditbox);
DECLARE_NATIVE_TYPE(Engine,UUIComp_DrawStringSlider);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListComponentBase);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListElementSorter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenter);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenterCascade);
DECLARE_NATIVE_TYPE(Engine,UUIComp_ListPresenterTree);
DECLARE_NATIVE_TYPE(Engine,UUIConfigFileProvider);
DECLARE_NATIVE_TYPE(Engine,UUIConfigProvider);
DECLARE_NATIVE_TYPE(Engine,UUIConfigSectionProvider);
DECLARE_NATIVE_TYPE(Engine,UUIContainer);
DECLARE_NATIVE_TYPE(Engine,UUIContextMenu);
DECLARE_NATIVE_TYPE(Engine,UUICustomSkin);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineClanMates);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineFriends);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlinePlayerDataBase);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlinePlayers);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineProfileSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_OnlineProfileSettingsArray);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_Settings);
DECLARE_NATIVE_TYPE(Engine,UUIDataProvider_SettingsArray);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Color);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Fonts);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_GameResource);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_GameState);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Gamma);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Images);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineGameSearch);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineGameSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlinePlayerData);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_OnlineStats);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_PlayerSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Registry);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Remote);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_SessionSettings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Settings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_StringAliasMap);
DECLARE_NATIVE_TYPE(Engine,UUIDataStore_Strings);
DECLARE_NATIVE_TYPE(Engine,UUIDataStorePublisher);
DECLARE_NATIVE_TYPE(Engine,UUIDataStoreSubscriber);
DECLARE_NATIVE_TYPE(Engine,UUIDynamicDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIDynamicFieldProvider);
DECLARE_NATIVE_TYPE(Engine,UUIEditBox);
DECLARE_NATIVE_TYPE(Engine,UUIEditboxString);
DECLARE_NATIVE_TYPE(Engine,UUIFrameBox);
DECLARE_NATIVE_TYPE(Engine,UUIImage);
DECLARE_NATIVE_TYPE(Engine,UUILabel);
DECLARE_NATIVE_TYPE(Engine,UUILabelButton);
DECLARE_NATIVE_TYPE(Engine,UUIList);
DECLARE_NATIVE_TYPE(Engine,UUIListElementCellProvider);
DECLARE_NATIVE_TYPE(Engine,UUIListElementProvider);
DECLARE_NATIVE_TYPE(Engine,UUIListString);
DECLARE_NATIVE_TYPE(Engine,UUIMeshWidget);
DECLARE_NATIVE_TYPE(Engine,UUINumericEditBox);
DECLARE_NATIVE_TYPE(Engine,UUINumericEditBoxButton);
DECLARE_NATIVE_TYPE(Engine,UUINumericOptionList);
DECLARE_NATIVE_TYPE(Engine,UUIObject);
DECLARE_NATIVE_TYPE(Engine,UUIOptionList);
DECLARE_NATIVE_TYPE(Engine,UUIOptionListBase);
DECLARE_NATIVE_TYPE(Engine,UUIOptionListButton);
DECLARE_NATIVE_TYPE(Engine,UUIPanel);
DECLARE_NATIVE_TYPE(Engine,UUIPrefab);
DECLARE_NATIVE_TYPE(Engine,UUIPrefabInstance);
DECLARE_NATIVE_TYPE(Engine,UUIPrefabScene);
DECLARE_NATIVE_TYPE(Engine,UUIProgressBar);
DECLARE_NATIVE_TYPE(Engine,UUIPropertyDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUIResourceDataProvider);
DECLARE_NATIVE_TYPE(Engine,UUISafeRegionPanel);
DECLARE_NATIVE_TYPE(Engine,UUIScene);
DECLARE_NATIVE_TYPE(Engine,UUIScreenObject);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbar);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbarButton);
DECLARE_NATIVE_TYPE(Engine,UUIScrollbarMarkerButton);
DECLARE_NATIVE_TYPE(Engine,UUIScrollFrame);
DECLARE_NATIVE_TYPE(Engine,UUISettingsProvider);
DECLARE_NATIVE_TYPE(Engine,UUISkin);
DECLARE_NATIVE_TYPE(Engine,UUISlider);
DECLARE_NATIVE_TYPE(Engine,UUIState_Active);
DECLARE_NATIVE_TYPE(Engine,UUIState_Focused);
DECLARE_NATIVE_TYPE(Engine,UUIState_Pressed);
DECLARE_NATIVE_TYPE(Engine,UUIState_TargetedTab);
DECLARE_NATIVE_TYPE(Engine,UUIStringRenderer);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Combo);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Data);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Image);
DECLARE_NATIVE_TYPE(Engine,UUIStyle_Text);
DECLARE_NATIVE_TYPE(Engine,UUIStyleResolver);
DECLARE_NATIVE_TYPE(Engine,UUITabButton);
DECLARE_NATIVE_TYPE(Engine,UUITabControl);
DECLARE_NATIVE_TYPE(Engine,UUITabPage);
DECLARE_NATIVE_TYPE(Engine,UUITexture);
DECLARE_NATIVE_TYPE(Engine,UUIToggleButton);
DECLARE_NATIVE_TYPE(Engine,UUIToolTip);
DECLARE_NATIVE_TYPE(Engine,UWeaponDataProvider);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_UIPRIVATE \
	UConsoleEntry::StaticClass(); \
	UCurrentGameDataStore::StaticClass(); \
	UCurrentWeaponDataProvider::StaticClass(); \
	UGameInfoDataProvider::StaticClass(); \
	UGameUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUGameUISceneClientNative; \
	UInventoryDataProvider::StaticClass(); \
	UPickupDataProvider::StaticClass(); \
	UPlayerDataProvider::StaticClass(); \
	UPlayerOwnerDataProvider::StaticClass(); \
	UPlayerOwnerDataStore::StaticClass(); \
	UPlayerSettingsProvider::StaticClass(); \
	UPowerupDataProvider::StaticClass(); \
	USceneDataStore::StaticClass(); \
	USessionSettingsProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSessionSettingsProviderNative; \
	UTeamDataProvider::StaticClass(); \
	UUIAnimationSeq::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIAnimationSeqNative; \
	UUIButton::StaticClass(); \
	UUICheckbox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUICheckboxNative; \
	UUIComboBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComboBoxNative; \
	UUIComp_AutoAlignment::StaticClass(); \
	UUIComp_ContextMenuListPresenter::StaticClass(); \
	UUIComp_DrawCaption::StaticClass(); \
	UUIComp_DrawComponents::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawComponentsNative; \
	UUIComp_DrawImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawImageNative; \
	UUIComp_DrawString::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawStringNative; \
	UUIComp_DrawStringEditbox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_DrawStringEditboxNative; \
	UUIComp_DrawStringSlider::StaticClass(); \
	UUIComp_ListComponentBase::StaticClass(); \
	UUIComp_ListElementSorter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_ListElementSorterNative; \
	UUIComp_ListPresenter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_ListPresenterNative; \
	UUIComp_ListPresenterCascade::StaticClass(); \
	UUIComp_ListPresenterTree::StaticClass(); \
	UUIConfigFileProvider::StaticClass(); \
	UUIConfigProvider::StaticClass(); \
	UUIConfigSectionProvider::StaticClass(); \
	UUIContainer::StaticClass(); \
	UUIContextMenu::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIContextMenuNative; \
	UUICustomSkin::StaticClass(); \
	UUIDataProvider::StaticClass(); \
	UUIDataProvider_OnlineClanMates::StaticClass(); \
	UUIDataProvider_OnlineFriends::StaticClass(); \
	UUIDataProvider_OnlinePlayerDataBase::StaticClass(); \
	UUIDataProvider_OnlinePlayers::StaticClass(); \
	UUIDataProvider_OnlineProfileSettings::StaticClass(); \
	UUIDataProvider_OnlineProfileSettingsArray::StaticClass(); \
	UUIDataProvider_Settings::StaticClass(); \
	UUIDataProvider_SettingsArray::StaticClass(); \
	UUIDataStore::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStoreNative; \
	UUIDataStore_Color::StaticClass(); \
	UUIDataStore_Fonts::StaticClass(); \
	UUIDataStore_GameResource::StaticClass(); \
	UUIDataStore_GameState::StaticClass(); \
	UUIDataStore_Gamma::StaticClass(); \
	UUIDataStore_Images::StaticClass(); \
	UUIDataStore_OnlineGameSearch::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlineGameSearchNative; \
	UUIDataStore_OnlineGameSettings::StaticClass(); \
	UUIDataStore_OnlinePlayerData::StaticClass(); \
	UUIDataStore_OnlineStats::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_OnlineStatsNative; \
	UUIDataStore_PlayerSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_PlayerSettingsNative; \
	UUIDataStore_Registry::StaticClass(); \
	UUIDataStore_Remote::StaticClass(); \
	UUIDataStore_SessionSettings::StaticClass(); \
	UUIDataStore_Settings::StaticClass(); \
	UUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDataStore_StringAliasMapNative; \
	UUIDataStore_Strings::StaticClass(); \
	UUIDataStorePublisher::StaticClass(); \
	UUIDataStoreSubscriber::StaticClass(); \
	UUIDynamicDataProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDynamicDataProviderNative; \
	UUIDynamicFieldProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIDynamicFieldProviderNative; \
	UUIEditBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIEditBoxNative; \
	UUIEditboxString::StaticClass(); \
	UUIFrameBox::StaticClass(); \
	UUIImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIImageNative; \
	UUILabel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUILabelNative; \
	UUILabelButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUILabelButtonNative; \
	UUIList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIListNative; \
	UUIListElementCellProvider::StaticClass(); \
	UUIListElementProvider::StaticClass(); \
	UUIListString::StaticClass(); \
	UUIMeshWidget::StaticClass(); \
	UUINumericEditBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUINumericEditBoxNative; \
	UUINumericEditBoxButton::StaticClass(); \
	UUINumericOptionList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUINumericOptionListNative; \
	UUIObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIObjectNative; \
	UUIOptionList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListNative; \
	UUIOptionListBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListBaseNative; \
	UUIOptionListButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIOptionListButtonNative; \
	UUIPanel::StaticClass(); \
	UUIPrefab::StaticClass(); \
	UUIPrefabInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIPrefabInstanceNative; \
	UUIPrefabScene::StaticClass(); \
	UUIProgressBar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIProgressBarNative; \
	UUIPropertyDataProvider::StaticClass(); \
	UUIResourceDataProvider::StaticClass(); \
	UUISafeRegionPanel::StaticClass(); \
	UUIScene::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneNative; \
	UUIScreenObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScreenObjectNative; \
	UUIScrollbar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScrollbarNative; \
	UUIScrollbarButton::StaticClass(); \
	UUIScrollbarMarkerButton::StaticClass(); \
	UUIScrollFrame::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScrollFrameNative; \
	UUISettingsProvider::StaticClass(); \
	UUISkin::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISkinNative; \
	UUISlider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISliderNative; \
	UUIState_Active::StaticClass(); \
	UUIState_Focused::StaticClass(); \
	UUIState_Pressed::StaticClass(); \
	UUIState_TargetedTab::StaticClass(); \
	UUIStringRenderer::StaticClass(); \
	UUIStyle_Combo::StaticClass(); \
	UUIStyle_Data::StaticClass(); \
	UUIStyle_Image::StaticClass(); \
	UUIStyle_Text::StaticClass(); \
	UUIStyleResolver::StaticClass(); \
	UUITabButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabButtonNative; \
	UUITabControl::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabControlNative; \
	UUITabPage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITabPageNative; \
	UUITexture::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUITextureNative; \
	UUIToggleButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIToggleButtonNative; \
	UUIToolTip::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIToolTipNative; \
	UWeaponDataProvider::StaticClass(); \

#endif // ENGINE_UIPRIVATE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UGameUISceneClient) GEngineUGameUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UGameUISceneClient,execSetActiveControl)
	MAP_NATIVE(UGameUISceneClient,execCanUnpauseInternalUI)
	MAP_NATIVE(UGameUISceneClient,execRequestCursorRenderUpdate)
	MAP_NATIVE(UGameUISceneClient,execRequestInputProcessingUpdate)
	MAP_NATIVE(UGameUISceneClient,execFindSceneByTag)
	MAP_NATIVE(UGameUISceneClient,execCreateTransientWidget)
	MAP_NATIVE(UGameUISceneClient,execCreateScene)
	MAP_NATIVE(UGameUISceneClient,execGetTransientScene)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UGameUISceneClient);

NATIVE_INFO(USessionSettingsProvider) GEngineUSessionSettingsProviderNatives[] = 
{ 
	MAP_NATIVE(USessionSettingsProvider,execUnbindProviderClient)
	MAP_NATIVE(USessionSettingsProvider,execBindProviderClient)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USessionSettingsProvider);

NATIVE_INFO(UUIAnimationSeq) GEngineUUIAnimationSeqNatives[] = 
{ 
	MAP_NATIVE(UUIAnimationSeq,execApplyAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIAnimationSeq);

NATIVE_INFO(UUICheckbox) GEngineUUICheckboxNatives[] = 
{ 
	MAP_NATIVE(UUICheckbox,execSetValue)
	MAP_NATIVE(UUICheckbox,execSaveSubscriberValue)
	MAP_NATIVE(UUICheckbox,execClearBoundDataStores)
	MAP_NATIVE(UUICheckbox,execGetBoundDataStores)
	MAP_NATIVE(UUICheckbox,execRefreshSubscriberValue)
	MAP_NATIVE(UUICheckbox,execGetDataStoreBinding)
	MAP_NATIVE(UUICheckbox,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUICheckbox);

NATIVE_INFO(UUIComboBox) GEngineUUIComboBoxNatives[] = 
{ 
	MAP_NATIVE(UUIComboBox,execClearBoundDataStores)
	MAP_NATIVE(UUIComboBox,execGetBoundDataStores)
	MAP_NATIVE(UUIComboBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUIComboBox,execGetDataStoreBinding)
	MAP_NATIVE(UUIComboBox,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComboBox);

NATIVE_INFO(UUIComp_DrawComponents) GEngineUUIComp_DrawComponentsNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawComponents,execResetFade)
	MAP_NATIVE(UUIComp_DrawComponents,execPulse)
	MAP_NATIVE(UUIComp_DrawComponents,execFade)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawComponents);

NATIVE_INFO(UUIComp_DrawImage) GEngineUUIComp_DrawImageNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawImage,execNotifyResolveStyle)
	MAP_NATIVE(UUIComp_DrawImage,execSetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawImage,execGetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawImage,execGetImage)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomFormatting)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomOpacity)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomColor)
	MAP_NATIVE(UUIComp_DrawImage,execDisableCustomCoordinates)
	MAP_NATIVE(UUIComp_DrawImage,execSetFormatting)
	MAP_NATIVE(UUIComp_DrawImage,execSetOpacity)
	MAP_NATIVE(UUIComp_DrawImage,execSetColor)
	MAP_NATIVE(UUIComp_DrawImage,execSetCoordinates)
	MAP_NATIVE(UUIComp_DrawImage,execSetImage)
	MAP_NATIVE(UUIComp_DrawImage,execGetAppliedImageStyle)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawImage);

NATIVE_INFO(UUIComp_DrawString) GEngineUUIComp_DrawStringNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawString,execNotifyResolveStyle)
	MAP_NATIVE(UUIComp_DrawString,execSetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawString,execGetStyleResolverTag)
	MAP_NATIVE(UUIComp_DrawString,execGetFinalStringStyle)
	MAP_NATIVE(UUIComp_DrawString,execGetAppliedStringStyle)
	MAP_NATIVE(UUIComp_DrawString,execGetWrapMode)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomScale)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAutoScaling)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomClipAlignment)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomClipMode)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAlignment)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomAttributes)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomFont)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomOpacity)
	MAP_NATIVE(UUIComp_DrawString,execDisableCustomColor)
	MAP_NATIVE(UUIComp_DrawString,execSetScale)
	MAP_NATIVE(UUIComp_DrawString,execSetAutoScaling)
	MAP_NATIVE(UUIComp_DrawString,execSetClipAlignment)
	MAP_NATIVE(UUIComp_DrawString,execSetWrapMode)
	MAP_NATIVE(UUIComp_DrawString,execSetAlignment)
	MAP_NATIVE(UUIComp_DrawString,execSetAttributes)
	MAP_NATIVE(UUIComp_DrawString,execSetFont)
	MAP_NATIVE(UUIComp_DrawString,execSetOpacity)
	MAP_NATIVE(UUIComp_DrawString,execSetColor)
	MAP_NATIVE(UUIComp_DrawString,execRefreshValue)
	MAP_NATIVE(UUIComp_DrawString,execGetValue)
	MAP_NATIVE(UUIComp_DrawString,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawString);

NATIVE_INFO(UUIComp_DrawStringEditbox) GEngineUUIComp_DrawStringEditboxNatives[] = 
{ 
	MAP_NATIVE(UUIComp_DrawStringEditbox,execGetUserTextLength)
	MAP_NATIVE(UUIComp_DrawStringEditbox,execSetUserText)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_DrawStringEditbox);

NATIVE_INFO(UUIComp_ListElementSorter) GEngineUUIComp_ListElementSorterNatives[] = 
{ 
	MAP_NATIVE(UUIComp_ListElementSorter,execResortItems)
	MAP_NATIVE(UUIComp_ListElementSorter,execSortItems)
	MAP_NATIVE(UUIComp_ListElementSorter,execResetSortColumns)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_ListElementSorter);

NATIVE_INFO(UUIComp_ListPresenter) GEngineUUIComp_ListPresenterNatives[] = 
{ 
	MAP_NATIVE(UUIComp_ListPresenter,execFindElementIndex)
	MAP_NATIVE(UUIComp_ListPresenter,execGetCellSchemaProvider)
	MAP_NATIVE(UUIComp_ListPresenter,execShouldAdjustListBounds)
	MAP_NATIVE(UUIComp_ListPresenter,execShouldRenderColumnHeaders)
	MAP_NATIVE(UUIComp_ListPresenter,execEnableColumnHeaderRendering)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_ListPresenter);

NATIVE_INFO(UUIContextMenu) GEngineUUIContextMenuNatives[] = 
{ 
	MAP_NATIVE(UUIContextMenu,execClose)
	MAP_NATIVE(UUIContextMenu,execOpen)
	MAP_NATIVE(UUIContextMenu,execIsActiveContextMenu)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIContextMenu);

NATIVE_INFO(UUIDataStore) GEngineUUIDataStoreNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore,execOnCommit)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore);

NATIVE_INFO(UUIDataStore_OnlineGameSearch) GEngineUUIDataStore_OnlineGameSearchNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineGameSearch,execBuildSearchResults)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlineGameSearch);

NATIVE_INFO(UUIDataStore_OnlineStats) GEngineUUIDataStore_OnlineStatsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineStats,execSortResultsByRank)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_OnlineStats);

NATIVE_INFO(UUIDataStore_PlayerSettings) GEngineUUIDataStore_PlayerSettingsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_PlayerSettings,execGetPlayerOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_PlayerSettings);

NATIVE_INFO(UUIDataStore_StringAliasMap) GEngineUUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_StringAliasMap,execGetStringWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap,execFindMappingWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap,execGetPlayerOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDataStore_StringAliasMap);

NATIVE_INFO(UUIDynamicDataProvider) GEngineUUIDynamicDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicDataProvider,execUnbindProviderInstance)
	MAP_NATIVE(UUIDynamicDataProvider,execBindProviderInstance)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDynamicDataProvider);

NATIVE_INFO(UUIDynamicFieldProvider) GEngineUUIDynamicFieldProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicFieldProvider,execFindCollectionValueIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execClearCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execReplaceCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execReplaceCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execInsertCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider,execSetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider,execSavePersistentProviderData)
	MAP_NATIVE(UUIDynamicFieldProvider,execSetField)
	MAP_NATIVE(UUIDynamicFieldProvider,execGetField)
	MAP_NATIVE(UUIDynamicFieldProvider,execClearFields)
	MAP_NATIVE(UUIDynamicFieldProvider,execFindFieldIndex)
	MAP_NATIVE(UUIDynamicFieldProvider,execRemoveField)
	MAP_NATIVE(UUIDynamicFieldProvider,execAddField)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIDynamicFieldProvider);

NATIVE_INFO(UUIEditBox) GEngineUUIEditBoxNatives[] = 
{ 
	MAP_NATIVE(UUIEditBox,execSaveSubscriberValue)
	MAP_NATIVE(UUIEditBox,execClearBoundDataStores)
	MAP_NATIVE(UUIEditBox,execGetBoundDataStores)
	MAP_NATIVE(UUIEditBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUIEditBox,execGetDataStoreBinding)
	MAP_NATIVE(UUIEditBox,execSetDataStoreBinding)
	MAP_NATIVE(UUIEditBox,execDeleteCharacter)
	MAP_NATIVE(UUIEditBox,execGetValue)
	MAP_NATIVE(UUIEditBox,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIEditBox);

NATIVE_INFO(UUIImage) GEngineUUIImageNatives[] = 
{ 
	MAP_NATIVE(UUIImage,execSaveSubscriberValue)
	MAP_NATIVE(UUIImage,execClearBoundDataStores)
	MAP_NATIVE(UUIImage,execGetBoundDataStores)
	MAP_NATIVE(UUIImage,execRefreshSubscriberValue)
	MAP_NATIVE(UUIImage,execGetDataStoreBinding)
	MAP_NATIVE(UUIImage,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIImage);

NATIVE_INFO(UUILabel) GEngineUUILabelNatives[] = 
{ 
	MAP_NATIVE(UUILabel,execClearBoundDataStores)
	MAP_NATIVE(UUILabel,execGetBoundDataStores)
	MAP_NATIVE(UUILabel,execRefreshSubscriberValue)
	MAP_NATIVE(UUILabel,execGetDataStoreBinding)
	MAP_NATIVE(UUILabel,execSetDataStoreBinding)
	MAP_NATIVE(UUILabel,execSetTextAlignment)
	MAP_NATIVE(UUILabel,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUILabel);

NATIVE_INFO(UUILabelButton) GEngineUUILabelButtonNatives[] = 
{ 
	MAP_NATIVE(UUILabelButton,execSaveSubscriberValue)
	MAP_NATIVE(UUILabelButton,execClearBoundDataStores)
	MAP_NATIVE(UUILabelButton,execGetBoundDataStores)
	MAP_NATIVE(UUILabelButton,execRefreshSubscriberValue)
	MAP_NATIVE(UUILabelButton,execGetDataStoreBinding)
	MAP_NATIVE(UUILabelButton,execSetDataStoreBinding)
	MAP_NATIVE(UUILabelButton,execSetTextAlignment)
	MAP_NATIVE(UUILabelButton,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUILabelButton);

NATIVE_INFO(UUIList) GEngineUUIListNatives[] = 
{ 
	MAP_NATIVE(UUIList,execIsElementAutoSizingEnabled)
	MAP_NATIVE(UUIList,execSaveSubscriberValue)
	MAP_NATIVE(UUIList,execClearBoundDataStores)
	MAP_NATIVE(UUIList,execGetBoundDataStores)
	MAP_NATIVE(UUIList,execRefreshSubscriberValue)
	MAP_NATIVE(UUIList,execGetDataStoreBinding)
	MAP_NATIVE(UUIList,execSetDataStoreBinding)
	MAP_NATIVE(UUIList,execIsHotTrackingEnabled)
	MAP_NATIVE(UUIList,execSetHotTracking)
	MAP_NATIVE(UUIList,execCanSelectElement)
	MAP_NATIVE(UUIList,execIsElementEnabled)
	MAP_NATIVE(UUIList,execSetTopIndex)
	MAP_NATIVE(UUIList,execSetIndex)
	MAP_NATIVE(UUIList,execGetElementValue)
	MAP_NATIVE(UUIList,execGetCurrentItem)
	MAP_NATIVE(UUIList,execGetSelectedItems)
	MAP_NATIVE(UUIList,execGetResizeColumn)
	MAP_NATIVE(UUIList,execCalculateIndexFromCursorLocation)
	MAP_NATIVE(UUIList,execGetClientRegion)
	MAP_NATIVE(UUIList,execGetRowHeight)
	MAP_NATIVE(UUIList,execGetColumnWidth)
	MAP_NATIVE(UUIList,execSetRowCount)
	MAP_NATIVE(UUIList,execSetColumnCount)
	MAP_NATIVE(UUIList,execGetTotalColumnCount)
	MAP_NATIVE(UUIList,execGetTotalRowCount)
	MAP_NATIVE(UUIList,execGetMaxNumVisibleColumns)
	MAP_NATIVE(UUIList,execGetMaxNumVisibleRows)
	MAP_NATIVE(UUIList,execGetMaxVisibleElementCount)
	MAP_NATIVE(UUIList,execGetItemCount)
	MAP_NATIVE(UUIList,execRemoveElement)
	MAP_NATIVE(UUIList,execScrollVertical)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIList);

NATIVE_INFO(UUINumericEditBox) GEngineUUINumericEditBoxNatives[] = 
{ 
	MAP_NATIVE(UUINumericEditBox,execSaveSubscriberValue)
	MAP_NATIVE(UUINumericEditBox,execGetBoundDataStores)
	MAP_NATIVE(UUINumericEditBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUINumericEditBox,execGetNumericValue)
	MAP_NATIVE(UUINumericEditBox,execSetNumericValue)
	MAP_NATIVE(UUINumericEditBox,execDecrementValue)
	MAP_NATIVE(UUINumericEditBox,execIncrementValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUINumericEditBox);

NATIVE_INFO(UUINumericOptionList) GEngineUUINumericOptionListNatives[] = 
{ 
	MAP_NATIVE(UUINumericOptionList,execGetValue)
	MAP_NATIVE(UUINumericOptionList,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUINumericOptionList);

NATIVE_INFO(UUIObject) GEngineUUIObjectNatives[] = 
{ 
	MAP_NATIVE(UUIObject,execAnimSetScale)
	MAP_NATIVE(UUIObject,execAnimSetRotation)
	MAP_NATIVE(UUIObject,execAnimSetRelPosition)
	MAP_NATIVE(UUIObject,execAnimSetPosition)
	MAP_NATIVE(UUIObject,execAnimSetColor)
	MAP_NATIVE(UUIObject,execAnimSetVisibility)
	MAP_NATIVE(UUIObject,execAnimSetOpacity)
	MAP_NATIVE(UUIObject,execTickAnim)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndexById)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndex)
	MAP_NATIVE(UUIObject,execRemoveStyleSubscriber)
	MAP_NATIVE(UUIObject,execAddStyleSubscriber)
	MAP_NATIVE(UUIObject,execGetPositionExtent)
	MAP_NATIVE(UUIObject,execGetPositionExtents)
	MAP_NATIVE(UUIObject,execNeedsActiveCursorUpdates)
	MAP_NATIVE(UUIObject,execSetActiveCursorUpdate)
	MAP_NATIVE(UUIObject,execSetPrivateBehavior)
	MAP_NATIVE(UUIObject,execIsPrivateBehaviorSet)
	MAP_NATIVE(UUIObject,execCanAcceptFocus)
	MAP_NATIVE(UUIObject,execSetForcedNavigationTarget)
	MAP_NATIVE(UUIObject,execSetNavigationTarget)
	MAP_NATIVE(UUIObject,execIsDockedTo)
	MAP_NATIVE(UUIObject,execSetDockParameters)
	MAP_NATIVE(UUIObject,execSetDockPadding)
	MAP_NATIVE(UUIObject,execSetDockTarget)
	MAP_NATIVE(UUIObject,execIsContainedBy)
	MAP_NATIVE(UUIObject,execNotifyValueChanged)
	MAP_NATIVE(UUIObject,execGetRotationMatrix)
	MAP_NATIVE(UUIObject,execGenerateTransformMatrix)
	MAP_NATIVE(UUIObject,execGetAnchorPosition)
	MAP_NATIVE(UUIObject,execUpdateRotationMatrix)
	MAP_NATIVE(UUIObject,execRotateWidget)
	MAP_NATIVE(UUIObject,execSetAnchorPosition)
	MAP_NATIVE(UUIObject,execHasTransform)
	MAP_NATIVE(UUIObject,execGetToolTipValue)
	MAP_NATIVE(UUIObject,execGenerateSceneDataStoreMarkup)
	MAP_NATIVE(UUIObject,execClearDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataStores)
	MAP_NATIVE(UUIObject,execResolveDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataBinding)
	MAP_NATIVE(UUIObject,execSetDefaultDataBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIObject);

NATIVE_INFO(UUIOptionList) GEngineUUIOptionListNatives[] = 
{ 
	MAP_NATIVE(UUIOptionList,execSetCurrentIndex)
	MAP_NATIVE(UUIOptionList,execGetCurrentIndex)
	MAP_NATIVE(UUIOptionList,execSetNextValue)
	MAP_NATIVE(UUIOptionList,execSetPrevValue)
	MAP_NATIVE(UUIOptionList,execGetListValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionList);

NATIVE_INFO(UUIOptionListBase) GEngineUUIOptionListBaseNatives[] = 
{ 
	MAP_NATIVE(UUIOptionListBase,execOnMoveSelectionRight)
	MAP_NATIVE(UUIOptionListBase,execOnMoveSelectionLeft)
	MAP_NATIVE(UUIOptionListBase,execHasNextValue)
	MAP_NATIVE(UUIOptionListBase,execHasPrevValue)
	MAP_NATIVE(UUIOptionListBase,execSaveSubscriberValue)
	MAP_NATIVE(UUIOptionListBase,execClearBoundDataStores)
	MAP_NATIVE(UUIOptionListBase,execGetBoundDataStores)
	MAP_NATIVE(UUIOptionListBase,execRefreshSubscriberValue)
	MAP_NATIVE(UUIOptionListBase,execGetDataStoreBinding)
	MAP_NATIVE(UUIOptionListBase,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionListBase);

NATIVE_INFO(UUIOptionListButton) GEngineUUIOptionListButtonNatives[] = 
{ 
	MAP_NATIVE(UUIOptionListButton,execUpdateButtonState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIOptionListButton);

NATIVE_INFO(UUIPrefabInstance) GEngineUUIPrefabInstanceNatives[] = 
{ 
	MAP_NATIVE(UUIPrefabInstance,execDetachFromSourcePrefab)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIPrefabInstance);

NATIVE_INFO(UUIProgressBar) GEngineUUIProgressBarNatives[] = 
{ 
	MAP_NATIVE(UUIProgressBar,execGetValue)
	MAP_NATIVE(UUIProgressBar,execSetValue)
	MAP_NATIVE(UUIProgressBar,execSaveSubscriberValue)
	MAP_NATIVE(UUIProgressBar,execClearBoundDataStores)
	MAP_NATIVE(UUIProgressBar,execGetBoundDataStores)
	MAP_NATIVE(UUIProgressBar,execRefreshSubscriberValue)
	MAP_NATIVE(UUIProgressBar,execGetDataStoreBinding)
	MAP_NATIVE(UUIProgressBar,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIProgressBar);

NATIVE_INFO(UUIScene) GEngineUUISceneNatives[] = 
{ 
	MAP_NATIVE(UUIScene,execSetActiveContextMenu)
	MAP_NATIVE(UUIScene,execGetActiveContextMenu)
	MAP_NATIVE(UUIScene,execSetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetDefaultContextMenu)
	MAP_NATIVE(UUIScene,execGetDefaultToolTip)
	MAP_NATIVE(UUIScene,execIsSceneActive)
	MAP_NATIVE(UUIScene,execGetWorldInfo)
	MAP_NATIVE(UUIScene,execSetSceneInputMode)
	MAP_NATIVE(UUIScene,execGetPreviousScene)
	MAP_NATIVE(UUIScene,execResolveDataStore)
	MAP_NATIVE(UUIScene,execUnbindSubscribers)
	MAP_NATIVE(UUIScene,execSaveSceneDataValues)
	MAP_NATIVE(UUIScene,execLoadSceneDataValues)
	MAP_NATIVE(UUIScene,execGetSceneDataStore)
	MAP_NATIVE(UUIScene,execResolveScenePositions)
	MAP_NATIVE(UUIScene,execRebuildDockingStack)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScene);

NATIVE_INFO(UUIScreenObject) GEngineUUIScreenObjectNatives[] = 
{ 
	MAP_NATIVE(UUIScreenObject,execGetWidgetPathName)
	MAP_NATIVE(UUIScreenObject,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execGetCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execPixelToCanvas)
	MAP_NATIVE(UUIScreenObject,execScreenToCanvas)
	MAP_NATIVE(UUIScreenObject,execPixelToScreen)
	MAP_NATIVE(UUIScreenObject,execScreenToPixel)
	MAP_NATIVE(UUIScreenObject,execCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execDeProject)
	MAP_NATIVE(UUIScreenObject,execProject)
	MAP_NATIVE(UUIScreenObject,execGetDockedWidgets)
	MAP_NATIVE(UUIScreenObject,execGetPositionVector)
	MAP_NATIVE(UUIScreenObject,execGetBounds)
	MAP_NATIVE(UUIScreenObject,execGetPosition)
	MAP_NATIVE(UUIScreenObject,execSetPosition)
	MAP_NATIVE(UUIScreenObject,execGetBestPlayerIndex)
	MAP_NATIVE(UUIScreenObject,execGetSupportedPlayerCount)
	MAP_NATIVE(UUIScreenObject,execGetActivePlayerCount)
	MAP_NATIVE(UUIScreenObject,execAcceptsPlayerInput)
	MAP_NATIVE(UUIScreenObject,execIsPressed)
	MAP_NATIVE(UUIScreenObject,execIsActive)
	MAP_NATIVE(UUIScreenObject,execIsFocused)
	MAP_NATIVE(UUIScreenObject,execIsEnabled)
	MAP_NATIVE(UUIScreenObject,execGetLastFocusedControl)
	MAP_NATIVE(UUIScreenObject,execGetFocusedControl)
	MAP_NATIVE(UUIScreenObject,execKillFocus)
	MAP_NATIVE(UUIScreenObject,execSetFocusToChild)
	MAP_NATIVE(UUIScreenObject,execSetFocus)
	MAP_NATIVE(UUIScreenObject,execCanPropagateFocusFor)
	MAP_NATIVE(UUIScreenObject,execCanAcceptFocus)
	MAP_NATIVE(UUIScreenObject,execNavigateFocus)
	MAP_NATIVE(UUIScreenObject,execPrevControl)
	MAP_NATIVE(UUIScreenObject,execNextControl)
	MAP_NATIVE(UUIScreenObject,execFocusLastControl)
	MAP_NATIVE(UUIScreenObject,execFocusFirstControl)
	MAP_NATIVE(UUIScreenObject,execIsHoldingShift)
	MAP_NATIVE(UUIScreenObject,execIsHoldingAlt)
	MAP_NATIVE(UUIScreenObject,execIsHoldingCtrl)
	MAP_NATIVE(UUIScreenObject,execDeactivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execDeactivateState)
	MAP_NATIVE(UUIScreenObject,execActivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execActivateState)
	MAP_NATIVE(UUIScreenObject,execHasActiveStateOfClass)
	MAP_NATIVE(UUIScreenObject,execGetCurrentState)
	MAP_NATIVE(UUIScreenObject,execSetEnabled)
	MAP_NATIVE(UUIScreenObject,execFindEventsOfClass)
	MAP_NATIVE(UUIScreenObject,execActivateEventByClass)
	MAP_NATIVE(UUIScreenObject,execGetViewportSize)
	MAP_NATIVE(UUIScreenObject,execGetViewportOrigin)
	MAP_NATIVE(UUIScreenObject,execGetViewportScale)
	MAP_NATIVE(UUIScreenObject,execGetViewportOffset)
	MAP_NATIVE(UUIScreenObject,execRebuildNavigationLinks)
	MAP_NATIVE(UUIScreenObject,execRequestPrimitiveReview)
	MAP_NATIVE(UUIScreenObject,execRequestFormattingUpdate)
	MAP_NATIVE(UUIScreenObject,execRequestSceneUpdate)
	MAP_NATIVE(UUIScreenObject,execGetObjectCount)
	MAP_NATIVE(UUIScreenObject,execGetChildren)
	MAP_NATIVE(UUIScreenObject,execContainsChildOfClass)
	MAP_NATIVE(UUIScreenObject,execContainsChild)
	MAP_NATIVE(UUIScreenObject,execFindChildIndex)
	MAP_NATIVE(UUIScreenObject,execFindChildUsingID)
	MAP_NATIVE(UUIScreenObject,execFindChild)
	MAP_NATIVE(UUIScreenObject,execReplaceChild)
	MAP_NATIVE(UUIScreenObject,execRemoveChildren)
	MAP_NATIVE(UUIScreenObject,execRemoveChild)
	MAP_NATIVE(UUIScreenObject,execInsertChild)
	MAP_NATIVE(UUIScreenObject,execCreateWidget)
	MAP_NATIVE(UUIScreenObject,execPlayUISound)
	MAP_NATIVE(UUIScreenObject,execGetPlayerOwner)
	MAP_NATIVE(UUIScreenObject,execInitializePlayerTracking)
	MAP_NATIVE(UUIScreenObject,execRemovePlayerData)
	MAP_NATIVE(UUIScreenObject,execCreatePlayerData)
	MAP_NATIVE(UUIScreenObject,execIsInitialized)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScreenObject);

NATIVE_INFO(UUIScrollbar) GEngineUUIScrollbarNatives[] = 
{ 
	MAP_NATIVE(UUIScrollbar,execDragScroll)
	MAP_NATIVE(UUIScrollbar,execDragScrollEnd)
	MAP_NATIVE(UUIScrollbar,execDragScrollBegin)
	MAP_NATIVE(UUIScrollbar,execScrollDecrement)
	MAP_NATIVE(UUIScrollbar,execScrollIncrement)
	MAP_NATIVE(UUIScrollbar,execEnableCornerPadding)
	MAP_NATIVE(UUIScrollbar,execSetNudgeSizePixels)
	MAP_NATIVE(UUIScrollbar,execSetNudgeSizePercent)
	MAP_NATIVE(UUIScrollbar,execSetMarkerPosition)
	MAP_NATIVE(UUIScrollbar,execSetMarkerSize)
	MAP_NATIVE(UUIScrollbar,execGetScrollZoneWidth)
	MAP_NATIVE(UUIScrollbar,execGetScrollZoneExtent)
	MAP_NATIVE(UUIScrollbar,execGetMarkerButtonPosition)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScrollbar);

NATIVE_INFO(UUIScrollFrame) GEngineUUIScrollFrameNatives[] = 
{ 
	MAP_NATIVE(UUIScrollFrame,execGetVisibleRegionPercentage)
	MAP_NATIVE(UUIScrollFrame,execGetClipRegion)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionSizeVector)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionPositionVector)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionSize)
	MAP_NATIVE(UUIScrollFrame,execGetClientRegionPosition)
	MAP_NATIVE(UUIScrollFrame,execSetClientRegionPositionVector)
	MAP_NATIVE(UUIScrollFrame,execSetClientRegionPosition)
	MAP_NATIVE(UUIScrollFrame,execScrollRegion)
	MAP_NATIVE(UUIScrollFrame,execReapplyFormatting)
	MAP_NATIVE(UUIScrollFrame,execRefreshScrollbars)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScrollFrame);

NATIVE_INFO(UUISkin) GEngineUUISkinNatives[] = 
{ 
	MAP_NATIVE(UUISkin,execGetStyleGroups)
	MAP_NATIVE(UUISkin,execFindStyleGroupIndex)
	MAP_NATIVE(UUISkin,execGetStyleGroupAtIndex)
	MAP_NATIVE(UUISkin,execRenameStyleGroup)
	MAP_NATIVE(UUISkin,execRemoveStyleGroupName)
	MAP_NATIVE(UUISkin,execAddStyleGroupName)
	MAP_NATIVE(UUISkin,execIsInheritedGroupName)
	MAP_NATIVE(UUISkin,execGetSkinSoundCues)
	MAP_NATIVE(UUISkin,execGetUISoundCue)
	MAP_NATIVE(UUISkin,execRemoveUISoundCue)
	MAP_NATIVE(UUISkin,execAddUISoundCue)
	MAP_NATIVE(UUISkin,execGetCursorResource)
	MAP_NATIVE(UUISkin,execGetAvailableStyles)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISkin);

NATIVE_INFO(UUISlider) GEngineUUISliderNatives[] = 
{ 
	MAP_NATIVE(UUISlider,execGetValue)
	MAP_NATIVE(UUISlider,execSetValue)
	MAP_NATIVE(UUISlider,execSaveSubscriberValue)
	MAP_NATIVE(UUISlider,execClearBoundDataStores)
	MAP_NATIVE(UUISlider,execGetBoundDataStores)
	MAP_NATIVE(UUISlider,execRefreshSubscriberValue)
	MAP_NATIVE(UUISlider,execGetDataStoreBinding)
	MAP_NATIVE(UUISlider,execSetDataStoreBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISlider);

NATIVE_INFO(UUITabButton) GEngineUUITabButtonNatives[] = 
{ 
	MAP_NATIVE(UUITabButton,execIsTargeted)
	MAP_NATIVE(UUITabButton,execCanActivateButton)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabButton);

NATIVE_INFO(UUITabControl) GEngineUUITabControlNatives[] = 
{ 
	MAP_NATIVE(UUITabControl,execCreateTabPage)
	MAP_NATIVE(UUITabControl,execFindTargetedTab)
	MAP_NATIVE(UUITabControl,execGetPageAtIndex)
	MAP_NATIVE(UUITabControl,execGetPageCount)
	MAP_NATIVE(UUITabControl,execRequestLayoutUpdate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabControl);

NATIVE_INFO(UUITabPage) GEngineUUITabPageNatives[] = 
{ 
	MAP_NATIVE(UUITabPage,execClearBoundDataStores)
	MAP_NATIVE(UUITabPage,execGetBoundDataStores)
	MAP_NATIVE(UUITabPage,execRefreshSubscriberValue)
	MAP_NATIVE(UUITabPage,execGetDataStoreBinding)
	MAP_NATIVE(UUITabPage,execSetDataStoreBinding)
	MAP_NATIVE(UUITabPage,execGetOwnerTabControl)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITabPage);

NATIVE_INFO(UUITexture) GEngineUUITextureNatives[] = 
{ 
	MAP_NATIVE(UUITexture,execHasValidStyleData)
	MAP_NATIVE(UUITexture,execSetImageStyle)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUITexture);

NATIVE_INFO(UUIToggleButton) GEngineUUIToggleButtonNatives[] = 
{ 
	MAP_NATIVE(UUIToggleButton,execSetValue)
	MAP_NATIVE(UUIToggleButton,execSaveSubscriberValue)
	MAP_NATIVE(UUIToggleButton,execClearBoundDataStores)
	MAP_NATIVE(UUIToggleButton,execGetBoundDataStores)
	MAP_NATIVE(UUIToggleButton,execRefreshSubscriberValue)
	MAP_NATIVE(UUIToggleButton,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIToggleButton);

NATIVE_INFO(UUIToolTip) GEngineUUIToolTipNatives[] = 
{ 
	MAP_NATIVE(UUIToolTip,execUpdateToolTipPosition)
	MAP_NATIVE(UUIToolTip,execEndTracking)
	MAP_NATIVE(UUIToolTip,execBeginTracking)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIToolTip);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,ConsoleEntry,ConsolePromptLabel)
VERIFY_CLASS_OFFSET_NODIE(U,ConsoleEntry,CursorPosition)
VERIFY_CLASS_SIZE_NODIE(UConsoleEntry)
VERIFY_CLASS_OFFSET_NODIE(U,CurrentGameDataStore,ProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,CurrentGameDataStore,TeamData)
VERIFY_CLASS_SIZE_NODIE(UCurrentGameDataStore)
VERIFY_CLASS_SIZE_NODIE(UCurrentWeaponDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GameInfoDataProvider,GameDataSource)
VERIFY_CLASS_SIZE_NODIE(UGameInfoDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,GameUISceneClient,ActiveScenes)
VERIFY_CLASS_OFFSET_NODIE(U,GameUISceneClient,AnimSubscribers)
VERIFY_CLASS_SIZE_NODIE(UGameUISceneClient)
VERIFY_CLASS_SIZE_NODIE(UInventoryDataProvider)
VERIFY_CLASS_SIZE_NODIE(UPickupDataProvider)
VERIFY_CLASS_SIZE_NODIE(UPlayerDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataProvider,PlayerData)
VERIFY_CLASS_SIZE_NODIE(UPlayerOwnerDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataStore,ProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerOwnerDataStore,PowerupList)
VERIFY_CLASS_SIZE_NODIE(UPlayerOwnerDataStore)
VERIFY_CLASS_SIZE_NODIE(UPlayerSettingsProvider)
VERIFY_CLASS_SIZE_NODIE(UPowerupDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,SceneDataStore,OwnerScene)
VERIFY_CLASS_OFFSET_NODIE(U,SceneDataStore,SceneDataProvider)
VERIFY_CLASS_SIZE_NODIE(USceneDataStore)
VERIFY_CLASS_OFFSET_NODIE(U,SessionSettingsProvider,ProviderClientClass)
VERIFY_CLASS_OFFSET_NODIE(U,SessionSettingsProvider,ProviderClient)
VERIFY_CLASS_SIZE_NODIE(USessionSettingsProvider)
VERIFY_CLASS_SIZE_NODIE(UTeamDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,SeqName)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,Tracks)
VERIFY_CLASS_SIZE_NODIE(UUIAnimationSeq)
VERIFY_CLASS_OFFSET_NODIE(U,UIButton,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIButton,ClickedCue)
VERIFY_CLASS_SIZE_NODIE(UUIButton)
VERIFY_CLASS_OFFSET_NODIE(U,UICheckbox,ValueDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UICheckbox,CheckStyle)
VERIFY_CLASS_SIZE_NODIE(UUICheckbox)
VERIFY_CLASS_OFFSET_NODIE(U,UIComboBox,ComboEditboxClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIComboBox,__CreateCustomComboList__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIComboBox)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_AutoAlignment,Vertical)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_AutoAlignment,VertAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIComp_AutoAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ContextMenuListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawCaption)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawComponents,FadeType)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawComponents,__OnFadeComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawComponents)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawImage,StyleResolverTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawImage,ImageCoordinates)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawString,SubscriberOwner)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawString,ClipAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawString)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawStringEditbox,UserText)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawStringEditbox,CaretOffset)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawStringEditbox)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawStringSlider)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListComponentBase)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListElementSorter,InitialSortColumn)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListElementSorter,SecondarySortColumn)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListElementSorter)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListPresenter,ElementSchema)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_ListPresenter,ListItemOverlayCoordinates)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenterCascade)
VERIFY_CLASS_SIZE_NODIE(UUIComp_ListPresenterTree)
VERIFY_CLASS_OFFSET_NODIE(U,UIConfigFileProvider,Sections)
VERIFY_CLASS_SIZE_NODIE(UUIConfigFileProvider)
VERIFY_CLASS_SIZE_NODIE(UUIConfigProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIConfigSectionProvider,SectionName)
VERIFY_CLASS_SIZE_NODIE(UUIConfigSectionProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIContainer,AutoAlignment)
VERIFY_CLASS_SIZE_NODIE(UUIContainer)
VERIFY_CLASS_OFFSET_NODIE(U,UIContextMenu,InvokingWidget)
VERIFY_CLASS_OFFSET_NODIE(U,UIContextMenu,MenuItems)
VERIFY_CLASS_SIZE_NODIE(UUIContextMenu)
VERIFY_CLASS_OFFSET_NODIE(U,UICustomSkin,WidgetStyleMap)
VERIFY_CLASS_SIZE_NODIE(UUICustomSkin)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider,WriteAccessType)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider,__OnDataProviderPropertyChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineClanMates)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineFriends,FriendsList)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineFriends)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlinePlayerDataBase,Player)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayerDataBase)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayers)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettings,Profile)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettings,ProfileSettingsArrayProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettingsArray,ProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_OnlineProfileSettingsArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineProfileSettingsArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_Settings,Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_Settings,SettingsArrayProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_SettingsArray,Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_SettingsArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_SettingsArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore,Tag)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore,__OnRefreshDataStore__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Color)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Fonts)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameResource,ElementProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameResource,ListElementProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameResource)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_GameState,__OnRefreshDataFieldValue__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameState)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Gamma)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Images)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSearch,SearchResultsName)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSearch,SelectedIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSearch)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSettings,GameSettingsCfgList)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineGameSettings,SelectedIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlinePlayerData,FriendsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlinePlayerData,ProfileProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlinePlayerData)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineStats,StatsReadClasses)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_OnlineStats,PlayerInterface)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineStats)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_PlayerSettings,PlayerSettingsProviderClassNames)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_PlayerSettings,PlayerIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_PlayerSettings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_Registry,RegistryDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Registry)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Remote)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_SessionSettings,SessionSettingsProviderClassNames)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_SessionSettings,SessionSettings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_SessionSettings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Settings)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_StringAliasMap,MenuInputMapArray)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_StringAliasMap,PlayerIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_Strings,LocFileProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Strings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStorePublisher)
VERIFY_CLASS_SIZE_NODIE(UUIDataStoreSubscriber)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicDataProvider,DataClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicDataProvider,DataSource)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicFieldProvider,PersistentDataFields)
VERIFY_CLASS_OFFSET_NODIE(U,UIDynamicFieldProvider,RuntimeCollectionData)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicFieldProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditBox,DataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIEditBox,__OnSubmitText__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIEditBox)
VERIFY_CLASS_SIZE_NODIE(UUIEditboxString)
VERIFY_CLASS_OFFSET_NODIE(U,UIFrameBox,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIFrameBox,BackgroundCornerSizes)
VERIFY_CLASS_SIZE_NODIE(UUIFrameBox)
VERIFY_CLASS_OFFSET_NODIE(U,UIImage,ImageDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIImage,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UUIImage)
VERIFY_CLASS_OFFSET_NODIE(U,UILabel,DataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UILabel,LabelBackground)
VERIFY_CLASS_SIZE_NODIE(UUILabel)
VERIFY_CLASS_OFFSET_NODIE(U,UILabelButton,CaptionDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UILabelButton,StringRenderComponent)
VERIFY_CLASS_SIZE_NODIE(UUILabelButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIList,RowHeight)
VERIFY_CLASS_OFFSET_NODIE(U,UIList,__OnListElementsSorted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIList)
VERIFY_CLASS_SIZE_NODIE(UUIListElementCellProvider)
VERIFY_CLASS_SIZE_NODIE(UUIListElementProvider)
VERIFY_CLASS_SIZE_NODIE(UUIListString)
VERIFY_CLASS_OFFSET_NODIE(U,UIMeshWidget,Mesh)
VERIFY_CLASS_SIZE_NODIE(UUIMeshWidget)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericEditBox,IncrementStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericEditBox,DecButton_Position)
VERIFY_CLASS_SIZE_NODIE(UUINumericEditBox)
VERIFY_CLASS_SIZE_NODIE(UUINumericEditBoxButton)
VERIFY_CLASS_OFFSET_NODIE(U,UINumericOptionList,RangeValue)
VERIFY_CLASS_SIZE_NODIE(UUINumericOptionList)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,WidgetID)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,__OnUIAnimEnd__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIObject)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionList,CurrentIndex)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionList,DataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIOptionList)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionListBase,DecrementStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UIOptionListBase,__CreateCustomIncrementButton__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIOptionListBase)
VERIFY_CLASS_SIZE_NODIE(UUIOptionListButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIPanel,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIPanel,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UUIPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefab,PrefabVersion)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefab,ModificationCounter)
VERIFY_CLASS_SIZE_NODIE(UUIPrefab)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefabInstance,SourcePrefab)
VERIFY_CLASS_OFFSET_NODIE(U,UIPrefabInstance,PI_ObjectMap)
VERIFY_CLASS_SIZE_NODIE(UUIPrefabInstance)
VERIFY_CLASS_SIZE_NODIE(UUIPrefabScene)
VERIFY_CLASS_OFFSET_NODIE(U,UIProgressBar,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIProgressBar,ProgressBarOrientation)
VERIFY_CLASS_SIZE_NODIE(UUIProgressBar)
VERIFY_CLASS_OFFSET_NODIE(U,UIPropertyDataProvider,ComplexPropertyTypes)
VERIFY_CLASS_SIZE_NODIE(UUIPropertyDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UISafeRegionPanel,RegionType)
VERIFY_CLASS_OFFSET_NODIE(U,UISafeRegionPanel,RegionPercentages)
VERIFY_CLASS_SIZE_NODIE(UUISafeRegionPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,SceneTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,__OnTopSceneChanged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,Position)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,__NotifyVisibilityChanged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScreenObject)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbar,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbar,__OnClickedScrollZone__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbar)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbarButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollbarMarkerButton,__OnButtonDragged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScrollbarMarkerButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollFrame,StaticBackgroundImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIScrollFrame,FrameBounds)
VERIFY_CLASS_SIZE_NODIE(UUIScrollFrame)
VERIFY_CLASS_OFFSET_NODIE(U,UISettingsProvider,ProviderTag)
VERIFY_CLASS_SIZE_NODIE(UUISettingsProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UISkin,Styles)
VERIFY_CLASS_OFFSET_NODIE(U,UISkin,SoundCueMap)
VERIFY_CLASS_SIZE_NODIE(UUISkin)
VERIFY_CLASS_OFFSET_NODIE(U,UISlider,BackgroundImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,UISlider,DecrementCue)
VERIFY_CLASS_SIZE_NODIE(UUISlider)
VERIFY_CLASS_SIZE_NODIE(UUIState_Active)
VERIFY_CLASS_SIZE_NODIE(UUIState_Focused)
VERIFY_CLASS_SIZE_NODIE(UUIState_Pressed)
VERIFY_CLASS_SIZE_NODIE(UUIState_TargetedTab)
VERIFY_CLASS_SIZE_NODIE(UUIStringRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Combo,ImageStyle)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Combo,TextStyle)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Combo)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Data,UIEditorControlClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Data,StyleColor)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Data)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Image,DefaultImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Image,AdjustmentType)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Image)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Text,StyleFont)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle_Text,Scale)
VERIFY_CLASS_SIZE_NODIE(UUIStyle_Text)
VERIFY_CLASS_SIZE_NODIE(UUIStyleResolver)
VERIFY_CLASS_OFFSET_NODIE(U,UITabButton,TabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UITabButton,__IsActivationAllowed__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUITabButton)
VERIFY_CLASS_OFFSET_NODIE(U,UITabControl,Pages)
VERIFY_CLASS_OFFSET_NODIE(U,UITabControl,__OnPageRemoved__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUITabControl)
VERIFY_CLASS_OFFSET_NODIE(U,UITabPage,ButtonClass)
VERIFY_CLASS_OFFSET_NODIE(U,UITabPage,PageDescription)
VERIFY_CLASS_SIZE_NODIE(UUITabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UITexture,ImageStyleData)
VERIFY_CLASS_OFFSET_NODIE(U,UITexture,ImageTexture)
VERIFY_CLASS_SIZE_NODIE(UUITexture)
VERIFY_CLASS_OFFSET_NODIE(U,UIToggleButton,ValueDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UIToggleButton,CheckedBackgroundImageComponent)
VERIFY_CLASS_SIZE_NODIE(UUIToggleButton)
VERIFY_CLASS_OFFSET_NODIE(U,UIToolTip,SecondsActive)
VERIFY_CLASS_OFFSET_NODIE(U,UIToolTip,__DeactivateToolTip__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIToolTip)
VERIFY_CLASS_SIZE_NODIE(UWeaponDataProvider)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
