/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineUIPrivateGlobalIncludes.h"

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_UIPRIVATE_ENUMS
#define INCLUDED_ENGINE_UIPRIVATE_ENUMS 1

enum EProviderAccessType
{
    ACCESS_ReadOnly         =0,
    ACCESS_PerField         =1,
    ACCESS_WriteAll         =2,
    ACCESS_MAX              =3,
};
#define FOREACH_ENUM_EPROVIDERACCESSTYPE(op) \
    op(ACCESS_ReadOnly) \
    op(ACCESS_PerField) \
    op(ACCESS_WriteAll) 
enum EStatsFetchType
{
    SFT_Player              =0,
    SFT_CenteredOnPlayer    =1,
    SFT_Friends             =2,
    SFT_TopRankings         =3,
    SFT_MAX                 =4,
};
#define FOREACH_ENUM_ESTATSFETCHTYPE(op) \
    op(SFT_Player) \
    op(SFT_CenteredOnPlayer) \
    op(SFT_Friends) \
    op(SFT_TopRankings) 
enum EMenuOptionType
{
    MENUOT_ComboReadOnly    =0,
    MENUOT_ComboNumeric     =1,
    MENUOT_CheckBox         =2,
    MENUOT_Slider           =3,
    MENUOT_Spinner          =4,
    MENUOT_EditBox          =5,
    MENUOT_CollectionCheckBox=6,
    MENUOT_CollapsingList   =7,
    MENUOT_MAX              =8,
};
#define FOREACH_ENUM_EMENUOPTIONTYPE(op) \
    op(MENUOT_ComboReadOnly) \
    op(MENUOT_ComboNumeric) \
    op(MENUOT_CheckBox) \
    op(MENUOT_Slider) \
    op(MENUOT_Spinner) \
    op(MENUOT_EditBox) \
    op(MENUOT_CollectionCheckBox) \
    op(MENUOT_CollapsingList) 

#endif // !INCLUDED_ENGINE_UIPRIVATE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_UIPRIVATE_CLASSES
#define INCLUDED_ENGINE_UIPRIVATE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UUIDataStoreSubscriber : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStoreSubscriber,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStoreSubscriber)
};

class IUIDataStoreSubscriber
{
protected:
	virtual ~IUIDataStoreSubscriber() {}
public:
	typedef UUIDataStoreSubscriber UClassType;
	virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber()=0;
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1)=0;
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const=0;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1)=0;
    virtual void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex)=0;
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores)=0;
    virtual void ClearBoundDataStores()=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStoreSubscriber)
};

class UUIDataStorePublisher : public UUIDataStoreSubscriber
{
public:
    DECLARE_ABSTRACT_CLASS(UUIDataStorePublisher,UUIDataStoreSubscriber,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStorePublisher)
};

class IUIDataStorePublisher : public IUIDataStoreSubscriber
{
protected:
	virtual ~IUIDataStorePublisher() {}
public:
	typedef UUIDataStorePublisher UClassType;
	virtual UObject* GetUObjectInterfaceUIDataStorePublisher()=0;
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIDataStorePublisher)
};

#define UCONST_UnknownCellDataFieldName NAME_None

class UUIListElementCellProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementCellProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementCellProvider)
};

class IUIListElementCellProvider
{
protected:
	virtual ~IUIListElementCellProvider() {}
public:
	typedef UUIListElementCellProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementCellProvider()=0;
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )=0;

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )=0;

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )=0;
};

class UUIListElementProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIListElementProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIListElementProvider)
};

class IUIListElementProvider
{
protected:
	virtual ~IUIListElementProvider() {}
public:
	typedef UUIListElementProvider UClassType;
	virtual UObject* GetUObjectInterfaceUIListElementProvider()=0;
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags()=0;

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName )=0;

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements )=0;

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName )=0;

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex )=0;
};

struct FUIDataProviderField
{
    FName FieldTag;
    BYTE FieldType;
private:
    TArray<class UUIDataProvider*> FieldProviders;
public:

	/** Constructors */
	FUIDataProviderField() {}

	FUIDataProviderField( FName InFieldTag, EUIDataProviderFieldType InFieldType=DATATYPE_Property, class UUIDataProvider* InFieldProvider=NULL );
	FUIDataProviderField( FName InFieldTag, const TArray<class UUIDataProvider*>& InFieldProviders );

	/**
	 * Retrieves the list of providers contained by this data provider field.
	 *
	 * @return	FALSE if the FieldType for this provider field is not DATATYPE_Provider/ProviderCollection
	 */
	UBOOL GetProviders( TArray<class UUIDataProvider*>& out_Providers ) const;

};

struct UIDataProvider_eventNotifyPropertyChanged_Parms
{
    FName PropTag;
    UIDataProvider_eventNotifyPropertyChanged_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventIsCollectionDataType_Parms
{
    BYTE FieldType;
    UBOOL ReturnValue;
    UIDataProvider_eventIsCollectionDataType_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventIsProviderDisabled_Parms
{
    UBOOL ReturnValue;
    UIDataProvider_eventIsProviderDisabled_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGenerateFillerData_Parms
{
    FString DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateFillerData_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGenerateScriptMarkupString_Parms
{
    FName DataTag;
    FString ReturnValue;
    UIDataProvider_eventGenerateScriptMarkupString_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventSetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventSetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventGetFieldValue_Parms
{
    FString FieldName;
    struct FUIProviderScriptFieldValue FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventGetFieldValue_Parms(EEventParm)
    : FieldValue(EC_EventParm)
    {
    }
};
struct UIDataProvider_eventAllowPublishingToField_Parms
{
    FString FieldName;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIDataProvider_eventAllowPublishingToField_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventGetSupportedScriptFields_Parms
{
    TArray<struct FUIDataProviderField> out_Fields;
    UIDataProvider_eventGetSupportedScriptFields_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_eventOnDataProviderPropertyChange_Parms
{
    class UUIDataProvider* SourceProvider;
    FName PropTag;
    UIDataProvider_eventOnDataProviderPropertyChange_Parms(EEventParm)
    {
    }
};
class UUIDataProvider : public UUIRoot
{
public:
    //## BEGIN PROPS UIDataProvider
    BYTE WriteAccessType;
    TArrayNoInit<FScriptDelegate> ProviderChangedNotifies;
    FScriptDelegate __OnDataProviderPropertyChange__Delegate;
    //## END PROPS UIDataProvider

    UBOOL GetProviderFieldType(const FString& DataTag,BYTE& out_ProviderFieldType);
    virtual INT ParseArrayDelimiter(FString& DataTag) const;
    DECLARE_FUNCTION(execGetProviderFieldType)
    {
        P_GET_STR(DataTag);
        P_GET_BYTE_REF(out_ProviderFieldType);
        P_FINISH;
        *(UBOOL*)Result=this->GetProviderFieldType(DataTag,out_ProviderFieldType);
    }
    DECLARE_FUNCTION(execParseArrayDelimiter)
    {
        P_GET_STR_REF(DataTag);
        P_FINISH;
        *(INT*)Result=this->ParseArrayDelimiter(DataTag);
    }
    void eventNotifyPropertyChanged(FName PropTag=NAME_None)
    {
        UIDataProvider_eventNotifyPropertyChanged_Parms Parms(EC_EventParm);
        Parms.PropTag=PropTag;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPropertyChanged),&Parms);
    }
    UBOOL eventIsCollectionDataType(BYTE FieldType)
    {
        UIDataProvider_eventIsCollectionDataType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldType=FieldType;
        ProcessEvent(FindFunctionChecked(ENGINE_IsCollectionDataType),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsProviderDisabled()
    {
        UIDataProvider_eventIsProviderDisabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsProviderDisabled),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGenerateFillerData(const FString& DataTag)
    {
        UIDataProvider_eventGenerateFillerData_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateFillerData),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGenerateScriptMarkupString(FName DataTag)
    {
        UIDataProvider_eventGenerateScriptMarkupString_Parms Parms(EC_EventParm);
        Parms.DataTag=DataTag;
        ProcessEvent(FindFunctionChecked(ENGINE_GenerateScriptMarkupString),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetFieldValue(const FString& FieldName,const struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventSetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetFieldValue),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetFieldValue(const FString& FieldName,struct FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex=-1)
    {
        UIDataProvider_eventGetFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.FieldValue=FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFieldValue),&Parms);
        FieldValue=Parms.FieldValue;
        return Parms.ReturnValue;
    }
    UBOOL eventAllowPublishingToField(const FString& FieldName,INT ArrayIndex=-1)
    {
        UIDataProvider_eventAllowPublishingToField_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_AllowPublishingToField),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetSupportedScriptFields(TArray<struct FUIDataProviderField>& out_Fields)
    {
        UIDataProvider_eventGetSupportedScriptFields_Parms Parms(EC_EventParm);
        Parms.out_Fields=out_Fields;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedScriptFields),&Parms);
        out_Fields=Parms.out_Fields;
    }
    void delegateOnDataProviderPropertyChange(class UUIDataProvider* SourceProvider,FName PropTag=NAME_None)
    {
        UIDataProvider_eventOnDataProviderPropertyChange_Parms Parms(EC_EventParm);
        Parms.SourceProvider=SourceProvider;
        Parms.PropTag=PropTag;
        ProcessDelegate(ENGINE_OnDataProviderPropertyChange,&__OnDataProviderPropertyChange__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider,UUIRoot,0|CLASS_Transient,Engine)
protected:
	/**
	 * Returns the data tag associated with the specified provider.
	 *
	 * @return	the data field tag associated with the provider specified, or NAME_None if the provider specified is not
	 *			contained by this data store.
	 */
	virtual FName GetProviderDataTag( class UUIDataProvider* Provider );

	/**
	 * Determines whether publishing updated values to the specified field is allowed.
	 *
	 * @param	PropTag		the name of the field within this data provider to check access for (might be blank)
	 * @param	ArrayIndex	optional array index for use with data collections.
	 *
	 * @return	TRUE if publishing updated values is allowed for the field.
	 */
	virtual UBOOL AllowsPublishingData( const FString& PropTag, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventGetFieldValue(FieldName, out_FieldValue, ArrayIndex);
	}

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE )
	{
		return eventSetFieldValue(FieldName, FieldValue, ArrayIndex);
	}

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue );

	/**
	 * Parses the data store reference and publishes the value specified to that location.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	FieldValue		contains the value that should be published to the location specified by MarkupString.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL SetDataStoreValue( const FString& MarkupString, const struct FUIProviderScriptFieldValue& FieldValue );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but for some data stores such as the Scene data store, data is pulled from an internal provider but the data fields are presented as
	 * though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider() { return this; }

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex );

	// NON VIRTUALS
	/**
	 * Returns whether the specified provider is contained by this data provider.
	 *
	 * @param	Provider			the provider to search for
	 * @param	out_ProviderOwner	will contain the UIDataProvider that contains the field tag which corresonds to the
	 *								Provider being searched for.
	 *
	 * @return	TRUE if Provider can be accessed through this data provider.
	 */
	UBOOL ContainsProvider( class UUIDataProvider* Provider, class UUIDataProvider*& out_ProviderOwner );

	/**
	 * Generates a data store path to the specified provider.
	 *
	 * @param	Provider			the data store provider to generate a path name to
	 * @param	out_DataStorePath	will be filled in with the path name necessary to access the specified provider,
	 *								including any trailing dots or colons
	 */
	void GetPathToProvider(class UUIDataStore* ContainerDataStore, class UUIDataProvider* Provider, FString& out_DataStorePath );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTag				the tag corresponding to the data field that we want a path to
	 *
	 * @return		a string containing the complete path name required to access the specified data field
	 */
	FString BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const FName& DataTag );

	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTag				the data field tag to generate the markup string for
	 *
	 * @return	a datastore markup string which resolves to the datastore field associated with DataTag, in the format:
	 *			<DataStoreTag:DataFieldTag>
	 */
	FString GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, FName DataTag );

	/**
	 * Builds the data store path name necessary to access the specified tag of this data provider.
	 *
	 * This is a bulk version of the BuildDataFieldPath function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the data field path
	 * @param	DataTags			Array of tags to build paths for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Paths			Array of generated paths, one for each of the datatags passed in.
	 */
	void BuildDataFieldPath( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Paths );


	/**
	 * Generates a data store markup string which can be used to access the data field specified.
	 *
	 * This is a bulk version of the GenerateDataMarkupString function.
	 *
	 * @param	ContainerDataStore	the data store to use as the starting point for building the markup string
	 * @param	DataTags			array of tags to generate the markup string for, ALL of these tags are assumed to be under the same data provider.
	 * @param	Out_Markup			Array of strings of generated markup, one for each tag passed in.
	 */
	void GenerateDataMarkupString( class UUIDataStore* ContainerDataStore, const TArray<FName>& DataTags, TArray<FString> &Out_Markup );


	/**
	 * Determines if the specified data tag is supported by this data provider
	 *
	 * @param	DataTag		the tag corresponding to the data field that we want to check for
	 *
	 * @return	TRUE if the data tag specified is supported by this data provider.
	 */
	UBOOL IsDataTagSupported( FName DataTag );

	/**
	 * Determines if the specified data tag is supported by this data provider
	 *
	 * @param	DataTag		a tag corresponding to the data field that we want to check for; ok for the tag to contain array indexes
	 * @param	SupportedFields		the collection of fields to search through; if empty, will automatically fill in the array by calling
	 *								GetSupportedFields; useful optimization when calling this method repeatedly, e.g. in a loop
	 *
	 * @return	TRUE if the data tag specified is supported by this data provider.
	 */
	UBOOL IsDataTagSupported( FName DataTag, TArray<struct FUIDataProviderField>& SupportedFields );

	/**
	 * Parses the specified markup string to get the data tag that should be evaluated by this data provider.
	 *
	 * @param	MarkupString	a string that contains a markup reference (either in whole, or in part), e.g. CurrentGame:Players;1.PlayerName.
	 *							if successfully parsed, after parsing,
	 * @param	out_NextDataTag	a string representing the data tag for the next portion of the data store path reference, including any
	 *							any array delimiters.
	 *
	 * @return	TRUE if the a data tag was successfully parsed.
	 */
	UBOOL ParseNextDataTag( FString& MarkupString, FString& out_NextDataTag ) const;
};

class UUIConfigProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIConfigProvider
    //## END PROPS UIConfigProvider

    DECLARE_ABSTRACT_CLASS(UUIConfigProvider,UUIDataProvider,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIConfigProvider)
};

class UUIConfigFileProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigFileProvider
    TArrayNoInit<class UUIConfigSectionProvider*> Sections;
    //## END PROPS UIConfigFileProvider

    DECLARE_CLASS(UUIConfigFileProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
	/** the name of the config file associated with this data provider */
	FFilename	ConfigFileName;

	/* === UIConfigFileProvider interface === */
	/**
	 * Initializes this config file provider, creating the section data providers for each of the sections contained
	 * within the ConfigFile specified.
	 *
	 * @param	ConfigFile	the config file to associated with this data provider
	 */
	void InitializeProvider( class FConfigFile* ConfigFile );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIConfigSectionProvider : public UUIConfigProvider
{
public:
    //## BEGIN PROPS UIConfigSectionProvider
    FStringNoInit SectionName;
    //## END PROPS UIConfigSectionProvider

    DECLARE_CLASS(UUIConfigSectionProvider,UUIConfigProvider,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIConfigFileProvider)
	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

struct UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms
{
    UIDataProvider_OnlinePlayerDataBase_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayerDataBase
    INT PlayerControllerId;
    //## END PROPS UIDataProvider_OnlinePlayerDataBase

    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataProvider_OnlinePlayerDataBase_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataProvider_OnlinePlayerDataBase,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Provides the data provider with the player they were just bound to
	 *
	 * @param Player the local player associated with this player settings provider
	 */
	virtual void OnRegister(ULocalPlayer* InPlayer)
	{
		eventOnRegister(InPlayer);
	}

	/**
	 * Tells the provider that the player is no longer valid
	 */
	virtual void OnUnregister(void)
	{
		eventOnUnregister();
	}
};

class UUIDataProvider_OnlineFriendMessages : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineFriendMessages
    TArrayNoInit<struct FOnlineFriendMessage> Messages;
    FStringNoInit SendingPlayerNameCol;
    FStringNoInit bIsFriendInviteCol;
    FStringNoInit bWasAcceptedCol;
    FStringNoInit bWasDeniedCol;
    FStringNoInit MessageCol;
    FStringNoInit LastInviteFrom;
    //## END PROPS UIDataProvider_OnlineFriendMessages

    DECLARE_CLASS(UUIDataProvider_OnlineFriendMessages,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("SendingPlayerNick")),*SendingPlayerNameCol);
		CellTags.Set(FName(TEXT("bIsFriendInvite")),*bIsFriendInviteCol);
		CellTags.Set(FName(TEXT("bWasAccepted")),*bWasAcceptedCol);
		CellTags.Set(FName(TEXT("bWasDenied")),*bWasDeniedCol);
		CellTags.Set(FName(TEXT("Message")),*MessageCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType )
	{
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields(TArray<struct FUIDataProviderField>& out_Fields)
	{
		new(out_Fields)FUIDataProviderField(FName(TEXT("FriendMessages")),DATATYPE_Collection);
		new(out_Fields)FUIDataProviderField(FName(TEXT("LastInviteFrom")));
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UIDataProvider_OnlineFriends_eventRefreshFriendsList_Parms
{
    UIDataProvider_OnlineFriends_eventRefreshFriendsList_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlineFriends : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineFriends
    TArrayNoInit<struct FOnlineFriend> FriendsList;
    FStringNoInit NickNameCol;
    FStringNoInit PresenceInfoCol;
    FStringNoInit FriendStateCol;
    FStringNoInit bIsOnlineCol;
    FStringNoInit bIsPlayingCol;
    FStringNoInit bIsPlayingThisGameCol;
    FStringNoInit bIsJoinableCol;
    FStringNoInit bHasVoiceSupportCol;
    FStringNoInit bHaveInvitedCol;
    FStringNoInit bHasInvitedYouCol;
    FStringNoInit OfflineText;
    FStringNoInit OnlineText;
    FStringNoInit AwayText;
    FStringNoInit BusyText;
    //## END PROPS UIDataProvider_OnlineFriends

    void eventRefreshFriendsList()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshFriendsList),NULL);
    }
    DECLARE_CLASS(UUIDataProvider_OnlineFriends,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("NickName")),*NickNameCol);
		CellTags.Set(FName(TEXT("PresenceInfo")),*PresenceInfoCol);
		CellTags.Set(FName(TEXT("FriendState")),*FriendStateCol);
		CellTags.Set(FName(TEXT("bIsOnline")),*bIsOnlineCol);
		CellTags.Set(FName(TEXT("bIsPlaying")),*bIsPlayingCol);
		CellTags.Set(FName(TEXT("bIsPlayingThisGame")),*bIsPlayingThisGameCol);
		CellTags.Set(FName(TEXT("bIsJoinable")),*bIsJoinableCol);
		CellTags.Set(FName(TEXT("bHasVoiceSupport")),*bHasVoiceSupportCol);
		CellTags.Set(FName(TEXT("bHaveInvited")),*bHaveInvitedCol);
		CellTags.Set(FName(TEXT("bHasInvitedYou")),*bHasInvitedYouCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& CellFieldType)
	{
		CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Friends")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UIDataProvider_OnlinePartyChatList_eventRefreshMembersList_Parms
{
    UIDataProvider_OnlinePartyChatList_eventRefreshMembersList_Parms(EEventParm)
    {
    }
};
class UUIDataProvider_OnlinePartyChatList : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePartyChatList
    TArrayNoInit<struct FOnlinePartyMember> PartyMembersList;
    TArrayNoInit<FString> NatTypes;
    FStringNoInit NickNameCol;
    FStringNoInit NatTypeCol;
    FStringNoInit IsLocalCol;
    FStringNoInit IsInPartyVoiceCol;
    FStringNoInit IsTalkingCol;
    FStringNoInit IsInGameSessionCol;
    FStringNoInit IsPlayingThisGameCol;
    //## END PROPS UIDataProvider_OnlinePartyChatList

    void eventRefreshMembersList()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshMembersList),NULL);
    }
    DECLARE_CLASS(UUIDataProvider_OnlinePartyChatList,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags)
	{
		CellTags.Set(FName(TEXT("NickName")),*NickNameCol);
		CellTags.Set(FName(TEXT("NatType")),*NatTypeCol);
		CellTags.Set(FName(TEXT("bIsLocal")),*IsLocalCol);
		CellTags.Set(FName(TEXT("bIsInPartyVoice")),*IsInPartyVoiceCol);
		CellTags.Set(FName(TEXT("bIsTalking")),*IsTalkingCol);
		CellTags.Set(FName(TEXT("bIsInGameSession")),*IsInGameSessionCol);
		CellTags.Set(FName(TEXT("bIsPlayingThisGame")),*IsPlayingThisGameCol);
	}

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName,const FName& CellTag,BYTE& CellFieldType)
	{
		CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue(FName FieldName,const FName& CellTag,INT ListIndex,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex=INDEX_NONE);

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields(TArray<struct FUIDataProviderField>& out_Fields)
	{
		new(out_Fields) FUIDataProviderField(FName(TEXT("PartyChatMembers")),DATATYPE_Collection);
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex=INDEX_NONE);
};

struct FPlayerStorageArrayProvider
{
    INT PlayerStorageId;
    FName PlayerStorageName;
    class UUIDataProvider_OnlinePlayerStorageArray* Provider;

    /** Constructors */
    FPlayerStorageArrayProvider() {}
    FPlayerStorageArrayProvider(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerStorageArrayProvider));
    }
};

class UUIDataProvider_OnlinePlayerStorage : public UUIDataProvider_OnlinePlayerDataBase
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayerStorage
    class UOnlinePlayerStorage* Profile;
    FName ProviderName;
    BITFIELD bWasErrorLastRead:1;
    BITFIELD bIsExternalUIOpen:1;
    BITFIELD bNeedsDeferredRefresh:1;
    TArrayNoInit<struct FPlayerStorageArrayProvider> PlayerStorageArrayProviders;
    INT DeviceStorageSizeNeeded;
    //## END PROPS UIDataProvider_OnlinePlayerStorage

    DECLARE_CLASS(UUIDataProvider_OnlinePlayerStorage,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Tells the provider the settings object it is resposible for exposing to
	 * the UI
	 *
	 * @param InSettings the settings object to expose
	 */
	virtual void BindPlayerStorage(UOnlinePlayerStorage* InStorage);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );
};

class UUIDataProvider_OnlineProfileSettings : public UUIDataProvider_OnlinePlayerStorage
{
public:
    //## BEGIN PROPS UIDataProvider_OnlineProfileSettings
    //## END PROPS UIDataProvider_OnlineProfileSettings

    DECLARE_CLASS(UUIDataProvider_OnlineProfileSettings,UUIDataProvider_OnlinePlayerStorage,0|CLASS_Transient|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataProvider_OnlineProfileSettings)
};

class UUIDataProvider_PlayerAchievements : public UUIDataProvider_OnlinePlayerDataBase, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_PlayerAchievements
    TArrayNoInit<struct FAchievementDetails> Achievements;
    //## END PROPS UIDataProvider_PlayerAchievements

    INT GetTotalGamerScore() const;
    INT GetMaxTotalGamerScore() const;
    DECLARE_FUNCTION(execGetTotalGamerScore)
    {
        P_FINISH;
        *(INT*)Result=this->GetTotalGamerScore();
    }
    DECLARE_FUNCTION(execGetMaxTotalGamerScore)
    {
        P_FINISH;
        *(INT*)Result=this->GetMaxTotalGamerScore();
    }
    DECLARE_CLASS(UUIDataProvider_PlayerAchievements,UUIDataProvider_OnlinePlayerDataBase,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === IUIListElement interface === */
	/**
	 * Returns the names of the exposed members in OnlineFriend
	 *
	 * @see OnlineFriend structure in OnlineSubsystem
	 */
	virtual void GetElementCellTags(FName FieldName, TMap<FName,FString>& CellTags);

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& CellFieldType);

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_OnlinePlayerStorageArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_OnlinePlayerStorageArray
    class UOnlinePlayerStorage* PlayerStorage;
    INT PlayerStorageId;
    FName PlayerStorageName;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<FName> Values;
    //## END PROPS UIDataProvider_OnlinePlayerStorageArray

    DECLARE_CLASS(UUIDataProvider_OnlinePlayerStorageArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new storage object and id to this provider.
	 *
	 * @param NewStorage the new object to bind
	 * @param NewPlayerStorageId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(UOnlinePlayerStorage* NewStorage,INT NewPlayerStorageId);

	/**
	 * Binds the new storage object and id to this provider.
	 *
	 * @param NewStorage the new object to bind
	 * @param PropertyId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(UOnlinePlayerStorage* NewStorage,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

class UUIDataProvider_SettingsArray : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_SettingsArray
    class USettings* Settings;
    INT SettingsId;
    FName SettingsName;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<struct FIdToStringMapping> Values;
    //## END PROPS UIDataProvider_SettingsArray

    DECLARE_CLASS(UUIDataProvider_SettingsArray,UUIDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Binds the new settings object and id to this provider.
	 *
	 * @param NewSettings the new object to bind
	 * @param NewSettingsId the id of the settings array to expose
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindStringSetting(USettings* NewSettings,INT NewSettingsId);

	/**
	 * Binds the property id as an array item. Requires that the property
	 * has a mapping type of PVMT_PredefinedValues
	 *
	 * @param NewSettings the new object to bind
	 * @param PropertyId the id of the property to expose as an array
	 *
	 * @return TRUE if the call worked, FALSE otherwise
	 */
	UBOOL BindPropertySetting(USettings* NewSettings,INT PropertyId);

	/**
	 * Determines if the specified name matches ours
	 *
	 * @param Property the name to compare with our own
	 *
	 * @return TRUE if the name matches, FALSE otherwise
	 */
	UBOOL IsMatch(const TCHAR* Property);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_eventRefreshSubscribers_Parms
{
    FName PropertyTag;
    UBOOL bInvalidateValues;
    class UUIDataProvider* SourceProvider;
    INT ArrayIndex;
    UIDataStore_eventRefreshSubscribers_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberDetached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberDetached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventSubscriberAttached_Parms
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    UIDataStore_eventSubscriberAttached_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventUnregistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventUnregistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventRegistered_Parms
{
    class ULocalPlayer* PlayerOwner;
    UIDataStore_eventRegistered_Parms(EEventParm)
    {
    }
};
struct UIDataStore_eventOnDataStoreValueUpdated_Parms
{
    class UUIDataStore* SourceDataStore;
    UBOOL bValuesInvalidated;
    FName PropertyTag;
    class UUIDataProvider* SourceProvider;
    INT ArrayIndex;
    UIDataStore_eventOnDataStoreValueUpdated_Parms(EEventParm)
    {
    }
};
class UUIDataStore : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataStore
    FName Tag;
    TArrayNoInit<FScriptDelegate> RefreshSubscriberNotifies;
    FScriptDelegate __OnDataStoreValueUpdated__Delegate;
    //## END PROPS UIDataStore

    virtual void OnCommit();
    DECLARE_FUNCTION(execOnCommit)
    {
        P_FINISH;
        this->OnCommit();
    }
    void eventRefreshSubscribers(FName PropertyTag=NAME_None,UBOOL bInvalidateValues=TRUE,class UUIDataProvider* SourceProvider=NULL,INT ArrayIndex=-1)
    {
        UIDataStore_eventRefreshSubscribers_Parms Parms(EC_EventParm);
        Parms.PropertyTag=PropertyTag;
        Parms.bInvalidateValues=bInvalidateValues ? FIRST_BITFIELD : FALSE;
        Parms.SourceProvider=SourceProvider;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshSubscribers),&Parms);
    }
    void eventSubscriberDetached(const TScriptInterface<class IUIDataStoreSubscriber>& Subscriber)
    {
        UIDataStore_eventSubscriberDetached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberDetached),&Parms);
    }
    void eventSubscriberAttached(const TScriptInterface<class IUIDataStoreSubscriber>& Subscriber)
    {
        UIDataStore_eventSubscriberAttached_Parms Parms(EC_EventParm);
        Parms.Subscriber=Subscriber;
        ProcessEvent(FindFunctionChecked(ENGINE_SubscriberAttached),&Parms);
    }
    void eventUnregistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventUnregistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Unregistered),&Parms);
    }
    void eventRegistered(class ULocalPlayer* PlayerOwner)
    {
        UIDataStore_eventRegistered_Parms Parms(EC_EventParm);
        Parms.PlayerOwner=PlayerOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_Registered),&Parms);
    }
    void delegateOnDataStoreValueUpdated(class UUIDataStore* SourceDataStore,UBOOL bValuesInvalidated,FName PropertyTag,class UUIDataProvider* SourceProvider,INT ArrayIndex)
    {
        UIDataStore_eventOnDataStoreValueUpdated_Parms Parms(EC_EventParm);
        Parms.SourceDataStore=SourceDataStore;
        Parms.bValuesInvalidated=bValuesInvalidated ? FIRST_BITFIELD : FALSE;
        Parms.PropertyTag=PropertyTag;
        Parms.SourceProvider=SourceProvider;
        Parms.ArrayIndex=ArrayIndex;
        ProcessDelegate(ENGINE_OnDataStoreValueUpdated,&__OnDataStoreValueUpdated__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore,UUIDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Allows each data store the chance to load any dependent classes
	 */
	virtual void LoadDependentClasses(void)
	{
	}

	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

	/**
	 * Called when this data store is removed from the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnUnregister( class ULocalPlayer* PlayerOwner );

	/**
	 * Retrieves the tag used for referencing this data store.  Normally corresponds to Tag, but may be different for some special
	 * data stores.
	 */
	virtual FName GetDataStoreID() const { return Tag; }
};

struct FDynamicResourceProviderDefinition
{
    FName ProviderTag;
    FStringNoInit ProviderClassName;
    class UClass* ProviderClass;

    /** Constructors */
    FDynamicResourceProviderDefinition() {}
    FDynamicResourceProviderDefinition(EEventParm)
    {
        appMemzero(this, sizeof(FDynamicResourceProviderDefinition));
    }
};

class UUIDataStore_DynamicResource : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_DynamicResource
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    class UUIDataStore_GameResource* GameResourceDataStore;
    TArrayNoInit<struct FDynamicResourceProviderDefinition> ResourceProviderDefinitions;
    TMultiMap<FName,class UUIResourceCombinationProvider*> ResourceProviders;
    //## END PROPS UIDataStore_DynamicResource

    INT FindProviderTypeIndex(FName ProviderTag) const;
    FName GenerateProviderAccessTag(INT ProviderIndex,INT InstanceIndex) const;
    virtual INT GetProviderCount(FName ProviderTag) const;
    UBOOL GetResourceProviders(FName ProviderTag,TArray<class UUIResourceCombinationProvider*>& out_Providers) const;
    UBOOL GetResourceProviderFields(FName ProviderTag,TArray<FName>& ProviderFieldTags) const;
    UBOOL GetProviderFieldValue(FName ProviderTag,FName SearchField,INT ProviderIndex,struct FUIProviderScriptFieldValue& out_FieldValue) const;
    INT FindProviderIndexByFieldValue(FName ProviderTag,FName SearchField,const struct FUIProviderScriptFieldValue& ValueToSearchFor) const;
    void OnLoginChange(BYTE LocalUserNum);
    DECLARE_FUNCTION(execFindProviderTypeIndex)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=this->FindProviderTypeIndex(ProviderTag);
    }
    DECLARE_FUNCTION(execGenerateProviderAccessTag)
    {
        P_GET_INT(ProviderIndex);
        P_GET_INT(InstanceIndex);
        P_FINISH;
        *(FName*)Result=this->GenerateProviderAccessTag(ProviderIndex,InstanceIndex);
    }
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=this->GetProviderCount(ProviderTag);
    }
    DECLARE_FUNCTION(execGetResourceProviders)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(class UUIResourceCombinationProvider*,out_Providers);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviders(ProviderTag,out_Providers);
    }
    DECLARE_FUNCTION(execGetResourceProviderFields)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(FName,ProviderFieldTags);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviderFields(ProviderTag,ProviderFieldTags);
    }
    DECLARE_FUNCTION(execGetProviderFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_INT(ProviderIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,out_FieldValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetProviderFieldValue(ProviderTag,SearchField,ProviderIndex,out_FieldValue);
    }
    DECLARE_FUNCTION(execFindProviderIndexByFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,ValueToSearchFor);
        P_FINISH;
        *(INT*)Result=this->FindProviderIndexByFieldValue(ProviderTag,SearchField,ValueToSearchFor);
    }
    DECLARE_FUNCTION(execOnLoginChange)
    {
        P_GET_BYTE(LocalUserNum);
        P_FINISH;
        this->OnLoginChange(LocalUserNum);
    }
    DECLARE_CLASS(UUIDataStore_DynamicResource,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the data provider associated with the tag specified.
	 *
	 * @param	ProviderTag		The tag of the provider to find.  Must match the ProviderTag value for one of elements
	 *							in the ElementProviderTypes array, though it can contain an array index (in which case
	 *							the array index will be removed from the ProviderTag value passed in).
	 * @param	InstanceIndex	If ProviderTag contains an array index, this will be set to the array index value that was parsed.
	 *
	 * @return	a data provider instance (or CDO if no array index was included in ProviderTag) for the element provider
	 *			type associated with ProviderTag.
	 */
	class UUIResourceCombinationProvider* ResolveProviderReference( FName& ProviderTag, INT* InstanceIndex=NULL ) const;

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Parses the string specified, separating the array index portion from the data field tag.
	 *
	 * @param	DataTag		the data tag that possibly contains an array index
	 *
	 * @return	the array index that was parsed from DataTag, or INDEX_NONE if there was no array index in the string specified.
	 */
	virtual INT ParseArrayDelimiter( FString& DataTag ) const;

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIDataStore_Fonts : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Fonts
    //## END PROPS UIDataStore_Fonts

    DECLARE_CLASS(UUIDataStore_Fonts,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataProvider interface === */
	/**
	 * Gets the list of font names available through this data store.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * This data store cannot generate string nodes.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue ) { return FALSE; }
};

struct FGameResourceDataProvider
{
    FName ProviderTag;
    FStringNoInit ProviderClassName;
    BITFIELD bExpandProviders:1;
    class UClass* ProviderClass;

    /** Constructors */
    FGameResourceDataProvider() {}
    FGameResourceDataProvider(EEventParm)
    {
        appMemzero(this, sizeof(FGameResourceDataProvider));
    }
};

class UUIDataStore_GameResource : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_GameResource
    TArrayNoInit<struct FGameResourceDataProvider> ElementProviderTypes;
    TMultiMap<FName,class UUIResourceDataProvider*> ListElementProviders;
    //## END PROPS UIDataStore_GameResource

    INT FindProviderTypeIndex(FName ProviderTag) const;
    FName GenerateProviderAccessTag(INT ProviderIndex,INT InstanceIndex) const;
    virtual INT GetProviderCount(FName ProviderTag) const;
    UBOOL GetResourceProviders(FName ProviderTag,TArray<class UUIResourceDataProvider*>& out_Providers) const;
    UBOOL GetResourceProviderFields(FName ProviderTag,TArray<FName>& ProviderFieldTags) const;
    UBOOL GetProviderFieldValue(FName ProviderTag,FName SearchField,INT ProviderIndex,struct FUIProviderScriptFieldValue& out_FieldValue) const;
    INT FindProviderIndexByFieldValue(FName ProviderTag,FName SearchField,const struct FUIProviderScriptFieldValue& ValueToSearchFor) const;
    DECLARE_FUNCTION(execFindProviderTypeIndex)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=this->FindProviderTypeIndex(ProviderTag);
    }
    DECLARE_FUNCTION(execGenerateProviderAccessTag)
    {
        P_GET_INT(ProviderIndex);
        P_GET_INT(InstanceIndex);
        P_FINISH;
        *(FName*)Result=this->GenerateProviderAccessTag(ProviderIndex,InstanceIndex);
    }
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=this->GetProviderCount(ProviderTag);
    }
    DECLARE_FUNCTION(execGetResourceProviders)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(class UUIResourceDataProvider*,out_Providers);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviders(ProviderTag,out_Providers);
    }
    DECLARE_FUNCTION(execGetResourceProviderFields)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(FName,ProviderFieldTags);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviderFields(ProviderTag,ProviderFieldTags);
    }
    DECLARE_FUNCTION(execGetProviderFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_INT(ProviderIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,out_FieldValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetProviderFieldValue(ProviderTag,SearchField,ProviderIndex,out_FieldValue);
    }
    DECLARE_FUNCTION(execFindProviderIndexByFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,ValueToSearchFor);
        P_FINISH;
        *(INT*)Result=this->FindProviderIndexByFieldValue(ProviderTag,SearchField,ValueToSearchFor);
    }
    DECLARE_CLASS(UUIDataStore_GameResource,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the data provider associated with the tag specified.
	 *
	 * @param	ProviderTag		The tag of the provider to find.  Must match the ProviderTag value for one of elements
	 *							in the ElementProviderTypes array, though it can contain an array index (in which case
	 *							the array index will be removed from the ProviderTag value passed in).
	 * @param	InstanceIndex	If ProviderTag contains an array index, this will be set to the array index value that was parsed.
	 *
	 * @return	a data provider instance (or CDO if no array index was included in ProviderTag) for the element provider
	 *			type associated with ProviderTag.
	 */
	class UUIResourceDataProvider* ResolveProviderReference( FName& ProviderTag, INT* InstanceIndex=NULL ) const;

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/**
	 * Parses the string specified, separating the array index portion from the data field tag.
	 *
	 * @param	DataTag		the data tag that possibly contains an array index
	 *
	 * @return	the array index that was parsed from DataTag, or INDEX_NONE if there was no array index in the string specified.
	 */
	virtual INT ParseArrayDelimiter( FString& DataTag ) const;

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIDataStore_MenuItems : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS UIDataStore_MenuItems
    FName CurrentGameSettingsTag;
    TMultiMap<FName, class UUIDataProvider_MenuItem*> OptionProviders;
    TArrayNoInit<class UUIDataProvider_MenuItem*> DynamicProviders;
    //## END PROPS UIDataStore_MenuItems

    virtual void ClearSet(FName SetName);
    virtual void AppendToSet(FName SetName,INT NumOptions);
    virtual void GetSet(FName SetName,TArray<class UUIDataProvider_MenuItem*>& OutProviders);
    DECLARE_FUNCTION(execClearSet)
    {
        P_GET_NAME(SetName);
        P_FINISH;
        this->ClearSet(SetName);
    }
    DECLARE_FUNCTION(execAppendToSet)
    {
        P_GET_NAME(SetName);
        P_GET_INT(NumOptions);
        P_FINISH;
        this->AppendToSet(SetName,NumOptions);
    }
    DECLARE_FUNCTION(execGetSet)
    {
        P_GET_NAME(SetName);
        P_GET_TARRAY_REF(class UUIDataProvider_MenuItem*,OutProviders);
        P_FINISH;
        this->GetSet(SetName,OutProviders);
    }
    DECLARE_CLASS(UUIDataStore_MenuItems,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UUIDataStore_MenuItems interface === */
	/**
	 * Converts the specified name into the tag required to access the options for the current game settings object,
	 * if the specified field is CurrentGameSettingsTag.  Otherwise, does nothing.
	 *
	 * @param	FieldName	the name of the field that was passed to this data store.
	 *
	 * @return	a tag which can be used to access the settings collection for the current game settings object, or the same
	 *			value as the input value.
	 */
	FName ResolveFieldName( FName FieldName ) const;
	FString ResolveFieldString( const FString& FieldString ) const;

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUIDataProvider_MenuItem*>& OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );
};

struct UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms
{
    UIDataStore_GameState_eventOnRefreshDataFieldValue_Parms(EEventParm)
    {
    }
};
class UUIDataStore_GameState : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_GameState
    FScriptDelegate __OnRefreshDataFieldValue__Delegate;
    //## END PROPS UIDataStore_GameState

    void delegateOnRefreshDataFieldValue()
    {
        ProcessDelegate(ENGINE_OnRefreshDataFieldValue,&__OnRefreshDataFieldValue__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_GameState,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_GameState)
};

#define UCONST_UNRANKEDPROVIDERTAG TEXT("PlaylistsUnranked")
#define UCONST_RANKEDPROVIDERTAG TEXT("PlaylistsRanked")

class UUIDataStore_OnlinePlaylists : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlinePlaylists
    FStringNoInit ProviderClassName;
    class UClass* ProviderClass;
    TArrayNoInit<class UUIResourceDataProvider*> RankedDataProviders;
    TArrayNoInit<class UUIResourceDataProvider*> UnRankedDataProviders;
    //## END PROPS UIDataStore_OnlinePlaylists

    virtual INT GetProviderCount(FName ProviderTag) const;
    UBOOL GetResourceProviders(FName ProviderTag,TArray<class UUIResourceDataProvider*>& out_Providers) const;
    UBOOL GetResourceProviderFields(FName ProviderTag,TArray<FName>& ProviderFieldTags) const;
    UBOOL GetProviderFieldValue(FName ProviderTag,FName SearchField,INT ProviderIndex,struct FUIProviderScriptFieldValue& out_FieldValue) const;
    INT FindProviderIndexByFieldValue(FName ProviderTag,FName SearchField,const struct FUIProviderScriptFieldValue& ValueToSearchFor) const;
    UBOOL GetPlaylistProvider(FName ProviderTag,INT ProviderIndex,class UUIResourceDataProvider*& out_Provider);
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(ProviderTag);
        P_FINISH;
        *(INT*)Result=this->GetProviderCount(ProviderTag);
    }
    DECLARE_FUNCTION(execGetResourceProviders)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(class UUIResourceDataProvider*,out_Providers);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviders(ProviderTag,out_Providers);
    }
    DECLARE_FUNCTION(execGetResourceProviderFields)
    {
        P_GET_NAME(ProviderTag);
        P_GET_TARRAY_REF(FName,ProviderFieldTags);
        P_FINISH;
        *(UBOOL*)Result=this->GetResourceProviderFields(ProviderTag,ProviderFieldTags);
    }
    DECLARE_FUNCTION(execGetProviderFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_INT(ProviderIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,out_FieldValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetProviderFieldValue(ProviderTag,SearchField,ProviderIndex,out_FieldValue);
    }
    DECLARE_FUNCTION(execFindProviderIndexByFieldValue)
    {
        P_GET_NAME(ProviderTag);
        P_GET_NAME(SearchField);
        P_GET_STRUCT_INIT_REF(struct FUIProviderScriptFieldValue,ValueToSearchFor);
        P_FINISH;
        *(INT*)Result=this->FindProviderIndexByFieldValue(ProviderTag,SearchField,ValueToSearchFor);
    }
    DECLARE_FUNCTION(execGetPlaylistProvider)
    {
        P_GET_NAME(ProviderTag);
        P_GET_INT(ProviderIndex);
        P_GET_OBJECT_REF(UUIResourceDataProvider,out_Provider);
        P_FINISH;
        *(UBOOL*)Result=this->GetPlaylistProvider(ProviderTag,ProviderIndex,out_Provider);
    }
    DECLARE_CLASS(UUIDataStore_OnlinePlaylists,UUIDataStore,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === UUIDataStore_GameResource interface === */
	/**
	 * Finds or creates the UIResourceDataProvider instances used by online playlists, and stores the result by ranked or unranked provider types
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Finds the data provider associated with the tag specified.
	 *
	 * @param	ProviderTag		The tag of the provider to find.  Must match the ProviderTag value for one of elements
	 *							in the ElementProviderTypes array, though it can contain an array index (in which case
	 *							the array index will be removed from the ProviderTag value passed in).
	 * @param	InstanceIndex	If ProviderTag contains an array index, this will be set to the array index value that was parsed.
	 *
	 * @return	a data provider instance (or CDO if no array index was included in ProviderTag) for the element provider
	 *			type associated with ProviderTag.
	 */
	class UUIResourceDataProvider* ResolveProviderReference( FName& ProviderTag, INT* InstanceIndex=NULL ) const;

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === UIDataStore interface === */
	/**
	 * Loads the classes referenced by the ElementProviderTypes array.
	 */
	virtual void LoadDependentClasses();

	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<FUIDataProviderField>& out_Fields );

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );

	/**
	 * Callback for retrieving a textual representation of natively serialized properties.  Child classes should implement this method if they wish
	 * to have natively serialized property values included in things like diffcommandlet output.
	 *
	 * @param	out_PropertyValues	receives the property names and values which should be reported for this object.  The map's key should be the name of
	 *								the property and the map's value should be the textual representation of the property's value.  The property value should
	 *								be formatted the same way that UProperty::ExportText formats property values (i.e. for arrays, wrap in quotes and use a comma
	 *								as the delimiter between elements, etc.)
	 * @param	ExportFlags			bitmask of EPropertyPortFlags used for modifying the format of the property values
	 *
	 * @return	return TRUE if property values were added to the map.
	 */
	virtual UBOOL GetNativePropertyValues( TMap<FString,FString>& out_PropertyValues, DWORD ExportFlags=0 ) const;
};

class UUIDataStore_Registry : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Registry
    class UUIDynamicFieldProvider* RegistryDataProvider;
    //## END PROPS UIDataStore_Registry

    DECLARE_CLASS(UUIDataStore_Registry,UUIDataStore,0|CLASS_Transient,Engine)
	/* === UIDataStore interface === */
	/**
	 * Creates the data provider for this registry data store.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Returns a pointer to the data provider which provides the tags for this data provider.  Normally, that will be this data provider,
	 * but in this data store, the data fields are pulled from an internal provider but presented as though they are fields of the data store itself.
	 */
	virtual UUIDataProvider* GetDefaultDataProvider();

	/**
	 * Notifies the data store that all values bound to this data store in the current scene have been saved.  Provides data stores which
	 * perform buffered or batched data transactions with a way to determine when the UI system has finished writing data to the data store.
	 */
	virtual void OnCommit();
};

class UUIDataStore_Remote : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Remote
    //## END PROPS UIDataStore_Remote

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Remote,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Remote)
};

struct FGameSearchCfg
{
    class UClass* GameSearchClass;
    class UClass* DefaultGameSettingsClass;
    class UClass* SearchResultsProviderClass;
    class UUIDataProvider_Settings* DesiredSettingsProvider;
    TArrayNoInit<class UUIDataProvider_Settings*> SearchResults;
    class UOnlineGameSearch* Search;
    FName SearchName;

    /** Constructors */
    FGameSearchCfg() {}
    FGameSearchCfg(EEventParm)
    {
        appMemzero(this, sizeof(FGameSearchCfg));
    }
};

struct UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms
{
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventMoveToNext_Parms
{
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms
{
    FName SearchName;
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UBOOL bInvalidateExistingSearchResults;
    UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms
{
    class UOnlineGameSearch* ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms
{
    class UOnlineGameSearch* ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms
{
    BYTE ControllerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms
{
    INT ListIndex;
    struct FOnlineGameSearchResult Result;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms
{
    BYTE ControllerIndex;
    UBOOL bInvalidateExistingSearchResults;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSearch_eventInit_Parms
{
    UIDataStore_OnlineGameSearch_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSearch
    FName SearchResultsName;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> GameInterface;
    TArrayNoInit<struct FGameSearchCfg> GameSearchCfgList;
    INT SelectedIndex;
    INT ActiveSearchIndex;
    //## END PROPS UIDataStore_OnlineGameSearch

    virtual void BuildSearchResults();
    DECLARE_FUNCTION(execBuildSearchResults)
    {
        P_FINISH;
        this->BuildSearchResults();
    }
    void eventMoveToPrevious(UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventMoveToPrevious_Parms Parms(EC_EventParm);
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),&Parms);
    }
    void eventMoveToNext(UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventMoveToNext_Parms Parms(EC_EventParm);
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),&Parms);
    }
    void eventSetCurrentByName(FName SearchName,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SearchName=SearchName;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UOnlineGameSearch* eventGetActiveGameSearch()
    {
        UIDataStore_OnlineGameSearch_eventGetActiveGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActiveGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineGameSearch* eventGetCurrentGameSearch()
    {
        UIDataStore_OnlineGameSearch_eventGetCurrentGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShowHostGamercard(BYTE ControllerIndex,INT ListIndex)
    {
        UIDataStore_OnlineGameSearch_eventShowHostGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowHostGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetSearchResultFromIndex(INT ListIndex,struct FOnlineGameSearchResult& Result)
    {
        UIDataStore_OnlineGameSearch_eventGetSearchResultFromIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ListIndex=ListIndex;
        Parms.Result=Result;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSearchResultFromIndex),&Parms);
        Result=Parms.Result;
        return Parms.ReturnValue;
    }
    UBOOL eventSubmitGameSearch(BYTE ControllerIndex,UBOOL bInvalidateExistingSearchResults=TRUE)
    {
        UIDataStore_OnlineGameSearch_eventSubmitGameSearch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        Parms.bInvalidateExistingSearchResults=bInvalidateExistingSearchResults ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SubmitGameSearch),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSearch,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

// IUIListElementProvider interface

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	DataTag		a tag corresponding to tag of a data provider in this list element provider
	 *						that can be represented by a list
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount(FName DataTag);

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	OutElements		will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	DataTag			the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName);

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT ListIndex);
};

struct UIDataStore_OnlinePlayerData_eventGetCachedPlayerStorage_Parms
{
    INT ControllerId;
    class UOnlinePlayerStorage* ReturnValue;
    UIDataStore_OnlinePlayerData_eventGetCachedPlayerStorage_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms
{
    INT ControllerId;
    class UOnlineProfileSettings* ReturnValue;
    UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnUnregister_Parms
{
    UIDataStore_OnlinePlayerData_eventOnUnregister_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlinePlayerData_eventOnRegister_Parms
{
    class ULocalPlayer* InPlayer;
    UIDataStore_OnlinePlayerData_eventOnRegister_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlinePlayerData
    class UUIDataProvider_OnlineFriends* FriendsProvider;
    INT PlayerControllerId;
    FStringNoInit PlayerNick;
    FStringNoInit ProfileSettingsClassName;
    class UClass* ProfileSettingsClass;
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    FStringNoInit ProfileProviderClassName;
    class UClass* ProfileProviderClass;
    FStringNoInit PlayerStorageClassName;
    class UClass* PlayerStorageClass;
    class UUIDataProvider_OnlinePlayerStorage* StorageProvider;
    FStringNoInit StorageProviderClassName;
    class UClass* StorageProviderClass;
    class UUIDataProvider_OnlineFriendMessages* FriendMessagesProvider;
    class UUIDataProvider_PlayerAchievements* AchievementsProvider;
    FStringNoInit FriendsProviderClassName;
    class UClass* FriendsProviderClass;
    FStringNoInit FriendMessagesProviderClassName;
    class UClass* FriendMessagesProviderClass;
    FStringNoInit AchievementsProviderClassName;
    class UClass* AchievementsProviderClass;
    FStringNoInit PartyChatProviderClassName;
    class UClass* PartyChatProviderClass;
    class UUIDataProvider_OnlinePartyChatList* PartyChatProvider;
    //## END PROPS UIDataStore_OnlinePlayerData

    void OnSettingProviderChanged(class UUIDataProvider* SourceProvider,FName SettingsName=NAME_None);
    DECLARE_FUNCTION(execOnSettingProviderChanged)
    {
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_NAME_OPTX(SettingsName,NAME_None);
        P_FINISH;
        this->OnSettingProviderChanged(SourceProvider,SettingsName);
    }
    class UOnlinePlayerStorage* eventGetCachedPlayerStorage(INT ControllerId)
    {
        UIDataStore_OnlinePlayerData_eventGetCachedPlayerStorage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCachedPlayerStorage),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineProfileSettings* eventGetCachedPlayerProfile(INT ControllerId)
    {
        UIDataStore_OnlinePlayerData_eventGetCachedPlayerProfile_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCachedPlayerProfile),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnUnregister()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnUnregister),NULL);
    }
    void eventOnRegister(class ULocalPlayer* InPlayer)
    {
        UIDataStore_OnlinePlayerData_eventOnRegister_Parms Parms(EC_EventParm);
        Parms.InPlayer=InPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRegister),&Parms);
    }
    DECLARE_CLASS(UUIDataStore_OnlinePlayerData,UUIDataStore_Remote,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
/* === UIDataStore interface === */

	/**
	 * Loads the game specific OnlineProfileSettings class
	 */
	virtual void LoadDependentClasses(void);

	/**
	 * Creates the data providers exposed by this data store
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Forwards the calls to the data providers so they can do their start up
	 *
	 * @param Player the player that will be associated with this DataStore
	 */
	virtual void OnRegister(ULocalPlayer* Player);

	/**
	 * Tells all of the child providers to clear their player data
	 *
	 * @param Player ignored
	 */
	virtual void OnUnregister(ULocalPlayer*);

	/**
	 * Gets the list of data fields exposed by this data provider
	 *
	 * @param OutFields Filled in with the list of fields supported by its aggregated providers
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex );

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

/* === IUIListElementProvider interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );
};

struct FPlayerNickMetaData
{
    FName PlayerNickName;
    FStringNoInit PlayerNickColumnName;

    /** Constructors */
    FPlayerNickMetaData() {}
    FPlayerNickMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerNickMetaData));
    }
};

struct FRankMetaData
{
    FName RankName;
    FStringNoInit RankColumnName;

    /** Constructors */
    FRankMetaData() {}
    FRankMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FRankMetaData));
    }
};

struct UIDataStore_OnlineStats_eventShowGamercard_Parms
{
    BYTE ConrollerIndex;
    INT ListIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventShowGamercard_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventRefreshStats_Parms
{
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineStats_eventRefreshStats_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineStats_eventInit_Parms
{
    UIDataStore_OnlineStats_eventInit_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineStats : public UUIDataStore_Remote, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataStore_OnlineStats
    TArrayNoInit<class UClass*> StatsReadClasses;
    FName StatsReadName;
    struct FPlayerNickMetaData PlayerNickData;
    struct FRankMetaData RankNameMetaData;
    FName TotalRowsName;
    TArrayNoInit<class UOnlineStatsRead*> StatsReadObjects;
    class UOnlineStatsRead* StatsRead;
    BYTE CurrentReadType;
    TScriptInterface<class IInterface> StatsInterface;
    TScriptInterface<class IInterface> PlayerInterface;
    //## END PROPS UIDataStore_OnlineStats

    virtual void SortResultsByRank();
    DECLARE_FUNCTION(execSortResultsByRank)
    {
        P_FINISH;
        this->SortResultsByRank();
    }
    UBOOL eventShowGamercard(BYTE ConrollerIndex,INT ListIndex)
    {
        UIDataStore_OnlineStats_eventShowGamercard_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ConrollerIndex=ConrollerIndex;
        Parms.ListIndex=ListIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ShowGamercard),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRefreshStats(BYTE ControllerIndex)
    {
        UIDataStore_OnlineStats_eventRefreshStats_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RefreshStats),&Parms);
        return Parms.ReturnValue;
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineStats,UUIDataStore_Remote,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
protected:
// UIDataStore interface

	/**
	 * Loads and creates an instance of the registered stats read object
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Returns the stats read results as a collection
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields)
	{
		OutFields.Empty();
		new(OutFields)FUIDataProviderField(StatsReadName,DATATYPE_Collection);
		new(OutFields)FUIDataProviderField(TotalRowsName);
	}

	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE)
	{
		if (FName(*FieldName) == TotalRowsName)
		{
			OutFieldValue.PropertyType = DATATYPE_Property;
			OutFieldValue.StringValue = FString::Printf(TEXT("%d"),StatsRead ? StatsRead->TotalRowsInView : 0);
			return TRUE;
		}
		return FALSE;
	}

	/**
	 * Returns the list element provider for the specified proprety name
	 *
	 * @param PropertyName the name of the property to look up
	 *
	 * @return pointer to the interface or null if the property name is invalid
	 */
	virtual TScriptInterface<IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName)
	{
		if (FName(*PropertyName) == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementProvider>();
	}

// IUIListElement interface

	/**
	 * Returns the names of the columns that can be bound to
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param CellTag the tag for the element cell to get the field type for
	 * @param OutCellFieldType receives the field type for the specified cell (property)
	 *
	 * @return TRUE if the cell tag is valid, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldType(FName FieldName, const FName& CellTag,BYTE& OutCellFieldType);

	/**
	 * Finds the value for the specified column in a row (if valid)
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param CellTag the tag for the element cell to resolve the value for
	 * @param ListIndex the index into the stats read results array
	 * @param OutFieldValue the out value that holds the cell's value
	 * @param ArrayIndex ignored
	 *
	 * @return TRUE if the cell value was found, FALSE otherwise
	 */
	virtual UBOOL GetCellFieldValue(FName FieldName, const FName& CellTag,INT ListIndex,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex = INDEX_NONE);

// IUIListElementProvider interface

	/**
	 * Fetches the column names that can be bound
	 *
	 * @return the list of tags supported
	 */
	virtual TArray<FName> GetElementProviderTags(void);

	/**
	 * Returns the number of rows in the data set
	 *
	 * @param DataTag the name of the collection that is being queried
	 *
	 * @return the number of items in the list
	 */
	virtual INT GetElementCount(FName DataTag)
	{
		check(StatsRead);
		return StatsRead->Rows.Num();
	}

	/**
	 * Returns the list of indices for the list items
	 *
	 * @param	FieldName		the name of the property to get the indices for
	 * @param	OutElements		will be filled with the indices into the list
	 *
	 * @return	TRUE if the field name is valid, FALSE otherwise
	 */
	virtual UBOOL GetListElements(FName FieldName,TArray<INT>& OutElements);

	/**
	 * Fetches the interface that allows the UI to query for column names
	 *
	 * @param DataTag the tag of the list needed
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellSchemaProvider(FName FieldName)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}

	/**
	 * Fetches the interface that allows the UI to query for column values
	 *
	 * @param FieldName the tag of the list that needs the interface
	 * @param ListIndex ignored
	 *
	 * @return a pointer to the interface or null if invalid
	 */
	virtual TScriptInterface<IUIListElementCellProvider> GetElementCellValueProvider(FName FieldName,INT)
	{
		if (FieldName == StatsReadName)
		{
			return this;
		}
		return TScriptInterface<IUIListElementCellProvider>();
	}
};

class UUIDataStore_Settings : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_Settings
    //## END PROPS UIDataStore_Settings

    DECLARE_ABSTRACT_CLASS(UUIDataStore_Settings,UUIDataStore,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_Settings)
};

struct FGameSettingsCfg
{
    class UClass* GameSettingsClass;
    class UUIDataProvider_Settings* Provider;
    class UOnlineGameSettings* GameSettings;
    FName SettingsName;

    /** Constructors */
    FGameSettingsCfg() {}
    FGameSettingsCfg(EEventParm)
    {
        appMemzero(this, sizeof(FGameSettingsCfg));
    }
};

struct UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToPrevious_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventMoveToNext_Parms
{
    UIDataStore_OnlineGameSettings_eventMoveToNext_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms
{
    FName SettingsName;
    UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms
{
    INT NewIndex;
    UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms
{
    class UUIDataProvider_Settings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms
{
    class UOnlineGameSettings* ReturnValue;
    UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms(EEventParm)
    {
    }
};
struct UIDataStore_OnlineGameSettings_eventCreateGame_Parms
{
    BYTE ControllerIndex;
    UBOOL ReturnValue;
    UIDataStore_OnlineGameSettings_eventCreateGame_Parms(EEventParm)
    {
    }
};
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings
{
public:
    //## BEGIN PROPS UIDataStore_OnlineGameSettings
    TArrayNoInit<struct FGameSettingsCfg> GameSettingsCfgList;
    class UClass* SettingsProviderClass;
    INT SelectedIndex;
    //## END PROPS UIDataStore_OnlineGameSettings

    void OnSettingProviderChanged(class UUIDataProvider* SourceProvider,FName SettingsName=NAME_None);
    DECLARE_FUNCTION(execOnSettingProviderChanged)
    {
        P_GET_OBJECT(UUIDataProvider,SourceProvider);
        P_GET_NAME_OPTX(SettingsName,NAME_None);
        P_FINISH;
        this->OnSettingProviderChanged(SourceProvider,SettingsName);
    }
    void eventMoveToPrevious()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToPrevious),NULL);
    }
    void eventMoveToNext()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MoveToNext),NULL);
    }
    void eventSetCurrentByName(FName SettingsName)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByName_Parms Parms(EC_EventParm);
        Parms.SettingsName=SettingsName;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByName),&Parms);
    }
    void eventSetCurrentByIndex(INT NewIndex)
    {
        UIDataStore_OnlineGameSettings_eventSetCurrentByIndex_Parms Parms(EC_EventParm);
        Parms.NewIndex=NewIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_SetCurrentByIndex),&Parms);
    }
    class UUIDataProvider_Settings* eventGetCurrentProvider()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentProvider),&Parms);
        return Parms.ReturnValue;
    }
    class UOnlineGameSettings* eventGetCurrentGameSettings()
    {
        UIDataStore_OnlineGameSettings_eventGetCurrentGameSettings_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCurrentGameSettings),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventCreateGame(BYTE ControllerIndex)
    {
        UIDataStore_OnlineGameSettings_eventCreateGame_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerIndex=ControllerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateGame),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIDataStore_OnlineGameSettings,UUIDataStore_Settings,0|CLASS_Transient,Engine)
private:
	/**
	 * Loads and creates an instance of the registered provider objects for each
	 * registered OnlineGameSettings class
	 */
	virtual void InitializeDataStore(void);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	OutFieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);
};

class UUIDataStore_StringBase : public UUIDataStore
{
public:
    //## BEGIN PROPS UIDataStore_StringBase
    //## END PROPS UIDataStore_StringBase

    DECLARE_ABSTRACT_CLASS(UUIDataStore_StringBase,UUIDataStore,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIDataStore_StringBase)
};

struct FUIInputKeyData
{
    struct FRawInputKeyEventData InputKeyData;
    FStringNoInit ButtonFontMarkupString;

    /** Constructors */
    FUIInputKeyData() {}
    FUIInputKeyData(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputKeyData));
    }
};

struct FUIDataStoreInputAlias
{
    FName AliasName;
    struct FUIInputKeyData PlatformInputKeys[3];

    /** Constructors */
    FUIDataStoreInputAlias() {}
    FUIDataStoreInputAlias(EEventParm)
    {
        appMemzero(this, sizeof(FUIDataStoreInputAlias));
    }
};

class UUIDataStore_InputAlias : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_InputAlias
protected:
    TArrayNoInit<struct FUIDataStoreInputAlias> InputAliases;
    TMap< FName,INT > InputAliasLookupMap;
public:
    //## END PROPS UIDataStore_InputAlias

    FString GetAliasFontMarkup(FName DesiredAlias,BYTE OverridePlatform=3) const;
    FString GetAliasFontMarkupByIndex(INT AliasIndex,BYTE OverridePlatform=3) const;
    FName GetAliasInputKeyName(FName DesiredAlias,BYTE OverridePlatform=3) const;
    FName GetAliasInputKeyNameByIndex(INT AliasIndex,BYTE OverridePlatform=3) const;
    UBOOL GetAliasInputKeyData(struct FRawInputKeyEventData& out_InputKeyData,FName DesiredAlias,BYTE OverridePlatform=3) const;
    UBOOL GetAliasInputKeyDataByIndex(struct FRawInputKeyEventData& out_InputKeyData,INT AliasIndex,BYTE OverridePlatform=3) const;
    INT FindInputAliasIndex(FName DesiredAlias) const;
    UBOOL HasAliasMappingForPlatform(FName DesiredAlias,BYTE DesiredPlatform) const;
    DECLARE_FUNCTION(execGetAliasFontMarkup)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FString*)Result=this->GetAliasFontMarkup(DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasFontMarkupByIndex)
    {
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FString*)Result=this->GetAliasFontMarkupByIndex(AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyName)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FName*)Result=this->GetAliasInputKeyName(DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyNameByIndex)
    {
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(FName*)Result=this->GetAliasInputKeyNameByIndex(AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyData)
    {
        P_GET_STRUCT_REF(struct FRawInputKeyEventData,out_InputKeyData);
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(UBOOL*)Result=this->GetAliasInputKeyData(out_InputKeyData,DesiredAlias,OverridePlatform);
    }
    DECLARE_FUNCTION(execGetAliasInputKeyDataByIndex)
    {
        P_GET_STRUCT_REF(struct FRawInputKeyEventData,out_InputKeyData);
        P_GET_INT(AliasIndex);
        P_GET_BYTE_OPTX(OverridePlatform,3);
        P_FINISH;
        *(UBOOL*)Result=this->GetAliasInputKeyDataByIndex(out_InputKeyData,AliasIndex,OverridePlatform);
    }
    DECLARE_FUNCTION(execFindInputAliasIndex)
    {
        P_GET_NAME(DesiredAlias);
        P_FINISH;
        *(INT*)Result=this->FindInputAliasIndex(DesiredAlias);
    }
    DECLARE_FUNCTION(execHasAliasMappingForPlatform)
    {
        P_GET_NAME(DesiredAlias);
        P_GET_BYTE(DesiredPlatform);
        P_FINISH;
        *(UBOOL*)Result=this->HasAliasMappingForPlatform(DesiredAlias,DesiredPlatform);
    }
    DECLARE_CLASS(UUIDataStore_InputAlias,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	/* === UUIDataStore_InputAlias interface === */
	/**
	 * Populates the InputAliasLookupMap based on the elements of the InputAliases array.
	 */
	void InitializeLookupMap();

	/**
	 * @return	the platform that should be used (by default) when retrieving data associated with input aliases
	 */
	EInputPlatformType GetDefaultPlatform() const;

	/* === UUIDataStore interface === */
	/**
	 * Hook for performing any initialization required for this data store.
	 *
	 * This version builds the InputAliasLookupMap based on the elements in the InputAliases array.
	 */
	virtual void InitializeDataStore();

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider
	 *
	 * @param OutFields Filled in with the list of fields supported by its aggregated providers
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

protected:
	/**
	 * Gets the value for the specified field
	 *
	 * @param	FieldName		the field to look up the value for
	 * @param	OutFieldValue	out param getting the value
	 * @param	ArrayIndex		ignored
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& OutFieldValue,INT ArrayIndex=INDEX_NONE );
};

struct FUIMenuInputMap
{
    FName FieldName;
    FName Set;
    FStringNoInit MappedText;

    /** Constructors */
    FUIMenuInputMap() {}
    FUIMenuInputMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIMenuInputMap));
    }
};

class UUIDataStore_StringAliasMap : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_StringAliasMap
    TArrayNoInit<struct FUIMenuInputMap> MenuInputMapArray;
    TMap<FName, TMap<FName, INT> > MenuInputSets;
    INT PlayerIndex;
    //## END PROPS UIDataStore_StringAliasMap

    class ULocalPlayer* GetPlayerOwner() const;
    INT FindMappingWithFieldName(const FString& FieldName=TEXT(""),const FString& SetName=TEXT(""));
    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_FINISH;
        *(class ULocalPlayer**)Result=this->GetPlayerOwner();
    }
    DECLARE_FUNCTION(execFindMappingWithFieldName)
    {
        P_GET_STR_OPTX(FieldName,TEXT(""));
        P_GET_STR_OPTX(SetName,TEXT(""));
        P_FINISH;
        *(INT*)Result=this->FindMappingWithFieldName(FieldName,SetName);
    }
    DECLARE_FUNCTION(execGetStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_FINISH;
        *(INT*)Result=this->GetStringWithFieldName(FieldName,MappedString);
    }
    DECLARE_CLASS(UUIDataStore_StringAliasMap,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/* === UIDataProvider interface === */
protected:
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	* Called when this data store is added to the data store manager's list of active data stores.
	*
	* @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	*							associated with a particular player; NULL if this is a global data store.
	*/
	virtual void OnRegister( class ULocalPlayer* PlayerOwner );

public:
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UIDataStore_MenuStringMap interface === */
public:
	/** Return the string representation of the field being queried */
	virtual FString GetStringFromIndex( INT MapArrayIndex );
};

class UUIDataStore_Strings : public UUIDataStore_StringBase
{
public:
    //## BEGIN PROPS UIDataStore_Strings
    TArrayNoInit<class UUIConfigFileProvider*> LocFileProviders;
    //## END PROPS UIDataStore_Strings

    DECLARE_CLASS(UUIDataStore_Strings,UUIDataStore_StringBase,0|CLASS_Transient,Engine)
protected:
	/* === UUIDataStore_Strings interface === */
	/**
	 * Creates an UIConfigFileProvider instance for the loc file specified by FilePathName.
	 *
	 * @return	a pointer to a newly allocated UUIConfigFileProvider instance that contains the data for the specified
	 *			loc file.
	 */
	class UUIConfigFileProvider* CreateLocProvider( const FFilename& FilePathName );

public:
	/* === UIDataStore interface === */
	/**
	 * Loads all .int files and creates UIConfigProviders for each loc file that was loaded.
	 */
	virtual void InitializeDataStore();

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString, out_FieldValue);
	}

	/**
	 * Parses the data store reference and resolves the data provider and field that is referenced by the markup.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldOwner	receives the value of the data provider that owns the field referenced by the markup string.
	 * @param	out_FieldTag	receives the value of the property or field referenced by the markup string.
	 * @param	out_ArrayIndex	receives the optional array index for the data field referenced by the markup string.  If there is no array index embedded in the markup string,
	 *							value will be INDEX_NONE.
	 *
	 * @return	TRUE if this data store was able to successfully resolve the string specified.
	 */
	virtual UBOOL ParseDataStoreReference( const FString& MarkupString, class UUIDataProvider*& out_FieldOwner, FString& out_FieldTag, INT& out_ArrayIndex )
	{
		out_FieldOwner = this;
		out_FieldTag = MarkupString;
		return TRUE;
	}

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UUIDynamicFieldProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDynamicFieldProvider
protected:
    TArrayNoInit<struct FUIProviderScriptFieldValue> PersistentDataFields;
    TArrayNoInit<struct FUIProviderScriptFieldValue> RuntimeDataFields;
    TMap< FName, TMap<FName,TArray<FString> > > PersistentCollectionData;
    TMap< FName, TMap<FName,TArray<FString> > > RuntimeCollectionData;
public:
    //## END PROPS UIDynamicFieldProvider

    virtual void InitializeRuntimeFields();
    virtual UBOOL RemoveField(FName FieldName);
    virtual INT FindFieldIndex(FName FieldName,UBOOL bSearchPersistentFields=FALSE) const;
    virtual UBOOL ClearFields(UBOOL bReinitializeRuntimeFields=TRUE);
    virtual void SavePersistentProviderData();
    virtual UBOOL GetCollectionValueSchema(FName FieldName,TArray<FName>& out_CellTagArray,UBOOL bPersistent=FALSE);
    virtual UBOOL GetCollectionValueArray(FName FieldName,TArray<FString>& out_DataValueArray,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL SetCollectionValueArray(FName FieldName,const TArray<FString>& CollectionValues,UBOOL bClearExisting=TRUE,INT InsertIndex=-1,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL InsertCollectionValue(FName FieldName,const FString& NewValue,INT InsertIndex=-1,UBOOL bPersistent=FALSE,UBOOL bAllowDuplicateValues=FALSE,FName CellTag=NAME_None);
    virtual UBOOL RemoveCollectionValue(FName FieldName,const FString& ValueToRemove,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL RemoveCollectionValueByIndex(FName FieldName,INT ValueIndex,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ReplaceCollectionValue(FName FieldName,const FString& CurrentValue,const FString& NewValue,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ReplaceCollectionValueByIndex(FName FieldName,INT ValueIndex,const FString& NewValue,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL ClearCollectionValueArray(FName FieldName,UBOOL bPersistent=FALSE,FName CellTag=NAME_None);
    virtual UBOOL GetCollectionValue(FName FieldName,INT ValueIndex,FString& out_Value,UBOOL bPersistent=FALSE,FName CellTag=NAME_None) const;
    virtual INT FindCollectionValueIndex(FName FieldName,const FString& ValueToFind,UBOOL bPersistent=FALSE,FName CellTag=NAME_None) const;
    DECLARE_FUNCTION(execInitializeRuntimeFields)
    {
        P_FINISH;
        this->InitializeRuntimeFields();
    }
    DECLARE_FUNCTION(execAddField);
    DECLARE_FUNCTION(execRemoveField)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(UBOOL*)Result=this->RemoveField(FieldName);
    }
    DECLARE_FUNCTION(execFindFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bSearchPersistentFields,FALSE);
        P_FINISH;
        *(INT*)Result=this->FindFieldIndex(FieldName,bSearchPersistentFields);
    }
    DECLARE_FUNCTION(execClearFields)
    {
        P_GET_UBOOL_OPTX(bReinitializeRuntimeFields,TRUE);
        P_FINISH;
        *(UBOOL*)Result=this->ClearFields(bReinitializeRuntimeFields);
    }
    DECLARE_FUNCTION(execGetField);
    DECLARE_FUNCTION(execSetField);
    DECLARE_FUNCTION(execSavePersistentProviderData)
    {
        P_FINISH;
        this->SavePersistentProviderData();
    }
    DECLARE_FUNCTION(execGetCollectionValueSchema)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FName,out_CellTagArray);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->GetCollectionValueSchema(FieldName,out_CellTagArray,bPersistent);
    }
    DECLARE_FUNCTION(execGetCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FString,out_DataValueArray);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->GetCollectionValueArray(FieldName,out_DataValueArray,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execSetCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_TARRAY_REF(FString,CollectionValues);
        P_GET_UBOOL_OPTX(bClearExisting,TRUE);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->SetCollectionValueArray(FieldName,CollectionValues,bClearExisting,InsertIndex,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execInsertCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(NewValue);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_UBOOL_OPTX(bAllowDuplicateValues,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->InsertCollectionValue(FieldName,NewValue,InsertIndex,bPersistent,bAllowDuplicateValues,CellTag);
    }
    DECLARE_FUNCTION(execRemoveCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToRemove);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->RemoveCollectionValue(FieldName,ValueToRemove,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execRemoveCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->RemoveCollectionValueByIndex(FieldName,ValueIndex,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execReplaceCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(CurrentValue);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->ReplaceCollectionValue(FieldName,CurrentValue,NewValue,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execReplaceCollectionValueByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(NewValue);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->ReplaceCollectionValueByIndex(FieldName,ValueIndex,NewValue,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execClearCollectionValueArray)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->ClearCollectionValueArray(FieldName,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execGetCollectionValue)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ValueIndex);
        P_GET_STR_REF(out_Value);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(UBOOL*)Result=this->GetCollectionValue(FieldName,ValueIndex,out_Value,bPersistent,CellTag);
    }
    DECLARE_FUNCTION(execFindCollectionValueIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_STR_REF(ValueToFind);
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_NAME_OPTX(CellTag,NAME_None);
        P_FINISH;
        *(INT*)Result=this->FindCollectionValueIndex(FieldName,ValueToFind,bPersistent,CellTag);
    }
    DECLARE_CLASS(UUIDynamicFieldProvider,UUIDataProvider,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* === UIDynamicFieldProvider interface === */
	/**
	 * Adds a new data field to the list of supported fields.
	 *
	 * @param	FieldName			the name to give the new field
	 * @param	FieldType			the type of data field being added
	 * @param	bPersistent			specify TRUE to add the field to the PersistentDataFields array as well.
	 * @param	out_InsertPosition	allows the caller to find out where the element was inserted
	 *
	 * @return	TRUE if the field was successfully added to the list; FALSE if the a field with that name already existed
	 *			or the specified name was invalid.
	 */
	virtual UBOOL AddField( FName FieldName, BYTE FieldType=0, UBOOL bPersistent=FALSE, INT* out_InsertPosition=NULL );

	/* === UUIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/* === UObject interface === */
	/**
	 * Serializes the value of the PersistentCollectionData and RuntimeCollectionData members, since they are not supported
	 * by script serialization.
	 */
	virtual void Serialize( FArchive& Ar );
};

struct UIPropertyDataProvider_eventGetCustomPropertyValue_Parms
{
    struct FUIProviderScriptFieldValue PropertyValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIPropertyDataProvider_eventGetCustomPropertyValue_Parms(EEventParm)
    : PropertyValue(EC_EventParm)
    {
    }
};
struct UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms
{
    class UProperty* UnsupportedProperty;
    UBOOL ReturnValue;
    UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms(EEventParm)
    {
    }
};
class UUIPropertyDataProvider : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIPropertyDataProvider
    TArrayNoInit<class UClass*> ComplexPropertyTypes;
    FScriptDelegate __CanSupportComplexPropertyType__Delegate;
    //## END PROPS UIPropertyDataProvider

    UBOOL eventGetCustomPropertyValue(struct FUIProviderScriptFieldValue& PropertyValue,INT ArrayIndex=-1)
    {
        UIPropertyDataProvider_eventGetCustomPropertyValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PropertyValue=PropertyValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCustomPropertyValue),&Parms);
        PropertyValue=Parms.PropertyValue;
        return Parms.ReturnValue;
    }
    UBOOL delegateCanSupportComplexPropertyType(class UProperty* UnsupportedProperty)
    {
        UIPropertyDataProvider_eventCanSupportComplexPropertyType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.UnsupportedProperty=UnsupportedProperty;
        ProcessDelegate(ENGINE_CanSupportComplexPropertyType,&__CanSupportComplexPropertyType__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIPropertyDataProvider,UUIDataProvider,0|CLASS_Transient,Engine)
	/* === UUIPropertyDataProvider interface === */
	/**
	 * Returns whether the specified property type is renderable in the UI.
	 *
	 * @param	Property				the property to check
	 * @param	bRequireNativeSupport	TRUE to require the property to be natively supported (i.e. don't check whether it's supported in script).
	 *
	 * @return	TRUE if this property type is something that can be rendered in the UI.
	 *
	 * @note: can't be const it must call into the script VM, where we can't guarantee that the object's state won't be changed.
	 */
	virtual UBOOL IsValidProperty( UProperty* Property, UBOOL bRequireNativeSupport=FALSE );

	/**
	 * Builds a list of UProperties that are flagged for exposure to data stores from the specified class.
	 *
	 * @param	SourceClass		a pointer to a UClass that contains properties which are marked with the "databinding" keyword.
	 *							Must be a child of the class assigned as the value for DataClass.
	 * @param	out_Properties	will contain pointers to the properties of SourceClass which can be exposed to the data store system.
	 */
	void GetProviderDataBindings( UClass* SourceClass, TArray<UProperty*>& out_Properties );

	/**
	 * Wrapper for copying the property value for Prop into the data field value using the appropriate method.
	 *
	 * @param	Prop			the property that is being copied
	 * @param	BaseAddress		pointer to the beginning of the block of data containing the value for the property; for example,
	 *							if the property represents a class member property, you'd pass in 'this' as the value.
	 * @param	ArrayIndex		specifies the index for the value; only relevant for array properties or static arrays
	 * @param	out_FieldValue	receives the property value; tag and type will also be set to the appropriate value.
	 *
	 * @return	TRUE if the value was successfully copied into the output var.  FALSE if the property isn't supported.
	 */
	UBOOL CopyPropertyValueIntoFieldValue( UProperty* Prop, BYTE* BaseDataAddress, INT ArrayIndex, struct FUIProviderFieldValue& out_FieldValue );
};

struct UIDynamicDataProvider_eventIsValidDataSourceClass_Parms
{
    class UClass* PotentialDataSourceClass;
    UBOOL ReturnValue;
    UIDynamicDataProvider_eventIsValidDataSourceClass_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceUnbound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceUnbound_Parms(EEventParm)
    {
    }
};
struct UIDynamicDataProvider_eventProviderInstanceBound_Parms
{
    class UObject* DataSourceInstance;
    UIDynamicDataProvider_eventProviderInstanceBound_Parms(EEventParm)
    {
    }
};
class UUIDynamicDataProvider : public UUIPropertyDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDynamicDataProvider
    class UClass* DataClass;
    class UObject* DataSource;
    //## END PROPS UIDynamicDataProvider

    UBOOL BindProviderInstance(class UObject* DataSourceInstance);
    UBOOL UnbindProviderInstance();
    DECLARE_FUNCTION(execBindProviderInstance)
    {
        P_GET_OBJECT(UObject,DataSourceInstance);
        P_FINISH;
        *(UBOOL*)Result=this->BindProviderInstance(DataSourceInstance);
    }
    DECLARE_FUNCTION(execUnbindProviderInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=this->UnbindProviderInstance();
    }
    UBOOL eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass)
    {
        UIDynamicDataProvider_eventIsValidDataSourceClass_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.PotentialDataSourceClass=PotentialDataSourceClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidDataSourceClass),&Parms);
        return Parms.ReturnValue;
    }
    void eventProviderInstanceUnbound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceUnbound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceUnbound),&Parms);
    }
    void eventProviderInstanceBound(class UObject* DataSourceInstance)
    {
        UIDynamicDataProvider_eventProviderInstanceBound_Parms Parms(EC_EventParm);
        Parms.DataSourceInstance=DataSourceInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ProviderInstanceBound),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIDynamicDataProvider,UUIPropertyDataProvider,0|CLASS_Transient,Engine)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UUIDynamicDataProvider interface === */
	/**
	 * Determines whether the specified class should be represented by this dynamic data provider.
	 *
	 * @param	PotentialDataSourceClass	a pointer to a UClass that is being considered for binding by this provider.
	 *
	 * @return	TRUE to allow the databinding properties of PotentialDataSourceClass to be displayed in the UI editor's data store browser
	 *			under this data provider.
	 */
	UBOOL IsValidDataSourceClass( UClass* PotentialDataSourceClass );

	/**
	 * Builds an array of classes that are supported by this data provider.  Used in the editor to generate the list of
	 * supported data fields.  Since dynamic data providers are only created during the game, the editor needs a way to
	 * retrieve the list of data field tags that can be bound without requiring instances of this data provider's DataClass to exist.
	 *
	 * @note: only called in the editor!
	 */
	void GetSupportedClasses( TArray<UClass*>& out_Classes );

	/* === UUIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );


	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/* === IUIListElementCellProvider interface === */
	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName			the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *								instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct FSettingsArrayProvider
{
    INT SettingsId;
    FName SettingsName;
    class UUIDataProvider_SettingsArray* Provider;

    /** Constructors */
    FSettingsArrayProvider() {}
    FSettingsArrayProvider(EEventParm)
    {
        appMemzero(this, sizeof(FSettingsArrayProvider));
    }
};

class UUIDataProvider_Settings : public UUIDynamicDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_Settings
    class USettings* Settings;
    TArrayNoInit<struct FSettingsArrayProvider> SettingsArrayProviders;
    BITFIELD bIsAListRow:1;
    SCRIPT_ALIGN;
    //## END PROPS UIDataProvider_Settings

    DECLARE_CLASS(UUIDataProvider_Settings,UUIDynamicDataProvider,0|CLASS_Transient,Engine)
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue(const FString& FieldName,const FUIProviderScriptFieldValue& FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Generates filler data for a given tag. Uses the OnlineDataType to determine
	 * what the hardcoded filler data will look like
	 *
 	 * @param DataTag the tag to generate filler data for
 	 *
	 * @return a string containing example data
	 */
	virtual FString GenerateFillerData(const FString& DataTag);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider(const FString& PropertyName);

	/**
	 * Binds the new settings object to this provider. Sets the type to instance
	 *
	 * @param NewSettings the new object to bind
	 * @param bIsInList whether to use list handling or not
	 *
	 * @return TRUE if bound ok, FALSE otherwise
	 */
	UBOOL BindSettings(USettings* NewSettings,UBOOL bIsInList = FALSE);
};

struct UIResourceDataProvider_eventInitializeProvider_Parms
{
    UBOOL bIsEditor;
    UIResourceDataProvider_eventInitializeProvider_Parms(EEventParm)
    {
    }
};
class UUIResourceDataProvider : public UUIPropertyDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIResourceDataProvider
    BITFIELD bDataBindingPropertiesOnly:1;
    BITFIELD bSkipDuringEnumeration:1;
    SCRIPT_ALIGN;
    //## END PROPS UIResourceDataProvider

    void eventInitializeProvider(UBOOL bIsEditor)
    {
        UIResourceDataProvider_eventInitializeProvider_Parms Parms(EC_EventParm);
        Parms.bIsEditor=bIsEditor ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeProvider),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIResourceDataProvider,UUIPropertyDataProvider,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
public:
	/* === UUIResourceDataProvider interface === */
	/**
	 * Determine if the specified tag corresponds to a collection or provider collection
	 *
	 * @param	FieldTag				the name of the field to check
	 * @param	out_CollectionProperty	if valid, receives a reference to the property which corresponds to the tag specified.
	 *
	 * @return	TRUE if the specified tag is a static or dynamic array property.
	 */
	virtual UBOOL IsCollectionProperty( FName FieldTag, UProperty** out_CollectionProperty=NULL );

	/**
	 * Gets the list of properties in this class which correspond to arrays.
	 *
	 * @param	out_CollectionProperties	receives the list of array properties
	 *
	 * @return	TRUE if array properties were found.
	 */
	virtual UBOOL GetCollectionProperties( TArray<UProperty*>& out_CollectionProperties );

	/**
	 * Attempts to find a nested data provider given the parameters
	 *
	 * @param	CollectionProperty	the property that potentially holds the reference to the data provider
	 * @param	CollectionIndex		the index into the collection for the data provider to retrieve; if the value is invalid, the default
	 *								object for the property class will be used.
	 * @param	InternalProvider	receives the reference to the provider, if found.
	 *
	 * @return	TRUE if the property held a reference to a data provider (even if a NULL provider was found).
	 */
	virtual UBOOL GetNestedProvider( UProperty* CollectionProperty, INT CollectionIndex, UUIDataProvider*& InternalProvider );

	/* === UUIPropertyDataProvider interface === */
	/**
	 * Returns whether the specified property type is renderable in the UI.
	 *
	 * @param	Property				the property to check
	 * @param	bRequireNativeSupport	TRUE to require the property to be natively supported (i.e. don't check whether it's supported in script).
	 *
	 * @return	TRUE if this property type is something that can be rendered in the UI.
	 *
	 * @note: can't be const it must call into the script VM, where we can't guarantee that the object's state won't be changed.
	 */
	virtual UBOOL IsValidProperty( UProperty* Property, UBOOL bRequireNativeSupport=FALSE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_MenuItem : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_MenuItem
    BYTE OptionType;
    TArrayNoInit<FName> OptionSet;
    FStringNoInit DataStoreMarkup;
    FStringNoInit DescriptionMarkup;
    FName RequiredGameMode;
    FStringNoInit FriendlyName;
    FStringNoInit CustomFriendlyName;
    FStringNoInit Description;
    BITFIELD bEditableCombo:1;
    BITFIELD bNumericCombo:1;
    BITFIELD bKeyboardOrMouseOption:1;
    BITFIELD bOnlineOnly:1;
    BITFIELD bOfflineOnly:1;
    BITFIELD bSearchAllInis:1;
    BITFIELD bRemoveOn360:1;
    BITFIELD bRemoveOnPC:1;
    BITFIELD bRemoveOnPS3:1;
    INT EditBoxMaxLength;
    struct FUIRangeData RangeData;
    TArrayNoInit<FName> SchemaCellFields;
    FStringNoInit IniName;
    //## END PROPS UIDataProvider_MenuItem

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsFiltered();
    }
    DECLARE_CLASS(UUIDataProvider_MenuItem,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

    NO_DEFAULT_CONSTRUCTOR(UUIDataProvider_MenuItem)
};

class UUIMapSummary : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UIMapSummary
    FStringNoInit MapName;
    FStringNoInit ScreenshotPathName;
    FStringNoInit DisplayName;
    FStringNoInit Description;
    //## END PROPS UIMapSummary

    DECLARE_CLASS(UUIMapSummary,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIMapSummary)
};

struct UIResourceCombinationProvider_eventGetCellFieldValue_Parms
{
    FName FieldName;
    FName CellTag;
    INT ListIndex;
    struct FUIProviderFieldValue out_FieldValue;
    INT ArrayIndex;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetCellFieldValue_Parms(EEventParm)
    : out_FieldValue(EC_EventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetCellFieldType_Parms
{
    FName FieldName;
    FName CellTag;
    BYTE FieldType;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetCellFieldType_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellTags_Parms
{
    FName FieldName;
    TArray<FName> CellFieldTags;
    TArray<FString> ColumnHeaderDisplayText;
    UIResourceCombinationProvider_eventGetElementCellTags_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms
{
    FName FieldName;
    INT ListIndex;
    TScriptInterface<class IUIListElementCellProvider> out_ValueProvider;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms
{
    FName FieldName;
    TScriptInterface<class IUIListElementCellProvider> out_SchemaProvider;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventIsElementEnabled_Parms
{
    FName FieldName;
    INT CollectionIndex;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventIsElementEnabled_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetListElements_Parms
{
    FName FieldName;
    TArray<INT> out_Elements;
    UBOOL ReturnValue;
    UIResourceCombinationProvider_eventGetListElements_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementCount_Parms
{
    FName FieldName;
    INT ReturnValue;
    UIResourceCombinationProvider_eventGetElementCount_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventGetElementProviderTags_Parms
{
    TArray<FName> ReturnValue;
    UIResourceCombinationProvider_eventGetElementProviderTags_Parms(EEventParm)
    {
    }
};
struct UIResourceCombinationProvider_eventInitializeProvider_Parms
{
    UBOOL bIsEditor;
    class UUIResourceDataProvider* InStaticResourceProvider;
    class UUIDataProvider_OnlineProfileSettings* InProfileProvider;
    UIResourceCombinationProvider_eventInitializeProvider_Parms(EEventParm)
    {
    }
};
class UUIResourceCombinationProvider : public UUIDataProvider, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIResourceCombinationProvider
    class UUIResourceDataProvider* StaticDataProvider;
    class UUIDataProvider_OnlineProfileSettings* ProfileProvider;
    //## END PROPS UIResourceCombinationProvider

    UBOOL eventGetCellFieldValue(FName FieldName,FName CellTag,INT ListIndex,struct FUIProviderFieldValue& out_FieldValue,INT ArrayIndex=-1)
    {
        UIResourceCombinationProvider_eventGetCellFieldValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CellTag=CellTag;
        Parms.ListIndex=ListIndex;
        Parms.out_FieldValue=out_FieldValue;
        Parms.ArrayIndex=ArrayIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCellFieldValue),&Parms);
        out_FieldValue=Parms.out_FieldValue;
        return Parms.ReturnValue;
    }
    UBOOL eventGetCellFieldType(FName FieldName,FName CellTag,BYTE& FieldType)
    {
        UIResourceCombinationProvider_eventGetCellFieldType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CellTag=CellTag;
        Parms.FieldType=FieldType;
        ProcessEvent(FindFunctionChecked(ENGINE_GetCellFieldType),&Parms);
        FieldType=Parms.FieldType;
        return Parms.ReturnValue;
    }
    void eventGetElementCellTags(FName FieldName,TArray<FName>& CellFieldTags,TArray<FString>* ColumnHeaderDisplayText=NULL)
    {
        UIResourceCombinationProvider_eventGetElementCellTags_Parms Parms(EC_EventParm);
        Parms.FieldName=FieldName;
        Parms.CellFieldTags=CellFieldTags;
        if(ColumnHeaderDisplayText){Parms.ColumnHeaderDisplayText=*ColumnHeaderDisplayText;}
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellTags),&Parms);
        CellFieldTags=Parms.CellFieldTags;
        if ( ColumnHeaderDisplayText ) { *ColumnHeaderDisplayText=Parms.ColumnHeaderDisplayText; }
    }
    UBOOL eventGetElementCellValueProvider(FName FieldName,INT ListIndex,TScriptInterface<class IUIListElementCellProvider>& out_ValueProvider)
    {
        UIResourceCombinationProvider_eventGetElementCellValueProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.ListIndex=ListIndex;
        Parms.out_ValueProvider=out_ValueProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellValueProvider),&Parms);
        out_ValueProvider=Parms.out_ValueProvider;
        return Parms.ReturnValue;
    }
    UBOOL eventGetElementCellSchemaProvider(FName FieldName,TScriptInterface<class IUIListElementCellProvider>& out_SchemaProvider)
    {
        UIResourceCombinationProvider_eventGetElementCellSchemaProvider_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_SchemaProvider=out_SchemaProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCellSchemaProvider),&Parms);
        out_SchemaProvider=Parms.out_SchemaProvider;
        return Parms.ReturnValue;
    }
    UBOOL eventIsElementEnabled(FName FieldName,INT CollectionIndex)
    {
        UIResourceCombinationProvider_eventIsElementEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.CollectionIndex=CollectionIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsElementEnabled),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetListElements(FName FieldName,TArray<INT>& out_Elements)
    {
        UIResourceCombinationProvider_eventGetListElements_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_Elements=out_Elements;
        ProcessEvent(FindFunctionChecked(ENGINE_GetListElements),&Parms);
        out_Elements=Parms.out_Elements;
        return Parms.ReturnValue;
    }
    INT eventGetElementCount(FName FieldName)
    {
        UIResourceCombinationProvider_eventGetElementCount_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementCount),&Parms);
        return Parms.ReturnValue;
    }
    TArray<FName> eventGetElementProviderTags()
    {
        UIResourceCombinationProvider_eventGetElementProviderTags_Parms Parms(EC_EventParm);
        Parms.ReturnValue=TArray<FName>(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetElementProviderTags),&Parms);
        return Parms.ReturnValue;
    }
    void eventInitializeProvider(UBOOL bIsEditor,class UUIResourceDataProvider* InStaticResourceProvider,class UUIDataProvider_OnlineProfileSettings* InProfileProvider)
    {
        UIResourceCombinationProvider_eventInitializeProvider_Parms Parms(EC_EventParm);
        Parms.bIsEditor=bIsEditor ? FIRST_BITFIELD : FALSE;
        Parms.InStaticResourceProvider=InStaticResourceProvider;
        Parms.InProfileProvider=InProfileProvider;
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeProvider),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIResourceCombinationProvider,UUIDataProvider,0|CLASS_Transient,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct GameUISceneClient_eventPauseGame_Parms
{
    UBOOL bDesiredPauseState;
    INT PlayerIndex;
    GameUISceneClient_eventPauseGame_Parms(EEventParm)
    {
    }
};
class UGameUISceneClient : public UUISceneClient
{
public:
    //## BEGIN PROPS GameUISceneClient
    FLOAT LatestDeltaTime;
    DOUBLE DoubleClickStartTime;
    FIntPoint DoubleClickStartPosition;
    TMap<INT,TArray<FName> > InitialPressedKeys;
    BITFIELD bUpdateInputProcessingStatus:1;
    BITFIELD bUpdateSceneViewportSizes:1;
    BITFIELD bEnableDebugInput:1;
    BITFIELD bRenderDebugInfo:1;
    BITFIELD bCaptureUnprocessedInput:1;
    TArrayNoInit<FName> NavAliases;
    TArrayNoInit<FName> AxisInputKeys;
    //## END PROPS GameUISceneClient

    BYTE GetCurrentNetMode();
    void RequestInputProcessingUpdate();
    UBOOL CanUnpauseInternalUI();
    DECLARE_FUNCTION(execGetCurrentNetMode)
    {
        P_FINISH;
        *(BYTE*)Result=this->GetCurrentNetMode();
    }
    DECLARE_FUNCTION(execRequestInputProcessingUpdate)
    {
        P_FINISH;
        this->RequestInputProcessingUpdate();
    }
    DECLARE_FUNCTION(execCanUnpauseInternalUI)
    {
        P_FINISH;
        *(UBOOL*)Result=this->CanUnpauseInternalUI();
    }
    void eventPauseGame(UBOOL bDesiredPauseState,INT PlayerIndex=0)
    {
        GameUISceneClient_eventPauseGame_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_PauseGame),&Parms);
    }
    DECLARE_CLASS(UGameUISceneClient,UUISceneClient,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UUIInteraction)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */
	/**
	 * Called when the UI controller receives a CALLBACK_ViewportResized notification.
	 *
	 * @param	SceneViewport	the viewport that was resized
	 */
	virtual void NotifyViewportResized( FViewport* SceneViewport );

	/**
	 * Process an input event which interacts with the in-game scene debugging overlays
	 *
	 * @param	Key		the key that was pressed
	 * @param	Event	the type of event received
	 *
	 * @return	TRUE if the input event was processed; FALSE otherwise.
	 */
	UBOOL DebugInputKey( FName Key, EInputEvent Event );

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UGameUISceneClient interface
	======================================= */

	/**
	 * Resets the time and mouse position values used for simulating double-click events to the current value or invalid values.
	 */
	void ResetDoubleClickTracking( UBOOL bClearValues );

	/**
	 * Checks the current time and mouse position to determine whether a double-click event should be simulated.
	 */
	UBOOL ShouldSimulateDoubleClick() const;

	/**
	 * Determines whether the any active scenes process axis input.
	 *
	 * @param	bProcessAxisInput	receives the flags for whether axis input is needed for each player.
	 */
	virtual void CheckAxisInputSupport( UBOOL* bProcessAxisInput[UCONST_MAX_SUPPORTED_GAMEPADS] ) const;

	/**
	 * Called once a frame to update the UI's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

private:

	#if WITH_GFx
	/**
	 * @return	TRUE if the scene meets the conditions defined by the bitmask specified.
	 */
	UBOOL GFxMovieMatchesFilter( DWORD FilterFlagMask, class FGFxMovie* TestMovie ) const;
	#endif //WITH_GFx
public:
	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=SCENEFILTER_Any ) const;

protected:

	/**
	 * Updates the value of UIInteraction.bProcessingInput to reflect whether any scenes are capable of processing input.
	 */
	void UpdateInputProcessingStatus();

	/**
	 * Clears the arrays of pressed keys for all local players in the game; used when the UI begins processing input.  Also
	 * updates the InitialPressedKeys maps for all players.
	 */
	void FlushPlayerInput();

public:
	/**
	 * Ensures that the game's paused state is appropriate considering the state of the UI.  If any scenes are active which require
	 * the game to be paused, pauses the game...otherwise, unpauses the game.
	 *
	 * @param	PlayerIndex		the index of the player that owns the scene that was just added or removed, or 0 if the scene didn't have
	 *							a player owner.
	 */
	virtual void UpdatePausedState( INT PlayerIndex );
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_UIPRIVATE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUIDataProvider,-1,execParseArrayDelimiter);
AUTOGENERATE_FUNCTION(UUIDataProvider,-1,execGetProviderFieldType);
AUTOGENERATE_FUNCTION(UUIDataProvider_PlayerAchievements,-1,execGetMaxTotalGamerScore);
AUTOGENERATE_FUNCTION(UUIDataProvider_PlayerAchievements,-1,execGetTotalGamerScore);
AUTOGENERATE_FUNCTION(UUIDataStore,-1,execOnCommit);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execOnLoginChange);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execFindProviderIndexByFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetProviderFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetResourceProviderFields);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetResourceProviders);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execGenerateProviderAccessTag);
AUTOGENERATE_FUNCTION(UUIDataStore_DynamicResource,-1,execFindProviderTypeIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execFindProviderIndexByFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetProviderFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetResourceProviderFields);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetResourceProviders);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execGenerateProviderAccessTag);
AUTOGENERATE_FUNCTION(UUIDataStore_GameResource,-1,execFindProviderTypeIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execGetSet);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execAppendToSet);
AUTOGENERATE_FUNCTION(UUIDataStore_MenuItems,-1,execClearSet);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execGetPlaylistProvider);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execFindProviderIndexByFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execGetProviderFieldValue);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execGetResourceProviderFields);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execGetResourceProviders);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlaylists,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineGameSearch,-1,execBuildSearchResults);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlinePlayerData,-1,execOnSettingProviderChanged);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineStats,-1,execSortResultsByRank);
AUTOGENERATE_FUNCTION(UUIDataStore_OnlineGameSettings,-1,execOnSettingProviderChanged);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execHasAliasMappingForPlatform);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execFindInputAliasIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyDataByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyData);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyNameByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasInputKeyName);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasFontMarkupByIndex);
AUTOGENERATE_FUNCTION(UUIDataStore_InputAlias,-1,execGetAliasFontMarkup);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execFindMappingWithFieldName);
AUTOGENERATE_FUNCTION(UUIDataStore_StringAliasMap,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindCollectionValueIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execReplaceCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValueByIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execInsertCollectionValue);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValueArray);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetCollectionValueSchema);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSavePersistentProviderData);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execSetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execGetField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execClearFields);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execFindFieldIndex);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execRemoveField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execAddField);
AUTOGENERATE_FUNCTION(UUIDynamicFieldProvider,-1,execInitializeRuntimeFields);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execUnbindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDynamicDataProvider,-1,execBindProviderInstance);
AUTOGENERATE_FUNCTION(UUIDataProvider_MenuItem,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execCanUnpauseInternalUI);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execRequestInputProcessingUpdate);
AUTOGENERATE_FUNCTION(UGameUISceneClient,-1,execGetCurrentNetMode);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_UIPRIVATE_NATIVE_DEFS
#define ENGINE_UIPRIVATE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_UIPRIVATE \
	UUIDataStoreSubscriber::StaticClass(); \
	UUIDataStorePublisher::StaticClass(); \
	UUIListElementCellProvider::StaticClass(); \
	UUIListElementProvider::StaticClass(); \
	UUIDataProvider::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataProvider"), GEngineUUIDataProviderNatives); \
	UUIConfigProvider::StaticClass(); \
	UUIConfigFileProvider::StaticClass(); \
	UUIConfigSectionProvider::StaticClass(); \
	UUIDataProvider_OnlinePlayerDataBase::StaticClass(); \
	UUIDataProvider_OnlineFriendMessages::StaticClass(); \
	UUIDataProvider_OnlineFriends::StaticClass(); \
	UUIDataProvider_OnlinePartyChatList::StaticClass(); \
	UUIDataProvider_OnlinePlayerStorage::StaticClass(); \
	UUIDataProvider_OnlineProfileSettings::StaticClass(); \
	UUIDataProvider_PlayerAchievements::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataProvider_PlayerAchievements"), GEngineUUIDataProvider_PlayerAchievementsNatives); \
	UUIDataProvider_OnlinePlayerStorageArray::StaticClass(); \
	UUIDataProvider_SettingsArray::StaticClass(); \
	UUIDataStore::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore"), GEngineUUIDataStoreNatives); \
	UUIDataStore_DynamicResource::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_DynamicResource"), GEngineUUIDataStore_DynamicResourceNatives); \
	UUIDataStore_Fonts::StaticClass(); \
	UUIDataStore_GameResource::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_GameResource"), GEngineUUIDataStore_GameResourceNatives); \
	UUIDataStore_MenuItems::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_MenuItems"), GEngineUUIDataStore_MenuItemsNatives); \
	UUIDataStore_GameState::StaticClass(); \
	UUIDataStore_OnlinePlaylists::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_OnlinePlaylists"), GEngineUUIDataStore_OnlinePlaylistsNatives); \
	UUIDataStore_Registry::StaticClass(); \
	UUIDataStore_Remote::StaticClass(); \
	UUIDataStore_OnlineGameSearch::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_OnlineGameSearch"), GEngineUUIDataStore_OnlineGameSearchNatives); \
	UUIDataStore_OnlinePlayerData::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_OnlinePlayerData"), GEngineUUIDataStore_OnlinePlayerDataNatives); \
	UUIDataStore_OnlineStats::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_OnlineStats"), GEngineUUIDataStore_OnlineStatsNatives); \
	UUIDataStore_Settings::StaticClass(); \
	UUIDataStore_OnlineGameSettings::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_OnlineGameSettings"), GEngineUUIDataStore_OnlineGameSettingsNatives); \
	UUIDataStore_StringBase::StaticClass(); \
	UUIDataStore_InputAlias::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_InputAlias"), GEngineUUIDataStore_InputAliasNatives); \
	UUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataStore_StringAliasMap"), GEngineUUIDataStore_StringAliasMapNatives); \
	UUIDataStore_Strings::StaticClass(); \
	UUIDynamicFieldProvider::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDynamicFieldProvider"), GEngineUUIDynamicFieldProviderNatives); \
	UUIPropertyDataProvider::StaticClass(); \
	UUIDynamicDataProvider::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDynamicDataProvider"), GEngineUUIDynamicDataProviderNatives); \
	UUIDataProvider_Settings::StaticClass(); \
	UUIResourceDataProvider::StaticClass(); \
	UUIDataProvider_MenuItem::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIDataProvider_MenuItem"), GEngineUUIDataProvider_MenuItemNatives); \
	UUIMapSummary::StaticClass(); \
	UUIResourceCombinationProvider::StaticClass(); \
	UGameUISceneClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameUISceneClient"), GEngineUGameUISceneClientNatives); \

#endif // ENGINE_UIPRIVATE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUUIDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider, execParseArrayDelimiter)
	MAP_NATIVE(UUIDataProvider, execGetProviderFieldType)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataProvider_PlayerAchievementsNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider_PlayerAchievements, execGetMaxTotalGamerScore)
	MAP_NATIVE(UUIDataProvider_PlayerAchievements, execGetTotalGamerScore)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStoreNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore, execOnCommit)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_DynamicResourceNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_DynamicResource, execOnLoginChange)
	MAP_NATIVE(UUIDataStore_DynamicResource, execFindProviderIndexByFieldValue)
	MAP_NATIVE(UUIDataStore_DynamicResource, execGetProviderFieldValue)
	MAP_NATIVE(UUIDataStore_DynamicResource, execGetResourceProviderFields)
	MAP_NATIVE(UUIDataStore_DynamicResource, execGetResourceProviders)
	MAP_NATIVE(UUIDataStore_DynamicResource, execGetProviderCount)
	MAP_NATIVE(UUIDataStore_DynamicResource, execGenerateProviderAccessTag)
	MAP_NATIVE(UUIDataStore_DynamicResource, execFindProviderTypeIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_GameResourceNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_GameResource, execFindProviderIndexByFieldValue)
	MAP_NATIVE(UUIDataStore_GameResource, execGetProviderFieldValue)
	MAP_NATIVE(UUIDataStore_GameResource, execGetResourceProviderFields)
	MAP_NATIVE(UUIDataStore_GameResource, execGetResourceProviders)
	MAP_NATIVE(UUIDataStore_GameResource, execGetProviderCount)
	MAP_NATIVE(UUIDataStore_GameResource, execGenerateProviderAccessTag)
	MAP_NATIVE(UUIDataStore_GameResource, execFindProviderTypeIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_MenuItemsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_MenuItems, execGetSet)
	MAP_NATIVE(UUIDataStore_MenuItems, execAppendToSet)
	MAP_NATIVE(UUIDataStore_MenuItems, execClearSet)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_OnlinePlaylistsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execGetPlaylistProvider)
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execFindProviderIndexByFieldValue)
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execGetProviderFieldValue)
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execGetResourceProviderFields)
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execGetResourceProviders)
	MAP_NATIVE(UUIDataStore_OnlinePlaylists, execGetProviderCount)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_OnlineGameSearchNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineGameSearch, execBuildSearchResults)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_OnlinePlayerDataNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlinePlayerData, execOnSettingProviderChanged)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_OnlineStatsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineStats, execSortResultsByRank)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_OnlineGameSettingsNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_OnlineGameSettings, execOnSettingProviderChanged)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_InputAliasNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_InputAlias, execHasAliasMappingForPlatform)
	MAP_NATIVE(UUIDataStore_InputAlias, execFindInputAliasIndex)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasInputKeyDataByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasInputKeyData)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasInputKeyNameByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasInputKeyName)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasFontMarkupByIndex)
	MAP_NATIVE(UUIDataStore_InputAlias, execGetAliasFontMarkup)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUIDataStore_StringAliasMap, execGetStringWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap, execFindMappingWithFieldName)
	MAP_NATIVE(UUIDataStore_StringAliasMap, execGetPlayerOwner)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDynamicFieldProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicFieldProvider, execFindCollectionValueIndex)
	MAP_NATIVE(UUIDynamicFieldProvider, execGetCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider, execClearCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider, execReplaceCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider, execReplaceCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider, execRemoveCollectionValueByIndex)
	MAP_NATIVE(UUIDynamicFieldProvider, execRemoveCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider, execInsertCollectionValue)
	MAP_NATIVE(UUIDynamicFieldProvider, execSetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider, execGetCollectionValueArray)
	MAP_NATIVE(UUIDynamicFieldProvider, execGetCollectionValueSchema)
	MAP_NATIVE(UUIDynamicFieldProvider, execSavePersistentProviderData)
	MAP_NATIVE(UUIDynamicFieldProvider, execSetField)
	MAP_NATIVE(UUIDynamicFieldProvider, execGetField)
	MAP_NATIVE(UUIDynamicFieldProvider, execClearFields)
	MAP_NATIVE(UUIDynamicFieldProvider, execFindFieldIndex)
	MAP_NATIVE(UUIDynamicFieldProvider, execRemoveField)
	MAP_NATIVE(UUIDynamicFieldProvider, execAddField)
	MAP_NATIVE(UUIDynamicFieldProvider, execInitializeRuntimeFields)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDynamicDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUIDynamicDataProvider, execUnbindProviderInstance)
	MAP_NATIVE(UUIDynamicDataProvider, execBindProviderInstance)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIDataProvider_MenuItemNatives[] = 
{ 
	MAP_NATIVE(UUIDataProvider_MenuItem, execIsFiltered)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UGameUISceneClient, execCanUnpauseInternalUI)
	MAP_NATIVE(UGameUISceneClient, execRequestInputProcessingUpdate)
	MAP_NATIVE(UGameUISceneClient, execGetCurrentNetMode)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UUIDataStoreSubscriber)
VERIFY_CLASS_SIZE_NODIE(UUIDataStorePublisher)
VERIFY_CLASS_SIZE_NODIE(UUIListElementCellProvider)
VERIFY_CLASS_SIZE_NODIE(UUIListElementProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider,UIDataProvider,WriteAccessType)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider,UIDataProvider,__OnDataProviderPropertyChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIConfigProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIConfigFileProvider,UIConfigFileProvider,Sections)
VERIFY_CLASS_SIZE_NODIE(UUIConfigFileProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIConfigSectionProvider,UIConfigSectionProvider,SectionName)
VERIFY_CLASS_SIZE_NODIE(UUIConfigSectionProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePlayerDataBase,UIDataProvider_OnlinePlayerDataBase,PlayerControllerId)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayerDataBase)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlineFriendMessages,UIDataProvider_OnlineFriendMessages,Messages)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlineFriendMessages,UIDataProvider_OnlineFriendMessages,LastInviteFrom)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineFriendMessages)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlineFriends,UIDataProvider_OnlineFriends,FriendsList)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlineFriends,UIDataProvider_OnlineFriends,BusyText)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineFriends)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePartyChatList,UIDataProvider_OnlinePartyChatList,PartyMembersList)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePartyChatList,UIDataProvider_OnlinePartyChatList,IsPlayingThisGameCol)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePartyChatList)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePlayerStorage,UIDataProvider_OnlinePlayerStorage,Profile)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePlayerStorage,UIDataProvider_OnlinePlayerStorage,DeviceStorageSizeNeeded)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayerStorage)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlineProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_PlayerAchievements,UIDataProvider_PlayerAchievements,Achievements)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_PlayerAchievements)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePlayerStorageArray,UIDataProvider_OnlinePlayerStorageArray,PlayerStorage)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_OnlinePlayerStorageArray,UIDataProvider_OnlinePlayerStorageArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_OnlinePlayerStorageArray)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_SettingsArray,UIDataProvider_SettingsArray,Settings)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_SettingsArray,UIDataProvider_SettingsArray,Values)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_SettingsArray)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore,UIDataStore,Tag)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore,UIDataStore,__OnDataStoreValueUpdated__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_DynamicResource,UIDataStore_DynamicResource,ProfileProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_DynamicResource,UIDataStore_DynamicResource,ResourceProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_DynamicResource)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Fonts)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_GameResource,UIDataStore_GameResource,ElementProviderTypes)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_GameResource,UIDataStore_GameResource,ListElementProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameResource)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_MenuItems,UIDataStore_MenuItems,CurrentGameSettingsTag)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_MenuItems,UIDataStore_MenuItems,DynamicProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_MenuItems)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_GameState,UIDataStore_GameState,__OnRefreshDataFieldValue__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_GameState)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlinePlaylists,UIDataStore_OnlinePlaylists,ProviderClassName)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlinePlaylists,UIDataStore_OnlinePlaylists,UnRankedDataProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlinePlaylists)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_Registry,UIDataStore_Registry,RegistryDataProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Registry)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Remote)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineGameSearch,UIDataStore_OnlineGameSearch,SearchResultsName)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineGameSearch,UIDataStore_OnlineGameSearch,ActiveSearchIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSearch)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlinePlayerData,UIDataStore_OnlinePlayerData,FriendsProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlinePlayerData,UIDataStore_OnlinePlayerData,PartyChatProvider)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlinePlayerData)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineStats,UIDataStore_OnlineStats,StatsReadClasses)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineStats,UIDataStore_OnlineStats,PlayerInterface)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineStats)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Settings)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineGameSettings,UIDataStore_OnlineGameSettings,GameSettingsCfgList)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_OnlineGameSettings,UIDataStore_OnlineGameSettings,SelectedIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_OnlineGameSettings)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_StringBase)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_InputAlias,UIDataStore_InputAlias,InputAliases)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_InputAlias,UIDataStore_InputAlias,InputAliasLookupMap)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_InputAlias)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_StringAliasMap,UIDataStore_StringAliasMap,MenuInputMapArray)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_StringAliasMap,UIDataStore_StringAliasMap,PlayerIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(UUIDataStore_Strings,UIDataStore_Strings,LocFileProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_Strings)
VERIFY_CLASS_OFFSET_NODIE(UUIDynamicFieldProvider,UIDynamicFieldProvider,PersistentDataFields)
VERIFY_CLASS_OFFSET_NODIE(UUIDynamicFieldProvider,UIDynamicFieldProvider,RuntimeCollectionData)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicFieldProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIPropertyDataProvider,UIPropertyDataProvider,ComplexPropertyTypes)
VERIFY_CLASS_OFFSET_NODIE(UUIPropertyDataProvider,UIPropertyDataProvider,__CanSupportComplexPropertyType__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIPropertyDataProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDynamicDataProvider,UIDynamicDataProvider,DataClass)
VERIFY_CLASS_OFFSET_NODIE(UUIDynamicDataProvider,UIDynamicDataProvider,DataSource)
VERIFY_CLASS_SIZE_NODIE(UUIDynamicDataProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_Settings,UIDataProvider_Settings,Settings)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_Settings,UIDataProvider_Settings,SettingsArrayProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_Settings)
VERIFY_CLASS_SIZE_NODIE(UUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_MenuItem,UIDataProvider_MenuItem,OptionType)
VERIFY_CLASS_OFFSET_NODIE(UUIDataProvider_MenuItem,UIDataProvider_MenuItem,IniName)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_MenuItem)
VERIFY_CLASS_OFFSET_NODIE(UUIMapSummary,UIMapSummary,MapName)
VERIFY_CLASS_OFFSET_NODIE(UUIMapSummary,UIMapSummary,Description)
VERIFY_CLASS_SIZE_NODIE(UUIMapSummary)
VERIFY_CLASS_OFFSET_NODIE(UUIResourceCombinationProvider,UIResourceCombinationProvider,StaticDataProvider)
VERIFY_CLASS_OFFSET_NODIE(UUIResourceCombinationProvider,UIResourceCombinationProvider,ProfileProvider)
VERIFY_CLASS_SIZE_NODIE(UUIResourceCombinationProvider)
VERIFY_CLASS_OFFSET_NODIE(UGameUISceneClient,GameUISceneClient,LatestDeltaTime)
VERIFY_CLASS_OFFSET_NODIE(UGameUISceneClient,GameUISceneClient,AxisInputKeys)
VERIFY_CLASS_SIZE_NODIE(UGameUISceneClient)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
