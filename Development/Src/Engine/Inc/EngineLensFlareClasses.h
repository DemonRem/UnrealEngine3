/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_LENSFLARE_ENUMS
#define INCLUDED_ENGINE_LENSFLARE_ENUMS 1


#endif // !INCLUDED_ENGINE_LENSFLARE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_LENSFLARE_CLASSES
#define INCLUDED_ENGINE_LENSFLARE_CLASSES 1

class ALensFlareSource : public AActor
{
public:
    //## BEGIN PROPS LensFlareSource
    class ULensFlareComponent* LensFlareComp;
    //## END PROPS LensFlareSource

    void SetTemplate(class ULensFlare* NewTemplate);
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(ULensFlare,NewTemplate);
        P_FINISH;
        SetTemplate(NewTemplate);
    }
    DECLARE_CLASS(ALensFlareSource,AActor,0,Engine)
	void AutoPopulateInstanceProperties();

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
};

struct FLensFlareElementCurvePair
{
    FString CurveName;
    class UObject* CurveObject;

    /** Constructors */
    FLensFlareElementCurvePair()
    : CurveObject(NULL)
    {}
    FLensFlareElementCurvePair(EEventParm)
    {
        appMemzero(this, sizeof(FLensFlareElementCurvePair));
    }
};

struct FLensFlareElement
{
    FName ElementName;
    FLOAT RayDistance;
    BITFIELD bIsEnabled:1;
    BITFIELD bUseSourceDistance:1;
    BITFIELD bNormalizeRadialDistance:1;
    BITFIELD bModulateColorBySource:1;
    FVector Size;
    TArrayNoInit<class UMaterialInterface*> LFMaterials;
    struct FRawDistributionFloat LFMaterialIndex;
    struct FRawDistributionFloat Scaling;
    struct FRawDistributionVector AxisScaling;
    struct FRawDistributionFloat Rotation;
    struct FRawDistributionVector Color;
    struct FRawDistributionFloat Alpha;
    struct FRawDistributionVector Offset;
    struct FRawDistributionVector DistMap_Scale;
    struct FRawDistributionVector DistMap_Color;
    struct FRawDistributionFloat DistMap_Alpha;

		void GetCurveObjects(TArray<FLensFlareElementCurvePair>& OutCurves);
	
};

class ULensFlare : public UObject
{
public:
    //## BEGIN PROPS LensFlare
    struct FLensFlareElement SourceElement;
    class UStaticMesh* SourceMesh;
    BYTE SourceDPG;
    BYTE ReflectionsDPG;
    TArrayNoInit<struct FLensFlareElement> Reflections;
    FLOAT OuterCone;
    FLOAT InnerCone;
    FLOAT ConeFudgeFactor;
    FLOAT Radius;
    struct FRawDistributionFloat ScreenPercentageMap;
    BITFIELD bUseFixedRelativeBoundingBox:1;
    BITFIELD bRenderDebugLines:1;
    BITFIELD ThumbnailImageOutOfDate:1;
    FBox FixedRelativeBoundingBox;
    class UInterpCurveEdSetup* CurveEdSetup;
    INT ReflectionCount;
    FRotator ThumbnailAngle;
    FLOAT ThumbnailDistance;
    class UTexture2D* ThumbnailImage;
    //## END PROPS LensFlare

    DECLARE_CLASS(ULensFlare,UObject,0,Engine)
	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostLoad();
	
	// CurveEditor helper interface
	void	AddElementCurvesToEditor(INT ElementIndex, UInterpCurveEdSetup* EdSetup);
	void	RemoveElementCurvesFromEditor(INT ElementIndex, UInterpCurveEdSetup* EdSetup);
	void	AddElementCurveToEditor(INT ElementIndex, FString& CurveName, UInterpCurveEdSetup* EdSetup);
	
	//
	const FLensFlareElement* GetElement(INT ElementIndex) const;
	
	/** Return TRUE if element was found and bIsEnabled set to given value. */
	UBOOL SetElementEnabled(INT ElementIndex, UBOOL bInIsEnabled);
	
	/** Initialize the element at the given index */
	UBOOL InitializeElement(INT ElementIndex);

	/** Get the curve objects associated with the LensFlare itself */
	void GetCurveObjects(TArray<FLensFlareElementCurvePair>& OutCurves);
};

class ULensFlareComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LensFlareComponent
    class ULensFlare* Template;
    class UDrawLightConeComponent* PreviewInnerCone;
    class UDrawLightConeComponent* PreviewOuterCone;
    class UDrawLightRadiusComponent* PreviewRadius;
    BITFIELD bAutoActivate:1;
    BITFIELD bIsActive:1;
    BITFIELD bHasTranslucency:1;
    BITFIELD bHasUnlitTranslucency:1;
    BITFIELD bHasUnlitDistortion:1;
    BITFIELD bUsesSceneColor:1;
    FLOAT OuterCone;
    FLOAT InnerCone;
    FLOAT ConeFudgeFactor;
    FLOAT Radius;
    FLinearColor SourceColor;
    class FRenderCommandFence* ReleaseResourcesFence;
    //## END PROPS LensFlareComponent

    void SetTemplate(class ULensFlare* NewTemplate);
    virtual void SetSourceColor(FLinearColor InSourceColor);
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(ULensFlare,NewTemplate);
        P_FINISH;
        SetTemplate(NewTemplate);
    }
    DECLARE_FUNCTION(execSetSourceColor)
    {
        P_GET_STRUCT(FLinearColor,InSourceColor);
        P_FINISH;
        SetSourceColor(InSourceColor);
    }
    DECLARE_CLASS(ULensFlareComponent,UPrimitiveComponent,0,Engine)
	// UObject interface
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostLoad();

	// UActorComponent interface.
	virtual void Attach();

public:
	// UPrimitiveComponent interface
	virtual void UpdateBounds();
	
	/** Returns true if the prim is using a material with unlit distortion */
	virtual UBOOL HasUnlitDistortion() const;
	/** Returns true if the prim is using a material with unlit translucency */
	virtual UBOOL HasUnlitTranslucency() const;

	/**
	* Returns true if the prim is using a material that samples the scene color texture.
	* If true then these primitives are drawn after all other translucency
	*/
	virtual UBOOL UsesSceneColor() const;

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// InstanceParameters interface
	void	AutoPopulateInstanceProperties();
};

#endif // !INCLUDED_ENGINE_LENSFLARE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetSourceColor);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(ALensFlareSource,-1,execSetTemplate);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_LENSFLARE_NATIVE_DEFS
#define ENGINE_LENSFLARE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,ULensFlare);
DECLARE_NATIVE_TYPE(Engine,ULensFlareComponent);
DECLARE_NATIVE_TYPE(Engine,ALensFlareSource);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_LENSFLARE \
	ULensFlare::StaticClass(); \
	ULensFlareComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineULensFlareComponentNative; \
	ALensFlareSource::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineALensFlareSourceNative; \

#endif // ENGINE_LENSFLARE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(ULensFlareComponent) GEngineULensFlareComponentNatives[] = 
{ 
	MAP_NATIVE(ULensFlareComponent,execSetSourceColor)
	MAP_NATIVE(ULensFlareComponent,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ULensFlareComponent);

NATIVE_INFO(ALensFlareSource) GEngineALensFlareSourceNatives[] = 
{ 
	MAP_NATIVE(ALensFlareSource,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ALensFlareSource);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,LensFlare,SourceElement)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlare,ThumbnailImage)
VERIFY_CLASS_SIZE_NODIE(ULensFlare)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareComponent,Template)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareComponent,ReleaseResourcesFence)
VERIFY_CLASS_SIZE_NODIE(ULensFlareComponent)
VERIFY_CLASS_OFFSET_NODIE(A,LensFlareSource,LensFlareComp)
VERIFY_CLASS_SIZE_NODIE(ALensFlareSource)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
