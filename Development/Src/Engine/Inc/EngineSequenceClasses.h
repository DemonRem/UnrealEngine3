/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_SEQUENCE_ENUMS
#define INCLUDED_ENGINE_SEQUENCE_ENUMS 1

enum EPointSelection
{
    PS_Normal               =0,
    PS_Random               =1,
    PS_Reverse              =2,
    PS_MAX                  =3,
};

#endif // !INCLUDED_ENGINE_SEQUENCE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Activated)
AUTOGENERATE_NAME(CheckLogins)
AUTOGENERATE_NAME(Deactivated)
AUTOGENERATE_NAME(InsertValueEntry)
AUTOGENERATE_NAME(IsFallThruEnabled)
AUTOGENERATE_NAME(IsValidLevelSequenceObject)
AUTOGENERATE_NAME(IsValidUISequenceObject)
AUTOGENERATE_NAME(RegisterEvent)
AUTOGENERATE_NAME(RemoveValueEntry)
AUTOGENERATE_NAME(Toggled)
AUTOGENERATE_NAME(VerifyDefaultCaseValue)

#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_SEQUENCE_CLASSES
#define INCLUDED_ENGINE_SEQUENCE_CLASSES 1

struct SequenceObject_eventIsValidUISequenceObject_Parms
{
    class UUIScreenObject* TargetObject;
    UBOOL ReturnValue;
    SequenceObject_eventIsValidUISequenceObject_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsValidLevelSequenceObject_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsValidLevelSequenceObject_Parms(EEventParm)
    {
    }
};
class USequenceObject : public UObject
{
public:
    //## BEGIN PROPS SequenceObject
    INT ObjClassVersion;
    INT ObjInstanceVersion;
    class USequence* ParentSequence;
    INT ObjPosX;
    INT ObjPosY;
    FStringNoInit ObjName;
    FStringNoInit ObjCategory;
    FColor ObjColor;
    FStringNoInit ObjComment;
    BITFIELD bDeletable:1;
    BITFIELD bDrawFirst:1;
    BITFIELD bDrawLast:1;
    BITFIELD bOutputObjCommentToScreen:1;
    BITFIELD bSuppressAutoComment:1;
    INT DrawWidth;
    INT DrawHeight;
    //## END PROPS SequenceObject

    void ScriptLog(const FString& LogText,UBOOL bWarning=TRUE);
    class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execScriptLog)
    {
        P_GET_STR(LogText);
        P_GET_UBOOL_OPTX(bWarning,TRUE);
        P_FINISH;
        ScriptLog(LogText,bWarning);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    UBOOL eventIsValidUISequenceObject(class UUIScreenObject* TargetObject=NULL)
    {
        SequenceObject_eventIsValidUISequenceObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TargetObject=TargetObject;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidUISequenceObject),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsValidLevelSequenceObject()
    {
        SequenceObject_eventIsValidLevelSequenceObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidLevelSequenceObject),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USequenceObject,UObject,0,Engine)
	virtual void CheckForErrors() {};
	virtual void OnExport();

	/**
	 * Notification that this object has been connected to another sequence object via a link.  Called immediately after
	 * the designer creates a link between two sequence objects.
	 *
	 * @param	connObj		the object that this op was just connected to.
	 * @param	connIdx		the index of the connection that was created.  Depends on the type of sequence op that is being connected.
	 */
	virtual void OnConnect(USequenceObject *connObj,INT connIdx) {}

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime) {};
	virtual void DrawLogicLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void DrawVariableLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void OnCreated()
	{
		ObjInstanceVersion = ObjClassVersion;
	};
	virtual void OnSelected() {};

	/**
	 * Called when a copy of this object is made in the editor via cut and paste
	 */
	virtual void OnPasted(){};

	virtual FIntRect GetSeqObjBoundingBox();
	void SnapPosition(INT Gridsize, INT MaxSequenceSize);
	FString GetSeqObjFullName();
	USequence* GetRootSequence();

	FIntPoint GetTitleBarSize(FCanvas* Canvas);
	FColor GetBorderColor(UBOOL bSelected, UBOOL bMouseOver);

	void DrawTitleBar(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);

	virtual void UpdateObject()
	{
		// set the new instance version to match the class version
		ObjInstanceVersion = ObjClassVersion;
		MarkPackageDirty();
	}

	virtual void DrawKismetRefs( FViewport* Viewport, const FSceneView* View, FCanvas* Canvas ) {}

	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Get the name of the class used to help out when handling events in UnrealEd.
	 * @return	String name of the helper class.
	 */
	virtual const FString GetEdHelperClassName() const
	{
		return FString( TEXT("UnrealEd.SequenceObjectHelper") );
	}

	virtual UBOOL IsPendingKill() const;

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return FALSE; }

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp() {}

	/**
	 * Determines whether this object is contained within a UPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UPrefab; FALSE if it IS a UPrefab or isn't contained within one.
	 */
	virtual UBOOL IsAPrefabArchetype( class UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UPrefabInstance or part of a prefab instance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class USequenceFrame : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceFrame
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    BITFIELD bDrawBox:1;
    BITFIELD bFilled:1;
    BITFIELD bTileFill:1;
    FColor BorderColor;
    FColor FillColor;
    class UTexture2D* FillTexture;
    class UMaterial* FillMaterial;
    //## END PROPS SequenceFrame

    DECLARE_CLASS(USequenceFrame,USequenceObject,0,Engine)
	/** Draws the box part of the comment (including handle) */
	void DrawFrameBox(FCanvas* Canvas, UBOOL bSelected);

	// SequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
};

class USequenceFrameWrapped : public USequenceFrame
{
public:
    //## BEGIN PROPS SequenceFrameWrapped
    //## END PROPS SequenceFrameWrapped

    DECLARE_CLASS(USequenceFrameWrapped,USequenceFrame,0,Engine)
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
};

struct FSeqOpInputLink
{
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    FName LinkAction;
    class USequenceOp* LinkedOp;
    INT DrawY;
    BITFIELD bHidden:1;
    FLOAT ActivateDelay;

     /** Constructors */
    FSeqOpInputLink() {}
    FSeqOpInputLink(EEventParm)
    {
	appMemzero(this, sizeof(FSeqOpInputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateInputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			bHasImpulse=TRUE;
			return TRUE;
		}

		return FALSE;
	}

};

struct FSeqOpOutputInputLink
{
    class USequenceOp* LinkedOp;
    INT InputLinkIdx;
};

struct FSeqOpOutputLink
{
    TArrayNoInit<struct FSeqOpOutputInputLink> Links;
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    FName LinkAction;
    class USequenceOp* LinkedOp;
    FLOAT ActivateDelay;
    INT DrawY;
    BITFIELD bHidden:1;

     /** Constructors */
    FSeqOpOutputLink() {}
    FSeqOpOutputLink(EEventParm)
    {
		appMemzero(this, sizeof(FSeqOpOutputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateOutputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			bHasImpulse = TRUE;
			return TRUE;
		}
		return FALSE;
	}

	UBOOL HasLinkTo(USequenceOp *Op, INT LinkIdx = -1)
	{
		if (Op != NULL)
		{
			for (INT Idx = 0; Idx < Links.Num(); Idx++)
			{
				if (Links(Idx).LinkedOp == Op &&
					(LinkIdx == -1 || Links(Idx).InputLinkIdx == LinkIdx))
				{
					return TRUE;
				}
			}
		}
		return FALSE;
	}

};

struct FSeqVarLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceVariable*> LinkedVariables;
    FStringNoInit LinkDesc;
    FName LinkVar;
    FName PropertyName;
    BITFIELD bWriteable:1;
    BITFIELD bHidden:1;
    INT MinVars;
    INT MaxVars;
    INT DrawX;
    class UProperty* CachedProperty;

    /** Constructors */
    FSeqVarLink() {}
    FSeqVarLink(EEventParm)
    {
	appMemzero(this, sizeof(FSeqVarLink));
    }

	/**
	 * Determines whether this variable link can be associated with the specified sequence variable class.
	 *
	 * @param	SequenceVariableClass	the class to check for compatibility with this variable link; must be a child of SequenceVariable
	 * @param	bRequireExactClass		if FALSE, child classes of the specified class return a match as well.
	 *
	 * @return	TRUE if this variable link can be linked to the a SequenceVariable of the specified type.
	 */
	UBOOL SupportsVariableType( UClass* SequenceVariableClass, UBOOL bRequireExactClass=TRUE );

};

struct FSeqEventLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceEvent*> LinkedEvents;
    FStringNoInit LinkDesc;
    INT DrawX;
    BITFIELD bHidden:1;

    /** Constructors */
    FSeqEventLink() {}
    FSeqEventLink(EEventParm)
    {
        appMemzero(this, sizeof(FSeqEventLink));
    }
};

struct SequenceOp_eventDeactivated_Parms
{
    SequenceOp_eventDeactivated_Parms(EEventParm)
    {
    }
};
struct SequenceOp_eventActivated_Parms
{
    SequenceOp_eventActivated_Parms(EEventParm)
    {
    }
};
class USequenceOp : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceOp
    BITFIELD bActive:1;
    BITFIELD bLatentExecution:1;
    BITFIELD bAutoActivateOutputLinks:1;
    TArrayNoInit<struct FSeqOpInputLink> InputLinks;
    TArrayNoInit<struct FSeqOpOutputLink> OutputLinks;
    TArrayNoInit<struct FSeqVarLink> VariableLinks;
    TArrayNoInit<struct FSeqEventLink> EventLinks;
    INT PlayerIndex;
    INT ActivateCount;
    //## END PROPS SequenceOp

    UBOOL HasLinkedOps(UBOOL bConsiderInputLinks=FALSE) const;
    void GetLinkedObjects(TArray<class USequenceObject*>& out_Objects,class UClass* ObjectType=NULL,UBOOL bRecurse=FALSE);
    virtual void PopulateLinkedVariableValues();
    virtual void PublishLinkedVariableValues();
    DECLARE_FUNCTION(execHasLinkedOps)
    {
        P_GET_UBOOL_OPTX(bConsiderInputLinks,FALSE);
        P_FINISH;
        *(UBOOL*)Result=HasLinkedOps(bConsiderInputLinks);
    }
    DECLARE_FUNCTION(execGetLinkedObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,out_Objects);
        P_GET_OBJECT_OPTX(UClass,ObjectType,NULL);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        GetLinkedObjects(out_Objects,ObjectType,bRecurse);
    }
    DECLARE_FUNCTION(execGetObjectVars);
    DECLARE_FUNCTION(execGetBoolVars);
    DECLARE_FUNCTION(execLinkedVariables);
    DECLARE_FUNCTION(execPopulateLinkedVariableValues)
    {
        P_FINISH;
        PopulateLinkedVariableValues();
    }
    DECLARE_FUNCTION(execPublishLinkedVariableValues)
    {
        P_FINISH;
        PublishLinkedVariableValues();
    }
    void eventDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Deactivated),NULL);
    }
    void eventActivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Activated),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceOp,USequenceObject,0,Engine)
	virtual void CheckForErrors();

	// USequenceOp interface
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
    virtual void PostDeActivated() {};	// only used by SequenceEvent at the moment for multiple activations in a frame

	/**
	 * Notification that an input link on this sequence op has been given impulse by another op.  Propagates the value of
	 * PlayerIndex from the ActivatorOp to this one.
	 *
	 * @param	ActivatorOp		the sequence op that applied impulse to this op's input link
	 * @param	InputLinkIndex	the index [into this op's InputLinks array] for the input link that was given impulse
	 */
	virtual void OnReceivedImpulse( class USequenceOp* ActivatorOp, INT InputLinkIndex );

	/**
	 * Allows the operation to initialize the values for any VariableLinks that need to be filled prior to executing this
	 * op's logic.  This is a convenient hook for filling VariableLinks that aren't necessarily associated with an actual
	 * member variable of this op, or for VariableLinks that are used in the execution of this ops logic.
	 */
	virtual void InitializeLinkedVariableValues() {}

	// helper functions
	void GetBoolVars(TArray<UBOOL*> &outBools, const TCHAR *inDesc = NULL);
	void GetIntVars(TArray<INT*> &outInts, const TCHAR *inDesc = NULL);
	void GetFloatVars(TArray<FLOAT*> &outFloats, const TCHAR *inDesc = NULL);
	void GetVectorVars(TArray<FVector*> &outVectors, const TCHAR *inDesc = NULL);
	void GetObjectVars(TArray<UObject**> &outObjects, const TCHAR *inDesc = NULL);
	void GetStringVars(TArray<FString*> &outStrings, const TCHAR *inDesc = NULL);
	/**
	 * Retrieve a list of FName values connected to this sequence op.
	 *
	 * @param	out_Names	receieves the list of name values
	 * @param	inDesc		if specified, only name values connected via a variable link that this name will be returned.
	 */
	void GetNameVars( TArray<FName*>& out_Names, const TCHAR* inDesc=NULL );

	/**
	 * Retrieve a list of UIRangeData values connected to this sequence op.
	 *
	 * @param	out_UIRanges	receieves the list of UIRangeData values
	 * @param	inDesc			if specified, only UIRangeData values connected via a variable link that this name will be returned.
	 */
	void GetUIRangeVars( TArray<struct FUIRangeData*>& out_UIRanges, const TCHAR* inDesc=NULL );

	INT FindConnectorIndex(const FString& ConnName, INT ConnType);
	void CleanupConnections();

	/** Called via PostEditChange(), lets ops create/remove dynamic links based on data. */
	virtual void UpdateDynamicLinks() {}
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntPoint	GetConnectionLocation(INT ConnType, INT ConnIndex);
	virtual FColor		GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );

	FIntPoint GetLogicConnectorsSize(FCanvas* Canvas, INT* InputY=0, INT* OutputY=0);
	FIntPoint GetVariableConnectorsSize(FCanvas* Canvas);
	FColor GetVarConnectorColor(INT LinkIndex);

	void DrawLogicConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex);
	void DrawVariableConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex, INT VarWidth);

	virtual void DrawLogicLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);
	virtual void DrawVariableLinks(FCanvas* Canvas, UBOOL bCurves, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);

	void MakeLinkedObjDrawInfo(struct FLinkedObjDrawInfo& ObjInfo, INT MouseOverConnType = -1, INT MouseOverConnIndex = INDEX_NONE);
	INT VisibleIndexToActualIndex(INT ConnType, INT VisibleIndex);

	/**
	 * Handles updating this sequence op when the ObjClassVersion doesn't match the ObjInstanceVersion, indicating that the op's
	 * default values have been changed.
	 */
	virtual void UpdateObject();
};

struct FActivateOp
{
    class USequenceOp* ActivatorOp;
    class USequenceOp* Op;
    INT InputIdx;
    FLOAT RemainingDelay;
};

class USequence : public USequenceOp
{
public:
    //## BEGIN PROPS Sequence
    FPointer LogFile;
    TArrayNoInit<class USequenceObject*> SequenceObjects;
    TArrayNoInit<class USequenceOp*> ActiveSequenceOps;
    TArrayNoInit<class USequence*> NestedSequences;
    TArrayNoInit<class USequenceEvent*> UnregisteredEvents;
    TArrayNoInit<struct FActivateOp> DelayedActivatedOps;
private:
    BITFIELD bEnabled:1;
public:
    INT DefaultViewX;
    INT DefaultViewY;
    FLOAT DefaultViewZoom;
    //## END PROPS Sequence

    void SetEnabled(UBOOL bInEnabled);
    DECLARE_FUNCTION(execFindSeqObjectsByClass);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bInEnabled);
        P_FINISH;
        SetEnabled(bInEnabled);
    }
    DECLARE_CLASS(USequence,USequenceOp,0,Engine)
	virtual void PostLoad();

	void CheckForErrors();

	/**
	 * Adds a new SequenceObject to this sequence's list of ops
	 *
	 * @param	NewObj		the sequence object to add.
	 * @param	bRecurse	if TRUE, recursively add any sequence objects attached to this one
	 *
	 * @return	TRUE if the object was successfully added to the sequence.
	 */
	virtual UBOOL AddSequenceObject( USequenceObject* NewObj, UBOOL bRecurse=FALSE );

	/**
	 * Removes the specified object from the SequenceObjects array, severing any links to that object.
	 *
	 * @param	ObjectToRemove	the SequenceObject to remove from this sequence.  All links to the object will be cleared.
	 * @param	ModifiedObjects	a list of objects that have been modified the objects that have been
	 */
	virtual void RemoveObject( USequenceObject* ObjectToRemove );

	/**
	 * Removes the specified objects from this Sequence's SequenceObjects array, severing any links to these objects.
	 *
	 * @param	ObjectsToRemove	the sequence objects to remove from this sequence.  All links to these objects will be cleared,
	 *							and the objects will be removed from all SequenceObject arrays.
	 */
	void RemoveObjects( const TArray<USequenceObject*>& ObjectsToRemove);

	/**
	 * Adds the specified SequenceOp to this sequence's list of ActiveOps.
	 *
	 * @param	NewSequenceOp	the sequence op to add to the list
	 * @param	bPushTop		if TRUE, adds the operation to the top of stack (meaning it will be executed first),
	 *							rather than the bottom
	 *
	 * @return	TRUE if the sequence operation was successfully added to the list.
	 */
	virtual UBOOL QueueSequenceOp( USequenceOp* NewSequenceOp, UBOOL bPushTop=FALSE );

	UBOOL ExecuteActiveOps(FLOAT DeltaTime, INT MaxSteps = 0);
	UBOOL UpdateOp(FLOAT DeltaTime);

	VARARG_DECL(void, void, {}, ScriptLogf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);
	VARARG_DECL(void, void, {}, ScriptWarnf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);

	virtual void Activated();

	virtual void UpdateObject()
	{
		// do nothing
	}

	virtual void OnCreated()
	{
		Super::OnCreated();
		// update our connectors
		UpdateConnectors();
	}

	virtual void OnExport()
	{
		Super::OnExport();
		for (INT idx = 0; idx < SequenceObjects.Num(); idx++)
		{
			SequenceObjects(idx)->OnExport();
		}
		for (INT idx = 0; idx < OutputLinks.Num(); idx++)
		{
			OutputLinks(idx).Links.Empty();
		}
		for (INT idx = 0; idx < VariableLinks.Num(); idx++)
		{
			VariableLinks(idx).LinkedVariables.Empty();
		}
		for (INT idx = 0; idx < EventLinks.Num(); idx++)
		{
			EventLinks(idx).LinkedEvents.Empty();
		}
	}

	virtual void UpdateConnectors();
	void UpdateNamedVarStatus();
	void UpdateInterpActionConnectors();

	/**
	 * Initialize this kismet sequence.
	 *  - Creates the kismet script log (if this sequence has no parent sequence)
	 *  - Registers all events with the objects that they're associated with.
	 *  - Resolves all "named" and "external" variable links contained by this sequence.
	 */
	virtual void InitializeSequence();

	/**
	 * Conditionally creates the log file for this sequence.
	 */
	virtual void CreateKismetLog();

	/**
	 * Called from level startup.  Initializes the sequence and activates any level-startup
	 * events contained within the sequence.
	 */
	virtual void BeginPlay();
	virtual void FinishDestroy();
	/**
	 * Activates LevelStartup and/or LevelBeginning events in this sequence
	 *
	 * @param bShouldActivateLevelStartupEvents If TRUE, will activate all LevelStartup events
	 * @param bShouldActivateLevelBeginningEvents If TRUE, will activate all LevelBeginning events
	 * @param bShouldActivateLevelLoadedEvents If TRUE, will activate all LevelLoadedAndVisible events
	 */
	virtual void NotifyMatchStarted(UBOOL bShouldActivateLevelStartupEvents=TRUE, UBOOL bShouldActivateLevelBeginningEvents=TRUE, UBOOL bShouldActivateLevelLoadedEvents=FALSE);

	void FindSeqObjectsByClass(UClass* DesiredClass, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindSeqObjectsByName(const FString& Name, UBOOL bCheckComment, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindSeqObjectsByObjectName(FName Name, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindNamedVariables(FName VarName, UBOOL bFindUses, TArray<USequenceVariable*>& OutputVars, UBOOL bRecursive = TRUE) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to the specified sequence object.
	 *
	 * @param	SearchObject		the sequence object to search for link references to
	 * @param	out_Referencers		if specified, receieves the list of sequence objects contained by this sequence
	 *								which are linked to the specified op
	 *
	 * @return	TRUE if at least one object in the sequence objects array is linked to the specified op.
	 */
	virtual UBOOL FindSequenceOpReferencers( USequenceObject* SearchObject, TArray<USequenceObject*>* out_Referencers=NULL );

	/**
	 * Returns a list of output links from this sequence's ops which reference the specified op.
	 *
	 * @param	SeqOp	the sequence object to search for output links to
	 * @param	Links	[out] receives the list of output links which reference the specified op.
	 */
	void FindLinksToSeqOp(USequenceOp* SeqOp, TArray<FSeqOpOutputLink*> &Links);

	USequence* GetPrefabsSequence();

	/**
	 * Determine if this sequence (or any of its subsequences) references a certain object.
	 *
	 * @param	InObject	the object to search for references to
	 * @param	pReferencer	if specified, will be set to the SequenceObject that is referencing the search object.
	 *
	 * @return TRUE if this sequence references the specified object.
	 */
	UBOOL ReferencesObject( const UObject* InObject, USequenceObject** pReferencer=NULL ) const;

	/**
	 * Determines whether the specified SequenceObject is contained in the SequenceObjects array of this sequence.
	 *
	 * @param	SearchObject	the sequence object to look for
	 * @param	bRecursive		specify FALSE to limit the search to this sequence only (do not search in sub-sequences as well)
	 *
	 * @return	TRUE if the specified sequence object was found in the SequenceObjects array of this sequence or one of its sub-sequences
	 */
	UBOOL ContainsSequenceObject( USequenceObject* SearchObject, UBOOL bRecursive=TRUE ) const;

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	void ClearNameUsage(FName InName, ERenameFlags RenameFlags=REN_None);

	/** Iterate over all SequenceObjects in this Sequence, making sure that their ParentSequence pointer points back to this Sequence. */
	void CheckParentSequencePointers();

	/** Draws the this sequence. */
	virtual void DrawSequence(FCanvas* Canvas, TArray<USequenceObject*>& SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime, UBOOL bCurves);

	/**
	 * @return		The ULevel this sequence occurs in.
	 */
	ULevel* GetLevel() const;

	UBOOL IsEnabled() const;

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();
};

class USequenceAction : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceAction
    FName HandlerName;
    BITFIELD bCallHandler:1;
    TArrayNoInit<class UObject*> Targets;
    //## END PROPS SequenceAction

    DECLARE_ABSTRACT_CLASS(USequenceAction,USequenceOp,0,Engine)
	virtual void Activated();

	/** Called before the handler function is called on a target actor. */
	virtual void PreActorHandle(AActor *inActor) {}
};

class USeqAct_ActivateRemoteEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ActivateRemoteEvent
    class AActor* Instigator;
    FName EventName;
    //## END PROPS SeqAct_ActivateRemoteEvent

    DECLARE_CLASS(USeqAct_ActivateRemoteEvent,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_ApplySoundNode : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ApplySoundNode
    class USoundCue* PlaySound;
    class USoundNode* ApplyNode;
    //## END PROPS SeqAct_ApplySoundNode

    DECLARE_CLASS(USeqAct_ApplySoundNode,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_AttachToEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_AttachToEvent
    //## END PROPS SeqAct_AttachToEvent

    DECLARE_CLASS(USeqAct_AttachToEvent,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_CameraLookAt : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraLookAt
    BITFIELD bAffectCamera:1;
    BITFIELD bAlwaysFocus:1;
    BITFIELD bAdjustCamera:1;
    BITFIELD bIgnoreTrace:1;
    BITFIELD bAffectHead:1;
    BITFIELD bToggleGodMode:1;
    BITFIELD bLeaveCameraRotation:1;
    BITFIELD bDisableInput:1;
    BITFIELD bUsedTimer:1;
    BITFIELD bCheckLineOfSight:1;
    FVector2D InterpSpeedRange;
    FVector2D InFocusFOV;
    FName FocusBoneName;
    FStringNoInit TextDisplay;
    FLOAT TotalTime;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_CameraLookAt

    DECLARE_CLASS(USeqAct_CameraLookAt,USequenceAction,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();
};

class USeqAct_CauseDamage : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CauseDamage
    class UClass* DamageType;
    FLOAT Momentum;
    FLOAT DamageAmount;
    class AActor* Instigator;
    //## END PROPS SeqAct_CauseDamage

    DECLARE_CLASS(USeqAct_CauseDamage,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_CauseDamage)
};

class USeqAct_CauseDamageRadial : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CauseDamageRadial
    class UClass* DamageType;
    FLOAT Momentum;
    FLOAT DamageAmount;
    FLOAT DamageRadius;
    BITFIELD bDamageFalloff:1;
    class AActor* Instigator;
    //## END PROPS SeqAct_CauseDamageRadial

    DECLARE_CLASS(USeqAct_CauseDamageRadial,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_CommitMapChange : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CommitMapChange
    //## END PROPS SeqAct_CommitMapChange

    DECLARE_CLASS(USeqAct_CommitMapChange,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_FinishSequence : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_FinishSequence
    FStringNoInit OutputLabel;
    //## END PROPS SeqAct_FinishSequence

    DECLARE_CLASS(USeqAct_FinishSequence,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_Gate : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Gate
    BITFIELD bOpen:1;
    INT AutoCloseCount;
    //## END PROPS SeqAct_Gate

    DECLARE_CLASS(USeqAct_Gate,USequenceAction,0,Engine)
	void Activated()
	{
		UBOOL bWasOpen = bOpen;
		// first look for an open/close impulse
		if (InputLinks(1).bHasImpulse)
		{
			// open the gate
			bOpen = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			// close the gate
			bOpen = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			// toggle the gate
			bOpen = !bOpen;
		}
		KISMET_LOG(TEXT("- Gate status: %s (was: %s)"),bOpen?TEXT("Open"):TEXT("Closed"),bWasOpen?TEXT("Open"):TEXT("Closed"));
		// next check for an activation impulse
		if (bOpen && InputLinks(0).bHasImpulse)
		{
			if (!OutputLinks(0).bDisabled && 
				!(OutputLinks(0).bDisabledPIE && GIsEditor))
			{
				OutputLinks(0).bHasImpulse = TRUE;
			}
			if (AutoCloseCount > 0 && ActivateCount >= AutoCloseCount)
			{
				bOpen = FALSE;
			}
		}
	}
};

class USeqAct_GetDistance : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetDistance
    FLOAT Distance;
    //## END PROPS SeqAct_GetDistance

    DECLARE_CLASS(USeqAct_GetDistance,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_GetProperty : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetProperty
    FName PropertyName;
    //## END PROPS SeqAct_GetProperty

    DECLARE_CLASS(USeqAct_GetProperty,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_GetVelocity : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetVelocity
    FLOAT Velocity;
    //## END PROPS SeqAct_GetVelocity

    DECLARE_CLASS(USeqAct_GetVelocity,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_IsInObjectList : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_IsInObjectList
    BITFIELD bCheckForAllObjects:1;
    BITFIELD bObjectFound:1;
    //## END PROPS SeqAct_IsInObjectList

    DECLARE_CLASS(USeqAct_IsInObjectList,USequenceAction,0,Engine)
	/**
	* When a IsInObjectList is Activated() it will look in the referenced
	* list and then determine if the referenced object is in it
	**/
	void Activated();

	/**
	* IsInObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();


private:
	/**
	* Helper functions to determine if objects are in the list for each of the cases
	**/
	UBOOL TestForAllObjectsInList();
	UBOOL TestForAnyObjectsInList();
};

struct SeqAct_Latent_eventUpdate_Parms
{
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    SeqAct_Latent_eventUpdate_Parms(EEventParm)
    {
    }
};
class USeqAct_Latent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Latent
    TArrayNoInit<class AActor*> LatentActors;
    BITFIELD bAborted:1;
    //## END PROPS SeqAct_Latent

    virtual void AbortFor(class AActor* latentActor);
    DECLARE_FUNCTION(execAbortFor)
    {
        P_GET_OBJECT(AActor,latentActor);
        P_FINISH;
        AbortFor(latentActor);
    }
    UBOOL eventUpdate(FLOAT DeltaTime)
    {
        SeqAct_Latent_eventUpdate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Update),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USeqAct_Latent,USequenceAction,0,Engine)
	virtual void PreActorHandle(AActor *inActor);
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
};

class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ActorFactory
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
    BITFIELD bIsSpawning:1;
    BITFIELD bCheckSpawnCollision:1;
    class UActorFactory* Factory;
    BYTE PointSelection;
    TArrayNoInit<class AActor*> SpawnPoints;
    INT SpawnCount;
    FLOAT SpawnDelay;
    INT LastSpawnIdx;
    INT SpawnedCount;
    FLOAT RemainingDelay;
    //## END PROPS SeqAct_ActorFactory

    DECLARE_CLASS(USeqAct_ActorFactory,USeqAct_Latent,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	virtual void Spawned(UObject *NewSpawn);

	/**
	 * Checks any of the bEnabled inputs and sets the new value.
	 */
	void CheckToggle()
	{
		if (InputLinks(1).bHasImpulse)
		{
			bEnabled = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			bEnabled = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			bEnabled = !bEnabled;
		}
	}
};

class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory
{
public:
    //## BEGIN PROPS SeqAct_ActorFactoryEx
    //## END PROPS SeqAct_ActorFactoryEx

    DECLARE_CLASS(USeqAct_ActorFactoryEx,USeqAct_ActorFactory,0,Engine)
	virtual void UpdateDynamicLinks();
	virtual void Spawned(UObject *NewSpawn);
};

class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_AIMoveToActor
    BITFIELD bInterruptable:1 GCC_BITFIELD_MAGIC;
    //## END PROPS SeqAct_AIMoveToActor

    DECLARE_CLASS(USeqAct_AIMoveToActor,USeqAct_Latent,0,Engine)
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void  Activated();
};

class USeqAct_CrossFadeMusicTracks : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_CrossFadeMusicTracks
    FName TrackBankName;
    FName CurrTrackType;
    class UAudioComponent* CurrPlayingTrack;
    FLOAT AdjustVolumeDuration;
    FLOAT AdjustVolumeLevel;
    FLOAT NextTrackToPlayAt;
    struct FMusicTrackStruct NextTrackToPlay;
    //## END PROPS SeqAct_CrossFadeMusicTracks

    void CrossFadeTrack(const struct FMusicTrackStruct& TrackToPlay);
    void ClientSideCrossFadeTrackImmediately(const struct FMusicTrackStruct& TrackToPlay);
    void StopAllMusicManagerSounds();
    DECLARE_FUNCTION(execCrossFadeTrack)
    {
        P_GET_STRUCT_REF(struct FMusicTrackStruct,TrackToPlay);
        P_FINISH;
        CrossFadeTrack(TrackToPlay);
    }
    DECLARE_FUNCTION(execClientSideCrossFadeTrackImmediately)
    {
        P_GET_STRUCT_REF(struct FMusicTrackStruct,TrackToPlay);
        P_FINISH;
        ClientSideCrossFadeTrackImmediately(TrackToPlay);
    }
    DECLARE_FUNCTION(execStopAllMusicManagerSounds)
    {
        P_FINISH;
        StopAllMusicManagerSounds();
    }
    DECLARE_CLASS(USeqAct_CrossFadeMusicTracks,USeqAct_Latent,0,Engine)
	virtual void Activated();

	/**
	 * Updates this sequence action to the current version.
	 */
	virtual void UpdateObject();

	/** 
	 * This sequence's "Tick" operation
	 */
	virtual UBOOL UpdateOp( FLOAT DeltaTime );

private:
	/** This will find all of the SeqAct_CrossFadeMusicTracks (music managers in the currently loaded levels **/
	void FindAllMusicManagers( USequence* SequenceToLookIn, TArray<USeqAct_CrossFadeMusicTracks*>& OutputVars ) const;
};

class USeqAct_Delay : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Delay
    BITFIELD bDelayActive:1 GCC_BITFIELD_MAGIC;
    FLOAT DefaultDuration;
    FLOAT Duration;
    FLOAT LastUpdateTime;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_Delay

    DECLARE_CLASS(USeqAct_Delay,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	virtual void PostLoad();
};

class USeqAct_DelaySwitch : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_DelaySwitch
    INT LinkCount;
    INT CurrentIdx;
    FLOAT SwitchDelay;
    FLOAT NextLinkTime;
    //## END PROPS SeqAct_DelaySwitch

    DECLARE_CLASS(USeqAct_DelaySwitch,USeqAct_Latent,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	void Activated()
	{
		// reset the link index
		CurrentIdx = 0;
		// figure out the total delay
		TArray<FLOAT*> floatVars;
		GetFloatVars(floatVars,TEXT("Delay"));
		SwitchDelay = 0.f;
		for (INT idx = 0; idx < floatVars.Num(); idx++)
		{
			SwitchDelay += *(floatVars(idx));
		}
		NextLinkTime = SwitchDelay;
	}

	UBOOL UpdateOp(FLOAT deltaTime)
	{
		if (NextLinkTime <= 0.f)
		{
			if( CurrentIdx < OutputLinks.Num() && !OutputLinks(CurrentIdx).bDisabled &&
				!(OutputLinks(CurrentIdx).bDisabledPIE && GIsEditor))
			{
				// activate the new link
				OutputLinks(CurrentIdx).bHasImpulse = 1;
				// fill any variables attached
				TArray<INT*> intVars;
				GetIntVars(intVars,TEXT("Active Link"));
				for (INT idx = 0; idx < intVars.Num(); idx++)
				{
					// offset by 1 for non-programmer friendliness
					*(intVars(idx)) = CurrentIdx + 1;
				}
				// and increment the link index
				CurrentIdx++;
			}
			NextLinkTime = SwitchDelay;
		}
		else
		{
			NextLinkTime -= deltaTime;
		}
		return (CurrentIdx >= OutputLinks.Num());
	}

	void DeActivated()
	{
	}
};

class USeqAct_ForceGarbageCollection : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ForceGarbageCollection
    //## END PROPS SeqAct_ForceGarbageCollection

    DECLARE_CLASS(USeqAct_ForceGarbageCollection,USeqAct_Latent,0,Engine)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_ForceMaterialMipsResident : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ForceMaterialMipsResident
    FLOAT ForceDuration;
    TArrayNoInit<class UMaterialInterface*> ForceMaterials;
    FLOAT RemainingTime;
    TArrayNoInit<class UTexture2D*> ModifiedTextures;
    //## END PROPS SeqAct_ForceMaterialMipsResident

    DECLARE_CLASS(USeqAct_ForceMaterialMipsResident,USeqAct_Latent,0,Engine)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

struct FSavedTransform
{
    FVector Location;
    FRotator Rotation;
    friend FArchive& operator<<(FArchive& Ar,FSavedTransform& MySavedTransform)
    {
        return Ar << MySavedTransform.Location << MySavedTransform.Rotation;
    }
};

class USeqAct_Interp : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Interp
    TMap< AActor*,FSavedTransform > SavedActorTransforms;
    FLOAT PlayRate;
    FLOAT Position;
    FLOAT ForceStartPosition;
    BITFIELD bIsPlaying:1;
    BITFIELD bPaused:1;
    BITFIELD bLooping:1;
    BITFIELD bRewindOnPlay:1;
    BITFIELD bNoResetOnRewind:1;
    BITFIELD bRewindIfAlreadyPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bInterpForPathBuilding:1;
    BITFIELD bForceStartPos:1;
    BITFIELD bClientSideOnly:1;
    BITFIELD bSkipUpdateIfNotVisible:1;
    BITFIELD bIsSkippable:1;
    BITFIELD bIsBeingEdited:1;
    TArrayNoInit<class ACoverLink*> LinkedCover;
    class UInterpData* InterpData;
    TArrayNoInit<class UInterpGroupInst*> GroupInst;
    class UClass* ReplicatedActorClass;
    class AMatineeActor* ReplicatedActor;
    //## END PROPS SeqAct_Interp

    void SetPosition(FLOAT NewPosition,UBOOL bJump=FALSE);
    void AddPlayerToDirectorTracks(class APlayerController* PC);
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewPosition);
        P_GET_UBOOL_OPTX(bJump,FALSE);
        P_FINISH;
        SetPosition(NewPosition,bJump);
    }
    DECLARE_FUNCTION(execAddPlayerToDirectorTracks)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_FINISH;
        AddPlayerToDirectorTracks(PC);
    }
    DECLARE_CLASS(USeqAct_Interp,USeqAct_Latent,0,Engine)
	// UObject interface.
	/**
	 * Serialize function.
	 *
	 * @param	Ar		The archive to serialize with.
	 */
	virtual void Serialize(FArchive& Ar);

	// USequenceAction interface

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void DeActivated();
	virtual void OnCreated();

	virtual void UpdateObject();

	// USeqAct_Interp interface

	/**
	 * Begin playback of this sequence. Only called in game.
	 * Will then advance Position by (PlayRate * Deltatime) each time the SeqAct_Interp is ticked.
	 */
	void Play();

	/** Stop playback at current position. */
	void Stop();

	/** Similar to play, but the playback will go backwards until the beginning of the sequence is reached. */
	void Reverse();

	/** Hold playback at its current position, but leave the sequence initialised. Calling Pause again will continue playback in its current direction. */
	void Pause();

	/** Changes the direction of playback (go in reverse if it was going forward, or vice versa) */
	void ChangeDirection();

	/** Called to notify affected actors when a new impulse changes the interpolation (paused, reversed direction, etc) */
	void NotifyActorsOfChange();

	/** Increment track forwards by given timestep and iterate over each track updating any properties. */
	virtual void StepInterp(FLOAT DeltaTime, UBOOL bPreview=false);

	/** Move interpolation to new position and iterate over each track updating any properties. */
	void UpdateInterp(FLOAT NewPosition, UBOOL bPreview=false, UBOOL bJump=false);

	/** For each InterGroup/Actor combination, create a InterpGroupInst, assign Actor and initialise each track. */
	void InitInterp();

	/** Destroy all InterpGroupInst. */
	void TermInterp();

	/** Reset the 'initial transform' for all movement tracks to be from the current actor positions. */
	void ResetMovementInitialTransforms();

	/** See if there is an instance referring to the supplied Actor. Returns NULL if not. */
	class UInterpGroupInst* FindGroupInst(AActor* Actor);

	/** Find the first group instance based on the given InterpGroup. */
	class UInterpGroupInst* FindFirstGroupInst(class UInterpGroup* InGroup);

	/** Find the first group instance based on the InterpGroup with the given name. */
	class UInterpGroupInst* FindFirstGroupInstByName(FName InGroupName);

	/** Find the InterpData connected to the first Variable connector. Returns NULL if none attached. */
	class UInterpData* FindInterpDataFromVariable();

	/** Synchronise the variable connectors with the currently attached InterpData. */
	void UpdateConnectorsFromData();

	/** Use any existing DirectorGroup to see which Actor we currently want to view through. */
	class AActor* FindViewedActor();

	/**
	 *	Utility for getting all Actors currently being worked on by this Matinee action.
	 *	If bMovementTrackOnly is set, Actors must have a Movement track in their group to be included in the results.
	 */
	void GetAffectedActors(TArray<AActor*>& OutActors, UBOOL bMovementTrackOnly);

	/**
	 * Adds the specified actor and any actors attached to it to the list
	 * of saved actor transforms.  Does nothing if an actor has already
	 * been saved.
	 */
	void SaveActorTransforms(AActor* Actor);

	/**
	 * Applies the saved locations and rotations to all saved actors.
	 */
	void RestoreActorTransforms();

	/**
	 * Stores the current scrub position, restores all saved actor transforms,
	 * then saves off the transforms for actors referenced (directly or indirectly)
	 * by group instances, and finally restores the scrub position.
	 */
	void RecaptureActorTransforms();

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();

	/** Sets up the group actor for the specified InterpGroup. */
	void InitGroupActorForGroup(class UInterpGroup* InGroup, class AActor* GroupActor);
};

class USeqAct_LevelStreamingBase : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelStreamingBase
    BITFIELD bMakeVisibleAfterLoad:1 GCC_BITFIELD_MAGIC;
    BITFIELD bShouldBlockOnLoad:1;
    //## END PROPS SeqAct_LevelStreamingBase

    DECLARE_ABSTRACT_CLASS(USeqAct_LevelStreamingBase,USeqAct_Latent,0,Engine)
	/**
	 * Handles "Activated" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "Activated" for.
	 */
	void ActivateLevel( ULevelStreaming* LevelStreamingObject );

	/**
	 * Handles "UpdateOp" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "UpdateOp" for.
	 *
	 * @return TRUE if operation has completed, FALSE if still in progress
	 */
	UBOOL UpdateLevel( ULevelStreaming* LevelStreamingObject );
};

class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_LevelStreaming
    class ULevelStreaming* Level;
    FName LevelName;
    //## END PROPS SeqAct_LevelStreaming

    DECLARE_CLASS(USeqAct_LevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
};

struct FLevelStreamingNameCombo
{
    class ULevelStreaming* Level;
    FName LevelName;
};

class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_MultiLevelStreaming
    TArrayNoInit<struct FLevelStreamingNameCombo> Levels;
    //## END PROPS SeqAct_MultiLevelStreaming

    DECLARE_CLASS(USeqAct_MultiLevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_LevelVisibility : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelVisibility
    class ULevelStreaming* Level;
    FName LevelName;
    //## END PROPS SeqAct_LevelVisibility

    DECLARE_CLASS(USeqAct_LevelVisibility,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_PlayCameraAnim : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlayCameraAnim
    class UCameraAnim* CameraAnim;
    BITFIELD bLoop:1;
    BITFIELD bRandomStartTime:1;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT Rate;
    FLOAT IntensityScale;
    BITFIELD bStopped:1;
    FLOAT AnimTimeRemaining;
    //## END PROPS SeqAct_PlayCameraAnim

    DECLARE_CLASS(USeqAct_PlayCameraAnim,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
};

class USeqAct_PlaySound : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlaySound
    class USoundCue* PlaySound;
    FLOAT ExtraDelay;
    FLOAT SoundDuration;
    FLOAT FadeInTime;
    FLOAT FadeOutTime;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    BITFIELD bSuppressSubtitles:1;
    BITFIELD bStopped:1;
    //## END PROPS SeqAct_PlaySound

    DECLARE_CLASS(USeqAct_PlaySound,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
};

class USeqAct_PrepareMapChange : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PrepareMapChange
    FName MainLevelName;
    TArrayNoInit<FName> InitiallyLoadedSecondaryLevelNames;
    BITFIELD bIsHighPriority:1;
    //## END PROPS SeqAct_PrepareMapChange

    DECLARE_CLASS(USeqAct_PrepareMapChange,USeqAct_Latent,0,Engine)
	/**
	 * Called when this sequence action is being activated. Kicks off async background loading.
	 */
	void Activated();

	void DeActivated();

	/**
	 * Called from parent sequence via ExecuteActiveOps, returns TRUE to indicate this
	 * action has completed, which in this case means the engine is ready to have
	 * CommitMapChange called.
	 *
	 * @return TRUE if action has completed, FALSE otherwise
	 */
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_SetDOFParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetDOFParams
    FLOAT FalloffExponent;
    FLOAT BlurKernelSize;
    FLOAT MaxNearBlurAmount;
    FLOAT MaxFarBlurAmount;
    FColor ModulateBlurColor;
    FLOAT FocusInnerRadius;
    FLOAT FocusDistance;
    FVector FocusPosition;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldFalloffExponent;
    FLOAT OldBlurKernelSize;
    FLOAT OldMaxNearBlurAmount;
    FLOAT OldMaxFarBlurAmount;
    FColor OldModulateBlurColor;
    FLOAT OldFocusInnerRadius;
    FLOAT OldFocusDistance;
    FVector OldFocusPosition;
    //## END PROPS SeqAct_SetDOFParams

    DECLARE_CLASS(USeqAct_SetDOFParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_SetMotionBlurParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetMotionBlurParams
    FLOAT MotionBlurAmount;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldMotionBlurAmount;
    //## END PROPS SeqAct_SetMotionBlurParams

    DECLARE_CLASS(USeqAct_SetMotionBlurParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_WaitForLevelsVisible : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_WaitForLevelsVisible
    TArrayNoInit<FName> LevelNames;
    BITFIELD bShouldBlockOnLoad:1;
    //## END PROPS SeqAct_WaitForLevelsVisible

    DECLARE_CLASS(USeqAct_WaitForLevelsVisible,USeqAct_Latent,0,Engine)
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_Log : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Log
    BITFIELD bOutputToScreen:1;
    BITFIELD bIncludeObjComment:1;
    FLOAT TargetDuration;
    FVector TargetOffset;
    //## END PROPS SeqAct_Log

    DECLARE_CLASS(USeqAct_Log,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_MoveToActor : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_MoveToActor
    BITFIELD bInterruptable:1;
    //## END PROPS SeqAct_MoveToActor

    DECLARE_CLASS(USeqAct_MoveToActor,USequenceAction,0,Engine)
	virtual void PostLoad();
};

class USeqAct_PlayFaceFXAnim : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayFaceFXAnim
    class UFaceFXAnimSet* FaceFXAnimSetRef;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXAnimName;
    //## END PROPS SeqAct_PlayFaceFXAnim

    DECLARE_CLASS(USeqAct_PlayFaceFXAnim,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_PlayFaceFXAnim)
};

class USeqAct_Possess : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Possess
    class APawn* PawnToPossess;
    BITFIELD bKillOldPawn:1;
    BITFIELD bTryToLeaveVehicle:1;
    //## END PROPS SeqAct_Possess

    DECLARE_CLASS(USeqAct_Possess,USequenceAction,0,Engine)
	void Activated();
};

struct FSwitchRange
{
    INT Min;
    INT Max;
};

class USeqAct_RangeSwitch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_RangeSwitch
    TArrayNoInit<struct FSwitchRange> Ranges;
    //## END PROPS SeqAct_RangeSwitch

    DECLARE_CLASS(USeqAct_RangeSwitch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		if (OutputLinks.Num() < Ranges.Num())
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < Ranges.Num())
			{
				OutputLinks.AddZeroed();
			}
		}
		else
		if (OutputLinks.Num() > Ranges.Num())
		{
			while (OutputLinks.Num() > Ranges.Num())
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		// match all the link descriptions to the range values
		for (INT idx = 0; idx < Ranges.Num(); idx++)
		{
			OutputLinks(idx).LinkDesc = FString::Printf(TEXT("%d - %d"),Ranges(idx).Min,Ranges(idx).Max);
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	virtual void Activated()
	{
		// get all of the attached int vars
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Index"));
		// and activate the matching outputs
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			INT activeIdx = *(intVars(idx));
			for (INT rangeIdx = 0; rangeIdx < Ranges.Num(); rangeIdx++)
			{
				if (activeIdx >= Ranges(rangeIdx).Min	&&
					activeIdx <= Ranges(rangeIdx).Max	&&
					!OutputLinks(rangeIdx).bDisabled	&&
					!(OutputLinks(rangeIdx).bDisabledPIE && GIsEditor)
					)
				{
					OutputLinks(rangeIdx).bHasImpulse = 1;
				}
			}
		}
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetBlockRigidBody
    //## END PROPS SeqAct_SetBlockRigidBody

    DECLARE_CLASS(USeqAct_SetBlockRigidBody,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetBlockRigidBody)
};

class USeqAct_SetCameraTarget : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetCameraTarget
    class AActor* CameraTarget;
    //## END PROPS SeqAct_SetCameraTarget

    DECLARE_CLASS(USeqAct_SetCameraTarget,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMaterial : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMaterial
    class UMaterialInterface* NewMaterial;
    INT MaterialIndex;
    //## END PROPS SeqAct_SetMaterial

    DECLARE_CLASS(USeqAct_SetMaterial,USequenceAction,0,Engine)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqAct_SetMatInstScalarParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstScalarParam
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLOAT ScalarValue;
    //## END PROPS SeqAct_SetMatInstScalarParam

    DECLARE_CLASS(USeqAct_SetMatInstScalarParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMatInstTexParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstTexParam
    class UMaterialInstanceConstant* MatInst;
    class UTexture* NewTexture;
    FName ParamName;
    //## END PROPS SeqAct_SetMatInstTexParam

    DECLARE_CLASS(USeqAct_SetMatInstTexParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMatInstVectorParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstVectorParam
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLinearColor VectorValue;
    //## END PROPS SeqAct_SetMatInstVectorParam

    DECLARE_CLASS(USeqAct_SetMatInstVectorParam,USequenceAction,0,Engine)
	void Activated();
};

class USequenceVariable : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceVariable
    FName VarName;
    //## END PROPS SequenceVariable

    DECLARE_ABSTRACT_CLASS(USequenceVariable,USequenceObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();

	//NOTE: yes this is unfortunate, and is tedious, but works as an interim solution
	virtual INT* GetIntRef()
	{
		return NULL;
	}

	virtual UBOOL* GetBoolRef()
	{
		return NULL;
	}

	virtual FLOAT* GetFloatRef()
	{
		return NULL;
	}

	virtual FVector* GetVectorRef()
	{
		return NULL;
	}

	virtual struct FUIRangeData* GetUIRangeRef()
	{
		return NULL;
	}

	virtual FString* GetStringRef()
	{
		return NULL;
	}

	virtual FName* GetNameRef()
	{
		return NULL;
	}

	virtual UObject** GetObjectRef( INT Idx )
	{
		return NULL;
	}

	virtual FString GetValueStr()
	{
		return FString(TEXT("Undefined"));
	}

	/**
	 * Used for property exposure to variable links, allows variables
	 * to determine what types they can support.
	 */
	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Allows the sequence variable to execute additional logic after copying values from the SequenceOp's members to the sequence variable.
	 *
	 * @param	SourceOp	the sequence op that contains the value that should be copied to this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PostPopulateValue( USequenceOp* SourceOp, FSeqVarLink& VarLink ) {}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter) {}

	FIntPoint GetVarConnectionLocation();
};

class UInterpData : public USequenceVariable
{
public:
    //## BEGIN PROPS InterpData
    FLOAT InterpLength;
    FLOAT PathBuildTime;
    TArrayNoInit<class UInterpGroup*> InterpGroups;
    class UInterpCurveEdSetup* CurveEdSetup;
    TArrayNoInit<class UInterpFilter*> InterpFilters;
    class UInterpFilter* SelectedFilter;
    TArrayNoInit<class UInterpFilter*> DefaultFilters;
    FLOAT EdSectionStart;
    FLOAT EdSectionEnd;
    //## END PROPS InterpData

    DECLARE_CLASS(UInterpData,USequenceVariable,0,Engine)
	// SequenceVariable interface
	virtual FString GetValueStr();

	// InterpData interface
	INT FindGroupByName(FName GroupName);
	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);
	class UInterpGroupDirector* FindDirectorGroup();
	void GetAllEventNames(TArray<FName>& OutEventNames);
};

class USeqVar_Bool : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Bool
    INT bValue;
    //## END PROPS SeqVar_Bool

    DECLARE_CLASS(USeqVar_Bool,USequenceVariable,0,Engine)
	UBOOL* GetBoolRef()
	{
		return (UBOOL*)&bValue;
	}

	FString GetValueStr()
	{
		return bValue == TRUE ? GTrue : GFalse;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UBoolProperty::StaticClass()));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_External : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_External
    class UClass* ExpectedType;
    FStringNoInit VariableLabel;
    //## END PROPS SeqVar_External

    DECLARE_CLASS(USeqVar_External,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	// SequenceVariable interface
	virtual FString GetValueStr();

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }
};

class USeqVar_Float : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Float
    FLOAT FloatValue;
    //## END PROPS SeqVar_Float

    DECLARE_CLASS(USeqVar_Float,USequenceVariable,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.3f"),FloatValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UFloatProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UFloatProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomFloat : public USeqVar_Float
{
public:
    //## BEGIN PROPS SeqVar_RandomFloat
    FLOAT Min;
    FLOAT Max;
    //## END PROPS SeqVar_RandomFloat

    DECLARE_CLASS(USeqVar_RandomFloat,USeqVar_Float,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		FloatValue = Min + appFrand() * (Max - Min);
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.1f..%2.1f"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Int : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Int
    INT IntValue;
    //## END PROPS SeqVar_Int

    DECLARE_CLASS(USeqVar_Int,USequenceVariable,0,Engine)
	virtual INT* GetIntRef()
	{
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d"),IntValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UIntProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UIntProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomInt : public USeqVar_Int
{
public:
    //## BEGIN PROPS SeqVar_RandomInt
    INT Min;
    INT Max;
    //## END PROPS SeqVar_RandomInt

    DECLARE_CLASS(USeqVar_RandomInt,USeqVar_Int,0,Engine)
	virtual INT* GetIntRef()
	{
		IntValue = Min + (appRand() % (Max - Min + 1));
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d..%d"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Name : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Name
    FName NameValue;
    //## END PROPS SeqVar_Name

    DECLARE_CLASS(USeqVar_Name,USequenceVariable,0,Engine)
	/** Returns the value of this variable */
	FName* GetNameRef()
	{
		return &NameValue;
	}

	/** Returns a string representation of the value of this variable */
	FString GetValueStr()
	{
		return NameValue.ToString();
	}

	/**
	 * Determines whether this variable can be used to contain a value for the specified property.
	 */
	virtual UBOOL SupportsProperty( UProperty *Property )
	{
		return (Property && Property->IsA(UNameProperty::StaticClass()));
	}

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp* Op, UProperty* Property, FSeqVarLink& VarLink);

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp* Op, UProperty* Property, FSeqVarLink& VarLink);
};

class USeqVar_Named : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Named
    class UClass* ExpectedType;
    FName FindVarName;
    BITFIELD bStatusIsOk:1;
    //## END PROPS SeqVar_Named

    DECLARE_CLASS(USeqVar_Named,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	// SequenceVariable interface
	virtual FString GetValueStr();
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	// SeqVar_Named interface
	void UpdateStatus();
};

class USeqVar_Object : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Object
    class UObject* ObjValue;
    //## END PROPS SeqVar_Object

    DECLARE_CLASS(USeqVar_Object,USequenceVariable,0,Engine)
	virtual UObject** GetObjectRef( INT Idx )
	{
		if( Idx != 0 )
		{
			return NULL;
		}
		return &ObjValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),ObjValue!=NULL?*ObjValue->GetName():TEXT("???"));
	}

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UObjectProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UObjectProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_MusicTrack : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_MusicTrack
    struct FMusicTrackStruct MusicTrack;
    //## END PROPS SeqVar_MusicTrack

    DECLARE_CLASS(USeqVar_MusicTrack,USeqVar_Object,0,Engine)
	virtual UObject** GetObjectRef( INT Idx )
	{
		if( Idx != 0 )
		{
			return NULL;
		}
		return &ObjValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),ObjValue!=NULL?*ObjValue->GetName():TEXT("???"));
	}

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UObjectProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UObjectProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_MusicTrackBank : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_MusicTrackBank
    TArrayNoInit<struct FMusicTrackStruct> MusicTrackBank;
    //## END PROPS SeqVar_MusicTrackBank

    DECLARE_CLASS(USeqVar_MusicTrackBank,USeqVar_Object,0,Engine)
	virtual UObject** GetObjectRef( INT Idx )
	{
		if( Idx != 0 )
		{
			return NULL;
		}
		return &ObjValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),ObjValue!=NULL?*ObjValue->GetName():TEXT("???"));
	}

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UObjectProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UObjectProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_ObjectList : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectList
    TArrayNoInit<class UObject*> ObjList;
    //## END PROPS SeqVar_ObjectList

    DECLARE_CLASS(USeqVar_ObjectList,USeqVar_Object,0,Engine)
	virtual void OnCreated();

	// we need to see how to export arrays here, let's look at inventory
	virtual void OnExport();

	virtual UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr();


	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

};

class USeqVar_ObjectVolume : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectVolume
    FLOAT LastUpdateTime;
    TArrayNoInit<class UObject*> ContainedObjects;
    TArrayNoInit<class UClass*> ExcludeClassList;
    BITFIELD bCollidingOnly:1;
    //## END PROPS SeqVar_ObjectVolume

    DECLARE_CLASS(USeqVar_ObjectVolume,USeqVar_Object,0,Engine)
	virtual UObject** GetObjectRef(INT Idx);
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Player : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Player
    TArrayNoInit<class UObject*> Players;
    BITFIELD bAllPlayers:1;
    INT PlayerIdx;
    //## END PROPS SeqVar_Player

    DECLARE_CLASS(USeqVar_Player,USeqVar_Object,0,Engine)
	UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr()
	{
		if (!bAllPlayers)
		{
			return FString::Printf(TEXT("Player %d"),PlayerIdx);
		}
		else
		{
			return FString(TEXT("Player"));
		}
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_String : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_String
    FStringNoInit StrValue;
    //## END PROPS SeqVar_String

    DECLARE_CLASS(USeqVar_String,USequenceVariable,0,Engine)
	FString* GetStringRef()
	{
		return &StrValue;
	}

	FString GetValueStr()
	{
		return StrValue;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UStrProperty::StaticClass()));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_Union : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Union
    TArrayNoInit<class UClass*> SupportedVariableClasses;
    INT IntValue;
    INT BoolValue;
    FLOAT FloatValue;
    FStringNoInit StringValue;
    class UObject* ObjectValue;
    //## END PROPS SeqVar_Union

    DECLARE_CLASS(USeqVar_Union,USequenceVariable,0,Engine)
	virtual INT* GetIntRef();
	virtual UBOOL* GetBoolRef();
	virtual FLOAT* GetFloatRef();
	virtual FString* GetStringRef();
	virtual UObject** GetObjectRef( INT Idx );
	virtual FString GetValueStr();

	/**
	 * Union should never be used as the ExpectedType in a variable link, so it doesn't support any property classes.
	 */
	virtual UBOOL SupportsProperty(UProperty *Property);

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

	/**
	 * Allows the sequence variable to execute additional logic after copying values from the SequenceOp's members to the sequence variable.
	 *
	 * @param	SourceOp	the sequence op that contains the value that should be copied to this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PostPopulateValue( USequenceOp* SourceOp, FSeqVarLink& VarLink );
};

class USeqVar_Vector : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Vector
    FVector VectValue;
    //## END PROPS SeqVar_Vector

    DECLARE_CLASS(USeqVar_Vector,USequenceVariable,0,Engine)
	virtual FVector* GetVectorRef()
	{
		return &VectValue;
	}

	virtual FString GetValueStr()
	{
		return VectValue.ToString();
	}
};

class USeqAct_SetMusicTrack : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMusicTrack
    FName TrackBankName;
    //## END PROPS SeqAct_SetMusicTrack

    DECLARE_CLASS(USeqAct_SetMusicTrack,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_SetPhysics : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetPhysics
    BYTE newPhysics;
    //## END PROPS SeqAct_SetPhysics

    DECLARE_CLASS(USeqAct_SetPhysics,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetPhysics)
};

class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetRigidBodyIgnoreVehicles
    //## END PROPS SeqAct_SetRigidBodyIgnoreVehicles

    DECLARE_CLASS(USeqAct_SetRigidBodyIgnoreVehicles,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetRigidBodyIgnoreVehicles)
};

class USeqAct_SetSequenceVariable : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetSequenceVariable
    //## END PROPS SeqAct_SetSequenceVariable

    DECLARE_ABSTRACT_CLASS(USeqAct_SetSequenceVariable,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetSequenceVariable)
};

class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_ModifyObjectList
    INT ListEntriesCount;
    //## END PROPS SeqAct_ModifyObjectList

    DECLARE_CLASS(USeqAct_ModifyObjectList,USeqAct_SetSequenceVariable,0,Engine)
	/**
	* When a ModifyObjectList is Activated() it may do a number of things.
	* In each of those cases we make use of a helper function.
	**/
	void Activated();

private:
	void ActivatedAddRemove();
	void ActivateAddRemove_Helper( INT LinkNum );

public:
	/**
	* SeqAct_ModifyObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();

};

class USeqAct_SetBool : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetBool
    BITFIELD DefaultValue:1;
    //## END PROPS SeqAct_SetBool

    DECLARE_CLASS(USeqAct_SetBool,USeqAct_SetSequenceVariable,0,Engine)
	void Activated();
};

class USeqAct_SetFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetFloat
    FLOAT Target;
    FLOAT Value;
    //## END PROPS SeqAct_SetFloat

    DECLARE_CLASS(USeqAct_SetFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SetInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetInt
    INT Target;
    INT Value;
    //## END PROPS SeqAct_SetInt

    DECLARE_CLASS(USeqAct_SetInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SetObject : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetObject
    class UObject* DefaultValue;
    class UObject* Value;
    //## END PROPS SeqAct_SetObject

    DECLARE_CLASS(USeqAct_SetObject,USeqAct_SetSequenceVariable,0,Engine)
	virtual void Activated();
};

class USeqAct_SetString : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetString
    FStringNoInit Target;
    FStringNoInit Value;
    //## END PROPS SeqAct_SetString

    DECLARE_CLASS(USeqAct_SetString,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_Switch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Switch
    INT LinkCount;
    INT IncrementAmount;
    BITFIELD bLooping:1;
    BITFIELD bAutoDisableLinks:1;
    TArrayNoInit<INT> Indices;
    //## END PROPS SeqAct_Switch

    DECLARE_CLASS(USeqAct_Switch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChange(PropertyThatChanged);
	}

	virtual void Activated()
	{
		// activate each of the indices
		for (INT Idx = 0; Idx < Indices.Num(); Idx++)
		{
			INT ActiveIdx = Indices(Idx) - 1;
			if (ActiveIdx >= 0 &&
				ActiveIdx < OutputLinks.Num())
			{
				if (!OutputLinks(ActiveIdx).bDisabled && 
					!(OutputLinks(ActiveIdx).bDisabledPIE && GIsEditor))
				{
					OutputLinks(ActiveIdx).bHasImpulse = TRUE;
					if (bAutoDisableLinks)
					{
						OutputLinks(ActiveIdx).bDisabled = TRUE;
					}
				}
			}
			// increment the indices
			if (IncrementAmount != 0)
			{
				if (bLooping)
				{
					Indices(Idx) = 1 + ((Indices(Idx) - 1 + IncrementAmount) % OutputLinks.Num());
				}
				else
				{
					Indices(Idx) += IncrementAmount;
				}
			}
		}
	}

	virtual void UpdateObject()
	{
		// save the output links
		TArray<FSeqOpOutputLink> SavedOutputLinks = OutputLinks;
		Super::UpdateObject();
		OutputLinks.Empty();
		OutputLinks = SavedOutputLinks;
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
    //## BEGIN PROPS SeqAct_RandomSwitch
    //## END PROPS SeqAct_RandomSwitch

    DECLARE_CLASS(USeqAct_RandomSwitch,USeqAct_Switch,0,Engine)
	virtual void Activated()
	{
		// build a list of enabled links
		TArray<INT> ValidLinks;
		for (INT Idx = 0; Idx < OutputLinks.Num(); Idx++)
		{
			if (!OutputLinks(Idx).bDisabled && !(OutputLinks(Idx).bDisabledPIE && GIsEditor))
			{
				ValidLinks.AddItem(Idx);
			}
		}
		if (ValidLinks.Num() > 0)
		{
			// pick a random link to activate
			INT OutIdx = ValidLinks(appRand() % ValidLinks.Num());
			OutputLinks(OutIdx).bHasImpulse = TRUE;
			if (bAutoDisableLinks)
			{
				OutputLinks(OutIdx).bDisabled = TRUE;
			}
			// fill any variables attached
			for (INT Idx = 0; Idx < Indices.Num(); Idx++)
			{
				// offset by 1 for non-programmer friendliness
				Indices(Idx) = OutIdx + 1;
			}
		}
	}
};

class USeqAct_Timer : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Timer
    FLOAT ActivationTime;
    FLOAT Time;
    //## END PROPS SeqAct_Timer

    DECLARE_CLASS(USeqAct_Timer,USequenceAction,0,Engine)
	void Activated()
	{
		// reset the activation time
		Time = 0.f;
		ActivationTime = GWorld != NULL ? GWorld->GetTimeSeconds() : 0.f;
	}

	UBOOL UpdateOp(FLOAT DeltaTime)
	{
		// check for stop
		if (InputLinks(1).bHasImpulse)
		{
			// record the exact duration
			Time = GWorld != NULL ? GWorld->GetTimeSeconds() - ActivationTime : 0.f;
			// finish the op
			return TRUE;
		}
		else
		{
			// update the current time
			Time += DeltaTime;
			// and force any attached variables to get the new value
			PopulateLinkedVariableValues();
		}
		return FALSE;
	}
};

class USeqAct_Toggle : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Toggle
    //## END PROPS SeqAct_Toggle

    DECLARE_CLASS(USeqAct_Toggle,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_ToggleDynamicChannel : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ToggleDynamicChannel
    //## END PROPS SeqAct_ToggleDynamicChannel

    DECLARE_CLASS(USeqAct_ToggleDynamicChannel,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_Trace : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Trace
    BITFIELD bTraceActors:1;
    BITFIELD bTraceWorld:1;
    FVector TraceExtent;
    FVector StartOffset;
    FVector EndOffset;
    class UObject* HitObject;
    FLOAT Distance;
    //## END PROPS SeqAct_Trace

    DECLARE_CLASS(USeqAct_Trace,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void DeActivated()
	{
	}
};

class USequenceCondition : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceCondition
    //## END PROPS SequenceCondition

    DECLARE_ABSTRACT_CLASS(USequenceCondition,USequenceOp,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USequenceCondition)
};

class USeqCond_CompareBool : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareBool
    //## END PROPS SeqCond_CompareBool

    DECLARE_CLASS(USeqCond_CompareBool,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_CompareFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareFloat
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_CompareFloat

    DECLARE_CLASS(USeqCond_CompareFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareInt : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareInt
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_CompareInt

    DECLARE_CLASS(USeqCond_CompareInt,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareObject : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareObject
    //## END PROPS SeqCond_CompareObject

    DECLARE_CLASS(USeqCond_CompareObject,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_GetServerType : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_GetServerType
    //## END PROPS SeqCond_GetServerType

    DECLARE_CLASS(USeqCond_GetServerType,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_Increment : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_Increment
    INT IncrementAmount;
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_Increment

    DECLARE_CLASS(USeqCond_Increment,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IncrementFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IncrementFloat
    FLOAT IncrementAmount;
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_IncrementFloat

    DECLARE_CLASS(USeqCond_IncrementFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsInCombat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsInCombat
    //## END PROPS SeqCond_IsInCombat

    DECLARE_CLASS(USeqCond_IsInCombat,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SeqCond_IsLoggedIn_eventCheckLogins_Parms
{
    UBOOL ReturnValue;
    SeqCond_IsLoggedIn_eventCheckLogins_Parms(EEventParm)
    {
    }
};
class USeqCond_IsLoggedIn : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsLoggedIn
    INT NumNeededLoggedIn;
    //## END PROPS SeqCond_IsLoggedIn

    UBOOL eventCheckLogins()
    {
        SeqCond_IsLoggedIn_eventCheckLogins_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_CheckLogins),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(USeqCond_IsLoggedIn,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		// Trigger the output based upon meeting the num logged in criteria
		if (eventCheckLogins() == TRUE)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsSameTeam : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsSameTeam
    //## END PROPS SeqCond_IsSameTeam

    DECLARE_CLASS(USeqCond_IsSameTeam,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SeqCond_SwitchBase_eventRemoveValueEntry_Parms
{
    INT RemoveIndex;
    SeqCond_SwitchBase_eventRemoveValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventInsertValueEntry_Parms
{
    INT InsertIndex;
    SeqCond_SwitchBase_eventInsertValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventIsFallThruEnabled_Parms
{
    INT ValueIndex;
    UBOOL ReturnValue;
    SeqCond_SwitchBase_eventIsFallThruEnabled_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms
{
    SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms(EEventParm)
    {
    }
};
class USeqCond_SwitchBase : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_SwitchBase
    //## END PROPS SeqCond_SwitchBase

    void eventRemoveValueEntry(INT RemoveIndex)
    {
        SeqCond_SwitchBase_eventRemoveValueEntry_Parms Parms(EC_EventParm);
        Parms.RemoveIndex=RemoveIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveValueEntry),&Parms);
    }
    void eventInsertValueEntry(INT InsertIndex)
    {
        SeqCond_SwitchBase_eventInsertValueEntry_Parms Parms(EC_EventParm);
        Parms.InsertIndex=InsertIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertValueEntry),&Parms);
    }
    UBOOL eventIsFallThruEnabled(INT ValueIndex)
    {
        SeqCond_SwitchBase_eventIsFallThruEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ValueIndex=ValueIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsFallThruEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventVerifyDefaultCaseValue()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_VerifyDefaultCaseValue),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USeqCond_SwitchBase,USequenceCondition,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate ) PURE_VIRTUAL(USeqCond_SwitchBase::GetOutputLinksToActivate,return FALSE;);

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::FindCaseValueIndex,return INDEX_NONE;);

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const PURE_VIRTUAL(USeqCond_SwitchBase::GetSupportedValueCount,return 0;);

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::GetCaseValueString,return TEXT("NOT IMPLMENTED"););

	/* === USequenceOp interface === */
	/**
	 * Called when this sequence op is activated.  Determines which output link should be activated based on the value
	 * of the linked object var.
	 */
	virtual void Activated();
	virtual void UpdateDynamicLinks();

	/**
	 * Returns the color that should be used for an input, variable, or output link connector in the kismet editor.
	 *
	 * @param	ConnType	the type of connection this represents.  Valid values are:
	 *							LOC_INPUT		(input link)
	 *							LOC_OUTPUT		(output link)
	 *							LOC_VARIABLE	(variable link)
	 *							LOC_EVENT		(event link)
	 * @param	ConnIndex	the index [into the corresponding array (i.e. InputLinks, OutputLinks, etc.)] for the link
	 *						being queried.
	 * @param	MouseOverConnType
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  One of the values
	 *						listed for ConnType otherwise.
	 * @param	MouseOverConnIndex
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  The index for the
	 *						link being moused over otherwise.
	 */
	virtual FColor GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
};

struct FSwitchClassInfo
{
    FName ClassName;
    BYTE bFallThru;
};

class USeqCond_SwitchClass : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchClass
    TArrayNoInit<struct FSwitchClassInfo> ClassArray;
    //## END PROPS SeqCond_SwitchClass

    DECLARE_CLASS(USeqCond_SwitchClass,USeqCond_SwitchBase,0,Engine)
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FSwitchNameCase
{
    FName NameValue;
    BITFIELD bFallThru:1;
};

class USeqCond_SwitchName : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchName
    TArrayNoInit<struct FSwitchNameCase> SupportedValues;
    //## END PROPS SeqCond_SwitchName

    DECLARE_ABSTRACT_CLASS(USeqCond_SwitchName,USeqCond_SwitchBase,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FSwitchObjectCase
{
    class UObject* ObjectValue;
    BITFIELD bFallThru:1;
    BITFIELD bDefaultValue:1;
};

class USeqCond_SwitchObject : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchObject
    TArrayNoInit<struct FSwitchObjectCase> SupportedValues;
    class UClass* MetaClass;
    //## END PROPS SeqCond_SwitchObject

    DECLARE_CLASS(USeqCond_SwitchObject,USeqCond_SwitchBase,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FQueuedActivationInfo
{
    class AActor* InOriginator;
    class AActor* InInstigator;
    TArrayNoInit<INT> ActivateIndices;
    BITFIELD bPushTop:1;

    /** Constructors */
    FQueuedActivationInfo() {}
    FQueuedActivationInfo(EEventParm)
    {
        appMemzero(this, sizeof(FQueuedActivationInfo));
    }
};

struct SequenceEvent_eventToggled_Parms
{
    SequenceEvent_eventToggled_Parms(EEventParm)
    {
    }
};
struct SequenceEvent_eventRegisterEvent_Parms
{
    SequenceEvent_eventRegisterEvent_Parms(EEventParm)
    {
    }
};
class USequenceEvent : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceEvent
    class AActor* Originator;
    class AActor* Instigator;
    FLOAT ActivationTime;
    INT TriggerCount;
    INT MaxTriggerCount;
    FLOAT ReTriggerDelay;
    BITFIELD bEnabled:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bClientSideOnly:1;
    BYTE Priority GCC_BITFIELD_MAGIC;
    INT MaxWidth;
    BITFIELD bRegistered:1;
    TArrayNoInit<struct FQueuedActivationInfo> QueuedActivations;
    //## END PROPS SequenceEvent

    DECLARE_FUNCTION(execCheckActivate);
    void eventToggled()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Toggled),NULL);
    }
    void eventRegisterEvent()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RegisterEvent),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceEvent,USequenceOp,0,Engine)
	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();
	FIntPoint GetCenterPoint(FCanvas* Canvas);

	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	/**
	 * Adds an error message to the map check dialog if this SequenceEvent's EventActivator is bStatic
	 */
	virtual void CheckForErrors();

	/**
	 * This is a debug version of ActivateEvent which can be used by automated testing tools to Activate
	 * an event for testing purposes.
	 **/
	virtual void DebugActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL);

	virtual UBOOL RegisterEvent();
	virtual void DeActivated();
	virtual void PostDeActivated();

	/**
	 * Fills in the value of the "Instigator" VariableLink
	 */
	virtual void InitializeLinkedVariableValues();

	virtual void OnExport()
	{
		Super::OnExport();
		Originator = NULL;
		Instigator = NULL;
	}

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

protected:
	virtual void ActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL, UBOOL bPushTop = FALSE, UBOOL bFromQueued = FALSE);
};

class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_AISeeEnemy
    FLOAT MaxSightDistance;
    //## END PROPS SeqEvent_AISeeEnemy

    DECLARE_CLASS(USeqEvent_AISeeEnemy,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE)
	{
		if (InOriginator != NULL &&
			InInstigator != NULL &&
			(MaxSightDistance <= 0.f ||
			 (InOriginator->Location-InInstigator->Location).Size() <= MaxSightDistance))
		{
			return Super::CheckActivate(InOriginator,InInstigator,bTest,ActivateIndices, bPushTop);
		}
		else
		{
			return FALSE;
		}
	}
};

class USeqEvent_Console : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Console
    FName ConsoleEventName;
    FStringNoInit EventDesc;
    //## END PROPS SeqEvent_Console

    DECLARE_CLASS(USeqEvent_Console,USequenceEvent,0,Engine)
protected:
	FString GetCustomTitle() const;

public:
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ConstraintBroken
    //## END PROPS SeqEvent_ConstraintBroken

    DECLARE_CLASS(USeqEvent_ConstraintBroken,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_ConstraintBroken)
};

class USeqEvent_Destroyed : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Destroyed
    //## END PROPS SeqEvent_Destroyed

    DECLARE_CLASS(USeqEvent_Destroyed,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_Destroyed)
};

class USeqEvent_GetInventory : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_GetInventory
    //## END PROPS SeqEvent_GetInventory

    DECLARE_CLASS(USeqEvent_GetInventory,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_LevelBeginning : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelBeginning
    //## END PROPS SeqEvent_LevelBeginning

    DECLARE_CLASS(USeqEvent_LevelBeginning,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelBeginning)
};

class USeqEvent_LevelLoaded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelLoaded
    //## END PROPS SeqEvent_LevelLoaded

    DECLARE_CLASS(USeqEvent_LevelLoaded,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelLoaded)
};

class USeqEvent_LevelStartup : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelStartup
    //## END PROPS SeqEvent_LevelStartup

    DECLARE_CLASS(USeqEvent_LevelStartup,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelStartup)
};

class USeqEvent_Mover : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Mover
    FLOAT StayOpenTime;
    //## END PROPS SeqEvent_Mover

    DECLARE_CLASS(USeqEvent_Mover,USequenceEvent,0,Engine)
	virtual void OnCreated();
};

class USeqEvent_ProjectileLanded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ProjectileLanded
    FLOAT MaxDistance;
    //## END PROPS SeqEvent_ProjectileLanded

    DECLARE_CLASS(USeqEvent_ProjectileLanded,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_RemoteEvent : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RemoteEvent
    FName EventName;
    //## END PROPS SeqEvent_RemoteEvent

    DECLARE_CLASS(USeqEvent_RemoteEvent,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_RemoteEvent)
};

class USeqEvent_RigidBodyCollision : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RigidBodyCollision
    FLOAT MinCollisionVelocity;
    //## END PROPS SeqEvent_RigidBodyCollision

    DECLARE_CLASS(USeqEvent_RigidBodyCollision,USequenceEvent,0,Engine)
	void CheckRBCollisionActivate( const FRigidBodyCollisionInfo& OriginatorInfo, const FRigidBodyCollisionInfo& InstigatorInfo1,
					const TArray<FRigidBodyContactInfo>& ContactInfos, FLOAT VelMag );
};

class USeqEvent_SeeDeath : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SeeDeath
    //## END PROPS SeqEvent_SeeDeath

    DECLARE_CLASS(USeqEvent_SeeDeath,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SequenceActivated
    FStringNoInit InputLabel;
    //## END PROPS SeqEvent_SequenceActivated

    DECLARE_CLASS(USeqEvent_SequenceActivated,USequenceEvent,0,Engine)
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	UBOOL CheckActivate(UBOOL bTest = FALSE);
};

class USeqEvent_Touch : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Touch
    TArrayNoInit<class UClass*> ClassProximityTypes;
    BITFIELD bForceOverlapping:1;
    BITFIELD bUseInstigator:1;
    BITFIELD bAllowDeadPawns:1;
    TArrayNoInit<class AActor*> TouchedList;
    //## END PROPS SeqEvent_Touch

    DECLARE_FUNCTION(execCheckTouchActivate);
    DECLARE_FUNCTION(execCheckUnTouchActivate);
    DECLARE_CLASS(USeqEvent_Touch,USequenceEvent,0,Engine)
	virtual UBOOL CheckTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);
	virtual UBOOL CheckUnTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);

private:
	// hide the default implementation to force use of CheckTouchActivate/CheckUnTouchActivate
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_Used : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Used
    BITFIELD bAimToInteract:1;
    FLOAT InteractDistance;
    FStringNoInit InteractText;
    class UTexture2D* InteractIcon;
    //## END PROPS SeqEvent_Used

    DECLARE_CLASS(USeqEvent_Used,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

#endif // !INCLUDED_ENGINE_SEQUENCE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(USeqAct_CrossFadeMusicTracks,-1,execStopAllMusicManagerSounds);
AUTOGENERATE_FUNCTION(USeqAct_CrossFadeMusicTracks,-1,execClientSideCrossFadeTrackImmediately);
AUTOGENERATE_FUNCTION(USeqAct_CrossFadeMusicTracks,-1,execCrossFadeTrack);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execAddPlayerToDirectorTracks);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execSetPosition);
AUTOGENERATE_FUNCTION(USeqAct_Latent,-1,execAbortFor);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckUnTouchActivate);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckTouchActivate);
AUTOGENERATE_FUNCTION(USequence,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByClass);
AUTOGENERATE_FUNCTION(USequenceEvent,-1,execCheckActivate);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execScriptLog);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPublishLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPopulateLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execLinkedVariables);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetBoolVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetObjectVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetLinkedObjects);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execHasLinkedOps);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_SEQUENCE_NATIVE_DEFS
#define ENGINE_SEQUENCE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UInterpData);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActivateRemoteEvent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActorFactory);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ActorFactoryEx);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AIMoveToActor);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ApplySoundNode);
DECLARE_NATIVE_TYPE(Engine,USeqAct_AttachToEvent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CameraLookAt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CauseDamage);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CauseDamageRadial);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CommitMapChange);
DECLARE_NATIVE_TYPE(Engine,USeqAct_CrossFadeMusicTracks);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Delay);
DECLARE_NATIVE_TYPE(Engine,USeqAct_DelaySwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_FinishSequence);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ForceGarbageCollection);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ForceMaterialMipsResident);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Gate);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetDistance);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetProperty);
DECLARE_NATIVE_TYPE(Engine,USeqAct_GetVelocity);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Interp);
DECLARE_NATIVE_TYPE(Engine,USeqAct_IsInObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Latent);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelStreaming);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelStreamingBase);
DECLARE_NATIVE_TYPE(Engine,USeqAct_LevelVisibility);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Log);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ModifyObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqAct_MoveToActor);
DECLARE_NATIVE_TYPE(Engine,USeqAct_MultiLevelStreaming);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlayCameraAnim);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlayFaceFXAnim);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PlaySound);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Possess);
DECLARE_NATIVE_TYPE(Engine,USeqAct_PrepareMapChange);
DECLARE_NATIVE_TYPE(Engine,USeqAct_RandomSwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_RangeSwitch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetBlockRigidBody);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetBool);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetCameraTarget);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetDOFParams);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetFloat);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetInt);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMaterial);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstScalarParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstTexParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMatInstVectorParam);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMotionBlurParams);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetMusicTrack);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetObject);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetPhysics);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetRigidBodyIgnoreVehicles);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetSequenceVariable);
DECLARE_NATIVE_TYPE(Engine,USeqAct_SetString);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Switch);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Timer);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Toggle);
DECLARE_NATIVE_TYPE(Engine,USeqAct_ToggleDynamicChannel);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Trace);
DECLARE_NATIVE_TYPE(Engine,USeqAct_WaitForLevelsVisible);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareBool);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareFloat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareInt);
DECLARE_NATIVE_TYPE(Engine,USeqCond_CompareObject);
DECLARE_NATIVE_TYPE(Engine,USeqCond_GetServerType);
DECLARE_NATIVE_TYPE(Engine,USeqCond_Increment);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IncrementFloat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsInCombat);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsLoggedIn);
DECLARE_NATIVE_TYPE(Engine,USeqCond_IsSameTeam);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchBase);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchClass);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchName);
DECLARE_NATIVE_TYPE(Engine,USeqCond_SwitchObject);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_AISeeEnemy);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Console);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_ConstraintBroken);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Destroyed);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_GetInventory);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelBeginning);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelLoaded);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_LevelStartup);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Mover);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_ProjectileLanded);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_RemoteEvent);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_RigidBodyCollision);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_SeeDeath);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_SequenceActivated);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Touch);
DECLARE_NATIVE_TYPE(Engine,USeqEvent_Used);
DECLARE_NATIVE_TYPE(Engine,USequence);
DECLARE_NATIVE_TYPE(Engine,USequenceAction);
DECLARE_NATIVE_TYPE(Engine,USequenceCondition);
DECLARE_NATIVE_TYPE(Engine,USequenceEvent);
DECLARE_NATIVE_TYPE(Engine,USequenceFrame);
DECLARE_NATIVE_TYPE(Engine,USequenceFrameWrapped);
DECLARE_NATIVE_TYPE(Engine,USequenceObject);
DECLARE_NATIVE_TYPE(Engine,USequenceOp);
DECLARE_NATIVE_TYPE(Engine,USequenceVariable);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Bool);
DECLARE_NATIVE_TYPE(Engine,USeqVar_External);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Float);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Int);
DECLARE_NATIVE_TYPE(Engine,USeqVar_MusicTrack);
DECLARE_NATIVE_TYPE(Engine,USeqVar_MusicTrackBank);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Name);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Named);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Object);
DECLARE_NATIVE_TYPE(Engine,USeqVar_ObjectList);
DECLARE_NATIVE_TYPE(Engine,USeqVar_ObjectVolume);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Player);
DECLARE_NATIVE_TYPE(Engine,USeqVar_RandomFloat);
DECLARE_NATIVE_TYPE(Engine,USeqVar_RandomInt);
DECLARE_NATIVE_TYPE(Engine,USeqVar_String);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Union);
DECLARE_NATIVE_TYPE(Engine,USeqVar_Vector);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_SEQUENCE \
	UInterpData::StaticClass(); \
	USeqAct_ActivateRemoteEvent::StaticClass(); \
	USeqAct_ActorFactory::StaticClass(); \
	USeqAct_ActorFactoryEx::StaticClass(); \
	USeqAct_AIMoveToActor::StaticClass(); \
	USeqAct_ApplySoundNode::StaticClass(); \
	USeqAct_AttachToEvent::StaticClass(); \
	USeqAct_CameraLookAt::StaticClass(); \
	USeqAct_CauseDamage::StaticClass(); \
	USeqAct_CauseDamageRadial::StaticClass(); \
	USeqAct_CommitMapChange::StaticClass(); \
	USeqAct_CrossFadeMusicTracks::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_CrossFadeMusicTracksNative; \
	USeqAct_Delay::StaticClass(); \
	USeqAct_DelaySwitch::StaticClass(); \
	USeqAct_FinishSequence::StaticClass(); \
	USeqAct_ForceGarbageCollection::StaticClass(); \
	USeqAct_ForceMaterialMipsResident::StaticClass(); \
	USeqAct_Gate::StaticClass(); \
	USeqAct_GetDistance::StaticClass(); \
	USeqAct_GetProperty::StaticClass(); \
	USeqAct_GetVelocity::StaticClass(); \
	USeqAct_Interp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_InterpNative; \
	USeqAct_IsInObjectList::StaticClass(); \
	USeqAct_Latent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_LatentNative; \
	USeqAct_LevelStreaming::StaticClass(); \
	USeqAct_LevelStreamingBase::StaticClass(); \
	USeqAct_LevelVisibility::StaticClass(); \
	USeqAct_Log::StaticClass(); \
	USeqAct_ModifyObjectList::StaticClass(); \
	USeqAct_MoveToActor::StaticClass(); \
	USeqAct_MultiLevelStreaming::StaticClass(); \
	USeqAct_PlayCameraAnim::StaticClass(); \
	USeqAct_PlayFaceFXAnim::StaticClass(); \
	USeqAct_PlaySound::StaticClass(); \
	USeqAct_Possess::StaticClass(); \
	USeqAct_PrepareMapChange::StaticClass(); \
	USeqAct_RandomSwitch::StaticClass(); \
	USeqAct_RangeSwitch::StaticClass(); \
	USeqAct_SetBlockRigidBody::StaticClass(); \
	USeqAct_SetBool::StaticClass(); \
	USeqAct_SetCameraTarget::StaticClass(); \
	USeqAct_SetDOFParams::StaticClass(); \
	USeqAct_SetFloat::StaticClass(); \
	USeqAct_SetInt::StaticClass(); \
	USeqAct_SetMaterial::StaticClass(); \
	USeqAct_SetMatInstScalarParam::StaticClass(); \
	USeqAct_SetMatInstTexParam::StaticClass(); \
	USeqAct_SetMatInstVectorParam::StaticClass(); \
	USeqAct_SetMotionBlurParams::StaticClass(); \
	USeqAct_SetMusicTrack::StaticClass(); \
	USeqAct_SetObject::StaticClass(); \
	USeqAct_SetPhysics::StaticClass(); \
	USeqAct_SetRigidBodyIgnoreVehicles::StaticClass(); \
	USeqAct_SetSequenceVariable::StaticClass(); \
	USeqAct_SetString::StaticClass(); \
	USeqAct_Switch::StaticClass(); \
	USeqAct_Timer::StaticClass(); \
	USeqAct_Toggle::StaticClass(); \
	USeqAct_ToggleDynamicChannel::StaticClass(); \
	USeqAct_Trace::StaticClass(); \
	USeqAct_WaitForLevelsVisible::StaticClass(); \
	USeqCond_CompareBool::StaticClass(); \
	USeqCond_CompareFloat::StaticClass(); \
	USeqCond_CompareInt::StaticClass(); \
	USeqCond_CompareObject::StaticClass(); \
	USeqCond_GetServerType::StaticClass(); \
	USeqCond_Increment::StaticClass(); \
	USeqCond_IncrementFloat::StaticClass(); \
	USeqCond_IsInCombat::StaticClass(); \
	USeqCond_IsLoggedIn::StaticClass(); \
	USeqCond_IsSameTeam::StaticClass(); \
	USeqCond_SwitchBase::StaticClass(); \
	USeqCond_SwitchClass::StaticClass(); \
	USeqCond_SwitchName::StaticClass(); \
	USeqCond_SwitchObject::StaticClass(); \
	USeqEvent_AISeeEnemy::StaticClass(); \
	USeqEvent_Console::StaticClass(); \
	USeqEvent_ConstraintBroken::StaticClass(); \
	USeqEvent_Destroyed::StaticClass(); \
	USeqEvent_GetInventory::StaticClass(); \
	USeqEvent_LevelBeginning::StaticClass(); \
	USeqEvent_LevelLoaded::StaticClass(); \
	USeqEvent_LevelStartup::StaticClass(); \
	USeqEvent_Mover::StaticClass(); \
	USeqEvent_ProjectileLanded::StaticClass(); \
	USeqEvent_RemoteEvent::StaticClass(); \
	USeqEvent_RigidBodyCollision::StaticClass(); \
	USeqEvent_SeeDeath::StaticClass(); \
	USeqEvent_SequenceActivated::StaticClass(); \
	USeqEvent_Touch::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqEvent_TouchNative; \
	USeqEvent_Used::StaticClass(); \
	USequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceNative; \
	USequenceAction::StaticClass(); \
	USequenceCondition::StaticClass(); \
	USequenceEvent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceEventNative; \
	USequenceFrame::StaticClass(); \
	USequenceFrameWrapped::StaticClass(); \
	USequenceObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceObjectNative; \
	USequenceOp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceOpNative; \
	USequenceVariable::StaticClass(); \
	USeqVar_Bool::StaticClass(); \
	USeqVar_External::StaticClass(); \
	USeqVar_Float::StaticClass(); \
	USeqVar_Int::StaticClass(); \
	USeqVar_MusicTrack::StaticClass(); \
	USeqVar_MusicTrackBank::StaticClass(); \
	USeqVar_Name::StaticClass(); \
	USeqVar_Named::StaticClass(); \
	USeqVar_Object::StaticClass(); \
	USeqVar_ObjectList::StaticClass(); \
	USeqVar_ObjectVolume::StaticClass(); \
	USeqVar_Player::StaticClass(); \
	USeqVar_RandomFloat::StaticClass(); \
	USeqVar_RandomInt::StaticClass(); \
	USeqVar_String::StaticClass(); \
	USeqVar_Union::StaticClass(); \
	USeqVar_Vector::StaticClass(); \

#endif // ENGINE_SEQUENCE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(USeqAct_CrossFadeMusicTracks) GEngineUSeqAct_CrossFadeMusicTracksNatives[] = 
{ 
	MAP_NATIVE(USeqAct_CrossFadeMusicTracks,execStopAllMusicManagerSounds)
	MAP_NATIVE(USeqAct_CrossFadeMusicTracks,execClientSideCrossFadeTrackImmediately)
	MAP_NATIVE(USeqAct_CrossFadeMusicTracks,execCrossFadeTrack)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_CrossFadeMusicTracks);

NATIVE_INFO(USeqAct_Interp) GEngineUSeqAct_InterpNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Interp,execAddPlayerToDirectorTracks)
	MAP_NATIVE(USeqAct_Interp,execSetPosition)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_Interp);

NATIVE_INFO(USeqAct_Latent) GEngineUSeqAct_LatentNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Latent,execAbortFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_Latent);

NATIVE_INFO(USeqEvent_Touch) GEngineUSeqEvent_TouchNatives[] = 
{ 
	MAP_NATIVE(USeqEvent_Touch,execCheckUnTouchActivate)
	MAP_NATIVE(USeqEvent_Touch,execCheckTouchActivate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqEvent_Touch);

NATIVE_INFO(USequence) GEngineUSequenceNatives[] = 
{ 
	MAP_NATIVE(USequence,execSetEnabled)
	MAP_NATIVE(USequence,execFindSeqObjectsByClass)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequence);

NATIVE_INFO(USequenceEvent) GEngineUSequenceEventNatives[] = 
{ 
	MAP_NATIVE(USequenceEvent,execCheckActivate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceEvent);

NATIVE_INFO(USequenceObject) GEngineUSequenceObjectNatives[] = 
{ 
	MAP_NATIVE(USequenceObject,execGetWorldInfo)
	MAP_NATIVE(USequenceObject,execScriptLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceObject);

NATIVE_INFO(USequenceOp) GEngineUSequenceOpNatives[] = 
{ 
	MAP_NATIVE(USequenceOp,execPublishLinkedVariableValues)
	MAP_NATIVE(USequenceOp,execPopulateLinkedVariableValues)
	MAP_NATIVE(USequenceOp,execLinkedVariables)
	MAP_NATIVE(USequenceOp,execGetBoolVars)
	MAP_NATIVE(USequenceOp,execGetObjectVars)
	MAP_NATIVE(USequenceOp,execGetLinkedObjects)
	MAP_NATIVE(USequenceOp,execHasLinkedOps)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceOp);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,InterpData,InterpLength)
VERIFY_CLASS_OFFSET_NODIE(U,InterpData,EdSectionEnd)
VERIFY_CLASS_SIZE_NODIE(UInterpData)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActivateRemoteEvent,Instigator)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActivateRemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActivateRemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActorFactory,Factory)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ActorFactory,RemainingDelay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactory)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactoryEx)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AIMoveToActor)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ApplySoundNode,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ApplySoundNode,ApplyNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ApplySoundNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AttachToEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraLookAt,InterpSpeedRange)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CameraLookAt,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraLookAt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamage,DamageType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamage,Instigator)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CauseDamage)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamageRadial,DamageType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CauseDamageRadial,Instigator)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CauseDamageRadial)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CommitMapChange)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CrossFadeMusicTracks,TrackBankName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_CrossFadeMusicTracks,NextTrackToPlay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CrossFadeMusicTracks)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Delay,DefaultDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Delay,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Delay)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DelaySwitch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_DelaySwitch,NextLinkTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DelaySwitch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_FinishSequence,OutputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqAct_FinishSequence)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ForceGarbageCollection)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ForceMaterialMipsResident,ForceDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ForceMaterialMipsResident,ModifiedTextures)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ForceMaterialMipsResident)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Gate,AutoCloseCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Gate)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetDistance,Distance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetDistance)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetProperty,PropertyName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetProperty)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_GetVelocity,Velocity)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Interp,SavedActorTransforms)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Interp,ReplicatedActor)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Interp)
VERIFY_CLASS_SIZE_NODIE(USeqAct_IsInObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Latent,LatentActors)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Latent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelStreaming,Level)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelStreaming,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreaming)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreamingBase)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelVisibility,Level)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_LevelVisibility,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelVisibility)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Log,TargetDuration)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Log,TargetOffset)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Log)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_ModifyObjectList,ListEntriesCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyObjectList)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MoveToActor)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_MultiLevelStreaming,Levels)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiLevelStreaming)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayCameraAnim,CameraAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayCameraAnim,AnimTimeRemaining)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayCameraAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayFaceFXAnim,FaceFXAnimSetRef)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlayFaceFXAnim,FaceFXAnimName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayFaceFXAnim)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlaySound,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PlaySound,PitchMultiplier)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlaySound)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Possess,PawnToPossess)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Possess)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PrepareMapChange,MainLevelName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_PrepareMapChange,InitiallyLoadedSecondaryLevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PrepareMapChange)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RandomSwitch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_RangeSwitch,Ranges)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RangeSwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBlockRigidBody)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetCameraTarget,CameraTarget)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetCameraTarget)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetDOFParams,FalloffExponent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetDOFParams,OldFocusPosition)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetDOFParams)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetFloat,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetFloat,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetInt,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetInt,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMaterial,NewMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMaterial,MaterialIndex)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstScalarParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstScalarParam,ScalarValue)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstScalarParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstTexParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstTexParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstTexParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstVectorParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMatInstVectorParam,VectorValue)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstVectorParam)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMotionBlurParams,MotionBlurAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMotionBlurParams,OldMotionBlurAmount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMotionBlurParams)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetMusicTrack,TrackBankName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMusicTrack)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetObject,DefaultValue)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetObject,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetObject)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetPhysics,newPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetRigidBodyIgnoreVehicles)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetSequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetString,Target)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_SetString,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetString)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Switch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Switch,Indices)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Switch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Timer,ActivationTime)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Timer,Time)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Timer)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Toggle)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ToggleDynamicChannel)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Trace,TraceExtent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_Trace,Distance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Trace)
VERIFY_CLASS_OFFSET_NODIE(U,SeqAct_WaitForLevelsVisible,LevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_WaitForLevelsVisible)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareBool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_CompareInt,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareInt)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareObject)
VERIFY_CLASS_SIZE_NODIE(USeqCond_GetServerType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_Increment,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_Increment,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_Increment)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IncrementFloat,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IncrementFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IncrementFloat)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsInCombat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_IsLoggedIn,NumNeededLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsSameTeam)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchBase)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchClass,ClassArray)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchClass)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchName,SupportedValues)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchObject,SupportedValues)
VERIFY_CLASS_OFFSET_NODIE(U,SeqCond_SwitchObject,MetaClass)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchObject)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_AISeeEnemy,MaxSightDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AISeeEnemy)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Console,ConsoleEventName)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Console,EventDesc)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Console)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ConstraintBroken)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Destroyed)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_GetInventory)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelBeginning)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelLoaded)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelStartup)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Mover,StayOpenTime)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Mover)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_ProjectileLanded,MaxDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ProjectileLanded)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_RemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_RigidBodyCollision,MinCollisionVelocity)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RigidBodyCollision)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SeeDeath)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_SequenceActivated,InputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SequenceActivated)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Touch,ClassProximityTypes)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Touch,TouchedList)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Touch)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Used,InteractDistance)
VERIFY_CLASS_OFFSET_NODIE(U,SeqEvent_Used,InteractIcon)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Used)
VERIFY_CLASS_OFFSET_NODIE(U,Sequence,LogFile)
VERIFY_CLASS_OFFSET_NODIE(U,Sequence,DefaultViewZoom)
VERIFY_CLASS_SIZE_NODIE(USequence)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceAction,HandlerName)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceAction,Targets)
VERIFY_CLASS_SIZE_NODIE(USequenceAction)
VERIFY_CLASS_SIZE_NODIE(USequenceCondition)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceEvent,Originator)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceEvent,QueuedActivations)
VERIFY_CLASS_SIZE_NODIE(USequenceEvent)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceFrame,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceFrame,FillMaterial)
VERIFY_CLASS_SIZE_NODIE(USequenceFrame)
VERIFY_CLASS_SIZE_NODIE(USequenceFrameWrapped)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceObject,ObjClassVersion)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceObject,DrawHeight)
VERIFY_CLASS_SIZE_NODIE(USequenceObject)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceOp,InputLinks)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceOp,ActivateCount)
VERIFY_CLASS_SIZE_NODIE(USequenceOp)
VERIFY_CLASS_OFFSET_NODIE(U,SequenceVariable,VarName)
VERIFY_CLASS_SIZE_NODIE(USequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Bool,bValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Bool)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_External,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_External,VariableLabel)
VERIFY_CLASS_SIZE_NODIE(USeqVar_External)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Float,FloatValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Float)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Int,IntValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Int)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_MusicTrack,MusicTrack)
VERIFY_CLASS_SIZE_NODIE(USeqVar_MusicTrack)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_MusicTrackBank,MusicTrackBank)
VERIFY_CLASS_SIZE_NODIE(USeqVar_MusicTrackBank)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Name,NameValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Name)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Named,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Named,FindVarName)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Named)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Object,ObjValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Object)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectList,ObjList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectList)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectVolume,LastUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_ObjectVolume,ExcludeClassList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectVolume)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Player,Players)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Player,PlayerIdx)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Player)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomFloat,Min)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomFloat,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomFloat)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomInt,Min)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_RandomInt,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomInt)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_String,StrValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_String)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Union,SupportedVariableClasses)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Union,ObjectValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Union)
VERIFY_CLASS_OFFSET_NODIE(U,SeqVar_Vector,VectValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Vector)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
