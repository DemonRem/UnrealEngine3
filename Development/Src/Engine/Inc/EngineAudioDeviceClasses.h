/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2007 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_AUDIODEVICE_ENUMS
#define INCLUDED_ENGINE_AUDIODEVICE_ENUMS 1

enum ESoundMode
{
    SOUNDMODE_NORMAL        =0,
    SOUNDMODE_DEATH         =1,
    SOUNDMODE_COVER         =2,
    SOUNDMODE_ROADIE_RUN    =3,
    SOUNDMODE_TACCOM        =4,
    SOUNDMODE_RADIO         =5,
    SOUNDMODE_MAX           =6,
};

#endif // !INCLUDED_ENGINE_AUDIODEVICE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_AUDIODEVICE_CLASSES
#define INCLUDED_ENGINE_AUDIODEVICE_CLASSES 1

struct FListener
{
    class APortalVolume* PortalVolume;
    FVector Location;
    FVector Up;
    FVector Right;
    FVector Front;
};

struct FModeSettings
{
    BYTE Mode;
    FLOAT FadeTime;
};

struct FSoundGroupProperties
{
    FLOAT Volume;
    FLOAT VoiceCenterChannelVolume;
    FLOAT VoiceRadioVolume;
    BITFIELD bApplyEffects:1;
    BITFIELD bAlwaysPlay:1;
    BITFIELD bIsUISound:1;
    BITFIELD bIsMusic:1;
    BITFIELD bNoReverb:1;

		/** Interpolate the data in sound groups */
		void Interpolate( FLOAT InterpValue, FSoundGroupProperties& Start, FSoundGroupProperties& End );
	
};

struct FSoundGroup
{
    struct FSoundGroupProperties Properties;
    FName GroupName;
    TArrayNoInit<FName> ChildGroupNames;

    /** Constructors */
    FSoundGroup() {}
    FSoundGroup(EEventParm)
    {
        appMemzero(this, sizeof(FSoundGroup));
    }
};

struct FSoundGroupAdjuster
{
    FName GroupName;
    FLOAT VolumeAdjuster;
};

struct FSoundGroupEffect
{
    TArrayNoInit<struct FSoundGroupAdjuster> GroupEffect;

    /** Constructors */
    FSoundGroupEffect() {}
    FSoundGroupEffect(EEventParm)
    {
        appMemzero(this, sizeof(FSoundGroupEffect));
    }
};

class UAudioDevice : public USubsystem
{
public:
    //## BEGIN PROPS AudioDevice
    INT MaxChannels;
    BITFIELD UseEffectsProcessing:1;
    BITFIELD bGameWasTicking:1;
    BITFIELD bTestLowPassFilter:1;
    BITFIELD bTestEQFilter:1;
    TArrayNoInit<class UAudioComponent*> AudioComponents;
    TArrayNoInit<FSoundSource*> Sources;
    TArrayNoInit<FSoundSource*> FreeSources;
    TDynamicMap<FWaveInstance*, FSoundSource*> WaveInstanceSourceMap;
    TArrayNoInit<struct FListener> Listeners;
    QWORD CurrentTick;
    TMap<FName, INT> NameToSoundGroupIndexMap;
    TArrayNoInit<struct FSoundGroup> SourceSoundGroups;
    TArrayNoInit<struct FSoundGroup> CurrentSoundGroups;
    TArrayNoInit<struct FSoundGroup> DestinationSoundGroups;
    TArrayNoInit<struct FSoundGroup> SoundGroups;
    TArrayNoInit<struct FSoundGroupEffect> SoundGroupEffects;
    class FAudioEffectsManager* Effects;
    BYTE CurrentMode;
    DOUBLE SoundModeStartTime;
    DOUBLE SoundModeEndTime;
    class FTextToSpeech* TextToSpeech;
    //## END PROPS AudioDevice

    DECLARE_CLASS(UAudioDevice,USubsystem,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	friend class FSoundSource;

	/** Constructor */
	UAudioDevice( void ) {}

	/** 
	 * Basic initialisation of the platform agnostic layer of the audio system
	 */
	virtual UBOOL Init( void );

	/** 
	 * Stop all the audio components and sources
	 */
	virtual void Flush( void );

	/** 
	 * Complete the destruction of this class
	 */
	virtual void FinishDestroy( void );

	/** 
	 * Handle pausing/unpausing of sources when entering or leaving pause mode
	 */
	void HandlePause( UBOOL bGameTicking );

	/** 
	 * Iterate over the active AudioComponents for wave instances that could be playing
	 */
	INT GetSortedActiveWaveInstances( TArray<FWaveInstance*>& WaveInstances, UBOOL bGameTicking );

	/** 
	 * Stop sources that are no longer audible
	 */
	void StopSources( TArray<FWaveInstance*>& WaveInstances, INT FirstActiveIndex );

	/** 
	 * Start and/or update any sources that have a high enough priority to play
	 */
	void StartSources( TArray<FWaveInstance*>& WaveInstances, INT FirstActiveIndex, UBOOL bGameTicking );

	/** 
	 * The audio system's main "Tick" function
	 */
	virtual void Update( UBOOL bGameTicking );

	/** 
	 * Sets the listener's location and orientation for the viewport
	 */
	void SetListener( INT ViewportIndex, const FVector& Location, const FVector& Up, const FVector& Right, const FVector& Front );

	/**
	 * Stops all game sounds (and possibly UI) sounds
	 *
	 * @param bShouldStopUISounds If TRUE, this function will stop UI sounds as well
	 */
	virtual void StopAllSounds( UBOOL bShouldStopUISounds = FALSE );

	/**
	 * Pushes the specified reverb settings onto the reverb settings stack.
	 *
	 * @param	ReverbSettings		The reverb settings to use.
	 */
	void SetReverbSettings( const FReverbSettings& ReverbSettings );

	/**
	 * Frees the bulk resource data assocated with this SoundNodeWave.
	 *
	 * @param	SoundNodeWave	wave object to free associated bulk data
	 */
	virtual void FreeResource( USoundNodeWave* SoundNodeWave ) 
	{
	}

	/**
	 * Precaches the passed in sound node wave object.
	 *
	 * @param	SoundNodeWave	Resource to be precached.
	 */
	virtual void Precache( USoundNodeWave* SoundNodeWave ) 
	{
	}

	/** 
	 * Lists all the loaded sounds and their memory footprint
	 */
	virtual void ListSounds( FOutputDevice& Ar ) 
	{
	}

	/** 
	 * Lists a summary of loaded sound collated by group
	 */
	void ListSoundGroups( FOutputDevice& Ar );

	/**
	 * Set up the sound group hierarchy
	 */
	void InitSoundGroups( void );

	/**
	 * Returns the sound group properties associates with a sound group taking into account
	 * the group tree.
	 *
	 * @param	SoundGroupName	name of sound group to retrieve properties from
	 * @return	sound group properties if a sound group with name SoundGroupName exists, NULL otherwise
	 */
	FSoundGroupProperties* GetSoundGroupProperties( FName SoundGroupName );

	/**
	 * Returns an array of existing sound group names.
	 *
	 * @return array of sound group names
	 */
	TArray<FName> GetSoundGroupNames( void );

	/**
	 * Parses the sound groups and propagates multiplicative properties down the tree.
	 */
	void ParseSoundGroups( void );

	/** 
	 * Construct the CurrentSoundGroupProperties map
	 *
	 * This contains the original sound group properties propagated properly, and all adjustments due to the sound mode
	 */
	void GetCurrentSoundGroupState( void );

	/** 
	 * Gets the parameters for EQ based on settings and time
	 */
	void Interpolate( FLOAT InterpValue, FSoundGroupProperties& Current, FSoundGroupProperties& Start, FSoundGroupProperties& End );

	/** 
	 * Set the mode for altering sound group properties
	 */
	void SetSoundGroupMode( FModeSettings& ModeSettings );

	/** 
	 * Adds a component to the audio device
	 */
	void AddComponent( UAudioComponent* AudioComponent );

	/** 
	 * Removes an attached audio component
	 */
	void RemoveComponent( UAudioComponent* AudioComponent );

	/** 
	 * Creates an audio component to handle playing a sound cue
	 */
	static UAudioComponent* CreateComponent( USoundCue* SoundCue, FSceneInterface* Scene, AActor* Actor = NULL, UBOOL Play = TRUE, UBOOL bStopWhenOwnerDestroyed = FALSE, FVector* Location = NULL );

	/** 
	 * Exec
	 */
	UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Ar = *GLog );

	/** 
	 * PostEditChange
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/** 
	 * Serialize
	 */
	virtual void Serialize( FArchive& Ar );

	/** 
	 * Platform dependent call to init effect data on a sound source
	 */
	virtual void* InitEffect( FSoundSource* Source );

	/** 
	 * Platform dependent call to update the sound output with new parameters
	 */
	virtual void* UpdateEffect( FSoundSource* Source );

	/**
	 * Updates sound group volumes
	 */
	void SetGroupVolume( FName Group, FLOAT Volume );

	/**
	 * Sets a new sound mode and applies it to all appropriate sound groups - Must be defined per platform
	 */
	void SetSoundMode( ESoundMode NewSoundMode );

	/** 
	 * Return the pointer to the sound effects handler
	 */
	class FAudioEffectsManager* GetEffects( void ) 
	{ 
		return( Effects ); 
	}
	
	/** 
	 * Checks to see if a coordinate is within a distance of any listener
	 */
	UBOOL LocationIsAudible( FVector Location, FLOAT MaxDistance );

	/** 
	 * Checks to see if the low pass filter is being tested
	 */
	UBOOL IsTestingLowPassFilter( void ) const 
	{ 
		return( bTestLowPassFilter ); 
	}

	/** 
	 * Checks to see if the EQ filter is being tested
	 */
	UBOOL IsTestingEQFilter( void ) const 
	{ 
		return( bTestEQFilter ); 
	}

protected:
	/** Internal */
	void SortWaveInstances( INT MaxChannels );

	/**
	 * Internal helper function used by ParseSoundGroups to traverse the tree.
	 *
	 * @param CurrentGroup			Subtree to deal with
	 * @param ParentProperties		Propagated properties of parent node
	 */
	void RecurseIntoSoundGroups( FSoundGroup* CurrentGroup, FSoundGroupProperties* ParentProperties );
};

#endif // !INCLUDED_ENGINE_AUDIODEVICE_CLASSES
#endif // !NAMES_ONLY


#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_AUDIODEVICE_NATIVE_DEFS
#define ENGINE_AUDIODEVICE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UAudioDevice);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_AUDIODEVICE \
	UAudioDevice::StaticClass(); \

#endif // ENGINE_AUDIODEVICE_NATIVE_DEFS

#ifdef NATIVES_ONLY
#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,AudioDevice,MaxChannels)
VERIFY_CLASS_OFFSET_NODIE(U,AudioDevice,TextToSpeech)
VERIFY_CLASS_SIZE_NODIE(UAudioDevice)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
