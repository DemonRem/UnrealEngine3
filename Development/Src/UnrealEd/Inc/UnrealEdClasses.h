/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum EThumbnailBackgroundType
{
    TBT_None                =0,
    TBT_DefaultBackground   =1,
    TBT_SolidBackground     =2,
    TBT_MAX                 =3,
};
enum EThumbnailPrimType
{
    TPT_None                =0,
    TPT_Sphere              =1,
    TPT_Cube                =2,
    TPT_Plane               =3,
    TPT_Cylinder            =4,
    TPT_MAX                 =5,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UNREALED_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(CheckAreSettingsValid)
AUTOGENERATE_NAME(FetchDisplayName)
AUTOGENERATE_NAME(FetchRequiredKeyInTimes)
AUTOGENERATE_NAME(GenerateCurveData)

#ifndef NAMES_ONLY

class UAnimNodeEditInfo : public UObject
{
public:
    //## BEGIN PROPS AnimNodeEditInfo
    class UClass* AnimNodeClass;
    //## END PROPS AnimNodeEditInfo

    DECLARE_ABSTRACT_CLASS(UAnimNodeEditInfo,UObject,0,UnrealEd)
	virtual void OnDoubleClickNode(UAnimNode* InNode, class WxAnimTreeEditor* InEditor) {}
	virtual void OnCloseAnimTreeEditor() {}
	virtual UBOOL ShouldDrawWidget() { return FALSE; }
	virtual UBOOL IsRotationWidget() { return TRUE; }
	virtual FMatrix GetWidgetTM() { return FMatrix::Identity; }
	virtual void HandleWidgetDrag(const FQuat& DeltaQuat, const FVector& DeltaTranslate) {}
	virtual void Draw3DInfo(const FSceneView* View, FPrimitiveDrawInterface* PDI) {}
};

class UAnimNodeEditInfo_AimOffset : public UAnimNodeEditInfo
{
public:
    //## BEGIN PROPS AnimNodeEditInfo_AimOffset
    class WxAnimAimOffsetEditor* EditWindow;
    class UAnimNodeAimOffset* EditNode;
    //## END PROPS AnimNodeEditInfo_AimOffset

    DECLARE_CLASS(UAnimNodeEditInfo_AimOffset,UAnimNodeEditInfo,0,UnrealEd)
	virtual void OnDoubleClickNode(UAnimNode* InNode, class WxAnimTreeEditor* InEditor);
	virtual void OnCloseAnimTreeEditor();
	virtual UBOOL ShouldDrawWidget();
	virtual UBOOL IsRotationWidget();
	virtual FMatrix GetWidgetTM();
	virtual void HandleWidgetDrag(const FQuat& DeltaQuat, const FVector& DeltaTranslate);
	virtual void Draw3DInfo(const FSceneView* View, FPrimitiveDrawInterface* PDI);
};

struct FBrowserPaneInfo
{
    INT PaneID;
    FStringNoInit WxWindowClassName;
    FStringNoInit FriendlyName;
    INT CloneOfPaneID;
    INT CloneNumber;
    FPointer WxBrowserPtr;

    /** Constructors */
    FBrowserPaneInfo() {}
    FBrowserPaneInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBrowserPaneInfo));
    }
};

class UBrowserManager : public UObject
{
public:
    //## BEGIN PROPS BrowserManager
    TArrayNoInit<struct FBrowserPaneInfo> BrowserPanes;
    BITFIELD bHasCreatedPanes:1;
    INT LastSelectedPaneID;
    FPointer DockingContainerPtr;
    FPointer FloatingWindowsArrayPtr;
    FPointer BrowserMenuPtr;
    class UUISceneManager* UISceneManager;
    //## END PROPS BrowserManager

    DECLARE_CLASS(UBrowserManager,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    #include "UBrowserManager.h"
};

class UCascadeOptions : public UObject
{
public:
    //## BEGIN PROPS CascadeOptions
    BITFIELD bShowModuleDump:1;
    BITFIELD bUseSubMenus:1;
    BITFIELD bUseSpaceBarReset:1;
    BITFIELD bShowGrid:1;
    BITFIELD bShowParticleCounts:1;
    BITFIELD bShowParticleTimes:1;
    BITFIELD bShowParticleDistance:1;
    BITFIELD bShowFloor:1;
    FColor BackgroundColor;
    FColor Empty_Background;
    FColor Emitter_Background;
    FColor Emitter_Unselected;
    FColor Emitter_Selected;
    FColor ModuleColor_General_Unselected;
    FColor ModuleColor_General_Selected;
    FColor ModuleColor_TypeData_Unselected;
    FColor ModuleColor_TypeData_Selected;
    FColor ModuleColor_Beam_Unselected;
    FColor ModuleColor_Beam_Selected;
    FColor ModuleColor_Trail_Unselected;
    FColor ModuleColor_Trail_Selected;
    FColor GridColor_Hi;
    FColor GridColor_Low;
    FLOAT GridPerspectiveSize;
    FStringNoInit FloorMesh;
    FVector FloorPosition;
    FRotator FloorRotation;
    FLOAT FloorScale;
    FVector FloorScale3D;
    FStringNoInit PostProcessChainName;
    INT ShowPPFlags;
    //## END PROPS CascadeOptions

    DECLARE_CLASS(UCascadeOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UCascadeOptions)
};

class UCascadePreviewComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS CascadePreviewComponent
    class WxCascade* CascadePtr;
    //## END PROPS CascadePreviewComponent

    DECLARE_CLASS(UCascadePreviewComponent,UPrimitiveComponent,0,UnrealEd)
	virtual void Render(const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class ULensFlarePreviewComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LensFlarePreviewComponent
    class WxLensFlareEditor* LensFlareEditorPtr;
    //## END PROPS LensFlarePreviewComponent

    DECLARE_CLASS(ULensFlarePreviewComponent,UPrimitiveComponent,0,UnrealEd)
	virtual void Render(const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UAnimTreeEdSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS AnimTreeEdSkelComponent
    FPointer AnimTreeEdPtr;
    //## END PROPS AnimTreeEdSkelComponent

    DECLARE_CLASS(UAnimTreeEdSkelComponent,USkeletalMeshComponent,0,UnrealEd)
	// UPrimitiveComponent interface.
	virtual void Render(const FSceneView* View, class FPrimitiveDrawInterface* PDI);

	// USkeletalMeshComponent interface.
	virtual UBOOL LegLineCheck(const FVector& Start, const FVector& End, FVector& HitLocation, FVector& HitNormal);
};

class UASVSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS ASVSkelComponent
    FPointer AnimSetViewerPtr;
    BITFIELD bRenderRawSkeleton:1;
    //## END PROPS ASVSkelComponent

    DECLARE_CLASS(UASVSkelComponent,USkeletalMeshComponent,0,UnrealEd)
	// UPrimitiveComponent interface.
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class UFaceFXStudioSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS FaceFXStudioSkelComponent
    FPointer RenderWidgetUE3Ptr;
    //## END PROPS FaceFXStudioSkelComponent

    DECLARE_CLASS(UFaceFXStudioSkelComponent,USkeletalMeshComponent,0,UnrealEd)
	// UPrimitiveComponent interface.
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class UMaterialEditorSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS MaterialEditorSkeletalMeshComponent
    FPointer MaterialEditor;
    //## END PROPS MaterialEditorSkeletalMeshComponent

    DECLARE_CLASS(UMaterialEditorSkeletalMeshComponent,USkeletalMeshComponent,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UMaterialEditorSkeletalMeshComponent)
};

class UPhATSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS PhATSkeletalMeshComponent
    FPointer PhATPtr;
    TArrayNoInit<FMatrix> AnimationSpaceBases;
    //## END PROPS PhATSkeletalMeshComponent

    DECLARE_CLASS(UPhATSkeletalMeshComponent,USkeletalMeshComponent,0,UnrealEd)
	// UPrimitiveComponent interface.
	virtual void Render(const FSceneView* View, class FPrimitiveDrawInterface* PDI);
	virtual void RenderHitTest(const FSceneView* View,class FPrimitiveDrawInterface* PDI);

	/**
	 * Creates a proxy to represent the primitive to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// PhATSkeletalMeshComponent interface
	void RenderAssetTools(const FSceneView* View, class FPrimitiveDrawInterface* PDI, UBOOL bHitTest);
	void DrawHierarchy(FPrimitiveDrawInterface* PDI, UBOOL bAnimSkel);
};

class UMaterialEditorMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS MaterialEditorMeshComponent
    FPointer MaterialEditor;
    //## END PROPS MaterialEditorMeshComponent

    DECLARE_CLASS(UMaterialEditorMeshComponent,UStaticMeshComponent,0,UnrealEd)
protected:
	// ActorComponent interface.
	virtual void Attach();
	virtual void Detach();
};

class UStaticMeshEditorComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS StaticMeshEditorComponent
    class WxStaticMeshEditor* StaticMeshEditor;
    //## END PROPS StaticMeshEditorComponent

    DECLARE_CLASS(UStaticMeshEditorComponent,UStaticMeshComponent,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UStaticMeshEditorComponent)
};

class UCurveEdOptions : public UObject
{
public:
    //## BEGIN PROPS CurveEdOptions
    FLOAT MinViewRange;
    FLOAT MaxViewRange;
    FLinearColor BackgroundColor;
    FLinearColor LabelColor;
    FLinearColor SelectedLabelColor;
    FLinearColor GridColor;
    FLinearColor GridTextColor;
    FLinearColor LabelBlockBkgColor;
    FLinearColor SelectedKeyColor;
    //## END PROPS CurveEdOptions

    DECLARE_CLASS(UCurveEdOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UCurveEdOptions)
};

struct CurveEdPresetBase_eventGenerateCurveData_Parms
{
    TArray<FLOAT> RequiredKeyInTimes;
    TArray<struct FPresetGeneratedPoint> GeneratedPoints;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventGenerateCurveData_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms
{
    TArray<FLOAT> RequiredKeyInTimes;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventCheckAreSettingsValid_Parms
{
    UBOOL bIsSaving;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventCheckAreSettingsValid_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventFetchDisplayName_Parms
{
    FString OutName;
    CurveEdPresetBase_eventFetchDisplayName_Parms(EEventParm)
    {
    }
};
class UCurveEdPresetBase : public UObject
{
public:
    //## BEGIN PROPS CurveEdPresetBase
    //## END PROPS CurveEdPresetBase

    UBOOL eventGenerateCurveData(TArray<FLOAT>& RequiredKeyInTimes,TArray<struct FPresetGeneratedPoint>& GeneratedPoints)
    {
        CurveEdPresetBase_eventGenerateCurveData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.RequiredKeyInTimes=RequiredKeyInTimes;
        Parms.GeneratedPoints=GeneratedPoints;
        ProcessEvent(FindFunctionChecked(UNREALED_GenerateCurveData),&Parms);
        RequiredKeyInTimes=Parms.RequiredKeyInTimes;
        GeneratedPoints=Parms.GeneratedPoints;
        return Parms.ReturnValue;
    }
    UBOOL eventFetchRequiredKeyInTimes(TArray<FLOAT>& RequiredKeyInTimes)
    {
        CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.RequiredKeyInTimes=RequiredKeyInTimes;
        ProcessEvent(FindFunctionChecked(UNREALED_FetchRequiredKeyInTimes),&Parms);
        RequiredKeyInTimes=Parms.RequiredKeyInTimes;
        return Parms.ReturnValue;
    }
    UBOOL eventCheckAreSettingsValid(UBOOL bIsSaving)
    {
        CurveEdPresetBase_eventCheckAreSettingsValid_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.bIsSaving=bIsSaving ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(UNREALED_CheckAreSettingsValid),&Parms);
        return Parms.ReturnValue;
    }
    void eventFetchDisplayName(FString& OutName)
    {
        CurveEdPresetBase_eventFetchDisplayName_Parms Parms(EC_EventParm);
        Parms.OutName=OutName;
        ProcessEvent(FindFunctionChecked(UNREALED_FetchDisplayName),&Parms);
        OutName=Parms.OutName;
    }
    DECLARE_ABSTRACT_CLASS(UCurveEdPresetBase,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPresetBase)
};

class UCurveEdPreset_CosWave : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_CosWave
    FLOAT Frequency;
    FLOAT Scale;
    FLOAT Offset;
    //## END PROPS CurveEdPreset_CosWave

    DECLARE_CLASS(UCurveEdPreset_CosWave,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_CosWave)
};

class UCurveEdPreset_LinearDecay : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_LinearDecay
    FLOAT StartDecay;
    FLOAT StartValue;
    FLOAT EndDecay;
    FLOAT EndValue;
    //## END PROPS CurveEdPreset_LinearDecay

    DECLARE_CLASS(UCurveEdPreset_LinearDecay,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_LinearDecay)
};

class UCurveEdPreset_Nothing : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_Nothing
    //## END PROPS CurveEdPreset_Nothing

    DECLARE_CLASS(UCurveEdPreset_Nothing,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_Nothing)
};

class UCurveEdPreset_SineWave : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_SineWave
    FLOAT Frequency;
    FLOAT Scale;
    FLOAT Offset;
    //## END PROPS CurveEdPreset_SineWave

    DECLARE_CLASS(UCurveEdPreset_SineWave,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_SineWave)
};

class UCurveEdPreset_UserSet : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_UserSet
    class UCurveEdPresetCurve* UserCurve;
    //## END PROPS CurveEdPreset_UserSet

    DECLARE_CLASS(UCurveEdPreset_UserSet,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_UserSet)
};

struct FGenericBrowserTypeInfo
{
    class UClass* Class;
    FColor BorderColor;
    QWORD RequiredFlags;
    wxMenu* ContextMenu;
    class UGenericBrowserType* BrowserType;
    FPointer IsSupportedCallback;

	typedef UBOOL (*GenericBrowserSupportCallback)(UObject* Object);

	FGenericBrowserTypeInfo(
		UClass* InClass,
		const FColor& InBorderColor,
		wxMenu* InContextMenu,
		QWORD InRequiredFlags = 0,
		UGenericBrowserType* InBrowserType = NULL,
		GenericBrowserSupportCallback InIsSupportedCallback = NULL
	)
	:	Class(InClass)
	,	ContextMenu(InContextMenu)
	,	RequiredFlags(InRequiredFlags)
	,	BorderColor(InBorderColor)
	,	BrowserType(InBrowserType)
	,	IsSupportedCallback(InIsSupportedCallback)
	{}

	UBOOL Supports( UObject* Object ) const
	{
		UBOOL bResult = FALSE;
		if ( Object->IsA(Class) )
		{
			bResult = TRUE;
			if ( RequiredFlags != 0 )
			{
				bResult = Object->HasAllFlags(RequiredFlags);
			}
			if( bResult && IsSupportedCallback )
			{
				GenericBrowserSupportCallback Callback = (GenericBrowserSupportCallback) IsSupportedCallback;
				bResult = Callback( Object );
			}
		}
		return bResult;
	}

	inline UBOOL operator==( const FGenericBrowserTypeInfo& Other ) const
	{
		return ( Class == Other.Class && RequiredFlags == Other.RequiredFlags );
	}

};

class UGenericBrowserType : public UObject
{
public:
    //## BEGIN PROPS GenericBrowserType
    FStringNoInit Description;
    TArrayNoInit<struct FGenericBrowserTypeInfo> SupportInfo;
    FColor BorderColor;
    //## END PROPS GenericBrowserType

    DECLARE_ABSTRACT_CLASS(UGenericBrowserType,UObject,0,UnrealEd)
	/**
	 * @return Returns the browser type description string.
	 */
	const FString& GetBrowserTypeDescription() const
	{
		return Description;
	}

	FColor GetBorderColor( UObject* InObject );

	/**
	 * Does any initial set up that the type requires.
	 */
	virtual void Init() {}

	/**
	 * Checks to see if the specified class is handled by this type.
	 *
	 * @param	InObject	The object we need to check if we support
	 */
	UBOOL Supports( UObject* InObject );

	/**
	 * Creates a context menu specific to the type of object passed in.
	 *
	 * @param	InObject	The object we need the menu for
	 */
	wxMenu* GetContextMenu( UObject* InObject );

	/**
	 * Invokes the editor for an object.  The default behaviour is to
	 * open a property window for the object.  Dervied classes can override
	 * this with eg an editor which is specialized for the object's class.
	 *
	 * @param	InObject	The object to invoke the editor for.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject )
	{
		return ShowObjectProperties( InObject );
	}

	/**
	 * Opens a property window for the specified object.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * @param	InObject	The object to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( UObject* InObject );

	/**
	 * Opens a property window for the specified objects.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * @param	InObjects	The objects to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );

	/**
	 * Invokes the editor for all selected objects.
	 */
	virtual UBOOL ShowObjectEditor();

	/**
	 * Displays the object properties window for all selected objects that this
	 * GenericBrowserType supports.
	 */
	UBOOL ShowObjectProperties();

	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * @param InCommand		The command to execute
	 */

	virtual void InvokeCustomCommand( INT InCommand );

	/**
	 * Invokes a custom menu item command.
	 *
	 * @param InCommand		The command to execute
	 * @param InObject		The object to invoke the command against
	 */

	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject ) {}

	/**
	 * Calls the virtual "DoubleClick" function for each object
	 * of a supported class.
	 */

	virtual void DoubleClick();

	/**
	 * Allows each type to handle double clicking as they see fit.
	 */

	virtual void DoubleClick( UObject* InObject );

	/**
	 * Retrieves a list of objects supported by this browser type which
	 * are currently selected in the generic browser.
	 */
	void GetSelectedObjects( TArray<UObject*>& Objects );

	/**
	 * Determines whether the specified package is allowed to be saved.
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave );

protected:
	/**
	 * Determines whether the specified package is allowed to be saved.
	 *
	 * @param	PackageToSave		the package that is about to be saved
	 * @param	StandaloneObjects	a list of objects from PackageToSave which were marked RF_Standalone
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave, TArray<UObject*>& StandaloneObjects ) { return TRUE; }

public:
	/**
	 * Called when the user chooses to delete objects from the generic browser.  Gives the resource type the opportunity
	 * to perform any special logic prior to the delete.
	 *
	 * @param	ObjectToDelete	the object about to be deleted.
	 *
	 * @return	TRUE to allow the object to be deleted, FALSE to prevent the object from being deleted.
	 */
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete ) { return TRUE; }

	/**
	 * Called when the user chooses to delete objects from the generic browser, after the object has been checked for referencers.
	 * Gives the resource type the opportunity to perform any special logic after the delete.
	 *
	 * @param	ObjectToDelete		the object that was deleted.
	 * @param	bDeleteSuccessful	TRUE if the object wasn't referenced and was successfully marked for deletion.
	 */
	virtual void NotifyPostDeleteObject( UObject* ObjectToDelete, UBOOL bDeleteSuccessful ) {}
};

class UGenericBrowserType_Animation : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Animation
    //## END PROPS GenericBrowserType_Animation

    DECLARE_CLASS(UGenericBrowserType_Animation,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_AnimTree : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_AnimTree
    //## END PROPS GenericBrowserType_AnimTree

    DECLARE_CLASS(UGenericBrowserType_AnimTree,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_Archetype : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Archetype
    //## END PROPS GenericBrowserType_Archetype

    DECLARE_CLASS(UGenericBrowserType_Archetype,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_UIArchetype : public UGenericBrowserType_Archetype
{
public:
    //## BEGIN PROPS GenericBrowserType_UIArchetype
    class UUISceneManager* SceneManager;
    //## END PROPS GenericBrowserType_UIArchetype

    DECLARE_CLASS(UGenericBrowserType_UIArchetype,UGenericBrowserType_Archetype,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();

	/**
	 * Display the editor for the object specified.
	 *
	 * @param	InObject	the object to edit.  this should always be a UIPrefab which has the RF_ArchetypeObject flag set.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Called when the user chooses to delete objects from the generic browser.  Gives the resource type the opportunity
	 * to perform any special logic prior to the delete.
	 *
	 * @param	ObjectToDelete	the object about to be deleted.
	 *
	 * @return	TRUE to allow the object to be deleted, FALSE to prevent the object from being deleted.
	 */
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete );

protected:
	/**
	 * Determines whether the specified package is allowed to be saved.
	 *
	 * @param	PackageToSave		the package that is about to be saved
	 * @param	StandaloneObjects	a list of objects from PackageToSave which were marked RF_Standalone
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave, TArray<UObject*>& StandaloneObjects );

public:
};

class UGenericBrowserType_CameraAnim : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_CameraAnim
    //## END PROPS GenericBrowserType_CameraAnim

    DECLARE_CLASS(UGenericBrowserType_CameraAnim,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_CurveEdPresetCurve : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_CurveEdPresetCurve
    //## END PROPS GenericBrowserType_CurveEdPresetCurve

    DECLARE_CLASS(UGenericBrowserType_CurveEdPresetCurve,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();
};

class UGenericBrowserType_Custom : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Custom
    //## END PROPS GenericBrowserType_Custom

    DECLARE_CLASS(UGenericBrowserType_Custom,UGenericBrowserType,0,UnrealEd)
	/**
	 * Invokes the editor for all selected objects.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 */
	virtual UBOOL ShowObjectEditor();

	/**
	 * Invokes the editor for an object.  The default behaviour is to
	 * open a property window for the object.  Dervied classes can override
	 * this with eg an editor which is specialized for the object's class.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param	InObject	The object to invoke the editor for.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Opens a property window for the specified object.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param	InObject	The object to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );


	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param InCommand		The command to execute
	 */
	virtual void InvokeCustomCommand( INT InCommand );

	/**
	 * Calls the virtual "DoubleClick" function for each object
	 * of a supported class.
 	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 */
	virtual void DoubleClick();
};

class UGenericBrowserType_All : public UGenericBrowserType_Custom
{
public:
    //## BEGIN PROPS GenericBrowserType_All
    //## END PROPS GenericBrowserType_All

    DECLARE_CLASS(UGenericBrowserType_All,UGenericBrowserType_Custom,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_DecalMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_DecalMaterial
    //## END PROPS GenericBrowserType_DecalMaterial

    DECLARE_CLASS(UGenericBrowserType_DecalMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_FaceFXAnimSet : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_FaceFXAnimSet
    //## END PROPS GenericBrowserType_FaceFXAnimSet

    DECLARE_CLASS(UGenericBrowserType_FaceFXAnimSet,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_FaceFXAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_FaceFXAsset
    //## END PROPS GenericBrowserType_FaceFXAsset

    DECLARE_CLASS(UGenericBrowserType_FaceFXAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual UBOOL ShowObjectProperties( UObject* InObject );
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_Font : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Font
    //## END PROPS GenericBrowserType_Font

    DECLARE_CLASS(UGenericBrowserType_Font,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	/**
	 * Displays the font properties window for editing & importing/exporting of
	 * font pages
	 *
	 * @param InObject the object being edited
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_LensFlare : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_LensFlare
    //## END PROPS GenericBrowserType_LensFlare

    DECLARE_CLASS(UGenericBrowserType_LensFlare,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_Material : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Material
    //## END PROPS GenericBrowserType_Material

    DECLARE_CLASS(UGenericBrowserType_Material,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_MaterialInstanceConstant : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MaterialInstanceConstant
    //## END PROPS GenericBrowserType_MaterialInstanceConstant

    DECLARE_CLASS(UGenericBrowserType_MaterialInstanceConstant,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_MaterialInstanceTimeVarying : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MaterialInstanceTimeVarying
    //## END PROPS GenericBrowserType_MaterialInstanceTimeVarying

    DECLARE_CLASS(UGenericBrowserType_MaterialInstanceTimeVarying,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_MorphTargetSet : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MorphTargetSet
    //## END PROPS GenericBrowserType_MorphTargetSet

    DECLARE_CLASS(UGenericBrowserType_MorphTargetSet,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_MorphWeightSequence : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MorphWeightSequence
    //## END PROPS GenericBrowserType_MorphWeightSequence

    DECLARE_CLASS(UGenericBrowserType_MorphWeightSequence,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_ParticleSystem : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ParticleSystem
    //## END PROPS GenericBrowserType_ParticleSystem

    DECLARE_CLASS(UGenericBrowserType_ParticleSystem,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_PhysicalMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PhysicalMaterial
    //## END PROPS GenericBrowserType_PhysicalMaterial

    DECLARE_CLASS(UGenericBrowserType_PhysicalMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_PhysicsAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PhysicsAsset
    //## END PROPS GenericBrowserType_PhysicsAsset

    DECLARE_CLASS(UGenericBrowserType_PhysicsAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_PostProcess : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PostProcess
    //## END PROPS GenericBrowserType_PostProcess

    DECLARE_CLASS(UGenericBrowserType_PostProcess,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_Prefab : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Prefab
    //## END PROPS GenericBrowserType_Prefab

    DECLARE_CLASS(UGenericBrowserType_Prefab,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_Sequence : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Sequence
    //## END PROPS GenericBrowserType_Sequence

    DECLARE_CLASS(UGenericBrowserType_Sequence,UGenericBrowserType,0,UnrealEd)
	virtual void Init();

	/**
	 * Determines whether the specified object is a USequence class that should be handled by this generic browser type.
	 *
	 * @param	Object	a pointer to a USequence object.
	 *
	 * @return	TRUE if this generic browser type supports to object specified.
	 */
	static UBOOL IsSequenceTypeSupported( UObject* Object );
};

class UGenericBrowserType_SkeletalMesh : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SkeletalMesh
    //## END PROPS GenericBrowserType_SkeletalMesh

    DECLARE_CLASS(UGenericBrowserType_SkeletalMesh,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_Sounds : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Sounds
    //## END PROPS GenericBrowserType_Sounds

    DECLARE_CLASS(UGenericBrowserType_Sounds,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
	virtual void DoubleClick( UObject* InObject );

	void Play( USoundCue* InSound );
	void Play( USoundNode* InSound );	
	void Stop();
};

class UGenericBrowserType_SoundCue : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundCue
    //## END PROPS GenericBrowserType_SoundCue

    DECLARE_CLASS(UGenericBrowserType_SoundCue,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init( void );
};

class UGenericBrowserType_SoundWave : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundWave
    //## END PROPS GenericBrowserType_SoundWave

    DECLARE_CLASS(UGenericBrowserType_SoundWave,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init( void );
};

class UGenericBrowserType_SpeechRecognition : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SpeechRecognition
    //## END PROPS GenericBrowserType_SpeechRecognition

    DECLARE_CLASS(UGenericBrowserType_SpeechRecognition,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_SpeedTree : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SpeedTree
    //## END PROPS GenericBrowserType_SpeedTree

    DECLARE_CLASS(UGenericBrowserType_SpeedTree,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_StaticMesh : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_StaticMesh
    //## END PROPS GenericBrowserType_StaticMesh

    DECLARE_CLASS(UGenericBrowserType_StaticMesh,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_TerrainLayer : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TerrainLayer
    //## END PROPS GenericBrowserType_TerrainLayer

    DECLARE_CLASS(UGenericBrowserType_TerrainLayer,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_TerrainMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TerrainMaterial
    //## END PROPS GenericBrowserType_TerrainMaterial

    DECLARE_CLASS(UGenericBrowserType_TerrainMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_Texture : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Texture
    //## END PROPS GenericBrowserType_Texture

    DECLARE_CLASS(UGenericBrowserType_Texture,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_RenderTexture : public UGenericBrowserType_Texture
{
public:
    //## BEGIN PROPS GenericBrowserType_RenderTexture
    //## END PROPS GenericBrowserType_RenderTexture

    DECLARE_CLASS(UGenericBrowserType_RenderTexture,UGenericBrowserType_Texture,0,UnrealEd)
	virtual void Init();
	virtual void InvokeCustomCommand( INT InCommand, UObject* InObject );
};

class UGenericBrowserType_TextureWithAlpha : public UGenericBrowserType_Texture
{
public:
    //## BEGIN PROPS GenericBrowserType_TextureWithAlpha
    //## END PROPS GenericBrowserType_TextureWithAlpha

    DECLARE_CLASS(UGenericBrowserType_TextureWithAlpha,UGenericBrowserType_Texture,0,UnrealEd)
	virtual void Init();

	/**
	 * Returns TRUE if passed in UObject is a texture using an alpha channel.
	 *
	 * @param	Object	Object to check whether it's a texture utilizing an alpha channel
	 * @return TRUE if passed in UObject is a texture using an alpha channel, FALSE otherwise
	 */
	static UBOOL IsTextureWithAlpha( UObject* Object );
};

class UGenericBrowserType_UIScene : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_UIScene
    class UUISceneManager* SceneManager;
    //## END PROPS GenericBrowserType_UIScene

    DECLARE_CLASS(UGenericBrowserType_UIScene,UGenericBrowserType,0,UnrealEd)
	/* === GenericBrowserType interface === */
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();

	/**
	 * Display the editor for the object specified.
	 *
	 * @param	InObject	the object to edit.  this should always be a UIScene object.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Called when the user chooses to delete objects from the generic browser.  Gives the resource type the opportunity
	 * to perform any special logic prior to the delete.
	 *
	 * @param	ObjectToDelete	the object about to be deleted.
	 *
	 * @return	TRUE to allow the object to be deleted, FALSE to prevent the object from being deleted.
	 */
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete );

protected:
	/**
	 * Determines whether the specified package is allowed to be saved.
	 *
	 * @param	PackageToSave		the package that is about to be saved
	 * @param	StandaloneObjects	a list of objects from PackageToSave which were marked RF_Standalone
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave, TArray<UObject*>& StandaloneObjects );

public:
};

class UGenericBrowserType_UISkin : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_UISkin
    //## END PROPS GenericBrowserType_UISkin

    DECLARE_CLASS(UGenericBrowserType_UISkin,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();

	/**
	 * Display the editor for the object specified.
	 *
	 * @param	InObject	the object to edit.  this should always be a UISkin object.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UInterpEdOptions : public UObject
{
public:
    //## BEGIN PROPS InterpEdOptions
    TArrayNoInit<FInterpEdSelKey> SelectedKeys;
    //## END PROPS InterpEdOptions

    DECLARE_CLASS(UInterpEdOptions,UObject,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UInterpEdOptions)
};

class UInterpTrackHelper : public UObject
{
public:
    //## BEGIN PROPS InterpTrackHelper
    //## END PROPS InterpTrackHelper

    DECLARE_CLASS(UInterpTrackHelper,UObject,0,UnrealEd)
	/**
	 * @return Returns the actor for the group's track if one exists, NULL otherwise.
	 */
	virtual AActor* GetGroupActor() const;

	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param	Trackdef			Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @return	Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack ) const  { return true; }

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const { }

	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const { return true; }

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const { }
};

class UInterpTrackAnimControlHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackAnimControlHelper
    //## END PROPS InterpTrackAnimControlHelper

    DECLARE_CLASS(UInterpTrackAnimControlHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param	Trackdef			Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @return	Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;


	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackDirectorHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackDirectorHelper
    //## END PROPS InterpTrackDirectorHelper

    DECLARE_CLASS(UInterpTrackDirectorHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackEventHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackEventHelper
    //## END PROPS InterpTrackEventHelper

    DECLARE_CLASS(UInterpTrackEventHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackFaceFXHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackFaceFXHelper
    //## END PROPS InterpTrackFaceFXHelper

    DECLARE_CLASS(UInterpTrackFaceFXHelper,UInterpTrackHelper,0,UnrealEd)
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackFloatPropHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackFloatPropHelper
    //## END PROPS InterpTrackFloatPropHelper

    DECLARE_CLASS(UInterpTrackFloatPropHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param	Trackdef			Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @return	Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackSoundHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackSoundHelper
    //## END PROPS InterpTrackSoundHelper

    DECLARE_CLASS(UInterpTrackSoundHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackToggleHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackToggleHelper
    //## END PROPS InterpTrackToggleHelper

    DECLARE_CLASS(UInterpTrackToggleHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new keyframe.
	 * Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	 * Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyTime	The time that this Key becomes active.
	 * @return			Returns true if this key can be created and false if some 
	 *					criteria is not met (i.e. No related item selected in browser).
	 */
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/**
	 * Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	 */
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackVectorPropHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackVectorPropHelper
    //## END PROPS InterpTrackVectorPropHelper

    DECLARE_CLASS(UInterpTrackVectorPropHelper,UInterpTrackHelper,0,UnrealEd)
	/**
	 * Pops up a dialog letting user choose between a set of properties, then checks to see if that property has been bound to yet.
	 *
	 * @param PropNames		Possible property names to select from.
	 *
	 * @return TRUE if the property selected was acceptable, FALSE otherwise.
	 */
	virtual UBOOL ChooseProperty(TArray<FName> &PropNames) const;

	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param	Trackdef			Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @return	Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackColorPropHelper : public UInterpTrackVectorPropHelper
{
public:
    //## BEGIN PROPS InterpTrackColorPropHelper
    //## END PROPS InterpTrackColorPropHelper

    DECLARE_CLASS(UInterpTrackColorPropHelper,UInterpTrackVectorPropHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param	Trackdef			Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @return	Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

struct FKismetKeyBind
{
    FName Key;
    BITFIELD bControl:1;
    FName SeqObjClassName;
};

struct FKismetCommentPreset
{
    FName PresetName;
    INT BorderWidth;
    FColor BorderColor;
    BITFIELD bFilled:1;
    FColor FillColor;
};

class UKismetBindings : public UObject
{
public:
    //## BEGIN PROPS KismetBindings
    TArrayNoInit<struct FKismetKeyBind> Bindings;
    TArrayNoInit<struct FKismetCommentPreset> CommentPresets;
    //## END PROPS KismetBindings

    DECLARE_CLASS(UKismetBindings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UKismetBindings)
};

class ULensFlareEditorOptions : public UObject
{
public:
    //## BEGIN PROPS LensFlareEditorOptions
    FLinearColor LFED_BackgroundColor;
    FLinearColor LFED_Empty_Background;
    FLinearColor LFED_Source_ElementEd_Background;
    FLinearColor LFED_Source_Unselected;
    FLinearColor LFED_Source_Selected;
    FLinearColor LFED_ElementEd_Background;
    FLinearColor LFED_Element_Unselected;
    FLinearColor LFED_Element_Selected;
    BITFIELD bShowGrid:1;
    FColor GridColor_Hi;
    FColor GridColor_Low;
    FLOAT GridPerspectiveSize;
    FStringNoInit PostProcessChainName;
    INT ShowPPFlags;
    //## END PROPS LensFlareEditorOptions

    DECLARE_CLASS(ULensFlareEditorOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(ULensFlareEditorOptions)
};

struct FEditorVectorParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    FLinearColor ParameterValue;
};

struct FEditorScalarParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    FLOAT ParameterValue;
};

struct FEditorTextureParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    class UTexture* ParameterValue;
};

struct FEditorFontParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
};

struct FEditorStaticSwitchParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    BITFIELD ParameterValue:1;
    FGuid ExpressionId;

	/** Constructor */
	FEditorStaticSwitchParameterValue(const FStaticSwitchParameter& InParameter) :
		bOverride(InParameter.bOverride),
		ParameterName(InParameter.ParameterName),
		ParameterValue(InParameter.Value),
		ExpressionId(InParameter.ExpressionGUID)
	{
	}

};

struct FComponentMaskParameter
{
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;

	/** Constructor */
	FComponentMaskParameter(UBOOL InR, UBOOL InG, UBOOL InB, UBOOL InA) :
		R(InR),
		G(InG),
		B(InB),
		A(InA)
	{
	}

};

struct FEditorStaticComponentMaskParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    struct FComponentMaskParameter ParameterValue;
    FGuid ExpressionId;

	/** Constructor */
	FEditorStaticComponentMaskParameterValue(const FStaticComponentMaskParameter& InParameter) :
		bOverride(InParameter.bOverride),
		ParameterName(InParameter.ParameterName),
		ParameterValue(InParameter.R, InParameter.G, InParameter.B, InParameter.A),
		ExpressionId(InParameter.ExpressionGUID)
	{
	}

};

class UMaterialEditorInstanceConstant : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorInstanceConstant
    class UPhysicalMaterial* PhysMaterial;
    class UMaterialInterface* Parent;
    TArrayNoInit<struct FEditorVectorParameterValue> VectorParameterValues;
    TArrayNoInit<struct FEditorScalarParameterValue> ScalarParameterValues;
    TArrayNoInit<struct FEditorTextureParameterValue> TextureParameterValues;
    TArrayNoInit<struct FEditorFontParameterValue> FontParameterValues;
    TArrayNoInit<struct FEditorStaticSwitchParameterValue> StaticSwitchParameterValues;
    TArrayNoInit<struct FEditorStaticComponentMaskParameterValue> StaticComponentMaskParameterValues;
    class UMaterialInstanceConstant* SourceInstance;
    //## END PROPS MaterialEditorInstanceConstant

    DECLARE_CLASS(UMaterialEditorInstanceConstant,UObject,0,UnrealEd)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Regenerates the parameter arrays. */
	void RegenerateArrays();

	/** Copies the parameter array values back to the source instance. */
	void CopyToSourceInstance();

	/** Copies static parameters to the source instance, which will be marked dirty if a compile was necessary */
	void CopyStaticParametersToSourceInstance();

	/** 
	 * Sets the source instance for this object and regenerates arrays. 
	 *
	 * @param MaterialInterface		Instance to use as the source for this material editor instance.
	 */
	void SetSourceInstance(UMaterialInstanceConstant* MaterialInterface);
};

struct FEditorVectorParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    FLinearColor ParameterValue;
};

struct FEditorScalarParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    FLOAT ParameterValue;
    FInterpCurveFloat ParameterValueCurve;

    /** Constructors */
    FEditorScalarParameterValueOverTime() {}
    FEditorScalarParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorScalarParameterValueOverTime));
    }
};

struct FEditorTextureParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    class UTexture* ParameterValue;
};

struct FEditorFontParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
};

struct FEditorStaticSwitchParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    BITFIELD ParameterValue:1;
    FGuid ExpressionId;
};

struct FComponentMaskParameterOverTime
{
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
};

struct FEditorStaticComponentMaskParameterValueOverTime
{
    BITFIELD bOverride:1;
    FName ParameterName;
    struct FComponentMaskParameterOverTime ParameterValue;
    FGuid ExpressionId;
};

class UMaterialEditorInstanceTimeVarying : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorInstanceTimeVarying
    class UPhysicalMaterial* PhysMaterial;
    class UMaterialInterface* Parent;
    TArrayNoInit<struct FEditorVectorParameterValueOverTime> VectorParameterValues;
    TArrayNoInit<struct FEditorScalarParameterValueOverTime> ScalarParameterValues;
    TArrayNoInit<struct FEditorTextureParameterValueOverTime> TextureParameterValues;
    TArrayNoInit<struct FEditorFontParameterValueOverTime> FontParameterValues;
    TArrayNoInit<struct FEditorStaticSwitchParameterValueOverTime> StaticSwitchParameterValues;
    TArrayNoInit<struct FEditorStaticComponentMaskParameterValueOverTime> StaticComponentMaskParameterValues;
    class UMaterialInstanceTimeVarying* SourceInstance;
    //## END PROPS MaterialEditorInstanceTimeVarying

    DECLARE_CLASS(UMaterialEditorInstanceTimeVarying,UObject,0,UnrealEd)
	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Regenerates the parameter arrays. */
	void RegenerateArrays();

	/** Copies the parameter array values back to the source instance. */
	void CopyToSourceInstance();

	/** Copies static parameters to the source instance, which will be marked dirty if a compile was necessary */
	void CopyStaticParametersToSourceInstance();

	/** 
	 * Sets the source instance for this object and regenerates arrays. 
	 *
	 * @param MaterialInterface		Instance to use as the source for this material editor instance.
	 */
	void SetSourceInstance(UMaterialInstanceTimeVarying* MaterialInterface);
};

class UMaterialEditorOptions : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorOptions
    BITFIELD bShowGrid:1;
    BITFIELD bShowBackground:1;
    BITFIELD bHideUnusedConnectors:1;
    BITFIELD bDrawCurves:1;
    BITFIELD bRealtimeMaterialViewport:1;
    BITFIELD bRealtimeExpressionViewport:1;
    BITFIELD bAlwaysRefreshAllPreviews:1;
    //## END PROPS MaterialEditorOptions

    DECLARE_CLASS(UMaterialEditorOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UMaterialEditorOptions)
};

class UPhATSimOptions : public UObject
{
public:
    //## BEGIN PROPS PhATSimOptions
    class UAnimSet* PreviewAnimSet;
    FLOAT PhysicsBlend;
    BITFIELD bBlendOnPoke:1;
    FLOAT PokePauseTime;
    FLOAT PokeBlendTime;
    FLOAT AngularSpringScale;
    FLOAT AngularDampingScale;
    FLOAT SimSpeed;
    BITFIELD bDrawContacts:1;
    BITFIELD bPromptOnBoneDelete:1;
    BITFIELD bShowConstraintsAsPoints:1;
    BITFIELD bShowNamesInHierarchy:1;
    FLOAT FloorGap;
    FLOAT GravScale;
    FLOAT HandleLinearDamping;
    FLOAT HandleLinearStiffness;
    FLOAT HandleAngularDamping;
    FLOAT HandleAngularStiffness;
    FLOAT PokeStrength;
    FLOAT SkyBrightness;
    FLOAT Brightness;
    FLOAT AngularSnap;
    FLOAT LinearSnap;
    //## END PROPS PhATSimOptions

    DECLARE_CLASS(UPhATSimOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UPhATSimOptions)
};

class USequenceObjectHelper : public UObject
{
public:
    //## BEGIN PROPS SequenceObjectHelper
    //## END PROPS SequenceObjectHelper

    DECLARE_CLASS(USequenceObjectHelper,UObject,0,UnrealEd)
	/**
	 * Called when the user double clicks on a sequence object, can be used to display object specific
	 * property dialogs.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 * @param InObject	Pointer to the object that was clicked on.
	 */
	virtual void  OnDoubleClick( const class WxKismet* InEditor, USequenceObject* InObject ) const { }

	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const { }

	/**
	 * Called when the Kismet editor wants the object to add itself to a tree control.
	 *
	 * @param InEditor		Pointer to the editor that initiated the callback.
	 * @param InTreeCtrl	Pointer to the tree control we will be adding an item to.
	 * @param ParentItem	The parent of the item that will be added.
	 * @return				The tree item we created.
	 */
	virtual wxTreeItemId AddToTreeControl(  class WxKismet* InEditor, class wxTreeCtrl* InTreeCtrl, class wxTreeItemId& ParentItem ) const 
	{
		return wxTreeItemId();
	}
};

class UUIEvent_MetaObjectHelper : public USequenceObjectHelper
{
public:
    //## BEGIN PROPS UIEvent_MetaObjectHelper
    //## END PROPS UIEvent_MetaObjectHelper

    DECLARE_CLASS(UUIEvent_MetaObjectHelper,USequenceObjectHelper,0,UnrealEd)
	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
	 * This version displays a menu allowing the user to add or remove buttons from the process input event.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const;

	/**
	 * Called when the user double clicks on a sequence object, can be used to display object specific
	 * property dialogs.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 * @param InObject	Pointer to the object that was clicked on.
	 */
	virtual void  OnDoubleClick( const class WxKismet* InEditor, USequenceObject* InObject ) const;
};

class UUISequenceHelper : public USequenceObjectHelper
{
public:
    //## BEGIN PROPS UISequenceHelper
    //## END PROPS UISequenceHelper

    DECLARE_CLASS(UUISequenceHelper,USequenceObjectHelper,0,UnrealEd)
	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const;
};

class UUISequenceObjectHelper : public USequenceObjectHelper
{
public:
    //## BEGIN PROPS UISequenceObjectHelper
    //## END PROPS UISequenceObjectHelper

    DECLARE_CLASS(UUISequenceObjectHelper,USequenceObjectHelper,0,UnrealEd)
	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
     * This version shows a context menu specific to UI Kismet objects.
     *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const;
};

class USoundNodeHelper : public UObject
{
public:
    //## BEGIN PROPS SoundNodeHelper
    //## END PROPS SoundNodeHelper

    DECLARE_CLASS(USoundNodeHelper,UObject,0,UnrealEd)
	/**
	 * Called when the user double clicks on a sound node object, can be used to display node specific
	 * property dialogs.
	 *
	 * @param InEditor	Pointer to the sound cue editor that initiated the callback.
	 * @param InNode	Pointer to the sound node that was clicked on.
	 */
	virtual void  OnDoubleClick( const class WxSoundCueEditor* InEditor, USoundNode* InNode ) const { }
};

class UTerrainEditOptions : public UObject
{
public:
    //## BEGIN PROPS TerrainEditOptions
    INT Solid1_Strength;
    INT Solid1_Radius;
    INT Solid1_Falloff;
    INT Solid2_Strength;
    INT Solid2_Radius;
    INT Solid2_Falloff;
    INT Solid3_Strength;
    INT Solid3_Radius;
    INT Solid3_Falloff;
    INT Solid4_Strength;
    INT Solid4_Radius;
    INT Solid4_Falloff;
    INT Solid5_Strength;
    INT Solid5_Radius;
    INT Solid5_Falloff;
    INT Noisy1_Strength;
    INT Noisy1_Radius;
    INT Noisy1_Falloff;
    INT Noisy2_Strength;
    INT Noisy2_Radius;
    INT Noisy2_Falloff;
    INT Noisy3_Strength;
    INT Noisy3_Radius;
    INT Noisy3_Falloff;
    INT Noisy4_Strength;
    INT Noisy4_Radius;
    INT Noisy4_Falloff;
    INT Noisy5_Strength;
    INT Noisy5_Radius;
    INT Noisy5_Falloff;
    INT Current_Tool;
    INT Current_Brush;
    INT Current_Strength;
    INT Current_Radius;
    INT Current_Falloff;
    BITFIELD bSoftSelectEnabled:1;
    BITFIELD bConstrainedEditing:1;
    BITFIELD bShowFoliageMeshes:1;
    BITFIELD bShowDecoarationMeshes:1;
    INT Current_MirrorFlag;
    INT SliderRange_Low_Strength;
    INT SliderRange_High_Strength;
    INT SliderRange_Low_Radius;
    INT SliderRange_High_Radius;
    INT SliderRange_Low_Falloff;
    INT SliderRange_High_Falloff;
    FColor TerrainLayerBrowser_BackgroundColor;
    FColor TerrainLayerBrowser_BackgroundColor2;
    FColor TerrainLayerBrowser_BackgroundColor3;
    FColor TerrainLayerBrowser_SelectedColor;
    FColor TerrainLayerBrowser_SelectedColor2;
    FColor TerrainLayerBrowser_SelectedColor3;
    FColor TerrainLayerBrowser_BorderColor;
    //## END PROPS TerrainEditOptions

    DECLARE_CLASS(UTerrainEditOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UTerrainEditOptions)
};

class UThumbnailLabelRenderer : public UObject
{
public:
    //## BEGIN PROPS ThumbnailLabelRenderer
    //## END PROPS ThumbnailLabelRenderer

    DECLARE_ABSTRACT_CLASS(UThumbnailLabelRenderer,UObject,0,UnrealEd)
protected:
	/**
	 * Calculates the size the thumbnail labels will be for the specified font.
	 * Note: that this is a common method for handling lists of strings. The
	 * child class is resposible for building this list of strings.
	 *
	 * @param Labels the list of strings to write out as the labels
	 * @param Font the font object to render with
	 * @param Viewport the viewport that will be rendered into
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	void GetSizeFromLabels(const TArray<FString>& Labels,UFont* Font,
		FViewport* Viewport,FCanvas* Canvas,DWORD& OutWidth,
		DWORD& OutHeight);

	/**
	 * Renders the thumbnail labels for the specified object with the specified
	 * font and text color
	 * Note: that this is a common method for handling lists of strings. The
	 * child class is resposible for building this list of strings.
	 *
	 * @param Labels the list of strings to write out as the labels
	 * @param Font the font to draw with
	 * @param X the X location to start drawing at
	 * @param Y the Y location to start drawing at
	 * @param Viewport the viewport to draw into
	 * @param RI the render interface to draw with
	 * @param TextColor the color to draw the text with
	 */
	void DrawLabels(const TArray<FString>& Labels,UFont* Font,INT X,INT Y,
		FViewport* Viewport,FCanvas* Canvas,const FColor& TextColor);

public:
	/**
	 * Subclasses should implement this function to add to the list of labels
	 * for a given object.
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	virtual void BuildLabelList(UObject*,TArray<FString>&) PURE_VIRTUAL(UThumbnailLabelRenderer::BuildLabelList,);

	/**
	 * Calculates the size the thumbnail labels will be for the specified font
	 *
	 * @param Object the object the thumbnail is of
	 * @param Font the font object to render with
	 * @param Viewport the viewport that will be rendered into
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailLabelSize(UObject* Object,UFont* Font,
		FViewport* Viewport,FCanvas* Canvas,DWORD& OutWidth,
		DWORD& OutHeight);

	/**
	 * Renders the thumbnail labels for the specified object with the specified
	 * font and text color
	 *
	 * @param Object the object to render labels for
	 * @param Font the font to draw with
	 * @param X the X location to start drawing at
	 * @param Y the Y location to start drawing at
	 * @param Viewport the viewport to draw into
	 * @param RI the render interface to draw with
	 * @param TextColor the color to draw the text with
	 */
	virtual void DrawThumbnailLabels(UObject* Object,UFont* Font,INT X,INT Y,
		FViewport* Viewport,FCanvas* Canvas,
		const FColor& TextColor = FColor(255,255,255,255));
};

class UAnimSetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS AnimSetLabelRenderer
    //## END PROPS AnimSetLabelRenderer

    DECLARE_CLASS(UAnimSetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and anim set
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class UAnimTreeLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS AnimTreeLabelRenderer
    //## END PROPS AnimTreeLabelRenderer

    DECLARE_CLASS(UAnimTreeLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the anim tree
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class UGenericThumbnailLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS GenericThumbnailLabelRenderer
    //## END PROPS GenericThumbnailLabelRenderer

    DECLARE_CLASS(UGenericThumbnailLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and the friendly class name
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels)
	{
		new(OutLabels)FString(Object->GetName());
		new(OutLabels)FString(Object->GetDesc());
	}
};

class UMaterialInstanceLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS MaterialInstanceLabelRenderer
    //## END PROPS MaterialInstanceLabelRenderer

    DECLARE_CLASS(UMaterialInstanceLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the material.
	 *
	 * @param Object		The object to build the labels for.
	 * @param OutLabels		The array that is added to.
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class UMemCountThumbnailLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS MemCountThumbnailLabelRenderer
    class UThumbnailLabelRenderer* AggregatedLabelRenderer;
    //## END PROPS MemCountThumbnailLabelRenderer

    DECLARE_CLASS(UMemCountThumbnailLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and the amount of memory used to the array
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);

public:
	/**
	 * Calculates the size the thumbnail labels will be for the specified font.
	 * Doesn't serialize the object so that it's faster
	 *
	 * @param Object the object the thumbnail is of
	 * @param Font the font object to render with
	 * @param Viewport the viewport that will be rendered into
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailLabelSize(UObject* Object,UFont* Font,
		FViewport* Viewport,FCanvas* Canvas,DWORD& OutWidth,
		DWORD& OutHeight);
};

class UPhysicsAssetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS PhysicsAssetLabelRenderer
    //## END PROPS PhysicsAssetLabelRenderer

    DECLARE_CLASS(UPhysicsAssetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about bodies & constraints
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class UPostProcessLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS PostProcessLabelRenderer
    //## END PROPS PostProcessLabelRenderer

    DECLARE_CLASS(UPostProcessLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and anim set
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class USkeletalMeshLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS SkeletalMeshLabelRenderer
    //## END PROPS SkeletalMeshLabelRenderer

    DECLARE_CLASS(USkeletalMeshLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the mesh
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class USoundLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS SoundLabelRenderer
    //## END PROPS SoundLabelRenderer

    DECLARE_CLASS(USoundLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the sound/cue
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

class UStaticMeshLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS StaticMeshLabelRenderer
    //## END PROPS StaticMeshLabelRenderer

    DECLARE_CLASS(UStaticMeshLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the mesh
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object,TArray<FString>& OutLabels);
};

struct FThumbnailRenderingInfo
{
    FStringNoInit ClassNeedingThumbnailName;
    class UClass* ClassNeedingThumbnail;
    FStringNoInit RendererClassName;
    class UThumbnailRenderer* Renderer;
    FStringNoInit LabelRendererClassName;
    class UThumbnailLabelRenderer* LabelRenderer;
    FColor BorderColor;
    FStringNoInit IconName;

    /** Constructors */
    FThumbnailRenderingInfo() {}
    FThumbnailRenderingInfo(EEventParm)
    {
        appMemzero(this, sizeof(FThumbnailRenderingInfo));
    }
};

class UThumbnailManager : public UObject
{
public:
    //## BEGIN PROPS ThumbnailManager
    TArrayNoInit<struct FThumbnailRenderingInfo> RenderableThumbnailTypes;
    TArrayNoInit<struct FThumbnailRenderingInfo> ArchetypeRenderableThumbnailTypes;
    BITFIELD bIsInitialized:1;
    BITFIELD bMapNeedsUpdate:1;
    BITFIELD bPSysRealTime:1;
private:
    FPointer RenderInfoMap;
    TMap<UClass *,FThumbnailRenderingInfo *>* ArchetypeRenderInfoMap;
public:
    struct FThumbnailRenderingInfo NotSupported;
    class UStaticMeshComponent* BackgroundComponent;
    class UStaticMeshComponent* SMPreviewComponent;
    class USkeletalMeshComponent* SKPreviewComponent;
    class UStaticMesh* TexPropCube;
    class UStaticMesh* TexPropSphere;
    class UStaticMesh* TexPropCylinder;
    class UStaticMesh* TexPropPlane;
    class UMaterial* ThumbnailBackground;
    class UMaterial* ThumbnailBackgroundSolid;
    class UMaterialInstanceConstant* ThumbnailBackgroundSolidMatInst;
    //## END PROPS ThumbnailManager

    DECLARE_CLASS(UThumbnailManager,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	typedef TMap<UClass*,FThumbnailRenderingInfo*> FClassToRenderInfoMap;

protected:
	/**
	 * Returns the pointer to the map as a reference. Creates it if one isn't
	 * already instanced.
	 */
	inline FClassToRenderInfoMap& GetRenderInfoMap(void)
	{
		if (RenderInfoMap == NULL)
		{
			RenderInfoMap = (void*)new FClassToRenderInfoMap();
		}
		return *(FClassToRenderInfoMap*)RenderInfoMap;
	}

	inline FClassToRenderInfoMap& GetArchetypeRenderInfoMap(void)
	{
		if ( ArchetypeRenderInfoMap == NULL )
		{
			ArchetypeRenderInfoMap = new FClassToRenderInfoMap();
		}
		return *ArchetypeRenderInfoMap;
	}

public:
	/**
	 * Returns the component to use for rendering a background. Creates one
	 * if needed.
	 */
	inline UStaticMeshComponent* GetBackgroundComponent(void)
	{
		if (BackgroundComponent == NULL)
		{
			BackgroundComponent = ConstructObject<UStaticMeshComponent>(UStaticMeshComponent::StaticClass());;
		}
		return BackgroundComponent;
	}

	/**
	 * Returns the component to use for rendering a static mesh. Creates one
	 * if needed.
	 */
	inline UStaticMeshComponent* GetStaticMeshPreviewComponent(void)
	{
		if (SMPreviewComponent == NULL)
		{
			SMPreviewComponent = ConstructObject<UStaticMeshComponent>(UStaticMeshComponent::StaticClass());;
		}
		// Reset the static-mesh's CastShadow flag to its default value.
		SMPreviewComponent->CastShadow = TRUE;
		return SMPreviewComponent;
	}

	/**
	 * Returns the component to use for rendering a skeletal mesh. Creates one
	 * if needed.
	 */
	inline USkeletalMeshComponent* GetSkeletalMeshPreviewComponent(void)
	{
		if (SKPreviewComponent == NULL)
		{
			SKPreviewComponent = ConstructObject<USkeletalMeshComponent>(USkeletalMeshComponent::StaticClass());;
		}
		return SKPreviewComponent;
	}

	/**
	 * Clears cached components.
	 */
	void ClearComponents(void);

	/**
	 * Cleans up any allocations that won't be GCed (UObject interface)
	 */
	void FinishDestroy(void);

	/**
	 * Serializes any object renferences and sets the map needs update flag
	 *
	 * @param Ar the archive to serialize to/from
	 */
	void Serialize(FArchive& Ar);

	/**
	 * Fixes up any classes that need to be loaded in the thumbnail types
	 */
	void Initialize(void);

	/**
	 * Returns the entry for the specified object
	 *
	 * @param Object the object to find thumbnail rendering info for
	 *
	 * @return A pointer to the rendering info if valid, otherwise NULL
	 */
	FThumbnailRenderingInfo* GetRenderingInfo(UObject* Object);

protected:
	/**
	 * Fixes up any classes that need to be loaded in the thumbnail types per-map type
	 */
	void InitializeRenderTypeArray( TArray<struct FThumbnailRenderingInfo>& ThumbnailRendererTypes, FClassToRenderInfoMap& ThumbnailMap );
};

class UThumbnailRenderer : public UObject
{
public:
    //## BEGIN PROPS ThumbnailRenderer
    //## END PROPS ThumbnailRenderer

    DECLARE_ABSTRACT_CLASS(UThumbnailRenderer,UObject,0,UnrealEd)
	/**
	 * Allows the thumbnail renderer object the chance to reject rendering a
	 * thumbnail for an object based upon the object's data. For instance, an
	 * archetype should only be rendered if it's flags have RF_ArchetypeObject.
	 *
	 * @param Object			the object to inspect
	 * @param bCheckObjectState	TRUE indicates that the object's state should be inspected to determine whether it can be supported;
	 *							FALSE indicates that only the object's type should be considered (for caching purposes)
	 *
	 * @return TRUE if it needs a thumbnail, FALSE otherwise
	 */
	virtual UBOOL SupportsThumbnailRendering(UObject*,UBOOL bCheckObjectState=TRUE)
	{
		return TRUE;
	}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType the primitive type to use for rendering
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType PrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight) PURE_VIRTUAL(UThumbnailRenderer::GetThumbnailSize,);

	/**
	 * Draws a thumbnail for the object that was specified.
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType the primitive to draw on (sphere, plane, etc.)
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport the viewport being drawn in
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType PrimType,
		INT X,INT Y,DWORD Width,DWORD Height,FViewport* Viewport,
		FCanvas* Canvas,EThumbnailBackgroundType BackgroundType) PURE_VIRTUAL(UThumbnailRenderer::Draw,);
};

class UDefaultSizedThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS DefaultSizedThumbnailRenderer
    INT DefaultSizeX;
    INT DefaultSizeY;
    //## END PROPS DefaultSizedThumbnailRenderer

    DECLARE_ABSTRACT_CLASS(UDefaultSizedThumbnailRenderer,UThumbnailRenderer,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level.
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);
};

class UMaterialInstanceThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS MaterialInstanceThumbnailRenderer
    //## END PROPS MaterialInstanceThumbnailRenderer

    DECLARE_CLASS(UMaterialInstanceThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class USkeletalMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS SkeletalMeshThumbnailRenderer
    //## END PROPS SkeletalMeshThumbnailRenderer

    DECLARE_CLASS(USkeletalMeshThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UStaticMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS StaticMeshThumbnailRenderer
    //## END PROPS StaticMeshThumbnailRenderer

    DECLARE_CLASS(UStaticMeshThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UIconThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS IconThumbnailRenderer
    FStringNoInit IconName;
    class UTexture2D* Icon;
    //## END PROPS IconThumbnailRenderer

    DECLARE_CLASS(UIconThumbnailRenderer,UThumbnailRenderer,0,UnrealEd)
protected:
	/**
	 * Returns the icon for this icon renderer instance. Loads it if it
	 * isn't already loaded
	 *
	 * @param A valid icon or the default texture if it couldn't be loaded
	 */
	inline UTexture2D* GetIcon(void)
	{
		// If this hasn't been loaded yet, load it
		if (Icon == NULL)
		{
			Icon = LoadObject<UTexture2D>(NULL,*IconName,NULL,LOAD_None,NULL);
			// Just in case the resource is bogus, check and return the default
			if (Icon == NULL)
			{
				Icon = GWorld->GetWorldInfo()->DefaultTexture;
			}
		}
		return Icon;
	}

public:
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight)
	{
		OutWidth = appTrunc(Zoom * (FLOAT)GetIcon()->SizeX);
		OutHeight = appTrunc(Zoom * (FLOAT)GetIcon()->SizeY);
	}

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UArchetypeThumbnailRenderer : public UIconThumbnailRenderer
{
public:
    //## BEGIN PROPS ArchetypeThumbnailRenderer
    //## END PROPS ArchetypeThumbnailRenderer

    DECLARE_CLASS(UArchetypeThumbnailRenderer,UIconThumbnailRenderer,0,UnrealEd)
	/**
	 * Allows the thumbnail renderer object the chance to reject rendering a
	 * thumbnail for an object based upon the object's data. For instance, an
	 * archetype should only be rendered if it's flags have RF_ArchetypeObject.
	 *
	 * @param Object 			the object to inspect
	 * @param bCheckObjectState	TRUE indicates that the object's state should be inspected to determine whether it can be supported;
	 *							FALSE indicates that only the object's type should be considered (for caching purposes)
	 *
	 * @return TRUE if it needs a thumbnail, FALSE otherwise
	 */
	virtual UBOOL SupportsThumbnailRendering(UObject* Object,UBOOL bCheckObjectState=TRUE);
};

class UPrefabThumbnailRenderer : public UIconThumbnailRenderer
{
public:
    //## BEGIN PROPS PrefabThumbnailRenderer
    //## END PROPS PrefabThumbnailRenderer

    DECLARE_CLASS(UPrefabThumbnailRenderer,UIconThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UUISceneThumbnailRenderer : public UIconThumbnailRenderer
{
public:
    //## BEGIN PROPS UISceneThumbnailRenderer
    //## END PROPS UISceneThumbnailRenderer

    DECLARE_CLASS(UUISceneThumbnailRenderer,UIconThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UTextureThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS TextureThumbnailRenderer
    //## END PROPS TextureThumbnailRenderer

    DECLARE_CLASS(UTextureThumbnailRenderer,UThumbnailRenderer,0,UnrealEd)
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UFontThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS FontThumbnailRenderer
    //## END PROPS FontThumbnailRenderer

    DECLARE_CLASS(UFontThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class ULensFlareThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS LensFlareThumbnailRenderer
    class UTexture2D* NoImage;
    class UTexture2D* OutOfDate;
    //## END PROPS LensFlareThumbnailRenderer

    DECLARE_CLASS(ULensFlareThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UParticleSystemThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS ParticleSystemThumbnailRenderer
    class UTexture2D* NoImage;
    class UTexture2D* OutOfDate;
    //## END PROPS ParticleSystemThumbnailRenderer

    DECLARE_CLASS(UParticleSystemThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UTextureCubeThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS TextureCubeThumbnailRenderer
    //## END PROPS TextureCubeThumbnailRenderer

    DECLARE_CLASS(UTextureCubeThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level.
	 * Grabs the texture from the first face of the cube map
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 * Grabs the texture from the first face of the cube map
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param RI the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FViewport*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType);
};

class UEditorUISceneClient : public UUISceneClient
{
public:
    //## BEGIN PROPS EditorUISceneClient
    class UUIScene* Scene;
    class UUISceneManager* SceneManager;
    class WxUIEditorBase* SceneWindow;
    class FCanvasScene* ClientCanvasScene;
    BITFIELD bIsUIPrimitiveSceneInitialized:1;
    //## END PROPS EditorUISceneClient

    DECLARE_CLASS(UEditorUISceneClient,UUISceneClient,0|CLASS_Transient,UnrealEd)
	/* =======================================
		UUISceneClient interface
	======================================= */
	/** Default constructor */
	UEditorUISceneClient();

	/**
	 * Retrieves the virtual offset for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 * Non-zero when the user has panned or zoomed the UI editor such that the 0,0 viewport position is no longer the same
	 * as the 0,0 canvas location.
	 *
	 * @param	out_ViewportOffset	[out] will be filled in with the delta between the viewport's actual origin and virtual origin.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOffset( const UUIScene* Scene, FVector2D& out_ViewportOffset );

	/**
	 * Retrieves the scale factor for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 */
	virtual FLOAT GetViewportScale( const UUIScene* Scene ) const;

	/**
	 * Retrieves the virtual point of origin for the viewport that renders the specified scene
	 *
	 * In the game, this will be non-zero if Scene is for split-screen and isn't for the first player.
	 * In the editor, this will be equal to the value of the gutter region around the viewport.
	 *
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the virtual origin point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin );

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen();

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin, then propagates the call
	 * to all child editors.
	 */
	virtual void OnActiveSkinChanged();

	/**
	 * Called when user opens the specified scene for editing.  Creates the editor window, initializes the scene's state,
	 * and converts it into "editing" mode.
	 *
	 * @param	Scene			the scene to open
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( class UUIScene* Scene, class ULocalPlayer* UnusedPlayer=NULL, class UUIScene** UnusedScene=NULL );

	/**
	 * Called when a scene editing window is closed. Returns the scene to a stable "resource-only" state.
	 *
	 * @param	Scene	the scene to deactivate
	 *
	 * @return true if the scene was successfully uninitialized
	 */
	virtual UBOOL CloseScene( class UUIScene* Scene );

	/**
	 * Generates a thumbnail for the scene using the current viewport image.
	 *
	 * @param	Scene	the scene to generate a thumbnail for.
	 *
	 */
	virtual void GenerateSceneThumbnail( class UUIScene* Scene );

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/**
	 * Renders the scene associated with this scene client.
	 */
	virtual void RenderScenes( FCanvas* Canvas );

	/**
	 * Returns if this UI requires a CanvasScene for rendering 3D primitives
	 *
	 * @return TRUE if 3D primitives are used
	 */
	virtual UBOOL UsesUIPrimitiveScene() const;

	/**
	 * Returns the internal CanvasScene that may be used by this UI
	 *
	 * @return canvas scene or NULL
	 */
	virtual class FCanvasScene* GetUIPrimitiveScene();

	/**
	 * Detaches and cleans up the ClientCanvasScene.
	 */
	virtual void DetachUIPrimitiveScene();

	/**
	 * Determine if the canvas scene for primitive rendering needs to be initialized
	 *
	 * @return TRUE if InitUIPrimitiveScene should be called
	 */
	virtual UBOOL NeedsInitUIPrimitiveScene();

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( class UUIScene* Sender );

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=0 ) const;

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const class UUIScene* Scene ) const;

	/* =======================================
		UEditorUISceneClient interface
	======================================= */

	/**
	 * Called when a scene is about to be deleted in the generic browser.  Closes any open editor windows for this scene
	 * and clears all references.
	 *
	 * @param	Scene	the scene being deleted
	 */
	void NotifyDeleteScene();

	/* === FCallbackEventDevice interface === */
	/**
	 * Called when the viewport has been resized.
	 */
	virtual void Send( ECallbackEventType InType, class FViewport* InViewport, UINT InMessage);

	/* ==============================================
		FExec interface
	============================================== */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* ==============================================
		UObject interface
	============================================== */
	/**
	 * Called to finish destroying the object.
	 */
	virtual void FinishDestroy();
};

struct FUIResourceInfo
{
    class UObject* UIResource;
    FString FriendlyName;

	/** Constructors */
	FUIResourceInfo( UObject* InResource )
	: UIResource(InResource)
	{
		checkSlow(UIResource);
		if ( !UIResource->HasAnyFlags(RF_ClassDefaultObject) )
		{
			FriendlyName = FString::Printf(TEXT("%s (%s)"), *UIResource->GetClass()->GetDescription(), *UIResource->GetName());
		}
		else
		{
			FriendlyName = UIResource->GetClass()->GetDescription();
		}
	}
	/** Copy Constructor */
	FUIResourceInfo( const FUIResourceInfo& Other )
	: UIResource(Other.UIResource), FriendlyName(Other.FriendlyName)
	{
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIResourceInfo& Other ) const
	{
		return UIResource == Other.UIResource;
	}
	FORCEINLINE UBOOL operator!=( const FUIResourceInfo& Other ) const
	{
		return UIResource != Other.UIResource;
	}

};

struct FUIObjectResourceInfo : public FUIResourceInfo
{

	/** Constructors */
	FUIObjectResourceInfo( class UUIObject* InResource );
	/** Copy Constructor */
	FUIObjectResourceInfo( const FUIObjectResourceInfo& Other )
	: FUIResourceInfo(Other)
	{
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIObjectResourceInfo& Other ) const
	{
		return UIResource == Other.UIResource;
	}
	FORCEINLINE UBOOL operator!=( const FUIObjectResourceInfo& Other ) const
	{
		return UIResource != Other.UIResource;
	}

};

struct FUIStyleResourceInfo : public FUIResourceInfo
{

	/** Constructors */
	FUIStyleResourceInfo( class UUIStyle_Data* InResource );
	/** Copy Constructor */
	FUIStyleResourceInfo( const FUIStyleResourceInfo& Other )
	: FUIResourceInfo(Other)
	{
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIStyleResourceInfo& Other ) const
	{
		return UIResource == Other.UIResource;
	}
	FORCEINLINE UBOOL operator!=( const FUIStyleResourceInfo& Other ) const
	{
		return UIResource != Other.UIResource;
	}

};

struct FUIStateResourceInfo : public FUIResourceInfo
{

	/** Constructors */
	FUIStateResourceInfo( class UUIState* InResource );
	/** Copy Constructor */
	FUIStateResourceInfo( const FUIStateResourceInfo& Other )
	: FUIResourceInfo(Other)
	{
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIStateResourceInfo& Other ) const
	{
		return UIResource == Other.UIResource;
	}
	FORCEINLINE UBOOL operator!=( const FUIStateResourceInfo& Other ) const
	{
		return UIResource != Other.UIResource;
	}

};

struct FUIObjectToolbarMapping
{
    FStringNoInit WidgetClassName;
    FStringNoInit IconName;
    FStringNoInit ToolTip;
    FStringNoInit HelpText;

    /** Constructors */
    FUIObjectToolbarMapping() {}
    FUIObjectToolbarMapping(EEventParm)
    {
        appMemzero(this, sizeof(FUIObjectToolbarMapping));
    }
};

struct FUITitleRegions
{
    FLOAT RecommendedPercentage;
    FLOAT MaxPercentage;
};

class UUISceneManager : public UObject, public FGlobalDataStoreClientManager, public FExec, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UISceneManager
    class UUISkin* ActiveSkin;
    class UDataStoreClient* DataStoreManager;
    TArrayNoInit<class UEditorUISceneClient*> SceneClients;
    TArrayNoInit<struct FUIObjectResourceInfo> UIWidgetResources;
    TArrayNoInit<struct FUIObjectToolbarMapping> UIWidgetToolbarMaps;
    TArrayNoInit<struct FUIStyleResourceInfo> UIStyleResources;
private:
    TArrayNoInit<struct FUIStateResourceInfo> UIStateResources;
public:
    TMap< UClass*, FUIStateResourceInfo* > UIStateResourceInfoMap;
    struct FUITitleRegions TitleRegions;
private:
    class WxDlgUIDataStoreBrowser* DlgUIDataStoreBrowser;
public:
    //## END PROPS UISceneManager

    void GetSupportedUIStates(TArray<struct FUIStateResourceInfo>& out_SupportedStates,class UClass* WidgetClass=NULL) const;
    DECLARE_FUNCTION(execGetSupportedUIStates)
    {
        P_GET_TARRAY_REF(struct FUIStateResourceInfo,out_SupportedStates);
        P_GET_OBJECT_OPTX(UClass,WidgetClass,NULL);
        P_FINISH;
        GetSupportedUIStates(out_SupportedStates,WidgetClass);
    }
    DECLARE_CLASS(UUISceneManager,UObject,0|CLASS_Transient|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Performs all initialization for the UI editor system.
	 */
	void Initialize();

	/**
	 * Loads the initial UISkin to use for rendering scenes
	 *
	 * @return	a pointer to the UISkin object corresponding to the default UI Skin
	 */
	class UUISkin* LoadInitialSkin() const;

	/**
	 * Changes the active skin to the skin specified
	 *
	 * @param	NewActiveSkin	the skin that should now be active
	 *
	 * @return	TRUE if the active skin was successfully changed
	 */
	UBOOL SetActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Builds the list of available widget, style, and state resources.
	 *
	 * @param	bRefresh	if FALSE, only builds the list if the list of resources is currently empty.
	 *						if TRUE, clears the existing list of resources first
	 */
	void InitUIResources( UBOOL bRefresh = FALSE );

	/**
	 * Clears the various resources arrays.
	 */
	void ClearUIResources();

	/**
	 * Determines whether the specified UI resource should be included in the list of placeable widgets.
	 *
	 * @param	UIResource		a UIObject archetype
	 */
	UBOOL IsValidUIResource( UUIObject* UIResource ) const;

	/**
	 * Determines whether the specified style data should be included in the list of useable styles.
	 *
	 * @param	StyleResource	a UUIStyle_Data archetype
	 */
	UBOOL IsValidStyleResource( UUIStyle_Data* StyleResource ) const;

	/**
	 * Determines whether the specified state should be included in the list of available UI states.
	 *
	 * @param	StateResource	a UIState archetype
	 */
	UBOOL IsValidStateResource( UUIState* StateResource ) const;

	/**
	 * Checks to see if any widgets in any of the scenes are currently referencing the passed in style.  If so,
	 * it displays a message box asking the user if they still want to go through with the action.
	 *
	 * @param	StyleToDelete	Style that we want to delete/replace.
	 * @param	bIsReplace		Whether or not this is a replacement operation, if so, display a different message to the user.
	 *
	 * @return	TRUE if it is safe to delete/replace the specified style
	 */
	UBOOL ShouldDeleteStyle( UUIStyle* StyleToDelete, UBOOL bIsReplace) const;

	/**
	 * Creates a new UIScene in the package specified.
	 *
	 * @param	SceneTemplate	the template to use for the new scene
	 * @param	InOuter			the outer for the scene
	 * @param	SceneTag		if specified, the scene will be given this tag when created
	 *
	 * @return	a pointer to the new UIScene that was created.
	 */
	class UUIScene* CreateScene( UUIScene* SceneTemplate, UObject* InOuter, FName SceneTag = NAME_None );

	/**
	 * Create a new scene client and associates it with the specified scene.
	 *
	 * @param	Scene	the scene to be associated with the new scene client.
	 */
	class UEditorUISceneClient* CreateSceneClient( class UUIScene* Scene );

	/**
	 * Find the position for the scene client window containing the scene specified.
	 *
	 * @param	Scene	the scene to search for
	 *
	 * @return	the index into array of SceneClients arry for the scene client associated with the scene specified,
	 *			or INDEX_NONE if that scene has never been edited
	 */
	INT FindSceneIndex( UUIScene* Scene ) const;

	/**
	 * Retrieves the set of selected widgets for scene specified.
	 *
	 * @param	Scene					the scene to get the selected widgets for
	 * @param	out_SelectedWidgets		will be filled with the selected widgets from the specified scene
	 *
	 * @return	TRUE if out_SelectedWidgets was successfully filled with widgets from the specified scene, or
	 *			FALSE if the scene specified isn't currently being edited.
	 */
	UBOOL GetSelectedSceneWidgets( UUIScene* Scene, TArray<UUIObject*>& out_SelectedWidgets ) const;

	/**
	 * Sets the selected widgets for the scene editor associated with the scene specified
	 *
	 * @param	Scene				the scene to get the selected widgets for
	 * @param	SelectedWidgets		the list of widgets to mark as selected
	 *
	 * @return	TRUE if the selection set was accepted
	 */
	UBOOL SetSelectedSceneWidgets( class UUIScene* Scene, TArray<class UUIObject*>& SelectedWidgets );

	/**
	 * Called when the user requests to edit a UIScene.  Creates a new scene client (or finds an existing scene client, if
	 * this isn't the first time the scene has been edited during this session) to handle initialization and de-initialization
	 * of the scene, and passes the edit scene request to the scene client.
	 *
	 * @param	Scene	the scene to open
	 *
	 * @return	TRUE if the scene was successfully opened and initialized
	 */
	UBOOL OpenScene( class UUIScene* Scene );

	/**
	 * Called when the editor window for the specified scene is closed.  Passes the notification to the appropriate
	 * scene client for further processing.
	 *
	 * @param	Scene	the scene to deactivate
	 */
	void SceneClosed( class UUIScene* Scene );

	/**
	 * Called when the user selects to delete a scene in the generic browser.
	 */
	void NotifySceneDeletion( UUIScene* Scene );

	/** @return Returns the pointer to the datastore browser dialog. */
	WxDlgUIDataStoreBrowser* GetDataStoreBrowser();

	/**
	 * Determines whether the data store subsystem has been initialized
	 */
	UBOOL AreDataStoresInitialized() const
	{
		return DlgUIDataStoreBrowser != NULL;
	}


	/* ==============================================
		FGlobalDataStoreClientManager interface
	============================================== */
	/**
	 * Initializes the singleton data store client that will manage the global data stores.
	 */
	virtual void InitializeGlobalDataStore();

	/* ==============================================
		FExec interface
	============================================== */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* === FCallbackEventDevice interface === */
	/**
	 * Called when a package containing a UISKin is loaded.
	 *
	 * @param	LoadedSkin	the skin that was loaded.
	 */
	virtual void Send( ECallbackEventType InType, class UObject* LoadedSkin );
};

struct FEditorKeyBinding
{
    BITFIELD bCtrlDown:1;
    BITFIELD bAltDown:1;
    BITFIELD bShiftDown:1;
    FName Key;
    FName CommandName;
};

class UUnrealEdKeyBindings : public UObject
{
public:
    //## BEGIN PROPS UnrealEdKeyBindings
    TArrayNoInit<struct FEditorKeyBinding> KeyBindings;
    //## END PROPS UnrealEdKeyBindings

    DECLARE_CLASS(UUnrealEdKeyBindings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorKeyBindings");}

    NO_DEFAULT_CONSTRUCTOR(UUnrealEdKeyBindings)
};

struct FEditorCommandCategory
{
    FName Parent;
    FName Name;
};

struct FEditorCommand
{
    FName Parent;
    FName CommandName;
    FStringNoInit ExecCommand;
    FStringNoInit Description;

    /** Constructors */
    FEditorCommand() {}
    FEditorCommand(EEventParm)
    {
        appMemzero(this, sizeof(FEditorCommand));
    }
};

class UUnrealEdOptions : public UObject
{
public:
    //## BEGIN PROPS UnrealEdOptions
    TArrayNoInit<struct FEditorCommandCategory> EditorCategories;
    TArrayNoInit<struct FEditorCommand> EditorCommands;
    class UUnrealEdKeyBindings* EditorKeyBindings;
    TMap< FName, INT > CommandMap;
    //## END PROPS UnrealEdOptions

    DECLARE_CLASS(UUnrealEdOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

public:

	/**
	 * Generates a mapping from commnads to their parent sets for quick lookup.
	 */
	void GenerateCommandMap();

	/**
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @return Returns whether or not the specified key event is already bound to a command or not.
	 */
	UBOOL IsKeyBound(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Binds a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param Command	Command to bind to.
	 */
	void BindKey(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName Command);

	/**
	 * Attempts to execute a command bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 */
	void ExecuteBinding(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Attempts to locate a exec command bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 */
	FString GetExecCommand(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Attempts to locate a command name bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 *
	 * @return Name of the command if found, NAME_None otherwise.
	 */
	FName GetCommand(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Retreives a editor key binding for a specified command.
	 *
	 * @param Command		Command to retrieve a key binding for.
	 *
	 * @return A pointer to a keybinding if one exists, NULL otherwise.
	 */
	FEditorKeyBinding* GetKeyBinding(FName Command);
};

#endif

AUTOGENERATE_FUNCTION(UUISceneManager,-1,execGetSupportedUIStates);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UNREALED_NATIVE_DEFS
#define UNREALED_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UnrealEd,UAnimNodeEditInfo);
DECLARE_NATIVE_TYPE(UnrealEd,UAnimNodeEditInfo_AimOffset);
DECLARE_NATIVE_TYPE(UnrealEd,UAnimSetLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UAnimTreeEdSkelComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UAnimTreeLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UArchetypeThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UASVSkelComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UBrowserManager);
DECLARE_NATIVE_TYPE(UnrealEd,UCascadeOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UCascadePreviewComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPreset_CosWave);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPreset_LinearDecay);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPreset_Nothing);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPreset_SineWave);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPreset_UserSet);
DECLARE_NATIVE_TYPE(UnrealEd,UCurveEdPresetBase);
DECLARE_NATIVE_TYPE(UnrealEd,UDefaultSizedThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UEditorUISceneClient);
DECLARE_NATIVE_TYPE(UnrealEd,UFaceFXStudioSkelComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UFontThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_All);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Animation);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_AnimTree);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Archetype);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_CameraAnim);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_CurveEdPresetCurve);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Custom);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_DecalMaterial);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_FaceFXAnimSet);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_FaceFXAsset);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Font);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_LensFlare);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Material);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_MaterialInstanceConstant);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_MaterialInstanceTimeVarying);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_MorphTargetSet);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_MorphWeightSequence);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_ParticleSystem);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_PhysicalMaterial);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_PhysicsAsset);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_PostProcess);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Prefab);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_RenderTexture);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Sequence);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_SkeletalMesh);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_SoundCue);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Sounds);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_SoundWave);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_SpeechRecognition);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_SpeedTree);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_StaticMesh);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_TerrainLayer);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_TerrainMaterial);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_Texture);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_TextureWithAlpha);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_UIArchetype);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_UIScene);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericBrowserType_UISkin);
DECLARE_NATIVE_TYPE(UnrealEd,UGenericThumbnailLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UIconThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpEdOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackAnimControlHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackColorPropHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackDirectorHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackEventHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackFaceFXHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackFloatPropHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackSoundHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackToggleHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UInterpTrackVectorPropHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UKismetBindings);
DECLARE_NATIVE_TYPE(UnrealEd,ULensFlareEditorOptions);
DECLARE_NATIVE_TYPE(UnrealEd,ULensFlarePreviewComponent);
DECLARE_NATIVE_TYPE(UnrealEd,ULensFlareThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialEditorInstanceConstant);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialEditorInstanceTimeVarying);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialEditorMeshComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialEditorOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialEditorSkeletalMeshComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialInstanceLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UMaterialInstanceThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UMemCountThumbnailLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UParticleSystemThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UPhATSimOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UPhATSkeletalMeshComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UPhysicsAssetLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UPostProcessLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UPrefabThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,USequenceObjectHelper);
DECLARE_NATIVE_TYPE(UnrealEd,USkeletalMeshLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,USkeletalMeshThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,USoundLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,USoundNodeHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UStaticMeshEditorComponent);
DECLARE_NATIVE_TYPE(UnrealEd,UStaticMeshLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UStaticMeshThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UTerrainEditOptions);
DECLARE_NATIVE_TYPE(UnrealEd,UTextureCubeThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UTextureThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UThumbnailLabelRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UThumbnailManager);
DECLARE_NATIVE_TYPE(UnrealEd,UThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UUIEvent_MetaObjectHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UUISceneManager);
DECLARE_NATIVE_TYPE(UnrealEd,UUISceneThumbnailRenderer);
DECLARE_NATIVE_TYPE(UnrealEd,UUISequenceHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UUISequenceObjectHelper);
DECLARE_NATIVE_TYPE(UnrealEd,UUnrealEdKeyBindings);
DECLARE_NATIVE_TYPE(UnrealEd,UUnrealEdOptions);

#define AUTO_INITIALIZE_REGISTRANTS_UNREALED \
	UAnimNodeEditInfo::StaticClass(); \
	UAnimNodeEditInfo_AimOffset::StaticClass(); \
	UAnimSetLabelRenderer::StaticClass(); \
	UAnimTreeEdSkelComponent::StaticClass(); \
	UAnimTreeLabelRenderer::StaticClass(); \
	UArchetypeThumbnailRenderer::StaticClass(); \
	UASVSkelComponent::StaticClass(); \
	UBrowserManager::StaticClass(); \
	UCascadeOptions::StaticClass(); \
	UCascadePreviewComponent::StaticClass(); \
	UCurveEdOptions::StaticClass(); \
	UCurveEdPreset_CosWave::StaticClass(); \
	UCurveEdPreset_LinearDecay::StaticClass(); \
	UCurveEdPreset_Nothing::StaticClass(); \
	UCurveEdPreset_SineWave::StaticClass(); \
	UCurveEdPreset_UserSet::StaticClass(); \
	UCurveEdPresetBase::StaticClass(); \
	UCustomInputProxy_Base::StaticClass(); \
	UDefaultSizedThumbnailRenderer::StaticClass(); \
	UEditorUISceneClient::StaticClass(); \
	UFaceFXStudioSkelComponent::StaticClass(); \
	UFontThumbnailRenderer::StaticClass(); \
	UGenericBrowserType::StaticClass(); \
	UGenericBrowserType_All::StaticClass(); \
	UGenericBrowserType_Animation::StaticClass(); \
	UGenericBrowserType_AnimTree::StaticClass(); \
	UGenericBrowserType_Archetype::StaticClass(); \
	UGenericBrowserType_CameraAnim::StaticClass(); \
	UGenericBrowserType_CurveEdPresetCurve::StaticClass(); \
	UGenericBrowserType_Custom::StaticClass(); \
	UGenericBrowserType_DecalMaterial::StaticClass(); \
	UGenericBrowserType_FaceFXAnimSet::StaticClass(); \
	UGenericBrowserType_FaceFXAsset::StaticClass(); \
	UGenericBrowserType_Font::StaticClass(); \
	UGenericBrowserType_LensFlare::StaticClass(); \
	UGenericBrowserType_Material::StaticClass(); \
	UGenericBrowserType_MaterialInstanceConstant::StaticClass(); \
	UGenericBrowserType_MaterialInstanceTimeVarying::StaticClass(); \
	UGenericBrowserType_MorphTargetSet::StaticClass(); \
	UGenericBrowserType_MorphWeightSequence::StaticClass(); \
	UGenericBrowserType_ParticleSystem::StaticClass(); \
	UGenericBrowserType_PhysicalMaterial::StaticClass(); \
	UGenericBrowserType_PhysicsAsset::StaticClass(); \
	UGenericBrowserType_PostProcess::StaticClass(); \
	UGenericBrowserType_Prefab::StaticClass(); \
	UGenericBrowserType_RenderTexture::StaticClass(); \
	UGenericBrowserType_Sequence::StaticClass(); \
	UGenericBrowserType_SkeletalMesh::StaticClass(); \
	UGenericBrowserType_SoundCue::StaticClass(); \
	UGenericBrowserType_Sounds::StaticClass(); \
	UGenericBrowserType_SoundWave::StaticClass(); \
	UGenericBrowserType_SpeechRecognition::StaticClass(); \
	UGenericBrowserType_SpeedTree::StaticClass(); \
	UGenericBrowserType_StaticMesh::StaticClass(); \
	UGenericBrowserType_TerrainLayer::StaticClass(); \
	UGenericBrowserType_TerrainMaterial::StaticClass(); \
	UGenericBrowserType_Texture::StaticClass(); \
	UGenericBrowserType_TextureWithAlpha::StaticClass(); \
	UGenericBrowserType_UIArchetype::StaticClass(); \
	UGenericBrowserType_UIScene::StaticClass(); \
	UGenericBrowserType_UISkin::StaticClass(); \
	UGenericThumbnailLabelRenderer::StaticClass(); \
	UIconThumbnailRenderer::StaticClass(); \
	UInterpEdOptions::StaticClass(); \
	UInterpTrackAnimControlHelper::StaticClass(); \
	UInterpTrackColorPropHelper::StaticClass(); \
	UInterpTrackDirectorHelper::StaticClass(); \
	UInterpTrackEventHelper::StaticClass(); \
	UInterpTrackFaceFXHelper::StaticClass(); \
	UInterpTrackFloatPropHelper::StaticClass(); \
	UInterpTrackHelper::StaticClass(); \
	UInterpTrackSoundHelper::StaticClass(); \
	UInterpTrackToggleHelper::StaticClass(); \
	UInterpTrackVectorPropHelper::StaticClass(); \
	UKismetBindings::StaticClass(); \
	ULensFlareEditorOptions::StaticClass(); \
	ULensFlarePreviewComponent::StaticClass(); \
	ULensFlareThumbnailRenderer::StaticClass(); \
	UMaterialEditorInstanceConstant::StaticClass(); \
	UMaterialEditorInstanceTimeVarying::StaticClass(); \
	UMaterialEditorMeshComponent::StaticClass(); \
	UMaterialEditorOptions::StaticClass(); \
	UMaterialEditorSkeletalMeshComponent::StaticClass(); \
	UMaterialInstanceLabelRenderer::StaticClass(); \
	UMaterialInstanceThumbnailRenderer::StaticClass(); \
	UMemCountThumbnailLabelRenderer::StaticClass(); \
	UParticleSystemThumbnailRenderer::StaticClass(); \
	UPhATSimOptions::StaticClass(); \
	UPhATSkeletalMeshComponent::StaticClass(); \
	UPhysicsAssetLabelRenderer::StaticClass(); \
	UPlayerInputMask_CustomDrawProxy::StaticClass(); \
	UPlayerInputMask_CustomInputProxy::StaticClass(); \
	UPostProcessLabelRenderer::StaticClass(); \
	UPrefabThumbnailRenderer::StaticClass(); \
	UPropertyDrawProxy::StaticClass(); \
	UPropertyInputArrayItemBase::StaticClass(); \
	UPropertyInputBool::StaticClass(); \
	UPropertyInputCombo::StaticClass(); \
	UPropertyInputEditInline::StaticClass(); \
	UPropertyInputProxy::StaticClass(); \
	UPropertyInputText::StaticClass(); \
	USequenceObjectHelper::StaticClass(); \
	USkeletalMeshLabelRenderer::StaticClass(); \
	USkeletalMeshThumbnailRenderer::StaticClass(); \
	USoundLabelRenderer::StaticClass(); \
	USoundNodeHelper::StaticClass(); \
	UStaticMeshEditorComponent::StaticClass(); \
	UStaticMeshLabelRenderer::StaticClass(); \
	UStaticMeshThumbnailRenderer::StaticClass(); \
	UTerrainEditOptions::StaticClass(); \
	UTextureCubeThumbnailRenderer::StaticClass(); \
	UTextureThumbnailRenderer::StaticClass(); \
	UThumbnailLabelRenderer::StaticClass(); \
	UThumbnailManager::StaticClass(); \
	UThumbnailRenderer::StaticClass(); \
	UUIEvent_MetaObjectHelper::StaticClass(); \
	UUISceneExporter::StaticClass(); \
	UUISceneFactory::StaticClass(); \
	UUISceneFactoryNew::StaticClass(); \
	UUISceneFactoryText::StaticClass(); \
	UUISceneManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUnrealEdUUISceneManagerNative; \
	UUISceneThumbnailRenderer::StaticClass(); \
	UUISequenceHelper::StaticClass(); \
	UUISequenceObjectHelper::StaticClass(); \
	UUIState_CustomInputProxy::StaticClass(); \
	UUIStateClass_CustomInputProxy::StaticClass(); \
	UUITexture_CustomDrawProxy::StaticClass(); \
	UUITexture_CustomInputProxy::StaticClass(); \
	UUnrealEdEngine::StaticClass(); \
	UUnrealEdKeyBindings::StaticClass(); \
	UUnrealEdOptions::StaticClass(); \

#endif // UNREALED_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UUISceneManager) GUnrealEdUUISceneManagerNatives[] = 
{ 
	MAP_NATIVE(UUISceneManager,execGetSupportedUIStates)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UnrealEd,UUISceneManager);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeEditInfo,AnimNodeClass)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeEditInfo)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeEditInfo_AimOffset,EditWindow)
VERIFY_CLASS_OFFSET_NODIE(U,AnimNodeEditInfo_AimOffset,EditNode)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeEditInfo_AimOffset)
VERIFY_CLASS_SIZE_NODIE(UAnimSetLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,AnimTreeEdSkelComponent,AnimTreeEdPtr)
VERIFY_CLASS_SIZE_NODIE(UAnimTreeEdSkelComponent)
VERIFY_CLASS_SIZE_NODIE(UAnimTreeLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UArchetypeThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,ASVSkelComponent,AnimSetViewerPtr)
VERIFY_CLASS_SIZE_NODIE(UASVSkelComponent)
VERIFY_CLASS_OFFSET_NODIE(U,BrowserManager,BrowserPanes)
VERIFY_CLASS_OFFSET_NODIE(U,BrowserManager,UISceneManager)
VERIFY_CLASS_SIZE_NODIE(UBrowserManager)
VERIFY_CLASS_OFFSET_NODIE(U,CascadeOptions,BackgroundColor)
VERIFY_CLASS_OFFSET_NODIE(U,CascadeOptions,ShowPPFlags)
VERIFY_CLASS_SIZE_NODIE(UCascadeOptions)
VERIFY_CLASS_OFFSET_NODIE(U,CascadePreviewComponent,CascadePtr)
VERIFY_CLASS_SIZE_NODIE(UCascadePreviewComponent)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdOptions,MinViewRange)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdOptions,SelectedKeyColor)
VERIFY_CLASS_SIZE_NODIE(UCurveEdOptions)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_CosWave,Frequency)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_CosWave,Offset)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_CosWave)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_LinearDecay,StartDecay)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_LinearDecay,EndValue)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_LinearDecay)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_Nothing)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_SineWave,Frequency)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_SineWave,Offset)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_SineWave)
VERIFY_CLASS_OFFSET_NODIE(U,CurveEdPreset_UserSet,UserCurve)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_UserSet)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPresetBase)
VERIFY_CLASS_OFFSET_NODIE(U,DefaultSizedThumbnailRenderer,DefaultSizeX)
VERIFY_CLASS_OFFSET_NODIE(U,DefaultSizedThumbnailRenderer,DefaultSizeY)
VERIFY_CLASS_SIZE_NODIE(UDefaultSizedThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,EditorUISceneClient,Scene)
VERIFY_CLASS_OFFSET_NODIE(U,EditorUISceneClient,ClientCanvasScene)
VERIFY_CLASS_SIZE_NODIE(UEditorUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(U,FaceFXStudioSkelComponent,RenderWidgetUE3Ptr)
VERIFY_CLASS_SIZE_NODIE(UFaceFXStudioSkelComponent)
VERIFY_CLASS_SIZE_NODIE(UFontThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,GenericBrowserType,Description)
VERIFY_CLASS_OFFSET_NODIE(U,GenericBrowserType,BorderColor)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_All)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Animation)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_AnimTree)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Archetype)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_CameraAnim)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_CurveEdPresetCurve)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Custom)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_DecalMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FaceFXAnimSet)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FaceFXAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Font)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_LensFlare)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Material)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MaterialInstanceConstant)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MaterialInstanceTimeVarying)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MorphTargetSet)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MorphWeightSequence)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PhysicalMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PhysicsAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PostProcess)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Prefab)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_RenderTexture)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Sequence)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SkeletalMesh)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundCue)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Sounds)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundWave)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SpeechRecognition)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SpeedTree)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_StaticMesh)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TerrainLayer)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TerrainMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Texture)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TextureWithAlpha)
VERIFY_CLASS_OFFSET_NODIE(U,GenericBrowserType_UIArchetype,SceneManager)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_UIArchetype)
VERIFY_CLASS_OFFSET_NODIE(U,GenericBrowserType_UIScene,SceneManager)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_UIScene)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_UISkin)
VERIFY_CLASS_SIZE_NODIE(UGenericThumbnailLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,IconThumbnailRenderer,IconName)
VERIFY_CLASS_OFFSET_NODIE(U,IconThumbnailRenderer,Icon)
VERIFY_CLASS_SIZE_NODIE(UIconThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,InterpEdOptions,SelectedKeys)
VERIFY_CLASS_SIZE_NODIE(UInterpEdOptions)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAnimControlHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackDirectorHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackEventHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFaceFXHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSoundHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackToggleHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorPropHelper)
VERIFY_CLASS_OFFSET_NODIE(U,KismetBindings,Bindings)
VERIFY_CLASS_OFFSET_NODIE(U,KismetBindings,CommentPresets)
VERIFY_CLASS_SIZE_NODIE(UKismetBindings)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareEditorOptions,LFED_BackgroundColor)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareEditorOptions,ShowPPFlags)
VERIFY_CLASS_SIZE_NODIE(ULensFlareEditorOptions)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlarePreviewComponent,LensFlareEditorPtr)
VERIFY_CLASS_SIZE_NODIE(ULensFlarePreviewComponent)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareThumbnailRenderer,NoImage)
VERIFY_CLASS_OFFSET_NODIE(U,LensFlareThumbnailRenderer,OutOfDate)
VERIFY_CLASS_SIZE_NODIE(ULensFlareThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorInstanceConstant,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorInstanceConstant,SourceInstance)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorInstanceTimeVarying,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorInstanceTimeVarying,SourceInstance)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorInstanceTimeVarying)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorMeshComponent,MaterialEditor)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorOptions)
VERIFY_CLASS_OFFSET_NODIE(U,MaterialEditorSkeletalMeshComponent,MaterialEditor)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorSkeletalMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,MemCountThumbnailLabelRenderer,AggregatedLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UMemCountThumbnailLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemThumbnailRenderer,NoImage)
VERIFY_CLASS_OFFSET_NODIE(U,ParticleSystemThumbnailRenderer,OutOfDate)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,PhATSimOptions,PreviewAnimSet)
VERIFY_CLASS_OFFSET_NODIE(U,PhATSimOptions,LinearSnap)
VERIFY_CLASS_SIZE_NODIE(UPhATSimOptions)
VERIFY_CLASS_OFFSET_NODIE(U,PhATSkeletalMeshComponent,PhATPtr)
VERIFY_CLASS_OFFSET_NODIE(U,PhATSkeletalMeshComponent,AnimationSpaceBases)
VERIFY_CLASS_SIZE_NODIE(UPhATSkeletalMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UPostProcessLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UPrefabThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(USequenceObjectHelper)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(USoundLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(USoundNodeHelper)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshEditorComponent,StaticMeshEditor)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshEditorComponent)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainEditOptions,Solid1_Strength)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainEditOptions,TerrainLayerBrowser_BorderColor)
VERIFY_CLASS_SIZE_NODIE(UTerrainEditOptions)
VERIFY_CLASS_SIZE_NODIE(UTextureCubeThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UTextureThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UThumbnailLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(U,ThumbnailManager,RenderableThumbnailTypes)
VERIFY_CLASS_OFFSET_NODIE(U,ThumbnailManager,ThumbnailBackgroundSolidMatInst)
VERIFY_CLASS_SIZE_NODIE(UThumbnailManager)
VERIFY_CLASS_SIZE_NODIE(UThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UUIEvent_MetaObjectHelper)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneManager,ActiveSkin)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneManager,DlgUIDataStoreBrowser)
VERIFY_CLASS_SIZE_NODIE(UUISceneManager)
VERIFY_CLASS_SIZE_NODIE(UUISceneThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UUISequenceHelper)
VERIFY_CLASS_SIZE_NODIE(UUISequenceObjectHelper)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,EditorOptionsInst)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,BrowserManager)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,ThumbnailManager)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,BrowserManagerClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,ThumbnailManagerClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,AutoSaveIndex)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,AutosaveCount)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,AutosaveTimeMinutes)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,MaterialCopyPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,MatineeCopyPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,AnimationCompressionAlgorithms)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,PackagesToBeFullyLoadedAtStartup)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,HiddenKismetClassNames)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdEngine,ClassRelocationInfo)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdEngine)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdKeyBindings,KeyBindings)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdKeyBindings)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdOptions,EditorCategories)
VERIFY_CLASS_OFFSET_NODIE(U,UnrealEdOptions,CommandMap)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdOptions)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
