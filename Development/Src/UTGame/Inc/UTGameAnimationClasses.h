/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum EBlendFallTypes
{
    FBT_Up                  =0,
    FBT_Down                =1,
    FBT_PreLand             =2,
    FBT_Land                =3,
    FBT_DblJumpUp           =4,
    FBT_DblJumpDown         =5,
    FBT_DblJumpPreLand      =6,
    FBT_DblJumpLand         =7,
    FBT_None                =8,
    FBT_MAX                 =9,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AnimStopFire)
AUTOGENERATE_NAME(BreakAPart)
AUTOGENERATE_NAME(EntireBeamVelocity)
AUTOGENERATE_NAME(OnTurretStatusChange)
AUTOGENERATE_NAME(PhysicsVolumeChanged)
AUTOGENERATE_NAME(Pulse)
AUTOGENERATE_NAME(SetForceBlend)

#ifndef NAMES_ONLY

class UUTAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS UTAnimNodeJumpLeanOffset
    FLOAT JumpLeanStrength;
    FLOAT MaxLeanChangeSpeed;
    BITFIELD bMultiplyByZVelocity:1;
    BITFIELD bDodging:1;
    BITFIELD bOldDodging:1;
    BITFIELD bDoubleJumping:1;
    BITFIELD bOldDoubleJumping:1;
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    FVector2D PreBlendAim;
    FLOAT LeanWeight;
    FLOAT LeanWeightTarget;
    FLOAT BlendTimeToGo;
    //## END PROPS UTAnimNodeJumpLeanOffset

    void SetLeanWeight(FLOAT WeightTarget,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetLeanWeight)
    {
        P_GET_FLOAT(WeightTarget);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        SetLeanWeight(WeightTarget,BlendTime);
    }
    DECLARE_CLASS(UUTAnimNodeJumpLeanOffset,UAnimNodeAimOffset,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );	
};

struct UTAnimBlendByCollision_eventPulse_Parms
{
    FLOAT delay;
    UTAnimBlendByCollision_eventPulse_Parms(EEventParm)
    {
    }
};
struct UTAnimBlendByCollision_eventSetForceBlend_Parms
{
    UBOOL bForce;
    FLOAT Rate;
    UTAnimBlendByCollision_eventSetForceBlend_Parms(EEventParm)
    {
    }
};
class UUTAnimBlendByCollision : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendByCollision
    FName TraceSocket;
    FLOAT TraceDistance;
    FLOAT TraceAdjustment;
    BITFIELD bForceBlend:1;
    BITFIELD bPulseBlend:1;
    FLOAT PulseDelay;
    class AActor* LastHitActor;
    FVector LastHitLocation;
    //## END PROPS UTAnimBlendByCollision

    void eventPulse(FLOAT delay)
    {
        UTAnimBlendByCollision_eventPulse_Parms Parms(EC_EventParm);
        Parms.delay=delay;
        ProcessEvent(FindFunctionChecked(UTGAME_Pulse),&Parms);
    }
    void eventSetForceBlend(UBOOL bForce,FLOAT Rate=0)
    {
        UTAnimBlendByCollision_eventSetForceBlend_Parms Parms(EC_EventParm);
        Parms.bForce=bForce ? FIRST_BITFIELD : 0;
        Parms.Rate=Rate;
        ProcessEvent(FindFunctionChecked(UTGAME_SetForceBlend),&Parms);
    }
    DECLARE_CLASS(UUTAnimBlendByCollision,UAnimNodeBlendPerBone,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendBySlotActive : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendBySlotActive
    class UAnimNodeSlot* ChildSlot;
    //## END PROPS UTAnimBlendBySlotActive

    DECLARE_CLASS(UUTAnimBlendBySlotActive,UAnimNodeBlendPerBone,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

struct UTAnimBlendByWeapon_eventAnimStopFire_Parms
{
    FLOAT SpecialBlendTime;
    UTAnimBlendByWeapon_eventAnimStopFire_Parms(EEventParm)
    {
    }
};
class UUTAnimBlendByWeapon : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendByWeapon
    BITFIELD bLooping:1;
    FName LoopingAnim;
    FLOAT BlendTime;
    //## END PROPS UTAnimBlendByWeapon

    void eventAnimStopFire(FLOAT SpecialBlendTime=0)
    {
        UTAnimBlendByWeapon_eventAnimStopFire_Parms Parms(EC_EventParm);
        Parms.SpecialBlendTime=SpecialBlendTime;
        ProcessEvent(FindFunctionChecked(UTGAME_AnimStopFire),&Parms);
    }
    DECLARE_CLASS(UUTAnimBlendByWeapon,UAnimNodeBlendPerBone,0,UTGame)
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUTAnimBlendByWeapType : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UTAnimBlendByWeapType
    //## END PROPS UTAnimBlendByWeapType

    DECLARE_CLASS(UUTAnimBlendByWeapType,UAnimNodeBlendPerBone,0,UTGame)
	void WeapTypeChanged(FName NewAimProfileName);
};

class UUTAnimBlendByDriving : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UTAnimBlendByDriving
    //## END PROPS UTAnimBlendByDriving

    DECLARE_CLASS(UUTAnimBlendByDriving,UAnimNodeBlend,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendBySpeed : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UTAnimBlendBySpeed
    FLOAT MinSpeed;
    FLOAT MaxSpeed;
    //## END PROPS UTAnimBlendBySpeed

    DECLARE_CLASS(UUTAnimBlendBySpeed,UAnimNodeBlend,0,UTGame)
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UUTAnimBlendBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS UTAnimBlendBase
    FLOAT BlendTime;
    TArrayNoInit<FLOAT> ChildBlendTimes;
    FLOAT SliderPosition;
    //## END PROPS UTAnimBlendBase

    FLOAT GetBlendTime(INT ChildIndex,UBOOL bGetDefault=0);
    FLOAT GetAnimDuration(INT ChildIndex);
    DECLARE_FUNCTION(execGetBlendTime)
    {
        P_GET_INT(ChildIndex);
        P_GET_UBOOL_OPTX(bGetDefault,0);
        P_FINISH;
        *(FLOAT*)Result=GetBlendTime(ChildIndex,bGetDefault);
    }
    DECLARE_FUNCTION(execGetAnimDuration)
    {
        P_GET_INT(ChildIndex);
        P_FINISH;
        *(FLOAT*)Result=GetAnimDuration(ChildIndex);
    }
    DECLARE_CLASS(UUTAnimBlendBase,UAnimNodeBlendList,0,UTGame)
	// AnimTree editor interface
	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UUTAnimBlendByFall : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByFall
    BITFIELD bIgnoreDoubleJumps:1;
    BITFIELD bDodgeFall:1;
    FLOAT PreLandTime;
    FLOAT PreLandStartUprightTime;
    FLOAT ToDblJumpUprightTime;
    BITFIELD bDidDoubleJump:1;
    BYTE FallState GCC_BITFIELD_MAGIC;
    FLOAT LastFallingVelocity;
    class UUTAnimNodeJumpLeanOffset* CachedLeanNode;
    //## END PROPS UTAnimBlendByFall

    DECLARE_CLASS(UUTAnimBlendByFall,UUTAnimBlendBase,0,UTGame)
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	virtual void ChangeFallState(EBlendFallTypes NewState);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void RenameChildConnectors();
};

class UUTAnimBlendByHoverJump : public UUTAnimBlendByFall
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverJump
    class AUTPawn* OwnerUTP;
    //## END PROPS UTAnimBlendByHoverJump

    DECLARE_CLASS(UUTAnimBlendByHoverJump,UUTAnimBlendByFall,0,UTGame)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
};

class UUTAnimBlendByHoverboarding : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboarding
    INT LastActiveChildIndex;
    FLOAT BoardLeanAmount;
    FLOAT FallTimeBeforeAnim;
    //## END PROPS UTAnimBlendByHoverboarding

    DECLARE_CLASS(UUTAnimBlendByHoverboarding,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
};

class UUTAnimBlendByIdle : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByIdle
    //## END PROPS UTAnimBlendByIdle

    DECLARE_CLASS(UUTAnimBlendByIdle,UUTAnimBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( float DeltaSeconds, FLOAT TotalWeight  );
};

class UUTAnimBlendByPhysics : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPhysics
    INT PhysicsMap[12];
    INT LastPhysics;
    FLOAT LandBlendDelay;
    INT PendingChildIndex;
    FLOAT PendingTimeToGo;
    //## END PROPS UTAnimBlendByPhysics

    DECLARE_CLASS(UUTAnimBlendByPhysics,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
};

struct FPhysicsVolumeParams
{
    INT ChildIndex;
    BITFIELD bWaterVolume:1;
    BITFIELD bCheckGravity:1;
    FLOAT MinGravity;
    FLOAT MaxGravity;
};

struct UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms
{
    class APhysicsVolume* NewVolume;
    UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms(EEventParm)
    {
    }
};
class UUTAnimBlendByPhysicsVolume : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPhysicsVolume
    TArrayNoInit<struct FPhysicsVolumeParams> PhysicsParamList;
    class APhysicsVolume* LastPhysicsVolume;
    //## END PROPS UTAnimBlendByPhysicsVolume

    void eventPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
    {
        UTAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms Parms(EC_EventParm);
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(UTGAME_PhysicsVolumeChanged),&Parms);
    }
    DECLARE_CLASS(UUTAnimBlendByPhysicsVolume,UUTAnimBlendBase,0,UTGame)
	virtual void RenameChildConnectors();
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UUTAnimBlendByPosture : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByPosture
    //## END PROPS UTAnimBlendByPosture

    DECLARE_CLASS(UUTAnimBlendByPosture,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
};

class UUTAnimBlendByTurnInPlace : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByTurnInPlace
    FLOAT RootYawSpeedThresh;
    FLOAT TurnInPlaceBlendSpeed;
    class AUTPawn* OwnerUTP;
    //## END PROPS UTAnimBlendByTurnInPlace

    DECLARE_CLASS(UUTAnimBlendByTurnInPlace,UUTAnimBlendBase,0,UTGame)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim( float DeltaSeconds, FLOAT TotalWeight  );
};

class UUTAnimBlendByVehicle : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByVehicle
    BITFIELD bLastPawnDriving:1;
    class AVehicle* LastVehicle;
    //## END PROPS UTAnimBlendByVehicle

    DECLARE_CLASS(UUTAnimBlendByVehicle,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendByWalkerState : public UUTAnimBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByWalkerState
    //## END PROPS UTAnimBlendByWalkerState

    DECLARE_CLASS(UUTAnimBlendByWalkerState,UUTAnimBlendBase,0,UTGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UUTAnimBlendByHoverboardTilt : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboardTilt
    FVector UpVector;
    FLOAT TiltScale;
    FLOAT TiltDeadZone;
    FLOAT TiltYScale;
    //## END PROPS UTAnimBlendByHoverboardTilt

    DECLARE_CLASS(UUTAnimBlendByHoverboardTilt,UAnimNodeBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );

	virtual INT GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UUTAnimBlendByHoverboardTurn : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimBlendByHoverboardTurn
    FLOAT TurnScale;
    FLOAT MaxBlendPerSec;
    FLOAT CurrentAnimWeight;
    //## END PROPS UTAnimBlendByHoverboardTurn

    DECLARE_CLASS(UUTAnimBlendByHoverboardTurn,UAnimNodeBlendBase,0,UTGame)
	// AnimNode interface
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
};

struct FBoneCopyInfo
{
    FName SrcBoneName;
    FName DstBoneName;
    INT SrcBoneIndex;
    INT DstBoneIndex;
};

class UUTAnimNodeCopyBoneTranslation : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UTAnimNodeCopyBoneTranslation
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    TArrayNoInit<struct FBoneCopyInfo> DefaultBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> DualWieldBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> ActiveBoneCopyArray;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<class UUTAnimNodeSeqWeap*> SeqWeaps;
    TArrayNoInit<class UUTAnimBlendByWeapType*> WeapTypeBlends;
    //## END PROPS UTAnimNodeCopyBoneTranslation

    DECLARE_CLASS(UUTAnimNodeCopyBoneTranslation,UAnimNodeBlendBase,0,UTGame)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void UpdateListOfRequiredBones(FName AimProfileName);

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void GetBoneAtoms(TArray<FBoneAtom>& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion);
};

class UUTAnimNodeFramePlayer : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeFramePlayer
    //## END PROPS UTAnimNodeFramePlayer

    virtual void SetAnimation(FName Sequence,FLOAT RateScale);
    virtual void SetAnimPosition(FLOAT Perc);
    DECLARE_FUNCTION(execSetAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(RateScale);
        P_FINISH;
        SetAnimation(Sequence,RateScale);
    }
    DECLARE_FUNCTION(execSetAnimPosition)
    {
        P_GET_FLOAT(Perc);
        P_FINISH;
        SetAnimPosition(Perc);
    }
    DECLARE_CLASS(UUTAnimNodeFramePlayer,UAnimNodeSequence,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTAnimNodeFramePlayer)
};

class UUTAnimNodeSequence : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeSequence
    BITFIELD bAutoStart:1 GCC_BITFIELD_MAGIC;
    BITFIELD bLoopLastSequence:1;
    TArrayNoInit<FName> SeqStack;
    //## END PROPS UTAnimNodeSequence

    virtual void PlayAnimation(FName Sequence,FLOAT SeqRate,UBOOL bSeqLoop);
    virtual void PlayAnimationSet(const TArray<FName>& Sequences,FLOAT SeqRate,UBOOL bLoopLast);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bSeqLoop);
        P_FINISH;
        PlayAnimation(Sequence,SeqRate,bSeqLoop);
    }
    DECLARE_FUNCTION(execPlayAnimationSet)
    {
        P_GET_TARRAY(FName,Sequences);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bLoopLast);
        P_FINISH;
        PlayAnimationSet(Sequences,SeqRate,bLoopLast);
    }
    DECLARE_CLASS(UUTAnimNodeSequence,UAnimNodeSequence,0,UTGame)
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUTAnimNodeSeqWeap : public UUTAnimNodeSequence
{
public:
    //## BEGIN PROPS UTAnimNodeSeqWeap
    FName DefaultAnim;
    FName DualPistolAnim;
    FName SinglePistolAnim;
    FName ShoulderRocketAnim;
    FName StingerAnim;
    //## END PROPS UTAnimNodeSeqWeap

    DECLARE_CLASS(UUTAnimNodeSeqWeap,UUTAnimNodeSequence,0,UTGame)
	virtual FString GetNodeTitle();

	void WeapTypeChanged(FName NewAimProfileName);
};

struct UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms
{
    FVector ReturnValue;
    UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms(EEventParm)
    {
    }
};
class UUTSkelControl_CantileverBeam : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UTSkelControl_CantileverBeam
    FVector WorldSpaceGoal;
    FVector InitialWorldSpaceGoalOffset;
    FVector Velocity;
    FLOAT SpringStiffness;
    FLOAT SpringDamping;
    FLOAT PercentBeamVelocityTransfer;
    FScriptDelegate __EntireBeamVelocity__Delegate;
    //## END PROPS UTSkelControl_CantileverBeam

    FVector delegateEntireBeamVelocity()
    {
        UTSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessDelegate(UTGAME_EntireBeamVelocity,&__EntireBeamVelocity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTSkelControl_CantileverBeam,USkelControlLookAt,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_LookAt : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UTSkelControl_LookAt
    BITFIELD bLimitYaw:1;
    BITFIELD bLimitPitch:1;
    BITFIELD bLimitRoll:1;
    BITFIELD bShowPerAxisLimits:1;
    FLOAT YawLimit;
    FLOAT PitchLimit;
    FLOAT RollLimit;
    //## END PROPS UTSkelControl_LookAt

    DECLARE_CLASS(UUTSkelControl_LookAt,USkelControlLookAt,0,UTGame)
protected:
	virtual UBOOL	ApplyLookDirectionLimits(FVector& DesiredLookDir, const FVector &CurrentLookDir, INT BoneIndex, USkeletalMeshComponent* SkelComp);
public:
	virtual void	TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void	DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class UUTSkelControl_CicadaEngine : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_CicadaEngine
    FLOAT ForwardPitch;
    FLOAT BackPitch;
    FLOAT PitchRate;
    FLOAT MaxVelocity;
    FLOAT MinVelocity;
    FLOAT MaxVelocityPitchRateMultiplier;
    FLOAT PitchTime;
    FLOAT LastThrust;
    INT DesiredPitch;
    //## END PROPS UTSkelControl_CicadaEngine

    DECLARE_CLASS(UUTSkelControl_CicadaEngine,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_CoreSpin : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_CoreSpin
    FLOAT DegreesPerSecondMax;
    FLOAT DegreesPerSecondMin;
    BITFIELD bCounterClockwise:1;
    //## END PROPS UTSkelControl_CoreSpin

    DECLARE_CLASS(UUTSkelControl_CoreSpin,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct UTSkelControl_Damage_eventBreakAPart_Parms
{
    FVector PartLocation;
    UTSkelControl_Damage_eventBreakAPart_Parms(EEventParm)
    {
    }
};
class UUTSkelControl_Damage : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Damage
    BITFIELD bInitialized:1;
    BITFIELD bControlStrFollowsHealth:1;
    class AUTVehicle* OwnerVehicle;
    FLOAT HealthPerc;
    INT DamageMax;
    FLOAT ActivationThreshold;
    class UStaticMesh* BreakMesh;
    FLOAT BreakThreshold;
    FLOAT BreakTime;
    FVector DefaultBreakDir;
    BITFIELD bIsBroken:1;
    BITFIELD bIsBreaking:1;
    FName BrokenBone;
    FLOAT BreakTimer;
    FLOAT OwnerVehicleMaxHealth;
    //## END PROPS UTSkelControl_Damage

    void eventBreakAPart(FVector PartLocation)
    {
        UTSkelControl_Damage_eventBreakAPart_Parms Parms(EC_EventParm);
        Parms.PartLocation=PartLocation;
        ProcessEvent(FindFunctionChecked(UTGAME_BreakAPart),&Parms);
    }
    DECLARE_CLASS(UUTSkelControl_Damage,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_DamageHinge : public UUTSkelControl_Damage
{
public:
    //## BEGIN PROPS UTSkelControl_DamageHinge
    FLOAT MaxAngle;
    BYTE PivotAxis;
    FLOAT AVModifier;
    FLOAT CurrentAngle;
    FLOAT SpringStiffness;
    //## END PROPS UTSkelControl_DamageHinge

    DECLARE_CLASS(UUTSkelControl_DamageHinge,UUTSkelControl_Damage,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_DamageSpring : public UUTSkelControl_Damage
{
public:
    //## BEGIN PROPS UTSkelControl_DamageSpring
    FRotator MaxAngle;
    FRotator MinAngle;
    FLOAT Falloff;
    FLOAT SpringStiffness;
    FLOAT AVModifier;
    FRotator CurrentAngle;
    FLOAT RandomPortion;
    FLOAT BreakSpeed;
    FVector LastHitMomentum;
    FLOAT LastHitTime;
    FLOAT MomentumPortion;
    //## END PROPS UTSkelControl_DamageSpring

    DECLARE_CLASS(UUTSkelControl_DamageSpring,UUTSkelControl_Damage,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual int CalcAxis(INT &InAngle, FLOAT CurVelocity, FLOAT MinAngle, FLOAT MaxAngle);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_HoverboardSuspension : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardSuspension
    FLOAT TransIgnore;
    FLOAT TransScale;
    FLOAT TransOffset;
    FLOAT MaxTrans;
    FLOAT RotScale;
    FLOAT MaxRot;
    //## END PROPS UTSkelControl_HoverboardSuspension

    DECLARE_CLASS(UUTSkelControl_HoverboardSuspension,USkelControlSingleBone,0,UTGame)
	// SkelControlWheel interface
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_HoverboardSwing : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardSwing
    FLOAT SwingScale;
    FLOAT MaxSwing;
    FLOAT MaxSwingPerSec;
    FLOAT MaxUseVel;
    FLOAT CurrentSwing;
    //## END PROPS UTSkelControl_HoverboardSwing

    DECLARE_CLASS(UUTSkelControl_HoverboardSwing,USkelControlSingleBone,0,UTGame)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_HoverboardVibration : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HoverboardVibration
    FLOAT VibFrequency;
    FLOAT VibSpeedAmpScale;
    FLOAT VibTurnAmpScale;
    FLOAT VibMaxAmplitude;
    FLOAT VibInput;
    //## END PROPS UTSkelControl_HoverboardVibration

    DECLARE_CLASS(UUTSkelControl_HoverboardVibration,USkelControlSingleBone,0,UTGame)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_HugGround : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_HugGround
    FLOAT DesiredGroundDist;
    FLOAT MaxDist;
    FName ParentBone;
    BITFIELD bOppositeFromParent:1;
    FLOAT XYDistFromParentBone;
    FLOAT ZDistFromParentBone;
    FLOAT MaxTranslationPerSec;
    FLOAT LastUpdateTime;
    //## END PROPS UTSkelControl_HugGround

    DECLARE_CLASS(UUTSkelControl_HugGround,USkelControlSingleBone,0,UTGame)
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_JetThruster : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_JetThruster
    FLOAT MaxForwardVelocity;
    FLOAT BlendRate;
    FLOAT DesiredStrength;
    //## END PROPS UTSkelControl_JetThruster

    DECLARE_CLASS(UUTSkelControl_JetThruster,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_MantaBlade : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_MantaBlade
    FLOAT MaxRotationsPerSecond;
    FLOAT SpinUpTime;
    BITFIELD bCounterClockwise:1;
    FLOAT RotationsPerSecond;
    FLOAT DesiredRotationsPerSecond;
    //## END PROPS UTSkelControl_MantaBlade

    DECLARE_CLASS(UUTSkelControl_MantaBlade,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_MantaFlaps : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_MantaFlaps
    FLOAT maxPitch;
    FLOAT OldZPitch;
    FLOAT MaxPitchTime;
    FLOAT MaxPitchChange;
    FName RightFlapControl;
    FName LeftFlapControl;
    //## END PROPS UTSkelControl_MantaFlaps

    DECLARE_CLASS(UUTSkelControl_MantaFlaps,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_NecrisRaptorWings : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_NecrisRaptorWings
    FName TipSocket;
    FName JointSocket;
    FName LowerWingBoneName;
    FName UpperWingBoneName;
    INT WingLength;
    BITFIELD bInverted:1;
    INT UpperWingIndex;
    INT bForcedDesired;
    INT ActualPitch;
    INT DesiredPitch;
    FLOAT PitchRate;
    INT DesiredAngle;
    FLOAT UpTimeSeconds;
    FLOAT MinUpTime;
    BITFIELD bInitialized:1;
    //## END PROPS UTSkelControl_NecrisRaptorWings

    DECLARE_CLASS(UUTSkelControl_NecrisRaptorWings,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_Oscillate : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Oscillate
    FVector MaxDelta;
    FLOAT Period;
    FLOAT CurrentTime;
    BITFIELD bReverseDirection:1;
    //## END PROPS UTSkelControl_Oscillate

    DECLARE_CLASS(UUTSkelControl_Oscillate,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_RaptorTail : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_RaptorTail
    INT YawConstraint;
    INT Deadzone;
    INT LastVehicleYaw;
    INT TailYaw;
    INT DesiredTailYaw;
    BITFIELD bInitialized:1;
    //## END PROPS UTSkelControl_RaptorTail

    DECLARE_CLASS(UUTSkelControl_RaptorTail,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_RaptorWing : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_RaptorWing
    FName TipSockets[2];
    FName JointSockets[2];
    FName TipBones[2];
    INT WingLength;
    INT Bones[2];
    INT bForcedDesired[2];
    INT ActualPitch[2];
    INT DesiredPitch[2];
    FLOAT PitchRate[2];
    INT DesiredAngle;
    FLOAT UpTimeSeconds;
    FLOAT MinUpTime;
    BITFIELD bInitialized:1;
    BITFIELD bAlreadyDescending:1;
    //## END PROPS UTSkelControl_RaptorWing

    virtual void ForceSingleWingUp(UBOOL bRight,FLOAT Rate);
    virtual void ForceWingsUp(FLOAT Rate);
    DECLARE_FUNCTION(execForceSingleWingUp)
    {
        P_GET_UBOOL(bRight);
        P_GET_FLOAT(Rate);
        P_FINISH;
        ForceSingleWingUp(bRight,Rate);
    }
    DECLARE_FUNCTION(execForceWingsUp)
    {
        P_GET_FLOAT(Rate);
        P_FINISH;
        ForceWingsUp(Rate);
    }
    DECLARE_CLASS(UUTSkelControl_RaptorWing,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_Rotate : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_Rotate
    FRotator DesiredBoneRotation;
    FRotator DesiredBoneRotationRate;
    //## END PROPS UTSkelControl_Rotate

    DECLARE_CLASS(UUTSkelControl_Rotate,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_SpinControl : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_SpinControl
    FLOAT DegreesPerSecond;
    FVector Axis;
    //## END PROPS UTSkelControl_SpinControl

    DECLARE_CLASS(UUTSkelControl_SpinControl,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct FTurretConstraintData
{
    INT PitchConstraint;
    INT YawConstraint;
    INT RollConstraint;
};

struct FTurretStepData
{
    INT StepStartAngle;
    INT StepEndAngle;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
};

struct UTSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms
{
    UBOOL bIsMoving;
    UTSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms(EEventParm)
    {
    }
};
class UUTSkelControl_TurretConstrained : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UTSkelControl_TurretConstrained
    BITFIELD bConstrainPitch:1;
    BITFIELD bConstrainYaw:1;
    BITFIELD bConstrainRoll:1;
    BITFIELD bInvertPitch:1;
    BITFIELD bInvertYaw:1;
    BITFIELD bInvertRoll:1;
    BITFIELD bFixedWhenFiring:1;
    BITFIELD bResetWhenUnattended:1;
    BITFIELD bIsInMotion:1;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
    TArrayNoInit<struct FTurretStepData> Steps;
    FLOAT LagDegreesPerSecond;
    FRotator DesiredBoneRotation;
    INT AssociatedSeatIndex;
    FRotator ConstrainedBoneRotation;
    FScriptDelegate __OnTurretStatusChange__Delegate;
    //## END PROPS UTSkelControl_TurretConstrained

    void delegateOnTurretStatusChange(UBOOL bIsMoving)
    {
        UTSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms Parms(EC_EventParm);
        Parms.bIsMoving=bIsMoving ? FIRST_BITFIELD : 0;
        ProcessDelegate(UTGAME_OnTurretStatusChange,&__OnTurretStatusChange__Delegate,&Parms);
    }
    DECLARE_CLASS(UUTSkelControl_TurretConstrained,USkelControlSingleBone,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_DarkWalkerHeadTurret : public UUTSkelControl_TurretConstrained
{
public:
    //## BEGIN PROPS UTSkelControl_DarkWalkerHeadTurret
    FName FramePlayerName;
    class UUTAnimNodeFramePlayer* Player;
    //## END PROPS UTSkelControl_DarkWalkerHeadTurret

    DECLARE_CLASS(UUTSkelControl_DarkWalkerHeadTurret,UUTSkelControl_TurretConstrained,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_TurretMultiBone : public UUTSkelControl_TurretConstrained
{
public:
    //## BEGIN PROPS UTSkelControl_TurretMultiBone
    FName LeftTurretArmBone;
    INT LeftTurretArmIndex;
    FName RightTurretArmBone;
    INT RightTurretArmIndex;
    FName PivotUpBone;
    INT PivotUpIndex;
    FLOAT PivotUpPerc;
    FLOAT PivotDownPerc;
    BITFIELD bIndexCacheIsValid:1;
    FLOAT ConstraintPct;
    //## END PROPS UTSkelControl_TurretMultiBone

    DECLARE_CLASS(UUTSkelControl_TurretMultiBone,UUTSkelControl_TurretConstrained,0,UTGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_LockRotation : public USkelControlBase
{
public:
    //## BEGIN PROPS UTSkelControl_LockRotation
    BITFIELD bLockPitch:1;
    BITFIELD bLockYaw:1;
    BITFIELD bLockRoll:1;
    FRotator LockRotation;
    FRotator MaxDelta;
    BYTE LockRotationSpace;
    FName RotationSpaceBoneName;
    //## END PROPS UTSkelControl_LockRotation

    DECLARE_CLASS(UUTSkelControl_LockRotation,USkelControlBase,0,UTGame)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
};

class UUTSkelControl_MassBoneScaling : public USkelControlBase
{
public:
    //## BEGIN PROPS UTSkelControl_MassBoneScaling
    TArrayNoInit<FLOAT> BoneScales;
    //## END PROPS UTSkelControl_MassBoneScaling

    void SetBoneScale(FName BoneName,FLOAT Scale);
    FLOAT GetBoneScale(FName BoneName);
    DECLARE_FUNCTION(execSetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        SetBoneScale(BoneName,Scale);
    }
    DECLARE_FUNCTION(execGetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_FINISH;
        *(FLOAT*)Result=GetBoneScale(BoneName);
    }
    DECLARE_CLASS(UUTSkelControl_MassBoneScaling,USkelControlBase,0,UTGame)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
};

class UUTSkelControl_TankTread : public USkelControlBase
{
public:
    //## BEGIN PROPS UTSkelControl_TankTread
    FLOAT SpaceAbove;
    FLOAT SpaceBelow;
    FName TreadBone;
    INT TreadIndex;
    FLOAT CenterOffset;
    TArrayNoInit<FLOAT> AlternateScanOffsets;
    BITFIELD bAlwaysScan:1;
    FLOAT Adjustment;
    FLOAT TargetAdjustment;
    BITFIELD bInitialized:1;
    BITFIELD bDormant:1;
    BITFIELD bLastDirWasBackwards:1;
    //## END PROPS UTSkelControl_TankTread

    DECLARE_CLASS(UUTSkelControl_TankTread,USkelControlBase,0,UTGame)
	FLOAT CalcAdjustment(FVector TraceStart, FVector TraceEnd, FVector Offsets, AActor* Owner);
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
};

#endif

AUTOGENERATE_FUNCTION(UUTAnimBlendBase,-1,execGetAnimDuration);
AUTOGENERATE_FUNCTION(UUTAnimBlendBase,-1,execGetBlendTime);
AUTOGENERATE_FUNCTION(UUTAnimNodeFramePlayer,-1,execSetAnimPosition);
AUTOGENERATE_FUNCTION(UUTAnimNodeFramePlayer,-1,execSetAnimation);
AUTOGENERATE_FUNCTION(UUTAnimNodeJumpLeanOffset,-1,execSetLeanWeight);
AUTOGENERATE_FUNCTION(UUTAnimNodeSequence,-1,execPlayAnimationSet);
AUTOGENERATE_FUNCTION(UUTAnimNodeSequence,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(UUTSkelControl_MassBoneScaling,-1,execGetBoneScale);
AUTOGENERATE_FUNCTION(UUTSkelControl_MassBoneScaling,-1,execSetBoneScale);
AUTOGENERATE_FUNCTION(UUTSkelControl_RaptorWing,-1,execForceWingsUp);
AUTOGENERATE_FUNCTION(UUTSkelControl_RaptorWing,-1,execForceSingleWingUp);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_ANIMATION_NATIVE_DEFS
#define UTGAME_ANIMATION_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBase);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByCollision);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByDriving);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByFall);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboarding);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboardTilt);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverboardTurn);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByHoverJump);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByIdle);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPhysics);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPhysicsVolume);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByPosture);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBySlotActive);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendBySpeed);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByTurnInPlace);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByVehicle);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByWalkerState);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByWeapon);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimBlendByWeapType);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeCopyBoneTranslation);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeFramePlayer);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeJumpLeanOffset);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeSequence);
DECLARE_NATIVE_TYPE(UTGame,UUTAnimNodeSeqWeap);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_CantileverBeam);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_CicadaEngine);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_CoreSpin);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Damage);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_DamageHinge);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_DamageSpring);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_DarkWalkerHeadTurret);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardSuspension);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardSwing);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HoverboardVibration);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_HugGround);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_JetThruster);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_LockRotation);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_LookAt);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MantaBlade);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MantaFlaps);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_MassBoneScaling);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_NecrisRaptorWings);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Oscillate);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_RaptorTail);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_RaptorWing);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_Rotate);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_SpinControl);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_TankTread);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_TurretConstrained);
DECLARE_NATIVE_TYPE(UTGame,UUTSkelControl_TurretMultiBone);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_ANIMATION \
	UUTAnimBlendBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimBlendBaseNative; \
	UUTAnimBlendByCollision::StaticClass(); \
	UUTAnimBlendByDriving::StaticClass(); \
	UUTAnimBlendByFall::StaticClass(); \
	UUTAnimBlendByHoverboarding::StaticClass(); \
	UUTAnimBlendByHoverboardTilt::StaticClass(); \
	UUTAnimBlendByHoverboardTurn::StaticClass(); \
	UUTAnimBlendByHoverJump::StaticClass(); \
	UUTAnimBlendByIdle::StaticClass(); \
	UUTAnimBlendByPhysics::StaticClass(); \
	UUTAnimBlendByPhysicsVolume::StaticClass(); \
	UUTAnimBlendByPosture::StaticClass(); \
	UUTAnimBlendBySlotActive::StaticClass(); \
	UUTAnimBlendBySpeed::StaticClass(); \
	UUTAnimBlendByTurnInPlace::StaticClass(); \
	UUTAnimBlendByVehicle::StaticClass(); \
	UUTAnimBlendByWalkerState::StaticClass(); \
	UUTAnimBlendByWeapon::StaticClass(); \
	UUTAnimBlendByWeapType::StaticClass(); \
	UUTAnimNodeCopyBoneTranslation::StaticClass(); \
	UUTAnimNodeFramePlayer::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeFramePlayerNative; \
	UUTAnimNodeJumpLeanOffset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeJumpLeanOffsetNative; \
	UUTAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTAnimNodeSequenceNative; \
	UUTAnimNodeSeqWeap::StaticClass(); \
	UUTSkelControl_CantileverBeam::StaticClass(); \
	UUTSkelControl_CicadaEngine::StaticClass(); \
	UUTSkelControl_CoreSpin::StaticClass(); \
	UUTSkelControl_Damage::StaticClass(); \
	UUTSkelControl_DamageHinge::StaticClass(); \
	UUTSkelControl_DamageSpring::StaticClass(); \
	UUTSkelControl_DarkWalkerHeadTurret::StaticClass(); \
	UUTSkelControl_HoverboardSuspension::StaticClass(); \
	UUTSkelControl_HoverboardSwing::StaticClass(); \
	UUTSkelControl_HoverboardVibration::StaticClass(); \
	UUTSkelControl_HugGround::StaticClass(); \
	UUTSkelControl_JetThruster::StaticClass(); \
	UUTSkelControl_LockRotation::StaticClass(); \
	UUTSkelControl_LookAt::StaticClass(); \
	UUTSkelControl_MantaBlade::StaticClass(); \
	UUTSkelControl_MantaFlaps::StaticClass(); \
	UUTSkelControl_MassBoneScaling::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSkelControl_MassBoneScalingNative; \
	UUTSkelControl_NecrisRaptorWings::StaticClass(); \
	UUTSkelControl_Oscillate::StaticClass(); \
	UUTSkelControl_RaptorTail::StaticClass(); \
	UUTSkelControl_RaptorWing::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSkelControl_RaptorWingNative; \
	UUTSkelControl_Rotate::StaticClass(); \
	UUTSkelControl_SpinControl::StaticClass(); \
	UUTSkelControl_TankTread::StaticClass(); \
	UUTSkelControl_TurretConstrained::StaticClass(); \
	UUTSkelControl_TurretMultiBone::StaticClass(); \

#endif // UTGAME_ANIMATION_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UUTAnimBlendBase) GUTGameUUTAnimBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UUTAnimBlendBase,execGetAnimDuration)
	MAP_NATIVE(UUTAnimBlendBase,execGetBlendTime)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimBlendBase);

NATIVE_INFO(UUTAnimNodeFramePlayer) GUTGameUUTAnimNodeFramePlayerNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeFramePlayer,execSetAnimPosition)
	MAP_NATIVE(UUTAnimNodeFramePlayer,execSetAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeFramePlayer);

NATIVE_INFO(UUTAnimNodeJumpLeanOffset) GUTGameUUTAnimNodeJumpLeanOffsetNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeJumpLeanOffset,execSetLeanWeight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeJumpLeanOffset);

NATIVE_INFO(UUTAnimNodeSequence) GUTGameUUTAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UUTAnimNodeSequence,execPlayAnimationSet)
	MAP_NATIVE(UUTAnimNodeSequence,execPlayAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTAnimNodeSequence);

NATIVE_INFO(UUTSkelControl_MassBoneScaling) GUTGameUUTSkelControl_MassBoneScalingNatives[] = 
{ 
	MAP_NATIVE(UUTSkelControl_MassBoneScaling,execGetBoneScale)
	MAP_NATIVE(UUTSkelControl_MassBoneScaling,execSetBoneScale)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSkelControl_MassBoneScaling);

NATIVE_INFO(UUTSkelControl_RaptorWing) GUTGameUUTSkelControl_RaptorWingNatives[] = 
{ 
	MAP_NATIVE(UUTSkelControl_RaptorWing,execForceWingsUp)
	MAP_NATIVE(UUTSkelControl_RaptorWing,execForceSingleWingUp)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSkelControl_RaptorWing);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBase,BlendTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBase,SliderPosition)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBase)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByCollision,TraceSocket)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByCollision,LastHitLocation)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByCollision)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByDriving)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFall,PreLandTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByFall,CachedLeanNode)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByFall)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboarding,LastActiveChildIndex)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboarding,FallTimeBeforeAnim)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboarding)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTilt,UpVector)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTilt,TiltYScale)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboardTilt)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTurn,TurnScale)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverboardTurn,CurrentAnimWeight)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverboardTurn)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByHoverJump,OwnerUTP)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByHoverJump)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByIdle)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysics,PhysicsMap)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysics,PendingTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPhysics)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysicsVolume,PhysicsParamList)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByPhysicsVolume,LastPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByPosture)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySlotActive,ChildSlot)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBySlotActive)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySpeed,MinSpeed)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendBySpeed,MaxSpeed)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByTurnInPlace,RootYawSpeedThresh)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByTurnInPlace,OwnerUTP)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByTurnInPlace)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByVehicle,LastVehicle)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByVehicle)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByWalkerState)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByWeapon,LoopingAnim)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimBlendByWeapon,BlendTime)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByWeapon)
VERIFY_CLASS_SIZE_NODIE(UUTAnimBlendByWeapType)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeCopyBoneTranslation,CachedAimNode)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeCopyBoneTranslation,WeapTypeBlends)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeCopyBoneTranslation)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeFramePlayer)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeJumpLeanOffset,JumpLeanStrength)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeJumpLeanOffset,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeJumpLeanOffset)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSequence,SeqStack)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeSequence)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSeqWeap,DefaultAnim)
VERIFY_CLASS_OFFSET_NODIE(U,UTAnimNodeSeqWeap,StingerAnim)
VERIFY_CLASS_SIZE_NODIE(UUTAnimNodeSeqWeap)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CantileverBeam,WorldSpaceGoal)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CantileverBeam,__EntireBeamVelocity__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_CantileverBeam)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CicadaEngine,ForwardPitch)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CicadaEngine,DesiredPitch)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_CicadaEngine)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CoreSpin,DegreesPerSecondMax)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_CoreSpin,DegreesPerSecondMin)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_CoreSpin)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Damage,OwnerVehicle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Damage,OwnerVehicleMaxHealth)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Damage)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageHinge,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageHinge,SpringStiffness)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_DamageHinge)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageSpring,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DamageSpring,MomentumPortion)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_DamageSpring)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DarkWalkerHeadTurret,FramePlayerName)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_DarkWalkerHeadTurret,Player)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_DarkWalkerHeadTurret)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSuspension,TransIgnore)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSuspension,MaxRot)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardSuspension)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSwing,SwingScale)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardSwing,CurrentSwing)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardSwing)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardVibration,VibFrequency)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HoverboardVibration,VibInput)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HoverboardVibration)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HugGround,DesiredGroundDist)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_HugGround,LastUpdateTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_HugGround)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_JetThruster,MaxForwardVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_JetThruster,DesiredStrength)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_JetThruster)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LockRotation,LockRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LockRotation,RotationSpaceBoneName)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_LockRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LookAt,YawLimit)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_LookAt,RollLimit)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_LookAt)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaBlade,MaxRotationsPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaBlade,DesiredRotationsPerSecond)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MantaBlade)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaFlaps,maxPitch)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MantaFlaps,LeftFlapControl)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MantaFlaps)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_MassBoneScaling,BoneScales)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_MassBoneScaling)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_NecrisRaptorWings,TipSocket)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_NecrisRaptorWings,MinUpTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_NecrisRaptorWings)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Oscillate,MaxDelta)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Oscillate,CurrentTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Oscillate)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_RaptorTail,YawConstraint)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_RaptorTail,DesiredTailYaw)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_RaptorTail)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_RaptorWing,TipSockets)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_RaptorWing,MinUpTime)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_RaptorWing)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Rotate,DesiredBoneRotation)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_Rotate,DesiredBoneRotationRate)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_Rotate)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_SpinControl,DegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_SpinControl,Axis)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_SpinControl)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TankTread,SpaceAbove)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TankTread,TargetAdjustment)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_TankTread)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TurretConstrained,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TurretConstrained,__OnTurretStatusChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_TurretConstrained)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TurretMultiBone,LeftTurretArmBone)
VERIFY_CLASS_OFFSET_NODIE(U,UTSkelControl_TurretMultiBone,ConstraintPct)
VERIFY_CLASS_SIZE_NODIE(UUTSkelControl_TurretMultiBone)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
