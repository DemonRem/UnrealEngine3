/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)


#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(CustomActionFunc)
AUTOGENERATE_NAME(DelayedLeaveVehicle)
AUTOGENERATE_NAME(DelayedWarning)
AUTOGENERATE_NAME(ExecuteWhatToDoNext)
AUTOGENERATE_NAME(MayDodgeToMoveTarget)
AUTOGENERATE_NAME(MissedDodge)
AUTOGENERATE_NAME(MonitoredPawnAlert)
AUTOGENERATE_NAME(ReceiveRunOverWarning)
AUTOGENERATE_NAME(SetLeader)
AUTOGENERATE_NAME(SoakStop)
AUTOGENERATE_NAME(SpecialJumpCost)
AUTOGENERATE_NAME(SpecialJumpTo)
AUTOGENERATE_NAME(SuperDesireability)
AUTOGENERATE_NAME(TranslocateTo)
AUTOGENERATE_NAME(WhatToDoNext)

#ifndef NAMES_ONLY

struct FEnemyPosition
{
    FVector Position;
    FVector Velocity;
    FLOAT Time;
};

#define UCONST_AngleConvert 0.0000958738
#define UCONST_MINVIEWDIST 200
#define UCONST_MINSTRAFEDIST 200
#define UCONST_TACTICALHEIGHTADVANTAGE 320
#define UCONST_ENEMYLOCATIONFUZZ 1200
#define UCONST_MAXSTAKEOUTDIST 2000

struct UTBot_eventCustomActionFunc_Parms
{
    class AUTBot* B;
    UBOOL ReturnValue;
    UTBot_eventCustomActionFunc_Parms(EEventParm)
    {
    }
};
struct UTBot_eventSuperDesireability_Parms
{
    class APickupFactory* P;
    FLOAT ReturnValue;
    UTBot_eventSuperDesireability_Parms(EEventParm)
    {
    }
};
struct UTBot_eventMissedDodge_Parms
{
    UTBot_eventMissedDodge_Parms(EEventParm)
    {
    }
};
struct UTBot_eventReceiveRunOverWarning_Parms
{
    class AUTVehicle* V;
    FLOAT projSpeed;
    FVector VehicleDir;
    UTBot_eventReceiveRunOverWarning_Parms(EEventParm)
    {
    }
};
struct UTBot_eventDelayedWarning_Parms
{
    UTBot_eventDelayedWarning_Parms(EEventParm)
    {
    }
};
struct UTBot_eventSoakStop_Parms
{
    FString problem;
    UTBot_eventSoakStop_Parms(EEventParm)
    {
    }
};
struct UTBot_eventDelayedLeaveVehicle_Parms
{
    UTBot_eventDelayedLeaveVehicle_Parms(EEventParm)
    {
    }
};
struct UTBot_eventExecuteWhatToDoNext_Parms
{
    UTBot_eventExecuteWhatToDoNext_Parms(EEventParm)
    {
    }
};
struct UTBot_eventWhatToDoNext_Parms
{
    UTBot_eventWhatToDoNext_Parms(EEventParm)
    {
    }
};
struct UTBot_eventSpecialJumpTo_Parms
{
    class AActor* DestinationActor;
    FLOAT RequiredJumpZ;
    UTBot_eventSpecialJumpTo_Parms(EEventParm)
    {
    }
};
struct UTBot_eventSpecialJumpCost_Parms
{
    FLOAT RequiredJumpZ;
    FLOAT Cost;
    UBOOL ReturnValue;
    UTBot_eventSpecialJumpCost_Parms(EEventParm)
    {
    }
};
struct UTBot_eventTranslocateTo_Parms
{
    class AActor* DestinationActor;
    UTBot_eventTranslocateTo_Parms(EEventParm)
    {
    }
};
struct UTBot_eventMayDodgeToMoveTarget_Parms
{
    UTBot_eventMayDodgeToMoveTarget_Parms(EEventParm)
    {
    }
};
struct UTBot_eventMonitoredPawnAlert_Parms
{
    UTBot_eventMonitoredPawnAlert_Parms(EEventParm)
    {
    }
};
class AUTBot : public AAIController
{
public:
    //## BEGIN PROPS UTBot
    FLOAT WarningDelay;
    class AProjectile* WarningProjectile;
    FVector MonitorStartLoc;
    class APawn* MonitoredPawn;
    FLOAT MonitorMaxDistSq;
    FVector LastSeenPos;
    FVector LastSeeingPos;
    FLOAT LastSeenTime;
    FLOAT LastWarningTime;
    BITFIELD bHuntPlayer:1;
    BITFIELD bEnemyInfoValid:1;
    BITFIELD bCanFire:1;
    BITFIELD bStrafeDir:1;
    BITFIELD bLeadTarget:1;
    BITFIELD bChangeDir:1;
    BITFIELD bFrustrated:1;
    BITFIELD bInitLifeMessage:1;
    BITFIELD bReachedGatherPoint:1;
    BITFIELD bHasTranslocator:1;
    BITFIELD bTacticalDoubleJump:1;
    BITFIELD bWasNearObjective:1;
    BITFIELD bHasFired:1;
    BITFIELD bForcedDirection:1;
    BITFIELD bFireSuccess:1;
    BITFIELD bStoppedFiring:1;
    BITFIELD bTranslocatorHop:1;
    BITFIELD bMustCharge:1;
    BITFIELD bPursuingFlag:1;
    BITFIELD bJustLanded:1;
    BITFIELD bRecommendFastMove:1;
    BITFIELD bInstantAck:1;
    BITFIELD bIgnoreEnemyChange:1;
    BITFIELD bHasSuperWeapon:1;
    BITFIELD bPlannedJump:1;
    BITFIELD bPendingDoubleJump:1;
    BITFIELD bAllowedToImpactJump:1;
    BITFIELD bInDodgeMove:1;
    BITFIELD bAllowedToTranslocate:1;
    BITFIELD bJumpOverWall:1;
    BITFIELD bEnemyAcquired:1;
    BITFIELD bScriptedFrozen:1;
    BITFIELD bSpawnedByKismet:1;
    BITFIELD bScriptSpecialJumpCost:1;
    BITFIELD bUsingSquadRoute:1;
    BITFIELD bUsePreviousSquadRoute:1;
    BITFIELD bExecutingWhatToDoNext:1;
    BITFIELD bEnemyIsVisible:1;
    BITFIELD bNeedDelayedLeaveVehicle:1;
    INT AcquisitionYawRate;
    FLOAT DodgeLandZ;
    class AActor* ImpactTarget;
    FLOAT ImpactJumpZ;
    class AActor* TranslocationTarget;
    FLOAT TranslocFreq;
    FLOAT NextTranslocTime;
    FLOAT MultiJumpZ;
    FLOAT MaxSpecialJumpZ;
    FName OldMessageType;
    INT OldMessageID;
    FVector HidingSpot;
    FLOAT Aggressiveness;
    FLOAT LastAttractCheck;
    class ANavigationPoint* BlockedPath;
    FLOAT AcquireTime;
    FLOAT Aggression;
    FLOAT LoseEnemyCheckTime;
    class AActor* StartleActor;
    FLOAT StartTacticalTime;
    FLOAT LastUnderFire;
    FLOAT BaseAlertness;
    FLOAT Accuracy;
    FLOAT BaseAggressiveness;
    FLOAT StrafingAbility;
    FLOAT CombatStyle;
    FLOAT Tactics;
    FLOAT TranslocUse;
    FLOAT ReactionTime;
    FLOAT Jumpiness;
    class UClass* FavoriteWeapon;
    FLOAT DodgeToGoalPct;
    FLOAT OldMessageTime;
    FStringNoInit GoalString;
    FStringNoInit SoakString;
    class AUTSquadAI* Squad;
    class AUTBot* NextSquadMember;
    class ANavigationPoint* SquadRouteGoal;
    FLOAT ReTaskTime;
    class AUTDefensePoint* DefensePoint;
    class ANavigationPoint* DefensivePosition;
    class AUTVehicle* FormerVehicle;
    class AActor* NoVehicleGoal;
    class AVehicle* LastBlockingVehicle;
    FVector DirectionHint;
    FLOAT StopStartTime;
    FLOAT LastRespawnTime;
    FLOAT FailedHuntTime;
    class APawn* FailedHuntEnemy;
    FLOAT EnemyVisibilityTime;
    class APawn* VisibleEnemy;
    FLOAT LastSearchTime;
    FLOAT LastSearchWeight;
    FLOAT CampTime;
    INT LastTaunt;
    INT NumRandomJumps;
    FLOAT LastFireAttempt;
    FLOAT GatherTime;
    FName OrderNames[16];
    FName OldOrders;
    class AController* OldOrderGiver;
    FLOAT TrackingReactionTime;
    FLOAT BaseTrackingReactionTime;
    class APawn* CurrentlyTrackedEnemy;
    FVector TrackedVelocity;
    TArrayNoInit<struct FEnemyPosition> SavedPositions;
    FVector LastKnownPosition;
    FVector LastKillerPosition;
    class AUTAvoidMarker* FearSpots[2];
    FVector ImpactVelocity;
    class AActor* ScriptedTarget;
    BYTE ScriptedFireMode;
    class UUTBotDecisionComponent* DecisionComponent;
    FScriptDelegate __CustomActionFunc__Delegate;
    //## END PROPS UTBot

    void WaitToSeeEnemy();
    void LatentWhatToDoNext();
    UBOOL CanMakePathTo(class AActor* A);
    class AActor* FindBestInventoryPath(FLOAT& MinWeight);
    class AActor* FindPathToSquadRoute(UBOOL bWeightDetours=0);
    void BuildSquadRoute(INT Iterations);
    virtual class AActor* FindBestSuperPickup(FLOAT MaxDist);
    DECLARE_FUNCTION(execWaitToSeeEnemy)
    {
        P_FINISH;
        WaitToSeeEnemy();
    }
    DECLARE_FUNCTION(execLatentWhatToDoNext)
    {
        P_FINISH;
        LatentWhatToDoNext();
    }
    DECLARE_FUNCTION(execCanMakePathTo)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=CanMakePathTo(A);
    }
    DECLARE_FUNCTION(execFindBestInventoryPath)
    {
        P_GET_FLOAT_REF(MinWeight);
        P_FINISH;
        *(class AActor**)Result=FindBestInventoryPath(MinWeight);
    }
    DECLARE_FUNCTION(execFindPathToSquadRoute)
    {
        P_GET_UBOOL_OPTX(bWeightDetours,0);
        P_FINISH;
        *(class AActor**)Result=FindPathToSquadRoute(bWeightDetours);
    }
    DECLARE_FUNCTION(execBuildSquadRoute)
    {
        P_GET_INT(Iterations);
        P_FINISH;
        BuildSquadRoute(Iterations);
    }
    DECLARE_FUNCTION(execFindBestSuperPickup)
    {
        P_GET_FLOAT(MaxDist);
        P_FINISH;
        *(class AActor**)Result=FindBestSuperPickup(MaxDist);
    }
    UBOOL delegateCustomActionFunc(class AUTBot* B)
    {
        UTBot_eventCustomActionFunc_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.B=B;
        ProcessDelegate(UTGAME_CustomActionFunc,&__CustomActionFunc__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventSuperDesireability(class APickupFactory* P)
    {
        UTBot_eventSuperDesireability_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(UTGAME_SuperDesireability),&Parms);
        return Parms.ReturnValue;
    }
    void eventMissedDodge()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_MissedDodge),NULL);
    }
    void eventReceiveRunOverWarning(class AUTVehicle* V,FLOAT projSpeed,FVector VehicleDir)
    {
        UTBot_eventReceiveRunOverWarning_Parms Parms(EC_EventParm);
        Parms.V=V;
        Parms.projSpeed=projSpeed;
        Parms.VehicleDir=VehicleDir;
        ProcessEvent(FindFunctionChecked(UTGAME_ReceiveRunOverWarning),&Parms);
    }
    void eventDelayedWarning()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_DelayedWarning),NULL);
    }
    void eventSoakStop(const FString& problem)
    {
        UTBot_eventSoakStop_Parms Parms(EC_EventParm);
        Parms.problem=problem;
        ProcessEvent(FindFunctionChecked(UTGAME_SoakStop),&Parms);
    }
    void eventDelayedLeaveVehicle()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_DelayedLeaveVehicle),NULL);
    }
    void eventExecuteWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_ExecuteWhatToDoNext),NULL);
    }
    void eventWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_WhatToDoNext),NULL);
    }
    void eventSpecialJumpTo(class AActor* DestinationActor,FLOAT RequiredJumpZ)
    {
        UTBot_eventSpecialJumpTo_Parms Parms(EC_EventParm);
        Parms.DestinationActor=DestinationActor;
        Parms.RequiredJumpZ=RequiredJumpZ;
        ProcessEvent(FindFunctionChecked(UTGAME_SpecialJumpTo),&Parms);
    }
    UBOOL eventSpecialJumpCost(FLOAT RequiredJumpZ,FLOAT& Cost)
    {
        UTBot_eventSpecialJumpCost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.RequiredJumpZ=RequiredJumpZ;
        Parms.Cost=Cost;
        ProcessEvent(FindFunctionChecked(UTGAME_SpecialJumpCost),&Parms);
        Cost=Parms.Cost;
        return Parms.ReturnValue;
    }
    void eventTranslocateTo(class AActor* DestinationActor)
    {
        UTBot_eventTranslocateTo_Parms Parms(EC_EventParm);
        Parms.DestinationActor=DestinationActor;
        ProcessEvent(FindFunctionChecked(UTGAME_TranslocateTo),&Parms);
    }
    void eventMayDodgeToMoveTarget()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_MayDodgeToMoveTarget),NULL);
    }
    void eventMonitoredPawnAlert()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_MonitoredPawnAlert),NULL);
    }
    DECLARE_CLASS(AUTBot,AAIController,0,UTGame)
	DECLARE_FUNCTION(execPollWaitToSeeEnemy);
	DECLARE_FUNCTION(execPollLatentWhatToDoNext);
	UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	virtual void UpdateEnemyInfo(APawn* AcquiredEnemy);
	virtual void PostPollMove();
	void CheckFears();
	virtual void PreAirSteering(float DeltaTime);
	virtual void PostAirSteering(float DeltaTime);
	virtual void PostPhysFalling(float DeltaTime);
	virtual UBOOL AirControlFromWall(float DeltaTime, FVector& RealAcceleration);
	virtual UReachSpec* PrepareForMove(ANavigationPoint *NavGoal, UReachSpec* CurrentPath);
	virtual void JumpOverWall(FVector WallNormal);
	virtual void NotifyJumpApex();
	virtual FRotator SetRotationRate(FLOAT deltaTime);
	virtual DWORD LineOfSightTo(AActor *Other, INT bUseLOSFlag=0, FVector *chkLocation = NULL);
	FLOAT SpecialJumpCost(FLOAT RequiredJumpZ);
	virtual UBOOL ForceReached(ANavigationPoint *Nav, const FVector& TestPosition);
	virtual void UpdatePawnRotation();
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
};

#define UCONST_NEAROBJECTIVEDIST 2000.0

struct UTSquadAI_eventSetLeader_Parms
{
    class AController* C;
    UTSquadAI_eventSetLeader_Parms(EEventParm)
    {
    }
};
class AUTSquadAI : public AReplicationInfo
{
public:
    //## BEGIN PROPS UTSquadAI
    class AUTTeamInfo* Team;
    class AController* SquadLeader;
    class AUTPlayerReplicationInfo* LeaderPRI;
    class AUTSquadAI* NextSquad;
    class AUTGameObjective* SquadObjective;
    INT Size;
    class AUTBot* SquadMembers;
    FStringNoInit SupportString;
    FStringNoInit DefendString;
    FStringNoInit AttackString;
    FStringNoInit HoldString;
    FStringNoInit FreelanceString;
    FStringNoInit SupportStringTrailer;
    FName CurrentOrders;
    class APawn* Enemies[8];
    INT MaxSquadSize;
    BITFIELD bFreelance:1;
    BITFIELD bFreelanceAttack:1;
    BITFIELD bFreelanceDefend:1;
    BITFIELD bRoamingSquad:1;
    BITFIELD bAddTransientCosts:1;
    FLOAT FormationSize;
    FLOAT GatherThreshold;
    class ANavigationPoint* RouteObjective;
    TArrayNoInit<class ANavigationPoint*> ObjectiveRouteCache;
    TArrayNoInit<class ANavigationPoint*> PreviousObjectiveRouteCache;
    class AUTBot* PendingSquadRouteMaker;
    //## END PROPS UTSquadAI

    void eventSetLeader(class AController* C)
    {
        UTSquadAI_eventSetLeader_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(UTGAME_SetLeader),&Parms);
    }
    DECLARE_CLASS(AUTSquadAI,AReplicationInfo,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(AUTSquadAI)
};

class UUTBotDecisionComponent : public UActorComponent
{
public:
    //## BEGIN PROPS UTBotDecisionComponent
    BITFIELD bTriggered:1 GCC_BITFIELD_MAGIC;
    //## END PROPS UTBotDecisionComponent

    DECLARE_CLASS(UUTBotDecisionComponent,UActorComponent,0,UTGame)
	virtual void Tick(FLOAT DeltaTime);
};

#endif

AUTOGENERATE_FUNCTION(AUTBot,-1,execFindBestSuperPickup);
AUTOGENERATE_FUNCTION(AUTBot,-1,execBuildSquadRoute);
AUTOGENERATE_FUNCTION(AUTBot,-1,execFindPathToSquadRoute);
AUTOGENERATE_FUNCTION(AUTBot,-1,execFindBestInventoryPath);
AUTOGENERATE_FUNCTION(AUTBot,-1,execCanMakePathTo);
AUTOGENERATE_FUNCTION(AUTBot,-1,execLatentWhatToDoNext);
AUTOGENERATE_FUNCTION(AUTBot,-1,execWaitToSeeEnemy);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_AI_NATIVE_DEFS
#define UTGAME_AI_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,AUTBot);
DECLARE_NATIVE_TYPE(UTGame,UUTBotDecisionComponent);
DECLARE_NATIVE_TYPE(UTGame,AUTSquadAI);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_AI \
	AUTBot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameAUTBotNative; \
	UUTBotDecisionComponent::StaticClass(); \
	AUTSquadAI::StaticClass(); \

#endif // UTGAME_AI_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AUTBot) GUTGameAUTBotNatives[] = 
{ 
	MAP_NATIVE(AUTBot,execFindBestSuperPickup)
	MAP_NATIVE(AUTBot,execBuildSquadRoute)
	MAP_NATIVE(AUTBot,execFindPathToSquadRoute)
	MAP_NATIVE(AUTBot,execFindBestInventoryPath)
	MAP_NATIVE(AUTBot,execCanMakePathTo)
	MAP_NATIVE(AUTBot,execLatentWhatToDoNext)
	MAP_NATIVE(AUTBot,execWaitToSeeEnemy)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,AUTBot);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,UTBot,WarningDelay)
VERIFY_CLASS_OFFSET_NODIE(A,UTBot,__CustomActionFunc__Delegate)
VERIFY_CLASS_SIZE_NODIE(AUTBot)
VERIFY_CLASS_SIZE_NODIE(UUTBotDecisionComponent)
VERIFY_CLASS_OFFSET_NODIE(A,UTSquadAI,Team)
VERIFY_CLASS_OFFSET_NODIE(A,UTSquadAI,PendingSquadRouteMaker)
VERIFY_CLASS_SIZE_NODIE(AUTSquadAI)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
