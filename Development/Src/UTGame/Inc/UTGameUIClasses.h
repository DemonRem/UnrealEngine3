/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum EMissionResult
{
    EMResult_Any            =0,
    EMResult_Won            =1,
    EMResult_Lost           =2,
    EMResult_MAX            =3,
};
enum EUTOptionType
{
    UTOT_ComboReadOnly      =0,
    UTOT_ComboNumeric       =1,
    UTOT_CheckBox           =2,
    UTOT_Slider             =3,
    UTOT_Spinner            =4,
    UTOT_EditBox            =5,
    UTOT_MAX                =6,
};
enum EAnimPropType
{
    EAPT_None               =0,
    EAPT_PositionLeft       =1,
    EAPT_PositionTop        =2,
    EAPT_MAX                =3,
};
enum EStatusIconState
{
    ESIS_Normal             =0,
    ESIS_Elevated           =1,
    ESIS_Critical           =2,
    ESIS_MAX                =3,
};
enum EGroupStatus
{
    EGS_Uninitialized       =0,
    EGS_NoWeapons           =1,
    EGS_AmmoOnly            =2,
    EGS_Weapons             =3,
    EGS_MAX                 =4,
};
enum EOptionButtonArrow
{
    OPTBUT_ArrowLeft        =0,
    OPTBUT_ArrowRight       =1,
    OPTBUT_MAX              =2,
};
enum EUTRecordDemo
{
    UTRecordDemo_No         =0,
    UTRecordDemo_Yes        =1,
    UTRecordDemo_MAX        =2,
};
enum EUTBotTeam
{
    UTBotTeam_Random        =0,
    UTBotTeam_Ironguard     =1,
    UTBotTeam_TwinSouls     =2,
    UTBotTeam_Krall         =3,
    UTBotTeam_Liandri       =4,
    UTBotTeam_Necris        =5,
    UTBotTeam_MAX           =6,
};
enum EUTPlatform
{
    UTPlatform_PC           =0,
    UTPlatform_360          =1,
    UTPlatform_PS3          =2,
    UTPlatform_MAX          =3,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AddItem)
AUTOGENERATE_NAME(CanPlayOnline)
AUTOGENERATE_NAME(DrawDelegate)
AUTOGENERATE_NAME(DrawPanel)
AUTOGENERATE_NAME(Empty)
AUTOGENERATE_NAME(FadeTo)
AUTOGENERATE_NAME(Finish)
AUTOGENERATE_NAME(GetCurrentValue)
AUTOGENERATE_NAME(GetCurrentValueIndex)
AUTOGENERATE_NAME(ImportStringList)
AUTOGENERATE_NAME(InsertItem)
AUTOGENERATE_NAME(IsLoggedIn)
AUTOGENERATE_NAME(Num)
AUTOGENERATE_NAME(OnAnimationFinished)
AUTOGENERATE_NAME(OnClosed)
AUTOGENERATE_NAME(OnDrawItem)
AUTOGENERATE_NAME(OnHideAnimationEnded)
AUTOGENERATE_NAME(OnHideComplete)
AUTOGENERATE_NAME(OnItemChosen)
AUTOGENERATE_NAME(OnMBInputKey)
AUTOGENERATE_NAME(OnMoveSelectionLeft)
AUTOGENERATE_NAME(OnMoveSelectionRight)
AUTOGENERATE_NAME(OnSceneTransitionFinished)
AUTOGENERATE_NAME(OnSelection)
AUTOGENERATE_NAME(OnSelectionChange)
AUTOGENERATE_NAME(OnShowAnimationEnded)
AUTOGENERATE_NAME(OnShowComplete)
AUTOGENERATE_NAME(PlayerOwnerIsSpectating)
AUTOGENERATE_NAME(PlayNextTeaser)
AUTOGENERATE_NAME(RemoveItem)
AUTOGENERATE_NAME(RemoveString)
AUTOGENERATE_NAME(SelectItem)
AUTOGENERATE_NAME(SetCurrentValueIndex)
AUTOGENERATE_NAME(SetOpacity)
AUTOGENERATE_NAME(SizeList)
AUTOGENERATE_NAME(SupportedByCurrentGameMode)
AUTOGENERATE_NAME(SupportsCurrentGameMode)
AUTOGENERATE_NAME(TickScene)
AUTOGENERATE_NAME(WidgetTick)

#ifndef NAMES_ONLY

struct FDamageInfo
{
    FLOAT FadeTime;
    FLOAT FadeValue;
    class UMaterialInstanceConstant* MatConstant;
};

struct FPowerupSlotData
{
    class AUTTimedPowerup* Powerup;
    BITFIELD bTransitionIn:1;
    FLOAT TransitionTime;
};

class AUTHUD : public AHUD
{
public:
    //## BEGIN PROPS UTHUD
    TArrayNoInit<class AActor*> PostRenderedActors;
    class UTexture2D* HudTexture;
    class UTexture2D* AltHudTexture;
    FLinearColor LC_White;
    FLOAT LastPickupTime;
    FLOAT LastAmmoPickupTime;
    FLOAT LastWeaponPickupTime;
    FLOAT LastHealthPickupTime;
    FLOAT LastArmorPickupTime;
    class APawn* PawnOwner;
    class AUTPawn* UTPawnOwner;
    class AUTPlayerController* UTPlayerOwner;
    class AUTPlayerReplicationInfo* UTOwnerPRI;
    BITFIELD bCrosshairShow:1;
    BITFIELD bShowAllAI:1;
    BITFIELD bHudMessageRendered:1;
    BITFIELD bCrosshairOnFriendly:1;
    BITFIELD bShowWeaponbar:1;
    BITFIELD bShowOnlyAvailableWeapons:1;
    BITFIELD bOnlyShowWeaponBarIfChanging:1;
    BITFIELD bNoWeaponNumbers:1;
    BITFIELD bFadeOutHitEffect:1;
    BITFIELD bShowClock:1;
    BITFIELD bShowDoll:1;
    BITFIELD bShowAmmo:1;
    BITFIELD bShowMap:1;
    BITFIELD bShowPowerups:1;
    BITFIELD bShowScoring:1;
    BITFIELD bShowFragCount:1;
    BITFIELD bShowLeaderboard:1;
    BITFIELD bShowVehicle:1;
    BITFIELD bShowDamage:1;
    class AUTGameReplicationInfo* UTGRI;
    FLOAT ResolutionScale;
    class UUTUIScene_Scoreboard* ScoreboardSceneTemplate;
    class UUTUIScene_Scoreboard* ScoreboardScene;
    class UClass* MusicManagerClass;
    TArrayNoInit<class UFont*> HudFonts;
    class UMaterial* CharPortraitMaterial;
    class UMaterialInstanceConstant* CharPortraitMI;
    FLOAT CharPortraitYPerc;
    FLOAT CharPortraitXPerc;
    FLOAT CharPortraitTime;
    FLOAT CharPortraitSlideTime;
    FLOAT CharPortraitSlideTransitionTime;
    FVector2D CharPortraitSize;
    class AUTPlayerReplicationInfo* CharPRI;
    class AUTPlayerReplicationInfo* CharPendingPRI;
    FLOAT WeaponBarScale;
    FLOAT WeaponBoxWidth;
    FLOAT WeaponBoxHeight;
    FLOAT HUDScaleX;
    FLOAT HUDScaleY;
    FLinearColor TeamHUDColor;
    FColor TeamColor;
    FColor TeamTextColor;
    FLOAT WeaponBarY;
    class AUTWeapon* WeaponList[10];
    FLOAT CurrentWeaponScale[10];
    FLOAT SelectedWeaponScale;
    FLOAT BounceWeaponScale;
    FLOAT SelectedWeaponAlpha;
    FLOAT OffWeaponAlpha;
    FLOAT EmptyWeaponAlpha;
    FLOAT LastHUDUpdateTime;
    INT BouncedWeapon;
    FLOAT WeaponScaleSpeed;
    FLOAT WeaponBarXOffset;
    FLOAT WeaponXOffset;
    FLOAT SelectedBoxScale;
    FLOAT WeaponYScale;
    FLOAT WeaponYOffset;
    FLOAT WeaponAmmoLength;
    FLOAT WeaponAmmoThickness;
    FLOAT WeaponAmmoOffsetX;
    FLOAT WeaponAmmoOffsetY;
    FLOAT SelectedWeaponAmmoOffsetX;
    FLOAT LastWeaponBarDrawnTime;
    class UUTUIScene_MOTD* MOTDSceneTemplate;
    FLOAT MessageOffset[7];
    FColor BlackColor;
    FColor GoldColor;
    class UTexture2D* MapBackground;
    FLOAT MapDefaultSize;
    FStringNoInit DisplayedOrders;
    class AWeapon* LastSelectedWeapon;
    class UFont* GlowFonts[2];
    FLOAT SafeRegionPct;
    FLOAT FullWidth;
    FLOAT FullHeight;
    INT MaxNoOfIndicators;
    TArrayNoInit<struct FDamageInfo> DamageData;
    class UMaterial* BaseMaterial;
    FLOAT FadeTime;
    FName PositionalParamName;
    FName FadeParamName;
    FLOAT MaxHitEffectIntensity;
    FLinearColor MaxHitEffectColor;
    FLOAT HitEffectFadeTime;
    class UMaterialEffect* HitEffect;
    class UMaterialInstanceConstant* HitEffectMaterialInstance;
    FVector2D ClockPosition;
    FVector2D DollPosition;
    INT LastHealth;
    FLOAT HealthPulseTime;
    INT LastArmorAmount;
    FLOAT ArmorPulseTime;
    FVector2D AmmoPosition;
    class AUTWeapon* LastWeapon;
    INT LastAmmoCount;
    FLOAT AmmoPulseTime;
    FVector2D MapPosition;
    FVector2D PowerupDims;
    FLOAT PowerupTransitionTime;
    struct FPowerupSlotData PowerupSlots[4];
    FVector2D ScoringPosition;
    FLOAT FragPulseTime;
    INT LastFragCount;
    FVector2D VehiclePosition;
    FLOAT DamageIndicatorSize;
    FLOAT PulseDuration;
    FLOAT PulseSplit;
    FLOAT PulseMultiplier;
    FStringNoInit WarmupString;
    FStringNoInit WaitingForMatch;
    FStringNoInit SpectatorMessage;
    FStringNoInit DeadMessage;
    FStringNoInit FireToRespawnMessage;
    FStringNoInit YouHaveWon;
    FStringNoInit YouHaveLost;
    FStringNoInit ConstructioningMessage;
    FStringNoInit BoostMessage;
    FStringNoInit EjectMessage;
    FStringNoInit PlaceMarks[4];
    FLOAT THeight;
    FLOAT TX;
    FLOAT TY;
    //## END PROPS UTHUD

    virtual void DrawGlowText(const FString& Text,FLOAT X,FLOAT Y,FLOAT MaxHeightInPixels=0.000000,FLOAT PulseScale=1.000000,UBOOL bRightJustified=0);
    virtual void LinkToHudScene();
    DECLARE_FUNCTION(execDrawGlowText)
    {
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT_OPTX(MaxHeightInPixels,0.000000);
        P_GET_FLOAT_OPTX(PulseScale,1.000000);
        P_GET_UBOOL_OPTX(bRightJustified,0);
        P_FINISH;
        DrawGlowText(Text,X,Y,MaxHeightInPixels,PulseScale,bRightJustified);
    }
    DECLARE_FUNCTION(execLinkToHudScene)
    {
        P_FINISH;
        LinkToHudScene();
    }
    DECLARE_CLASS(AUTHUD,AHUD,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(AUTHUD)
};

class UUIComp_DrawTeamColoredImage : public UUIComp_DrawImage
{
public:
    //## BEGIN PROPS UIComp_DrawTeamColoredImage
    TArrayNoInit<FLinearColor> TeamColors;
    INT EditorTeamIndex;
    //## END PROPS UIComp_DrawTeamColoredImage

    DECLARE_CLASS(UUIComp_DrawTeamColoredImage,UUIComp_DrawImage,0,UTGame)
	virtual void RenderComponent( class FCanvas* Canvas, FRenderParameters Parameters );
};

class UUIComp_UTDrawStateImage : public UUIComp_DrawImage
{
public:
    //## BEGIN PROPS UIComp_UTDrawStateImage
    class UClass* ImageState;
    //## END PROPS UIComp_UTDrawStateImage

    DECLARE_CLASS(UUIComp_UTDrawStateImage,UUIComp_DrawImage,0,UTGame)
 	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the component's image.
	 */
	void RefreshAppliedStyleData();
};

class UUIComp_UTGlowString : public UUIComp_DrawString
{
public:
    //## BEGIN PROPS UIComp_UTGlowString
    struct FUIStyleReference GlowStyle;
    //## END PROPS UIComp_UTGlowString

    DECLARE_CLASS(UUIComp_UTGlowString,UUIComp_DrawString,0,UTGame)
	/* === UUIComp_DrawString interface === */
	/**
	 * Returns the combo style data being used by this string rendering component.  If the component's StringStyle is not set, the style data
	 * will be pulled from the owning widget's PrimaryStyle, if possible.
	 *
	 * This version resolves the additional style reference property declared by the UTGlowString component.
	 *
	 * @param	DesiredMenuState	the menu state for the style data to retrieve; if not specified, uses the owning widget's current menu state.
	 * @param	SourceSkin			the skin to use for resolving this component's combo style; only relevant when the component's combo style is invalid
	 *								(or if TRUE is passed for bClearExistingValue). If the combo style is invalid and a value is not specified, returned value
	 *								will be NULL.
	 * @param	bClearExistingValue	used to force the component's combo style to be re-resolved from the specified skin; if TRUE, you must supply a valid value for
	 *								SourceSkin.
	 *
	 * @return	the combo style data used to render this component's string for the specified menu state.
	 */
	virtual class UUIStyle_Combo* GetAppliedStringStyle( class UUIState* DesiredMenuState=NULL, class UUISkin* SourceSkin=NULL, UBOOL bClearExistingValue=FALSE );

	/**
	 * Resolves the glow style for this string rendering component.
	 *
	 * @param	ActiveSkin			the skin the use for resolving the style reference.
	 * @param	bClearExistingValue	if TRUE, style references will be invalidated first.
	 * @param	CurrentMenuState	the menu state to use for resolving the style data; if not specified, uses the current
	 *								menu state of the owning widget.
	 * @param	StyleProperty		if specified, only the style reference corresponding to the specified property
	 *								will be resolved; otherwise, all style references will be resolved.
	 */
	virtual UBOOL NotifyResolveStyle(class UUISkin* ActiveSkin,UBOOL bClearExistingValue,class UUIState* CurrentMenuState=NULL,const FName StylePropertyName=NAME_None);

protected:
	/**
	 * We override InternalRender_String so that we can render twice.  Once with the glow style, once with the normal
	 * style
	 *
	 * @param	Canvas	the canvas to use for rendering this string
	 */
	virtual void InternalRender_String( FCanvas* Canvas, FRenderParameters& Parameters );
};

struct FPrefabMarkupReplace
{
    FName WidgetTag;
    FName CellTag;
};

struct FInstancedPrefabInfo
{
    class UUIPrefabInstance* PrefabInstance;
    TArrayNoInit<class UUIObject*> ResolvedObjects;

    /** Constructors */
    FInstancedPrefabInfo() {}
    FInstancedPrefabInfo(EEventParm)
    {
        appMemzero(this, sizeof(FInstancedPrefabInfo));
    }
};

class UUIComp_UTUIMenuListPresenter : public UUIComp_ListPresenter
{
public:
    //## BEGIN PROPS UIComp_UTUIMenuListPresenter
    INT SelectedItemHeight;
    class UUIPrefab* SelectedItemPrefab;
    class UUIPrefab* NormalItemPrefab;
    TArrayNoInit<struct FPrefabMarkupReplace> PrefabMarkupReplaceList;
    TArrayNoInit<struct FInstancedPrefabInfo> InstancedPrefabs;
    //## END PROPS UIComp_UTUIMenuListPresenter

    DECLARE_CLASS(UUIComp_UTUIMenuListPresenter,UUIComp_ListPresenter,0,UTGame)
	friend class UUIList;

	/**
	 * Initializes the component's prefabs.
	 */
	virtual void InitializePrefabs();

	/**
	 * Renders the elements in this list.
	 *
	 * @param	RI					the render interface to use for rendering
	 */
	virtual void Render_List( FCanvas* Canvas );

	/**
	 * Renders the list element specified.
	 *
	 * @param	Canvas			the canvas to use for rendering
	 * @param	ElementIndex	the index for the list element to render
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in]	specifies the pixel location of the start of the horizontal bounding region that should be used for
	 *												rendering this element
	 *										[out]	unused
	 *							DrawY:		[in]	specifies the pixel Y location of the bounding region that should be used for rendering this list element.
	 *										[out]	Will be set to the Y position of the rendering "pen" after rendering this element.  This is the Y position for rendering
	 *												the next element should be rendered
	 *							DrawXL:		[in]	specifies the pixel location of the end of the horizontal bounding region that should be used for rendering this element.
	 *										[out]	unused
	 *							DrawYL:		[in]	specifies the height of the bounding region, in pixels.  If this value is not large enough to render the specified element,
	 *												the element will not be rendered.
	 *										[out]	Will be reduced by the height of the element that was rendered. Thus represents the "remaining" height available for rendering.
	 *							DrawFont:	[in]	specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in]	specifies the amount of scaling to apply when rendering the element
	 */
	void Render_ListElement( FCanvas* Canvas, INT ElementIndex, FRenderParameters& Parameters );

	/**
	 * Called when a member property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Updates the prefab widgets we are dynamically changing the markup of to use a new list row for their datasource.
	 *
	 * @param NewIndex	New list row index to rebind the widgets with.
	 */
	virtual void UpdatePrefabMarkup();

	/** Updates the position of the selected item prefab. */
	virtual void UpdatePrefabPosition();
};

struct FEMissionCondition
{
    BYTE MissionResult;
    FStringNoInit ConditionDesc;
    TArrayNoInit<BYTE> RequiredPersistentKeys;
    TArrayNoInit<BYTE> RestrictedPersistentKeys;

    /** Constructors */
    FEMissionCondition() {}
    FEMissionCondition(EEventParm)
    {
        appMemzero(this, sizeof(FEMissionCondition));
    }
};

struct FEMissionTeaserInfo
{
    class UTexture2D* Portrait;
    struct FTextureCoordinates PortraitUVs;
    class USoundCue* Audio;
    FStringNoInit Text;
    FLOAT MinPlaybackDuration;

    /** Constructors */
    FEMissionTeaserInfo() {}
    FEMissionTeaserInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEMissionTeaserInfo));
    }
};

struct FEMissionObjectiveInfo
{
    class UTexture2D* BackgroundImg;
    FStringNoInit Text;

    /** Constructors */
    FEMissionObjectiveInfo() {}
    FEMissionObjectiveInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEMissionObjectiveInfo));
    }
};

struct FEMissionMapInfo
{
    FStringNoInit MissionMap;
    FStringNoInit MissionURL;
    class USurface* MissionMapImage;
    BITFIELD bCustomMapCoords:1;
    struct FTextureCoordinates MissionMapCoords;
    BITFIELD bCutSequence:1;
    BITFIELD bAutomaticTransition:1;
    FName MapPoint;
    FName MapGlobeTag;
    FLOAT MapDist;
    TArrayNoInit<struct FEMissionTeaserInfo> Teasers;
    TArrayNoInit<struct FEMissionObjectiveInfo> Objectives;
    class UStaticMeshComponent* MapBeacon;

    /** Constructors */
    FEMissionMapInfo() {}
    FEMissionMapInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEMissionMapInfo));
    }
};

struct FEMissionData
{
    INT MissionIndex;
    FStringNoInit MissionTitle;
    FStringNoInit MissionDescription;
    struct FEMissionMapInfo MissionRules;
    TArrayNoInit<struct FEMissionCondition> MissionProgression;

    /** Constructors */
    FEMissionData() {}
    FEMissionData(EEventParm)
    {
        appMemzero(this, sizeof(FEMissionData));
    }
};

class UUTSeqObj_SPMission : public USequenceAction
{
public:
    //## BEGIN PROPS UTSeqObj_SPMission
    BITFIELD bFirstMission:1;
    struct FEMissionData MissionInfo;
    INT OldIndex;
    //## END PROPS UTSeqObj_SPMission

    DECLARE_CLASS(UUTSeqObj_SPMission,USequenceAction,0,UTGame)
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChange( class FEditPropertyChain& PropertyThatChanged );
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	void WrappedPrint( FCanvas* Canvas, UBOOL Draw, FLOAT CurX, FLOAT CurY, FLOAT &XL, FLOAT& YL, UFont* Font, const TCHAR* Text, FLinearColor DrawColor);
	FString GetDescription();
	virtual void OnCreated();
	void AdjustIndex();
	void SetAsFirstMission();
	virtual void OnPasted();
	void FindInitialIndex();
};

class UUTSeqObj_SPRootMission : public UUTSeqObj_SPMission
{
public:
    //## BEGIN PROPS UTSeqObj_SPRootMission
    //## END PROPS UTSeqObj_SPRootMission

    DECLARE_CLASS(UUTSeqObj_SPRootMission,UUTSeqObj_SPMission,0,UTGame)
	virtual void OnCreated();
	virtual void PostEditChange( class FEditPropertyChain& PropertyThatChanged );
};

class UUTUIDataStore_MenuItems : public UUIDataStore_GameResource, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataStore_MenuItems
    TArrayNoInit<INT> EnabledMutators;
    TArrayNoInit<INT> MapCycle;
    TArrayNoInit<INT> WeaponPriority;
    INT GameModeFilter;
    //## END PROPS UTUIDataStore_MenuItems

    virtual INT GetProviderCount(FName FieldName);
    void GetAllResourceDataProviders(class UClass* ProviderClass,TArray<class UUTUIResourceDataProvider*>& Providers);
    virtual INT FindValueInProviderSet(FName ProviderFieldName,FName SearchTag,const FString& SearchValue);
    virtual UBOOL GetValueFromProviderSet(FName ProviderFieldName,FName SearchTag,INT ListIndex,FString& OutValue);
    DECLARE_FUNCTION(execGetProviderCount)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(INT*)Result=GetProviderCount(FieldName);
    }
    DECLARE_FUNCTION(execGetAllResourceDataProviders)
    {
        P_GET_OBJECT(UClass,ProviderClass);
        P_GET_TARRAY_REF(class UUTUIResourceDataProvider*,Providers);
        P_FINISH;
        GetAllResourceDataProviders(ProviderClass,Providers);
    }
    DECLARE_FUNCTION(execFindValueInProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_STR(SearchValue);
        P_FINISH;
        *(INT*)Result=FindValueInProviderSet(ProviderFieldName,SearchTag,SearchValue);
    }
    DECLARE_FUNCTION(execGetValueFromProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetValueFromProviderSet(ProviderFieldName,SearchTag,ListIndex,OutValue);
    }
    DECLARE_CLASS(UUTUIDataStore_MenuItems,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUTUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );


	/**
	 * Attempts to find a simple menu with the field name provided.
	 *
	 * @param FieldName		Field name of the simple menu.  Defined in UUTUIDataProvider_SimpleMenu::FieldName
	 */
	virtual class UUTUIDataProvider_SimpleMenu* FindSimpleMenu(FName FieldName);


// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

};

class UUTUIDataStore_Options : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS UTUIDataStore_Options
    TMultiMap<FName, class UUTUIResourceDataProvider*> OptionProviders;
    //## END PROPS UTUIDataStore_Options

    DECLARE_CLASS(UUTUIDataStore_Options,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UTGame)
	/**
	 * Initializes the dataproviders for all of the various character parts.
	 */
	virtual void InitializeDataStore();

	/** 
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUTUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );
};

class UUTUIDataStore_StringAliasMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS UTUIDataStore_StringAliasMap
    //## END PROPS UTUIDataStore_StringAliasMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_CLASS(UUTUIDataStore_StringAliasMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataStore_StringAliasMap)
};

class UUTUIDataStore_CustomChar : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UTUIDataStore_CustomChar
    TMultiMap<FName, class UUIDataProvider*> PartProviders;
    TArrayNoInit<FName> PartTags;
    TArrayNoInit<INT> ActiveBots;
    FStringNoInit CurrentFamily;
    FStringNoInit CurrentCharacter;
    FStringNoInit CurrentFaction;
    //## END PROPS UTUIDataStore_CustomChar

    virtual INT FindValueInProviderSet(FName ProviderFieldName,FName SearchTag,const FString& SearchValue);
    virtual UBOOL GetValueFromProviderSet(FName ProviderFieldName,FName SearchTag,INT ListIndex,FString& OutValue);
    DECLARE_FUNCTION(execFindValueInProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_STR(SearchValue);
        P_FINISH;
        *(INT*)Result=FindValueInProviderSet(ProviderFieldName,SearchTag,SearchValue);
    }
    DECLARE_FUNCTION(execGetValueFromProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetValueFromProviderSet(ProviderFieldName,SearchTag,ListIndex,OutValue);
    }
    DECLARE_CLASS(UUTUIDataStore_CustomChar,UUIDataStore,0|CLASS_Transient,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("CustomChar");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/** @return Returns the enum value for a part type given its tag. */
	ECharPart ResolvePartEnumFromTag(const FName &FieldTag);

	/** @return Returns the tag value for a part type given its enum. */
	FName ResolveTagFromPartEnum(ECharPart PartType);

	/**
	 * Initializes the dataproviders for all of the various character parts.
	 */
	virtual void InitializeDataStore();

	/** 
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutParts				Array to store part indices in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUIDataProvider*> &OutParts);

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/* === UObject interface === */
	/** Required since maps are not yet supported by script serialization */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );

	/**
	 * Called from ReloadConfig after the object has reloaded its configuration data.  Reinitializes the collection of list element providers.
	 */
	virtual void PostReloadConfig( UProperty* PropertyThatWasLoaded );
};

struct FEStringListData
{
    FName Tag;
    FStringNoInit CurrentValue;
    INT DefaultValueIndex;
    TArrayNoInit<FString> Strings;

    /** Constructors */
    FEStringListData() {}
    FEStringListData(EEventParm)
    {
        appMemzero(this, sizeof(FEStringListData));
    }
};

#define UCONST_INVALIDFIELD -1

struct UTUIDataStore_StringList_eventNum_Parms
{
    FName FieldName;
    INT ReturnValue;
    UTUIDataStore_StringList_eventNum_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms
{
    FName FieldName;
    INT NewValueIndex;
    INT ReturnValue;
    UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms
{
    FName FieldName;
    INT ReturnValue;
    UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UTUIDataStore_StringList_eventGetCurrentValue_Parms
{
    FName FieldName;
    FString out_Value;
    UBOOL ReturnValue;
    UTUIDataStore_StringList_eventGetCurrentValue_Parms(EEventParm)
    {
    }
};
class UUTUIDataStore_StringList : public UUIDataStore, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataStore_StringList
    TArrayNoInit<struct FEStringListData> StringData;
    //## END PROPS UTUIDataStore_StringList

    virtual INT GetFieldIndex(FName FieldName);
    virtual void AddStr(FName FieldName,const FString& NewString);
    virtual void InsertStr(FName FieldName,const FString& NewString,INT InsertIndex);
    virtual void RemoveStr(FName FieldName,const FString& StringToRemove);
    virtual void RemoveStrByIndex(FName FieldName,INT Index,INT Count=1);
    virtual void Empty(FName FieldName);
    virtual INT FindStr(FName FieldName,const FString& SearchString);
    virtual FString GetStr(FName FieldName,INT StrIndex);
    virtual TArray<FString> GetList(FName FieldName);
    DECLARE_FUNCTION(execGetFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(INT*)Result=GetFieldIndex(FieldName);
    }
    DECLARE_FUNCTION(execAddStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_FINISH;
        AddStr(FieldName,NewString);
    }
    DECLARE_FUNCTION(execInsertStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_GET_INT(InsertIndex);
        P_FINISH;
        InsertStr(FieldName,NewString,InsertIndex);
    }
    DECLARE_FUNCTION(execRemoveStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(StringToRemove);
        P_FINISH;
        RemoveStr(FieldName,StringToRemove);
    }
    DECLARE_FUNCTION(execRemoveStrByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(Index);
        P_GET_INT_OPTX(Count,1);
        P_FINISH;
        RemoveStrByIndex(FieldName,Index,Count);
    }
    DECLARE_FUNCTION(execEmpty)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        Empty(FieldName);
    }
    DECLARE_FUNCTION(execFindStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(SearchString);
        P_FINISH;
        *(INT*)Result=FindStr(FieldName,SearchString);
    }
    DECLARE_FUNCTION(execGetStr)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(StrIndex);
        P_FINISH;
        *(FString*)Result=GetStr(FieldName,StrIndex);
    }
    DECLARE_FUNCTION(execGetList)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(TArray<FString>*)Result=GetList(FieldName);
    }
    INT eventNum(FName FieldName)
    {
        UTUIDataStore_StringList_eventNum_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UTGAME_Num),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSetCurrentValueIndex(FName FieldName,INT NewValueIndex)
    {
        UTUIDataStore_StringList_eventSetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.NewValueIndex=NewValueIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_SetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    INT eventGetCurrentValueIndex(FName FieldName)
    {
        UTUIDataStore_StringList_eventGetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UTGAME_GetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetCurrentValue(FName FieldName,FString& out_Value)
    {
        UTUIDataStore_StringList_eventGetCurrentValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.out_Value=out_Value;
        ProcessEvent(FindFunctionChecked(UTGAME_GetCurrentValue),&Parms);
        out_Value=Parms.out_Value;
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataStore_StringList,UUIDataStore,0|CLASS_Transient|CLASS_Config,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === UIListElementProvider === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

   	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );


/* === UIListElementCellProvider === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );



/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Adds a new field to the list
	 *
	 * @param	FieldName		the data field to resolve the value for
	 * @param	NewString		The first string to add.
	 */
	virtual INT AddNewField(FName FieldName, const FString &NewString);


};

struct FResultImageInfo
{
    class USurface* ImageReference;
    FStringNoInit ImageName;
    FLOAT ImageX;
    FLOAT ImageY;
    FLOAT ImageXL;
    FLOAT ImageYL;

    /** Constructors */
    FResultImageInfo() {}
    FResultImageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FResultImageInfo));
    }
};

class UUTUIDataProvider_SearchResult : public UUIDataProvider_Settings
{
public:
    //## BEGIN PROPS UTUIDataProvider_SearchResult
    struct FResultImageInfo LockedImage;
    struct FResultImageInfo PureImage;
    struct FResultImageInfo FriendOnlineImage;
    //## END PROPS UTUIDataProvider_SearchResult

    DECLARE_CLASS(UUTUIDataProvider_SearchResult,UUIDataProvider_Settings,0|CLASS_Transient,UTGame)
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);
};

class UUTUIDataProvider_KeyBinding : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_KeyBinding
    FStringNoInit FriendlyName;
    FStringNoInit Command;
    //## END PROPS UTUIDataProvider_KeyBinding

    DECLARE_CLASS(UUTUIDataProvider_KeyBinding,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_KeyBinding)
};

class UUTUIResourceDataProvider : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIResourceDataProvider
    BITFIELD bSearchAllInis:1;
    BITFIELD bRemoveOn360:1;
    BITFIELD bRemoveOnPC:1;
    BITFIELD bRemoveOnPS3:1;
    FStringNoInit IniName;
    //## END PROPS UTUIResourceDataProvider

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=IsFiltered();
    }
    DECLARE_CLASS(UUTUIResourceDataProvider,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags )
	{
		Super::GetElementCellTags(out_CellTags);
	}
};

class UUTUIDataProvider_CommunityMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_CommunityMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_CommunityMenuItem

    DECLARE_CLASS(UUTUIDataProvider_CommunityMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_CommunityMenuItem)
};

class UUTUIDataProvider_DemoFile : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_DemoFile
    FStringNoInit Filename;
    //## END PROPS UTUIDataProvider_DemoFile

    DECLARE_CLASS(UUTUIDataProvider_DemoFile,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_DemoFile)
};

class UUTUIDataProvider_GameModeInfo : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_GameModeInfo
    FStringNoInit GameMode;
    FStringNoInit DefaultMap;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit PreviewImageMarkup;
    FStringNoInit Prefix;
    //## END PROPS UTUIDataProvider_GameModeInfo

    DECLARE_CLASS(UUTUIDataProvider_GameModeInfo,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_GameModeInfo)
};

class UUTUIDataProvider_MainMenuItems : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MainMenuItems
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_MainMenuItems

    DECLARE_CLASS(UUTUIDataProvider_MainMenuItems,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_MainMenuItems)
};

struct UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms
{
    UBOOL ReturnValue;
    UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms(EEventParm)
    {
    }
};
class UUTUIDataProvider_MapInfo : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MapInfo
    INT MapID;
    FStringNoInit MapName;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit PreviewImageMarkup;
    //## END PROPS UTUIDataProvider_MapInfo

    virtual UBOOL IsFiltered();
    UBOOL eventSupportedByCurrentGameMode()
    {
        UTUIDataProvider_MapInfo_eventSupportedByCurrentGameMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UTGAME_SupportedByCurrentGameMode),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataProvider_MapInfo,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_MapInfo)
};

class UUTUIDataProvider_MenuOption : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MenuOption
    BYTE OptionType;
    FName OptionSet;
    FStringNoInit DataStoreMarkup;
    FName RequiredGameMode;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    struct FUIRangeData RangeData;
    //## END PROPS UTUIDataProvider_MenuOption

    virtual UBOOL IsFiltered();
    DECLARE_CLASS(UUTUIDataProvider_MenuOption,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_MenuOption)
};

class UUTUIDataProvider_MultiplayerMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_MultiplayerMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_MultiplayerMenuItem

    DECLARE_CLASS(UUTUIDataProvider_MultiplayerMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_MultiplayerMenuItem)
};

struct UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms
{
    UBOOL ReturnValue;
    UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms(EEventParm)
    {
    }
};
class UUTUIDataProvider_Mutator : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Mutator
    FStringNoInit ClassName;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    FStringNoInit GroupName;
    FStringNoInit UIConfigScene;
    //## END PROPS UTUIDataProvider_Mutator

    virtual UBOOL IsFiltered();
    UBOOL eventSupportsCurrentGameMode()
    {
        UTUIDataProvider_Mutator_eventSupportsCurrentGameMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UTGAME_SupportsCurrentGameMode),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTUIDataProvider_Mutator,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_Mutator)
};

class UUTUIDataProvider_SettingsMenuItem : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_SettingsMenuItem
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_SettingsMenuItem

    DECLARE_CLASS(UUTUIDataProvider_SettingsMenuItem,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_SettingsMenuItem)
};

class UUTUIDataProvider_SimpleMenu : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_SimpleMenu
    FName FieldName;
    TArrayNoInit<FString> Options;
    //## END PROPS UTUIDataProvider_SimpleMenu

    DECLARE_CLASS(UUTUIDataProvider_SimpleMenu,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );


	/* === UIDataProvider interface === */
	/**
	 * Returns the data tag associated with the specified provider.
	 *
	 * @return	the data field tag associated with the provider specified, or NAME_None if the provider specified is not
	 *			contained by this data store.
	 */
	virtual FName GetProviderDataTag( class UUIDataProvider* Provider );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }
};

class UUTUIDataProvider_Weapon : public UUTUIResourceDataProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Weapon
    FStringNoInit ClassName;
    FStringNoInit AmmoClassPath;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    //## END PROPS UTUIDataProvider_Weapon

    DECLARE_CLASS(UUTUIDataProvider_Weapon,UUTUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIDataProvider_Weapon)
};

class UUTUIDataProvider_Character : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_Character
    struct FCharacterInfo CustomData;
    //## END PROPS UTUIDataProvider_Character

    DECLARE_CLASS(UUTUIDataProvider_Character,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/** Sets the data for this provider. */
	void SetData(FCharacterInfo &InData);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUTUIDataProvider_CharacterFaction : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_CharacterFaction
    struct FFactionInfo CustomData;
    //## END PROPS UTUIDataProvider_CharacterFaction

    DECLARE_CLASS(UUTUIDataProvider_CharacterFaction,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/** Sets the data for this provider. */
	void SetData(FFactionInfo &InData);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUTUIDataProvider_CharacterPart : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UTUIDataProvider_CharacterPart
    struct FCustomCharPart PartData;
    //## END PROPS UTUIDataProvider_CharacterPart

    DECLARE_CLASS(UUTUIDataProvider_CharacterPart,UUIDataProvider,0|CLASS_Transient,UTGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/** Sets the part data for this provider. */
	void SetPartData(FCustomCharPart &InPartData);

// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUTGameUISceneClient : public UGameUISceneClient
{
public:
    //## BEGIN PROPS UTGameUISceneClient
    BITFIELD bShowRenderTimes:1;
    FLOAT PreRenderTime;
    FLOAT RenderTime;
    FLOAT TickTime;
    FLOAT AnimTime;
    FLOAT AvgTime;
    FLOAT AvgRenderTime;
    FLOAT FrameCount;
    FLOAT StringRenderTime;
    struct FEMissionData CurrentMissionData;
    //## END PROPS UTGameUISceneClient

    virtual UBOOL IsUIAcceptingInput();
    DECLARE_FUNCTION(execIsUIAcceptingInput)
    {
        P_FINISH;
        *(UBOOL*)Result=IsUIAcceptingInput();
    }
    DECLARE_CLASS(UUTGameUISceneClient,UGameUISceneClient,0|CLASS_Transient|CLASS_Config,UTGame)
	/**
	 * Render all the active scenes
	 */
	virtual void RenderScenes( FCanvas* Canvas );

	virtual void Render_Scene( FCanvas* Canvas, UUIScene* Scene );
	virtual void Tick(FLOAT DeltaTime);
};

class UUTUIButtonBarButton : public UUILabelButton
{
public:
    //## BEGIN PROPS UTUIButtonBarButton
    //## END PROPS UTUIButtonBarButton

    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    DECLARE_CLASS(UUTUIButtonBarButton,UUILabelButton,0,UTGame)
	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

class UUTUIComboBox : public UUIComboBox, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UTUIComboBox
    FName ToggleButtonStyleName;
    FName ToggleButtonCheckedStyleName;
    FName EditboxBGStyleName;
    //## END PROPS UTUIComboBox

    virtual void SetupChildStyles();
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execSetupChildStyles)
    {
        P_FINISH;
        SetupChildStyles();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    DECLARE_CLASS(UUTUIComboBox,UUIComboBox,0,UTGame)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/**
	 * Called whenever the selected item is modified.  Activates the SliderValueChanged kismet event and calls the OnValueChanged
	 * delegate.
	 *
	 * @param	PlayerIndex		the index of the player that generated the call to this method; used as the PlayerIndex when activating
	 *							UIEvents; if not specified, the value of GetBestPlayerIndex() is used instead.
	 * @param	NotifyFlags		optional parameter for individual widgets to use for passing additional information about the notification.
	 */
	virtual void NotifyValueChanged( INT PlayerIndex=INDEX_NONE, INT NotifyFlags=0 );
};

class UUTTabPage : public UUITabPage
{
public:
    //## BEGIN PROPS UTTabPage
    BITFIELD bRequiresTick:1;
    //## END PROPS UTTabPage

    DECLARE_CLASS(UUTTabPage,UUITabPage,0,UTGame)
	virtual void Tick_Widget(FLOAT DeltaTime){};
};

struct UTDrawPanel_eventDrawPanel_Parms
{
    UTDrawPanel_eventDrawPanel_Parms(EEventParm)
    {
    }
};
struct UTDrawPanel_eventDrawDelegate_Parms
{
    class UCanvas* C;
    UBOOL ReturnValue;
    UTDrawPanel_eventDrawDelegate_Parms(EEventParm)
    {
    }
};
class UUTDrawPanel : public UUIContainer
{
public:
    //## BEGIN PROPS UTDrawPanel
    class UCanvas* Canvas;
    FScriptDelegate __DrawDelegate__Delegate;
    //## END PROPS UTDrawPanel

    void Draw2DLine(INT X1,INT Y1,INT X2,INT Y2,FColor LineColor);
    DECLARE_FUNCTION(execDraw2DLine)
    {
        P_GET_INT(X1);
        P_GET_INT(Y1);
        P_GET_INT(X2);
        P_GET_INT(Y2);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        Draw2DLine(X1,Y1,X2,Y2,LineColor);
    }
    void eventDrawPanel()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_DrawPanel),NULL);
    }
    UBOOL delegateDrawDelegate(class UCanvas* C)
    {
        UTDrawPanel_eventDrawDelegate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.C=C;
        ProcessDelegate(UTGAME_DrawDelegate,&__DrawDelegate__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUTDrawPanel,UUIContainer,0,UTGame)
	void PostRender_Widget(FCanvas* Canvas);
};

struct FSimpleListData
{
    FStringNoInit Text;
    INT Tag;
    FLOAT HeightMultipliers[2];
    FLOAT CurHeightMultiplier;
    FLOAT CellTransitionTime;
    FLOAT YBounds[2];
    BITFIELD bWasRendered:1;

    /** Constructors */
    FSimpleListData() {}
    FSimpleListData(EEventParm)
    {
        appMemzero(this, sizeof(FSimpleListData));
    }
};

struct UTSimpleList_eventOnSelectionChange_Parms
{
    class UUTSimpleList* SourceList;
    INT NewSelectedIndex;
    UTSimpleList_eventOnSelectionChange_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnItemChosen_Parms
{
    class UUTSimpleList* SourceList;
    INT SelectedIndex;
    INT PlayerIndex;
    UTSimpleList_eventOnItemChosen_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventOnDrawItem_Parms
{
    class UUTSimpleList* SimpleList;
    INT ItemIndex;
    FLOAT XPos;
    FLOAT YPos;
    UBOOL ReturnValue;
    UTSimpleList_eventOnDrawItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventSelectItem_Parms
{
    INT NewSelection;
    UTSimpleList_eventSelectItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventSizeList_Parms
{
    UTSimpleList_eventSizeList_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventEmpty_Parms
{
    UTSimpleList_eventEmpty_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventRemoveString_Parms
{
    FString TextToRemove;
    UTSimpleList_eventRemoveString_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventRemoveItem_Parms
{
    INT IndexToRemove;
    UTSimpleList_eventRemoveItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventInsertItem_Parms
{
    INT Index;
    FString Text;
    INT Tag;
    UTSimpleList_eventInsertItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventAddItem_Parms
{
    FString Text;
    INT Tag;
    UTSimpleList_eventAddItem_Parms(EEventParm)
    {
    }
};
struct UTSimpleList_eventImportStringList_Parms
{
    TArray<FString> StringList;
    UTSimpleList_eventImportStringList_Parms(EEventParm)
    {
    }
};
class UUTSimpleList : public UUTDrawPanel
{
public:
    //## BEGIN PROPS UTSimpleList
    class UFont* TextFont;
    FColor NormalColor;
    FColor AboveBelowColor;
    FColor SelectedColor;
    FColor SelectionBarColor;
    class UTexture2D* SelectionImage;
    FLOAT DefaultCellHeight;
    FLOAT AboveBelowCellHeightMultiplier;
    FLOAT SelectionCellHeightMultiplier;
    FLOAT TransitionTime;
    FLOAT ScrollWidthRatio;
    TArrayNoInit<struct FSimpleListData> List;
    INT Top;
    INT Selection;
    BITFIELD bInvalidated:1;
    BITFIELD bDragging:1;
    FVector2D ResScaling;
    FLOAT LastRenderTime;
    FLOAT WindowTop;
    FLOAT WindowHeight;
    FLOAT ListHeightInPixel;
    FLOAT TargetWindowTop;
    FLOAT WindowTopTransitionTime;
    FLOAT UpArrowBounds[4];
    FLOAT DownArrowBounds[4];
    FLOAT DragAdjustment;
    FLOAT LastMouseUpdate;
    FLOAT SelectionBarTransitionTime;
    FScriptDelegate __OnDrawItem__Delegate;
    FScriptDelegate __OnItemChosen__Delegate;
    FScriptDelegate __OnSelectionChange__Delegate;
    //## END PROPS UTSimpleList

    virtual INT Find(const FString& SearchText);
    virtual INT FindTag(INT SearchTag);
    virtual void SortList();
    virtual void UpdateAnimation(FLOAT DeltaTime);
    DECLARE_FUNCTION(execFind)
    {
        P_GET_STR(SearchText);
        P_FINISH;
        *(INT*)Result=Find(SearchText);
    }
    DECLARE_FUNCTION(execFindTag)
    {
        P_GET_INT(SearchTag);
        P_FINISH;
        *(INT*)Result=FindTag(SearchTag);
    }
    DECLARE_FUNCTION(execSortList)
    {
        P_FINISH;
        SortList();
    }
    DECLARE_FUNCTION(execUpdateAnimation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateAnimation(DeltaTime);
    }
    void delegateOnSelectionChange(class UUTSimpleList* SourceList,INT NewSelectedIndex)
    {
        UTSimpleList_eventOnSelectionChange_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.NewSelectedIndex=NewSelectedIndex;
        ProcessDelegate(UTGAME_OnSelectionChange,&__OnSelectionChange__Delegate,&Parms);
    }
    void delegateOnItemChosen(class UUTSimpleList* SourceList,INT SelectedIndex,INT PlayerIndex)
    {
        UTSimpleList_eventOnItemChosen_Parms Parms(EC_EventParm);
        Parms.SourceList=SourceList;
        Parms.SelectedIndex=SelectedIndex;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnItemChosen,&__OnItemChosen__Delegate,&Parms);
    }
    UBOOL delegateOnDrawItem(class UUTSimpleList* SimpleList,INT ItemIndex,FLOAT XPos,FLOAT& YPos)
    {
        UTSimpleList_eventOnDrawItem_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.SimpleList=SimpleList;
        Parms.ItemIndex=ItemIndex;
        Parms.XPos=XPos;
        Parms.YPos=YPos;
        ProcessDelegate(UTGAME_OnDrawItem,&__OnDrawItem__Delegate,&Parms);
        YPos=Parms.YPos;
        return Parms.ReturnValue;
    }
    void eventSelectItem(INT NewSelection)
    {
        UTSimpleList_eventSelectItem_Parms Parms(EC_EventParm);
        Parms.NewSelection=NewSelection;
        ProcessEvent(FindFunctionChecked(UTGAME_SelectItem),&Parms);
    }
    void eventSizeList()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_SizeList),NULL);
    }
    void eventEmpty()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_Empty),NULL);
    }
    void eventRemoveString(const FString& TextToRemove)
    {
        UTSimpleList_eventRemoveString_Parms Parms(EC_EventParm);
        Parms.TextToRemove=TextToRemove;
        ProcessEvent(FindFunctionChecked(UTGAME_RemoveString),&Parms);
    }
    void eventRemoveItem(INT IndexToRemove)
    {
        UTSimpleList_eventRemoveItem_Parms Parms(EC_EventParm);
        Parms.IndexToRemove=IndexToRemove;
        ProcessEvent(FindFunctionChecked(UTGAME_RemoveItem),&Parms);
    }
    void eventInsertItem(INT Index,const FString& Text,INT Tag=-1)
    {
        UTSimpleList_eventInsertItem_Parms Parms(EC_EventParm);
        Parms.Index=Index;
        Parms.Text=Text;
        Parms.Tag=Tag;
        ProcessEvent(FindFunctionChecked(UTGAME_InsertItem),&Parms);
    }
    void eventAddItem(const FString& Text,INT Tag=-1)
    {
        UTSimpleList_eventAddItem_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        Parms.Tag=Tag;
        ProcessEvent(FindFunctionChecked(UTGAME_AddItem),&Parms);
    }
    void eventImportStringList(const TArray<FString>& StringList)
    {
        UTSimpleList_eventImportStringList_Parms Parms(EC_EventParm);
        Parms.StringList=StringList;
        ProcessEvent(FindFunctionChecked(UTGAME_ImportStringList),&Parms);
    }
    DECLARE_CLASS(UUTSimpleList,UUTDrawPanel,0,UTGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UUTUINumericEditBox : public UUINumericEditBox
{
public:
    //## BEGIN PROPS UTUINumericEditBox
    //## END PROPS UTUINumericEditBox

    DECLARE_CLASS(UUTUINumericEditBox,UUINumericEditBox,0,UTGame)
	/**
	 * Initializes the buttons and creates the background image.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

};

class UUTUIEditBox : public UUIEditBox
{
public:
    //## BEGIN PROPS UTUIEditBox
    //## END PROPS UTUIEditBox

    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_CLASS(UUTUIEditBox,UUIEditBox,0,UTGame)
	/**
	* Perform all initialization for this widget. Called on all widgets when a scene is opened,
	* once the scene has been completely initialized.
	* For widgets added at runtime, called after the widget has been inserted into its parent's
	* list of children.
	*
	* @param	inOwnerScene	the scene to add this widget to.
	* @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	*							is being added to the scene's list of children.
	*/
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

class UMiniMapImage : public UUIImage
{
public:
    //## BEGIN PROPS MiniMapImage
    class UUIState* CurrentState;
    //## END PROPS MiniMapImage

    virtual void SetStyle(FName NewStyleTag);
    DECLARE_FUNCTION(execSetStyle)
    {
        P_GET_NAME(NewStyleTag);
        P_FINISH;
        SetStyle(NewStyleTag);
    }
    DECLARE_CLASS(UMiniMapImage,UUIImage,0,UTGame)
	virtual void Render_Widget( FCanvas* Canvas );
};

class UUTUIList : public UUIList
{
public:
    //## BEGIN PROPS UTUIList
    //## END PROPS UTUIList

    DECLARE_CLASS(UUTUIList,UUIList,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIList)
};

class UUTUIMenuList : public UUIList
{
public:
    //## BEGIN PROPS UTUIMenuList
    struct FUIDataStoreBinding SelectedIndexDataSource;
    BITFIELD bIsRotating:1;
    FLOAT StartRotationTime;
    INT PreviousItem;
    //## END PROPS UTUIMenuList

    UBOOL GetCellFieldValue(class UUIList* InList,FName InCellTag,INT InListIndex,struct FUIProviderFieldValue& OutValue);
    virtual FLOAT GetRowHeight(INT RowIndex=-1) const;
    INT FindCellFieldString(class UUIList* InList,FName InCellTag,const FString& FindValue,UBOOL bCaseSensitive=0);
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    DECLARE_FUNCTION(execGetCellFieldValue)
    {
        P_GET_OBJECT(UUIList,InList);
        P_GET_NAME(InCellTag);
        P_GET_INT(InListIndex);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,OutValue);
        P_FINISH;
        *(UBOOL*)Result=GetCellFieldValue(InList,InCellTag,InListIndex,OutValue);
    }
    DECLARE_FUNCTION(execFindCellFieldString)
    {
        P_GET_OBJECT(UUIList,InList);
        P_GET_NAME(InCellTag);
        P_GET_STR(FindValue);
        P_GET_UBOOL_OPTX(bCaseSensitive,0);
        P_FINISH;
        *(INT*)Result=FindCellFieldString(InList,InCellTag,FindValue,bCaseSensitive);
    }
    DECLARE_CLASS(UUTUIMenuList,UUIList,0,UTGame)
	/** Tick callback for this widget. */
	virtual void Tick_Widget(FLOAT DeltaTime);

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );


	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreRenderCallback();

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Called when the list's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	virtual void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );
};

class UUTUISlider : public UUISlider
{
public:
    //## BEGIN PROPS UTUISlider
    //## END PROPS UTUISlider

    DECLARE_CLASS(UUTUISlider,UUISlider,0,UTGame)
public:
	/**
	 * Render this slider.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );
};

class UUTUITabControl : public UUITabControl
{
public:
    //## BEGIN PROPS UTUITabControl
    //## END PROPS UTUITabControl

    DECLARE_CLASS(UUTUITabControl,UUITabControl,0|CLASS_Config,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUITabControl)
};

class UUTUI_Widget : public UUIObject
{
public:
    //## BEGIN PROPS UTUI_Widget
    BITFIELD bRequiresTick:1;
    BITFIELD bShowBounds:1;
    class UUTUIScene* UTSceneOwner;
    //## END PROPS UTUI_Widget

    DECLARE_ABSTRACT_CLASS(UUTUI_Widget,UUIObject,0,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime){};
	virtual void PreRender_Widget(FCanvas* Canvas){};
	virtual void Render_Widget(FCanvas* Canvas);
	virtual void RefreshPosition();

	/**
	  * WARNING: This function does not check the destination and assumes it is valid.
	  *
	  * LookupProperty - Finds a property of a source actor and returns it's value.
	  *
	  * @param		SourceActor			The actor to search
	  * @param		SourceProperty		The property to look up
	  * @out param 	DestPtr				A Point to the storgage of the value
	  *
	  * @Returns true if the look up succeeded
	  */
	virtual UBOOL LookupProperty(AActor* SourceActor, FName SourceProperty, BYTE* DestPtr);

};

struct FWidgetAnimSequence
{
    FName Tag;
    FLOAT Rate;
    FLOAT StartValue;
    FLOAT EndValue;
};

struct FWidgetAnimation
{
    FName Tag;
    BYTE Property;
    BITFIELD bNotifyWhenFinished:1 GCC_BITFIELD_MAGIC;
    TArrayNoInit<struct FWidgetAnimSequence> Sequences;
    BITFIELD bIsPlaying:1;
    INT SeqIndex;
    FLOAT Time;
    FLOAT Value;

    /** Constructors */
    FWidgetAnimation() {}
    FWidgetAnimation(EEventParm)
    {
        appMemzero(this, sizeof(FWidgetAnimation));
    }
};

struct UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms
{
    UBOOL ReturnValue;
    UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventSetOpacity_Parms
{
    FLOAT NewOpacity;
    UTUI_HudWidget_eventSetOpacity_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventWidgetTick_Parms
{
    FLOAT DeltaTime;
    UTUI_HudWidget_eventWidgetTick_Parms(EEventParm)
    {
    }
};
struct UTUI_HudWidget_eventFadeTo_Parms
{
    FLOAT NewOpacity;
    FLOAT NewFadeTime;
    UBOOL bTimeFromExtent;
    UTUI_HudWidget_eventFadeTo_Parms(EEventParm)
    {
    }
};
class UUTUI_HudWidget : public UUTUI_Widget
{
public:
    //## BEGIN PROPS UTUI_HudWidget
    class UUTUIScene_Hud* UTHudSceneOwner;
    FLOAT OpacityTarget;
    FLOAT OpacityTimer;
    BITFIELD bManualVisibility:1;
    BITFIELD bVisibleBeforeMatch:1;
    BITFIELD bVisibleDuringMatch:1;
    BITFIELD bVisibleAfterMatch:1;
    BITFIELD bVisibleWhileSpectating:1;
    TArrayNoInit<struct FWidgetAnimation> Animations;
    //## END PROPS UTUI_HudWidget

    virtual UBOOL PlayAnimation(FName AnimTag,FName SeqTag,UBOOL bForceBeginning=0);
    virtual void StopAnimation(FName AnimTag,UBOOL bForceEnd=0);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(AnimTag);
        P_GET_NAME(SeqTag);
        P_GET_UBOOL_OPTX(bForceBeginning,0);
        P_FINISH;
        *(UBOOL*)Result=PlayAnimation(AnimTag,SeqTag,bForceBeginning);
    }
    DECLARE_FUNCTION(execStopAnimation)
    {
        P_GET_NAME(AnimTag);
        P_GET_UBOOL_OPTX(bForceEnd,0);
        P_FINISH;
        StopAnimation(AnimTag,bForceEnd);
    }
    UBOOL eventPlayerOwnerIsSpectating()
    {
        UTUI_HudWidget_eventPlayerOwnerIsSpectating_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UTGAME_PlayerOwnerIsSpectating),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetOpacity(FLOAT NewOpacity)
    {
        UTUI_HudWidget_eventSetOpacity_Parms Parms(EC_EventParm);
        Parms.NewOpacity=NewOpacity;
        ProcessEvent(FindFunctionChecked(UTGAME_SetOpacity),&Parms);
    }
    void eventWidgetTick(FLOAT DeltaTime)
    {
        UTUI_HudWidget_eventWidgetTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_WidgetTick),&Parms);
    }
    void eventFadeTo(FLOAT NewOpacity,FLOAT NewFadeTime,UBOOL bTimeFromExtent=0)
    {
        UTUI_HudWidget_eventFadeTo_Parms Parms(EC_EventParm);
        Parms.NewOpacity=NewOpacity;
        Parms.NewFadeTime=NewFadeTime;
        Parms.bTimeFromExtent=bTimeFromExtent ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(UTGAME_FadeTo),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUTUI_HudWidget,UUTUI_Widget,0,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime);
	virtual void UpdateAnimations(FLOAT DeltaTime);
};

class UHudWidget_LocalMessages : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_LocalMessages
    class UUILabel* MessageZones[7];
    class UUILabel* WeaponName;
    FStringNoInit LastWeaponName;
    class UFont* FontPool[4];
    BITFIELD bHACKInitialize:1;
    //## END PROPS HudWidget_LocalMessages

    virtual void SizeZone(INT ZoneIndex,INT FontIndex);
    DECLARE_FUNCTION(execSizeZone)
    {
        P_GET_INT(ZoneIndex);
        P_GET_INT(FontIndex);
        P_FINISH;
        SizeZone(ZoneIndex,FontIndex);
    }
    DECLARE_CLASS(UHudWidget_LocalMessages,UUTUI_HudWidget,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UHudWidget_LocalMessages)
};

class UHudWidget_Map : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_Map
    BITFIELD bMapInitialized:1;
    class UUIImage* OuterRing;
    class UUIImage* InnerRing;
    class UUTDrawMapPanel* UTMapPanel;
    //## END PROPS HudWidget_Map

    DECLARE_CLASS(UHudWidget_Map,UUTUI_HudWidget,0,UTGame)
	virtual void Tick_Widget(FLOAT DeltaTime);
};

class UHudWidget_PawnDoll : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_PawnDoll
    class UUIImage* BaseImg;
    //## END PROPS HudWidget_PawnDoll

    DECLARE_ABSTRACT_CLASS(UHudWidget_PawnDoll,UUTUI_HudWidget,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UHudWidget_PawnDoll)
};

class UHudWidget_QuickPickCell : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_QuickPickCell
    class UUIProgressBar* AmmoBar;
    class UUIImage* WeaponIcon;
    class UUIImage* Background;
    class UUIImage* Overlay;
    INT CellIndex;
    class AUTWeapon* MyWeapon;
    //## END PROPS HudWidget_QuickPickCell

    DECLARE_CLASS(UHudWidget_QuickPickCell,UUTUI_HudWidget,0,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	void AssociatedWithWeapon(AUTWeapon* Weapon);
};

class UHudWidget_TeamBar : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_TeamBar
    class UUIImage* Separator;
    class UHudWidget_TeamScore* TeamWidgets[2];
    FLOAT TeamScale[2];
    FLOAT TeamScaleModifier;
    FLOAT TeamScaleTransitionRate;
    FLOAT WidgetDefaultWidth;
    FLOAT WidgetDefaultHeight;
    FLOAT TestTeamIndex;
    //## END PROPS HudWidget_TeamBar

    DECLARE_CLASS(UHudWidget_TeamBar,UUTUI_HudWidget,0,UTGame)
	virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime);

	void InitializeChild(UHudWidget_TeamScore* Child);
};

class UHudWidget_TeamScore : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_TeamScore
    class UUILabel* TeamScore;
    class UUIImage* TeamStatusIcon;
    class UUIImage* HomeBaseIndicator;
    INT TeamIndex;
    BYTE CurrentState;
    INT CurrentScore;
    //## END PROPS HudWidget_TeamScore

    DECLARE_CLASS(UHudWidget_TeamScore,UUTUI_HudWidget,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UHudWidget_TeamScore)
};

struct FWeaponGroupData
{
    class UHudWidget_WeaponGroup* Group;
    FLOAT Scaler;
    BITFIELD bOversized:1;
    FLOAT OverSizeScaler;
};

class UHudWidget_WeaponBar : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_WeaponBar
    FLOAT InactiveScale;
    FLOAT TransitionRate;
    INT ActiveGroupIndex;
    FLOAT NumberOfGroups;
    TArrayNoInit<struct FWeaponGroupData> GroupWidgets;
    class UUIPrefab* GroupTemplate;
    FLOAT OpacityList[4];
    FLOAT ActiveGroupOpacity;
    //## END PROPS HudWidget_WeaponBar

    DECLARE_CLASS(UHudWidget_WeaponBar,UUTUI_HudWidget,0,UTGame)
	/**
	 * We manage the weapon groups natively for speed.
	 */

	virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick_Widget(FLOAT DeltaTime);
	virtual void Render_Widget(FCanvas* Canvas);

	void InitializeGroup(UHudWidget_WeaponGroup* ChildGrp);
	void SetGroupAsActive(UHudWidget_WeaponGroup* ActiveGroup);

};

class UHudWidget_WeaponGroup : public UUTUI_HudWidget
{
public:
    //## BEGIN PROPS HudWidget_WeaponGroup
    BYTE AssociatedWeaponGroup;
    BYTE GroupStatus;
    BYTE LastWeaponGroup;
    BYTE LastPendingWeaponGroup;
    class UUILabel* GroupLabel;
    class UUIProgressBar* AmmoBar;
    class UUIImage* WeaponIcon;
    class UUIImage* Background;
    class UUIImage* Overlay;
    class UUIImage* PendingOverlay;
    class UHudWidget_WeaponBar* WeaponBar;
    FName HighlightStyleNames[3];
    //## END PROPS HudWidget_WeaponGroup

    DECLARE_CLASS(UHudWidget_WeaponGroup,UUTUI_HudWidget,0,UTGame)
	/**
	 * We manage the weapon groups natively for speed.
	 */
	virtual void Tick_Widget(FLOAT DeltaTime);

	/** UGLY - Overrride Initialize so that we can set the opacitys on the highlights until Ron get's back */

	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	void ChangeState(UBOOL bIsActive);
	void FadeIn(UUIImage* Image, FLOAT FadeRate);
	void FadeOut(UUIImage* Image, FLOAT FadeRate);
};

class UHudWidget_DeployableGroup : public UHudWidget_WeaponGroup
{
public:
    //## BEGIN PROPS HudWidget_DeployableGroup
    //## END PROPS HudWidget_DeployableGroup

    DECLARE_CLASS(UHudWidget_DeployableGroup,UHudWidget_WeaponGroup,0,UTGame)
	/**
	 * We manage the weapon groups natively for speed.
	 */
	virtual void Tick_Widget(FLOAT DeltaTime);
};

#define UCONST_UTUIBUTTONBAR_BUTTON_SPACING -20
#define UCONST_UTUIBUTTONBAR_MAX_BUTTONS 6

class UUTUIButtonBar : public UUTUI_Widget
{
public:
    //## BEGIN PROPS UTUIButtonBar
    class UUTUIButtonBarButton* Buttons[6];
    //## END PROPS UTUIButtonBar

    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    DECLARE_CLASS(UUTUIButtonBar,UUTUI_Widget,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIButtonBar)
};

#define UCONST_UIKEY_MoveCursorRight UIKEY_MoveCursorRight
#define UCONST_UIKEY_MoveCursorLeft UIKEY_MoveCursorLeft

struct UTUIOptionButton_eventOnMoveSelectionRight_Parms
{
    INT PlayerIndex;
    UTUIOptionButton_eventOnMoveSelectionRight_Parms(EEventParm)
    {
    }
};
struct UTUIOptionButton_eventOnMoveSelectionLeft_Parms
{
    INT PlayerIndex;
    UTUIOptionButton_eventOnMoveSelectionLeft_Parms(EEventParm)
    {
    }
};
class UUTUIOptionButton : public UUTUI_Widget, public IUIDataStorePublisher
{
public:
    //## BEGIN PROPS UTUIOptionButton
    class UUIButton* ArrowLeftButton;
    class UUIButton* ArrowRightButton;
    struct FUIScreenValue ButtonSpacing;
    class UUIComp_DrawImage* BackgroundImageComponent;
    class UUIComp_DrawString* StringRenderComponent;
    INT CurrentIndex;
    FName IncrementCue;
    FName DecrementCue;
    BITFIELD bWrapOptions:1;
    struct FUIDataStoreBinding DataSource;
    TScriptInterface<class IUIListElementProvider> DataProvider;
    //## END PROPS UTUIOptionButton

    virtual UBOOL HasPrevValue();
    virtual UBOOL HasNextValue();
    virtual void SetPrevValue();
    virtual void SetNextValue();
    virtual INT GetCurrentIndex();
    virtual void SetCurrentIndex(INT NewIndex);
    virtual void SetDataStoreBinding(const FString& MarkupText,INT BindingIndex=-1);
    virtual FString GetDataStoreBinding(INT BindingIndex=-1) const;
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void GetBoundDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    virtual void ClearBoundDataStores();
    virtual UBOOL SaveSubscriberValue(TArray<class UUIDataStore*>& out_BoundDataStores,INT BindingIndex=-1);
    DECLARE_FUNCTION(execHasPrevValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasPrevValue();
    }
    DECLARE_FUNCTION(execHasNextValue)
    {
        P_FINISH;
        *(UBOOL*)Result=HasNextValue();
    }
    DECLARE_FUNCTION(execSetPrevValue)
    {
        P_FINISH;
        SetPrevValue();
    }
    DECLARE_FUNCTION(execSetNextValue)
    {
        P_FINISH;
        SetNextValue();
    }
    DECLARE_FUNCTION(execGetCurrentIndex)
    {
        P_FINISH;
        *(INT*)Result=GetCurrentIndex();
    }
    DECLARE_FUNCTION(execSetCurrentIndex)
    {
        P_GET_INT(NewIndex);
        P_FINISH;
        SetCurrentIndex(NewIndex);
    }
    DECLARE_FUNCTION(execSetDataStoreBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        SetDataStoreBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreBinding)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(FString*)Result=GetDataStoreBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execRefreshSubscriberValue)
    {
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=RefreshSubscriberValue(BindingIndex);
    }
    DECLARE_FUNCTION(execGetBoundDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetBoundDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearBoundDataStores)
    {
        P_FINISH;
        ClearBoundDataStores();
    }
    DECLARE_FUNCTION(execSaveSubscriberValue)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_GET_INT_OPTX(BindingIndex,-1);
        P_FINISH;
        *(UBOOL*)Result=SaveSubscriberValue(out_BoundDataStores,BindingIndex);
    }
    void eventOnMoveSelectionRight(INT PlayerIndex)
    {
        UTUIOptionButton_eventOnMoveSelectionRight_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_OnMoveSelectionRight),&Parms);
    }
    void eventOnMoveSelectionLeft(INT PlayerIndex)
    {
        UTUIOptionButton_eventOnMoveSelectionLeft_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(UTGAME_OnMoveSelectionLeft),&Parms);
    }
    DECLARE_CLASS(UUTUIOptionButton,UUTUI_Widget,0,UTGame)
    virtual UObject* GetUObjectInterfaceUIDataStorePublisher(){return this;}
    virtual UObject* GetUObjectInterfaceUIDataStoreSubscriber(){return this;}
	/* === UUIScreenObject interface === */

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/* === UUIObject interface === */
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the LabelBackground (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();


	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	
	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Render this button.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Resolves DataSource into the list element provider that it references.
	 */
	void ResolveListElementProvider();

protected:
	/**
	 * Called when the option button's index has changed.
	 *
	 * @param	PreviousIndex	the list's Index before it was changed
	 * @param	PlayerIndex		the index of the player associated with this index change.
	 */
	void NotifyIndexChanged( INT PreviousIndex, INT PlayerIndex );

	/** @return Returns the number of possible values for the field we are bound to. */
	INT GetNumValues();

	/**
	 * @param ListIndex		List index to get the value of.
	 * @param OutValue	Storage string for the list value
	 *
	 * @return Returns TRUE if we were able to get a value, FALSE otherwise
	 */
	UBOOL GetListValue(INT ListIndex, FString &OutValue);

	/** Updates the string value using the current index. */
	void UpdateCurrentStringValue();

	/**
	 * Handles input events for this list.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Handles input events for this button.
	 *
	 * @param	InState		State class to activate.
	 * @param	Arrow		Which arrow to activate the state for, LEFT is 0, RIGHT is 1.
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	void ActivateArrowState( UClass* InState, EOptionButtonArrow Arrow );

	/**
	 * Returns the current arrow state(Enabled or disabled) depending on whether or not the widget can shift left or right.
	 */
	UClass* GetArrowEnabledState(EOptionButtonArrow Arrow);

	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );
};

struct UTUIScene_eventCanPlayOnline_Parms
{
    INT ControllerId;
    UBOOL ReturnValue;
    UTUIScene_eventCanPlayOnline_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventIsLoggedIn_Parms
{
    INT ControllerId;
    UBOOL ReturnValue;
    UTUIScene_eventIsLoggedIn_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnAnimationFinished_Parms
{
    class UUIObject* AnimTarget;
    FName AnimName;
    FName SeqName;
    UTUIScene_eventOnAnimationFinished_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnHideAnimationEnded_Parms
{
    UTUIScene_eventOnHideAnimationEnded_Parms(EEventParm)
    {
    }
};
struct UTUIScene_eventOnShowAnimationEnded_Parms
{
    UTUIScene_eventOnShowAnimationEnded_Parms(EEventParm)
    {
    }
};
class UUTUIScene : public UUIScene
{
public:
    //## BEGIN PROPS UTUIScene
    BITFIELD bEditorRealTimePreview:1;
    class UUIScene* MessageBoxScene;
    class UUIScene* PendingOpenScene;
    class UUIScene* PendingCloseScene;
    FScriptDelegate __OnShowAnimationEnded__Delegate;
    FScriptDelegate __OnHideAnimationEnded__Delegate;
    //## END PROPS UTUIScene

    virtual class AWorldInfo* GetWorldInfo();
    virtual class AUTPlayerController* GetUTPlayerOwner(INT PlayerIndex=-1);
    virtual class APawn* GetPawnOwner();
    virtual class AUTPlayerReplicationInfo* GetPRIOwner();
    BYTE GetPlatform();
    virtual UBOOL IsGame();
    virtual void StartDedicatedServer(const FString& TravelURL);
    virtual void ActivateLevelEvent(FName EventName);
    DECLARE_FUNCTION(execGetUTPlayerOwner)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class AUTPlayerController**)Result=GetUTPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetPawnOwner)
    {
        P_FINISH;
        *(class APawn**)Result=GetPawnOwner();
    }
    DECLARE_FUNCTION(execGetPRIOwner)
    {
        P_FINISH;
        *(class AUTPlayerReplicationInfo**)Result=GetPRIOwner();
    }
    DECLARE_FUNCTION(execGetPlatform)
    {
        P_FINISH;
        *(BYTE*)Result=GetPlatform();
    }
    DECLARE_FUNCTION(execIsGame)
    {
        P_FINISH;
        *(UBOOL*)Result=IsGame();
    }
    DECLARE_FUNCTION(execStartDedicatedServer)
    {
        P_GET_STR(TravelURL);
        P_FINISH;
        StartDedicatedServer(TravelURL);
    }
    DECLARE_FUNCTION(execActivateLevelEvent)
    {
        P_GET_NAME(EventName);
        P_FINISH;
        ActivateLevelEvent(EventName);
    }
    UBOOL eventCanPlayOnline(INT ControllerId=-1)
    {
        UTUIScene_eventCanPlayOnline_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(UTGAME_CanPlayOnline),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsLoggedIn(INT ControllerId=-1)
    {
        UTUIScene_eventIsLoggedIn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(UTGAME_IsLoggedIn),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnAnimationFinished(class UUIObject* AnimTarget,FName AnimName,FName SeqName)
    {
        UTUIScene_eventOnAnimationFinished_Parms Parms(EC_EventParm);
        Parms.AnimTarget=AnimTarget;
        Parms.AnimName=AnimName;
        Parms.SeqName=SeqName;
        ProcessEvent(FindFunctionChecked(UTGAME_OnAnimationFinished),&Parms);
    }
    void delegateOnHideAnimationEnded()
    {
        ProcessDelegate(UTGAME_OnHideAnimationEnded,&__OnHideAnimationEnded__Delegate,NULL);
    }
    void delegateOnShowAnimationEnded()
    {
        ProcessDelegate(UTGAME_OnShowAnimationEnded,&__OnShowAnimationEnded__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUTUIScene,UUIScene,0,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick( FLOAT DeltaTime );
	virtual void TickChildren(UUIScreenObject* ParentObject, FLOAT DeltaTime);
	virtual void PreRender(FCanvas* Canvas);

	static void AutoPlaceChildren(UUIScreenObject *const BaseObject);
};

class UUTUIScene_Campaign : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_Campaign
    class UUTUIButtonBar* ButtonBar;
    //## END PROPS UTUIScene_Campaign

    DECLARE_ABSTRACT_CLASS(UUTUIScene_Campaign,UUTUIScene,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_Campaign)
};

struct UTUIScene_CMissionSelection_eventPlayNextTeaser_Parms
{
    UTUIScene_CMissionSelection_eventPlayNextTeaser_Parms(EEventParm)
    {
    }
};
class UUTUIScene_CMissionSelection : public UUTUIScene_Campaign
{
public:
    //## BEGIN PROPS UTUIScene_CMissionSelection
    class UUTUIOptionButton* NextMission;
    class UUILabel* NextMissionCaption;
    class UUIImage* PreviousMissionBox;
    class UUILabel* PreviousMission;
    class UUILabel* PreviousResult;
    class UUTUIDataStore_StringList* StringStore;
    class UUILabel* MissionTeaserText;
    class UUIImage* MissionTeaserPortrait;
    class UUIImage* MissionTeaser;
    class UUILabel* PlayerLabels[4];
    class UAudioComponent* AudioPlayer;
    TArrayNoInit<class UUTSeqObj_SPMission*> AvailMissionList;
    class UUTSeqObj_SPMission* PreviousMissionObj;
    BITFIELD bIsHost:1;
    INT CurrentMissionIndex;
    INT TeaserIndex;
    FLOAT TeaserDuration;
    class UStaticMesh* PrevMapPointSFXTemplate;
    class UStaticMesh* MapPointSFXTemplate;
    class UStaticMesh* SelectedMapPointSFXTemplate;
    //## END PROPS UTUIScene_CMissionSelection

    void eventPlayNextTeaser()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_PlayNextTeaser),NULL);
    }
    DECLARE_CLASS(UUTUIScene_CMissionSelection,UUTUIScene_Campaign,0,UTGame)
	/**
	 * Update the Teaser
	 *
	 * @param	DeltaTime	the time since the last Tick call
	 */
	virtual void Tick( FLOAT DeltaTime );

};

class UUTUIScene_Hud : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_Hud
    //## END PROPS UTUIScene_Hud

    virtual class AUTHUD* GetPlayerHud();
    DECLARE_FUNCTION(execGetPlayerHud)
    {
        P_FINISH;
        *(class AUTHUD**)Result=GetPlayerHud();
    }
    DECLARE_CLASS(UUTUIScene_Hud,UUTUIScene,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_Hud)
};

class UUTUIScene_MapVote : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_MapVote
    class UUTDrawMapVotePanel* MapList;
    class UUILabel* TimeRemaining;
    class AUTVoteReplicationInfo* VoteRI;
    //## END PROPS UTUIScene_MapVote

    DECLARE_CLASS(UUTUIScene_MapVote,UUTUIScene_Hud,0,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_MOTD_eventFinish_Parms
{
    UTUIScene_MOTD_eventFinish_Parms(EEventParm)
    {
    }
};
class UUTUIScene_MOTD : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_MOTD
    FLOAT TimeRemainingOnScreen;
    class UUISafeRegionPanel* Panel;
    //## END PROPS UTUIScene_MOTD

    void eventFinish()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_Finish),NULL);
    }
    DECLARE_CLASS(UUTUIScene_MOTD,UUTUIScene_Hud,0,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_Pawns_eventOnSceneTransitionFinished_Parms
{
    class UUTUIScene_Hud* SourceScene;
    UBOOL bOut;
    UTUIScene_Pawns_eventOnSceneTransitionFinished_Parms(EEventParm)
    {
    }
};
class UUTUIScene_Pawns : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_Pawns
    BITFIELD bForceInitialAnimation:1;
    BITFIELD bDeactivating:1;
    FScriptDelegate __OnSceneTransitionFinished__Delegate;
    //## END PROPS UTUIScene_Pawns

    void delegateOnSceneTransitionFinished(class UUTUIScene_Hud* SourceScene,UBOOL bOut)
    {
        UTUIScene_Pawns_eventOnSceneTransitionFinished_Parms Parms(EC_EventParm);
        Parms.SourceScene=SourceScene;
        Parms.bOut=bOut ? FIRST_BITFIELD : 0;
        ProcessDelegate(UTGAME_OnSceneTransitionFinished,&__OnSceneTransitionFinished__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUTUIScene_Pawns,UUTUIScene_Hud,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_Pawns)
};

class UUTUIScene_UTPawn : public UUTUIScene_Pawns
{
public:
    //## BEGIN PROPS UTUIScene_UTPawn
    //## END PROPS UTUIScene_UTPawn

    DECLARE_CLASS(UUTUIScene_UTPawn,UUTUIScene_Pawns,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_UTPawn)
};

class UUTUIScene_VehicleHud : public UUTUIScene_Pawns
{
public:
    //## BEGIN PROPS UTUIScene_VehicleHud
    class AUTVehicle* MyVehicle;
    //## END PROPS UTUIScene_VehicleHud

    DECLARE_ABSTRACT_CLASS(UUTUIScene_VehicleHud,UUTUIScene_Pawns,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_VehicleHud)
};

class UVHud_Scorpion : public UUTUIScene_VehicleHud
{
public:
    //## BEGIN PROPS VHud_Scorpion
    class UUIProgressBar* BoostBar;
    class UUILabel* BoostMsg;
    FName BoostBarName;
    FName BoostMsgName;
    FStringNoInit LastBoostMsg;
    FStringNoInit BoostMarkup;
    FStringNoInit EjectMarkup;
    //## END PROPS VHud_Scorpion

    DECLARE_CLASS(UVHud_Scorpion,UUTUIScene_VehicleHud,0,UTGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	virtual void Tick( FLOAT DeltaTime );
};

struct UTUIScene_Scoreboard_eventTickScene_Parms
{
    FLOAT DeltaTime;
    UTUIScene_Scoreboard_eventTickScene_Parms(EEventParm)
    {
    }
};
class UUTUIScene_Scoreboard : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_Scoreboard
    class UUILabel* MapName;
    class UUILabel* GoalScore;
    FStringNoInit LastMapName;
    INT LastGoalScore;
    //## END PROPS UTUIScene_Scoreboard

    void eventTickScene(FLOAT DeltaTime)
    {
        UTUIScene_Scoreboard_eventTickScene_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_TickScene),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUTUIScene_Scoreboard,UUTUIScene_Hud,0,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

class UUTUIScene_WeaponHud : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_WeaponHud
    //## END PROPS UTUIScene_WeaponHud

    DECLARE_CLASS(UUTUIScene_WeaponHud,UUTUIScene_Hud,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUTUIScene_WeaponHud)
};

struct FRLSegmentData
{
    class UUIContainer* Container;
    TArrayNoInit<class UUIImage*> ChildrenImages;
    FLOAT OpacityTarget;
    FLOAT Opacity;
    FLOAT OpacityTime;

    /** Constructors */
    FRLSegmentData() {}
    FRLSegmentData(EEventParm)
    {
        appMemzero(this, sizeof(FRLSegmentData));
    }
};

struct WeapHud_RocketLauncher_eventTickScene_Parms
{
    FLOAT DeltaTime;
    WeapHud_RocketLauncher_eventTickScene_Parms(EEventParm)
    {
    }
};
class UWeapHud_RocketLauncher : public UUTUIScene_WeaponHud
{
public:
    //## BEGIN PROPS WeapHud_RocketLauncher
    class UUIImage* DefaultCrosshairImage;
    FLOAT TransitionInTime;
    FLOAT TransitionOutTime;
    struct FRLSegmentData Segments[3];
    INT FireMode;
    INT LoadedShotCount;
    FLOAT CrosshairTargetRotation;
    FLOAT CrosshairRotation;
    FLOAT CrosshairRotationTime;
    //## END PROPS WeapHud_RocketLauncher

    void eventTickScene(FLOAT DeltaTime)
    {
        WeapHud_RocketLauncher_eventTickScene_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UTGAME_TickScene),&Parms);
    }
    DECLARE_CLASS(UWeapHud_RocketLauncher,UUTUIScene_WeaponHud,0,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

class UUTUIScene_WeaponQuickPick : public UUTUIScene_Hud
{
public:
    //## BEGIN PROPS UTUIScene_WeaponQuickPick
    class UHudWidget_QuickPickCell* Cells[8];
    INT CurrentGroup;
    FLOAT RefreshTimer;
    FLOAT RefreshFrequency;
    //## END PROPS UTUIScene_WeaponQuickPick

    virtual void RefreshCells();
    DECLARE_FUNCTION(execRefreshCells)
    {
        P_FINISH;
        RefreshCells();
    }
    DECLARE_CLASS(UUTUIScene_WeaponQuickPick,UUTUIScene_Hud,0,UTGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void Tick( FLOAT DeltaTime );
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
};

struct FPotentialOptionKeys
{
    TArrayNoInit<FName> Keys;

    /** Constructors */
    FPotentialOptionKeys() {}
    FPotentialOptionKeys(EEventParm)
    {
        appMemzero(this, sizeof(FPotentialOptionKeys));
    }
};

#define UCONST_MESSAGEBOX_MAX_POSSIBLE_OPTIONS 4

struct UTUIScene_MessageBox_eventOnHideComplete_Parms
{
    UTUIScene_MessageBox_eventOnHideComplete_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnShowComplete_Parms
{
    UTUIScene_MessageBox_eventOnShowComplete_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnMBInputKey_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UTUIScene_MessageBox_eventOnMBInputKey_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnClosed_Parms
{
    UTUIScene_MessageBox_eventOnClosed_Parms(EEventParm)
    {
    }
};
struct UTUIScene_MessageBox_eventOnSelection_Parms
{
    INT SelectedOption;
    INT PlayerIndex;
    UTUIScene_MessageBox_eventOnSelection_Parms(EEventParm)
    {
    }
};
class UUTUIScene_MessageBox : public UUTUIScene
{
public:
    //## BEGIN PROPS UTUIScene_MessageBox
    class UUILabel* MessageLabel;
    class UUILabel* TitleLabel;
    class UUIImage* BackgroundImage;
    class UUTUIButtonBar* ButtonBar;
    TArrayNoInit<FString> PotentialOptions;
    TArrayNoInit<struct FPotentialOptionKeys> PotentialOptionKeyMappings;
    BITFIELD bFullyVisible:1;
    BITFIELD bHideOnNextTick:1;
    INT PreviouslySelectedOption;
    INT SelectingPlayer;
    INT DefaultOptionIdx;
    FLOAT DisplayTime;
    FLOAT MinimumDisplayTime;
    FLOAT FadeDuration;
    INT FadeDirection;
    FLOAT FadeStartTime;
    FScriptDelegate __OnSelection__Delegate;
    FScriptDelegate __OnClosed__Delegate;
    FScriptDelegate __OnMBInputKey__Delegate;
    //## END PROPS UTUIScene_MessageBox

    virtual void BeginShow();
    virtual void BeginHide();
    DECLARE_FUNCTION(execBeginShow)
    {
        P_FINISH;
        BeginShow();
    }
    DECLARE_FUNCTION(execBeginHide)
    {
        P_FINISH;
        BeginHide();
    }
    void eventOnHideComplete()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_OnHideComplete),NULL);
    }
    void eventOnShowComplete()
    {
        ProcessEvent(FindFunctionChecked(UTGAME_OnShowComplete),NULL);
    }
    UBOOL delegateOnMBInputKey(const struct FInputEventParameters& EventParms)
    {
        UTUIScene_MessageBox_eventOnMBInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(UTGAME_OnMBInputKey,&__OnMBInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnClosed()
    {
        ProcessDelegate(UTGAME_OnClosed,&__OnClosed__Delegate,NULL);
    }
    void delegateOnSelection(INT SelectedOption,INT PlayerIndex)
    {
        UTUIScene_MessageBox_eventOnSelection_Parms Parms(EC_EventParm);
        Parms.SelectedOption=SelectedOption;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(UTGAME_OnSelection,&__OnSelection__Delegate,&Parms);
    }
    DECLARE_CLASS(UUTUIScene_MessageBox,UUTUIScene,0,UTGame)
	virtual void Tick( FLOAT DeltaTime );
};

class UUIState_UTObjStates : public UUIState
{
public:
    //## BEGIN PROPS UIState_UTObjStates
    //## END PROPS UIState_UTObjStates

    DECLARE_ABSTRACT_CLASS(UUIState_UTObjStates,UUIState,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjStates)
};

class UUIState_UTObjActive : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjActive
    //## END PROPS UIState_UTObjActive

    DECLARE_CLASS(UUIState_UTObjActive,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjActive)
};

class UUIState_UTObjBuilding : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjBuilding
    //## END PROPS UIState_UTObjBuilding

    DECLARE_CLASS(UUIState_UTObjBuilding,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjBuilding)
};

class UUIState_UTObjCritical : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjCritical
    //## END PROPS UIState_UTObjCritical

    DECLARE_CLASS(UUIState_UTObjCritical,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjCritical)
};

class UUIState_UTObjInactive : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjInactive
    //## END PROPS UIState_UTObjInactive

    DECLARE_CLASS(UUIState_UTObjInactive,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjInactive)
};

class UUIState_UTObjNeutral : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjNeutral
    //## END PROPS UIState_UTObjNeutral

    DECLARE_CLASS(UUIState_UTObjNeutral,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjNeutral)
};

class UUIState_UTObjProtected : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjProtected
    //## END PROPS UIState_UTObjProtected

    DECLARE_CLASS(UUIState_UTObjProtected,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjProtected)
};

class UUIState_UTObjUnderAttack : public UUIState_UTObjStates
{
public:
    //## BEGIN PROPS UIState_UTObjUnderAttack
    //## END PROPS UIState_UTObjUnderAttack

    DECLARE_CLASS(UUIState_UTObjUnderAttack,UUIState_UTObjStates,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(UUIState_UTObjUnderAttack)
};

#endif

AUTOGENERATE_FUNCTION(UHudWidget_LocalMessages,-1,execSizeZone);
AUTOGENERATE_FUNCTION(UMiniMapImage,-1,execSetStyle);
AUTOGENERATE_FUNCTION(UUTDrawPanel,-1,execDraw2DLine);
AUTOGENERATE_FUNCTION(UUTGameUISceneClient,-1,execIsUIAcceptingInput);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execLinkToHudScene);
AUTOGENERATE_FUNCTION(AUTHUD,-1,execDrawGlowText);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execUpdateAnimation);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execSortList);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execFindTag);
AUTOGENERATE_FUNCTION(UUTSimpleList,-1,execFind);
AUTOGENERATE_FUNCTION(UUTUI_HudWidget,-1,execStopAnimation);
AUTOGENERATE_FUNCTION(UUTUI_HudWidget,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(UUTUIButtonBar,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUTUIButtonBarButton,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIComboBox,-1,execSetupChildStyles);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_MapInfo,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_MenuOption,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIDataProvider_Mutator,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIDataStore_CustomChar,-1,execGetValueFromProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_CustomChar,-1,execFindValueInProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetValueFromProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execFindValueInProviderSet);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetAllResourceDataProviders);
AUTOGENERATE_FUNCTION(UUTUIDataStore_MenuItems,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetList);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execFindStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execEmpty);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execRemoveStrByIndex);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execRemoveStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execInsertStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execAddStr);
AUTOGENERATE_FUNCTION(UUTUIDataStore_StringList,-1,execGetFieldIndex);
AUTOGENERATE_FUNCTION(UUTUIEditBox,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIEditBox,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execFindCellFieldString);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execGetRowHeight);
AUTOGENERATE_FUNCTION(UUTUIMenuList,-1,execGetCellFieldValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSaveSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execClearBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetBoundDataStores);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetDataStoreBinding);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetCurrentIndex);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execGetCurrentIndex);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetNextValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execSetPrevValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execHasNextValue);
AUTOGENERATE_FUNCTION(UUTUIOptionButton,-1,execHasPrevValue);
AUTOGENERATE_FUNCTION(UUTUIResourceDataProvider,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execActivateLevelEvent);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execStartDedicatedServer);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execIsGame);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPlatform);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPRIOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetPawnOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetUTPlayerOwner);
AUTOGENERATE_FUNCTION(UUTUIScene,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UUTUIScene_Hud,-1,execGetPlayerHud);
AUTOGENERATE_FUNCTION(UUTUIScene_MessageBox,-1,execBeginHide);
AUTOGENERATE_FUNCTION(UUTUIScene_MessageBox,-1,execBeginShow);
AUTOGENERATE_FUNCTION(UUTUIScene_WeaponQuickPick,-1,execRefreshCells);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_UI_NATIVE_DEFS
#define UTGAME_UI_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,UHudWidget_DeployableGroup);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_LocalMessages);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_Map);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_PawnDoll);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_QuickPickCell);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_TeamBar);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_TeamScore);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_WeaponBar);
DECLARE_NATIVE_TYPE(UTGame,UHudWidget_WeaponGroup);
DECLARE_NATIVE_TYPE(UTGame,UMiniMapImage);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_DrawTeamColoredImage);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTDrawStateImage);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTGlowString);
DECLARE_NATIVE_TYPE(UTGame,UUIComp_UTUIMenuListPresenter);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjActive);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjBuilding);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjCritical);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjInactive);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjNeutral);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjProtected);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjStates);
DECLARE_NATIVE_TYPE(UTGame,UUIState_UTObjUnderAttack);
DECLARE_NATIVE_TYPE(UTGame,UUTDrawPanel);
DECLARE_NATIVE_TYPE(UTGame,UUTGameUISceneClient);
DECLARE_NATIVE_TYPE(UTGame,AUTHUD);
DECLARE_NATIVE_TYPE(UTGame,UUTSeqObj_SPMission);
DECLARE_NATIVE_TYPE(UTGame,UUTSeqObj_SPRootMission);
DECLARE_NATIVE_TYPE(UTGame,UUTSimpleList);
DECLARE_NATIVE_TYPE(UTGame,UUTTabPage);
DECLARE_NATIVE_TYPE(UTGame,UUTUI_HudWidget);
DECLARE_NATIVE_TYPE(UTGame,UUTUI_Widget);
DECLARE_NATIVE_TYPE(UTGame,UUTUIButtonBar);
DECLARE_NATIVE_TYPE(UTGame,UUTUIButtonBarButton);
DECLARE_NATIVE_TYPE(UTGame,UUTUIComboBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Character);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_CharacterFaction);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_CharacterPart);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_CommunityMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_DemoFile);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_GameModeInfo);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_KeyBinding);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MainMenuItems);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MapInfo);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MenuOption);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_MultiplayerMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Mutator);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SearchResult);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SettingsMenuItem);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_SimpleMenu);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataProvider_Weapon);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_CustomChar);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_MenuItems);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_Options);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_StringAliasMap);
DECLARE_NATIVE_TYPE(UTGame,UUTUIDataStore_StringList);
DECLARE_NATIVE_TYPE(UTGame,UUTUIEditBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIList);
DECLARE_NATIVE_TYPE(UTGame,UUTUIMenuList);
DECLARE_NATIVE_TYPE(UTGame,UUTUINumericEditBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIOptionButton);
DECLARE_NATIVE_TYPE(UTGame,UUTUIResourceDataProvider);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Campaign);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_CMissionSelection);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Hud);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MapVote);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MessageBox);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_MOTD);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Pawns);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_Scoreboard);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_UTPawn);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_VehicleHud);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_WeaponHud);
DECLARE_NATIVE_TYPE(UTGame,UUTUIScene_WeaponQuickPick);
DECLARE_NATIVE_TYPE(UTGame,UUTUISlider);
DECLARE_NATIVE_TYPE(UTGame,UUTUITabControl);
DECLARE_NATIVE_TYPE(UTGame,UVHud_Scorpion);
DECLARE_NATIVE_TYPE(UTGame,UWeapHud_RocketLauncher);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_UI \
	UHudWidget_DeployableGroup::StaticClass(); \
	UHudWidget_LocalMessages::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUHudWidget_LocalMessagesNative; \
	UHudWidget_Map::StaticClass(); \
	UHudWidget_PawnDoll::StaticClass(); \
	UHudWidget_QuickPickCell::StaticClass(); \
	UHudWidget_TeamBar::StaticClass(); \
	UHudWidget_TeamScore::StaticClass(); \
	UHudWidget_WeaponBar::StaticClass(); \
	UHudWidget_WeaponGroup::StaticClass(); \
	UMiniMapImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUMiniMapImageNative; \
	UUIComp_DrawTeamColoredImage::StaticClass(); \
	UUIComp_UTDrawStateImage::StaticClass(); \
	UUIComp_UTGlowString::StaticClass(); \
	UUIComp_UTUIMenuListPresenter::StaticClass(); \
	UUIState_UTObjActive::StaticClass(); \
	UUIState_UTObjBuilding::StaticClass(); \
	UUIState_UTObjCritical::StaticClass(); \
	UUIState_UTObjInactive::StaticClass(); \
	UUIState_UTObjNeutral::StaticClass(); \
	UUIState_UTObjProtected::StaticClass(); \
	UUIState_UTObjStates::StaticClass(); \
	UUIState_UTObjUnderAttack::StaticClass(); \
	UUTDrawPanel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTDrawPanelNative; \
	UUTGameUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTGameUISceneClientNative; \
	AUTHUD::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameAUTHUDNative; \
	UUTSeqObj_SPMission::StaticClass(); \
	UUTSeqObj_SPRootMission::StaticClass(); \
	UUTSimpleList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTSimpleListNative; \
	UUTTabPage::StaticClass(); \
	UUTUI_HudWidget::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUI_HudWidgetNative; \
	UUTUI_Widget::StaticClass(); \
	UUTUIButtonBar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIButtonBarNative; \
	UUTUIButtonBarButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIButtonBarButtonNative; \
	UUTUIComboBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIComboBoxNative; \
	UUTUIDataProvider_Character::StaticClass(); \
	UUTUIDataProvider_CharacterFaction::StaticClass(); \
	UUTUIDataProvider_CharacterPart::StaticClass(); \
	UUTUIDataProvider_CommunityMenuItem::StaticClass(); \
	UUTUIDataProvider_DemoFile::StaticClass(); \
	UUTUIDataProvider_GameModeInfo::StaticClass(); \
	UUTUIDataProvider_KeyBinding::StaticClass(); \
	UUTUIDataProvider_MainMenuItems::StaticClass(); \
	UUTUIDataProvider_MapInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_MapInfoNative; \
	UUTUIDataProvider_MenuOption::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_MenuOptionNative; \
	UUTUIDataProvider_MultiplayerMenuItem::StaticClass(); \
	UUTUIDataProvider_Mutator::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataProvider_MutatorNative; \
	UUTUIDataProvider_SearchResult::StaticClass(); \
	UUTUIDataProvider_SettingsMenuItem::StaticClass(); \
	UUTUIDataProvider_SimpleMenu::StaticClass(); \
	UUTUIDataProvider_Weapon::StaticClass(); \
	UUTUIDataStore_CustomChar::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_CustomCharNative; \
	UUTUIDataStore_MenuItems::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_MenuItemsNative; \
	UUTUIDataStore_Options::StaticClass(); \
	UUTUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_StringAliasMapNative; \
	UUTUIDataStore_StringList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIDataStore_StringListNative; \
	UUTUIEditBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIEditBoxNative; \
	UUTUIList::StaticClass(); \
	UUTUIMenuList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIMenuListNative; \
	UUTUINumericEditBox::StaticClass(); \
	UUTUIOptionButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIOptionButtonNative; \
	UUTUIResourceDataProvider::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIResourceDataProviderNative; \
	UUTUIScene::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUISceneNative; \
	UUTUIScene_Campaign::StaticClass(); \
	UUTUIScene_CMissionSelection::StaticClass(); \
	UUTUIScene_Hud::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_HudNative; \
	UUTUIScene_MapVote::StaticClass(); \
	UUTUIScene_MessageBox::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_MessageBoxNative; \
	UUTUIScene_MOTD::StaticClass(); \
	UUTUIScene_Pawns::StaticClass(); \
	UUTUIScene_Scoreboard::StaticClass(); \
	UUTUIScene_UTPawn::StaticClass(); \
	UUTUIScene_VehicleHud::StaticClass(); \
	UUTUIScene_WeaponHud::StaticClass(); \
	UUTUIScene_WeaponQuickPick::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameUUTUIScene_WeaponQuickPickNative; \
	UUTUISlider::StaticClass(); \
	UUTUITabControl::StaticClass(); \
	UVHud_Scorpion::StaticClass(); \
	UWeapHud_RocketLauncher::StaticClass(); \

#endif // UTGAME_UI_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UHudWidget_LocalMessages) GUTGameUHudWidget_LocalMessagesNatives[] = 
{ 
	MAP_NATIVE(UHudWidget_LocalMessages,execSizeZone)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UHudWidget_LocalMessages);

NATIVE_INFO(UMiniMapImage) GUTGameUMiniMapImageNatives[] = 
{ 
	MAP_NATIVE(UMiniMapImage,execSetStyle)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UMiniMapImage);

NATIVE_INFO(UUTDrawPanel) GUTGameUUTDrawPanelNatives[] = 
{ 
	MAP_NATIVE(UUTDrawPanel,execDraw2DLine)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTDrawPanel);

NATIVE_INFO(UUTGameUISceneClient) GUTGameUUTGameUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUTGameUISceneClient,execIsUIAcceptingInput)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTGameUISceneClient);

NATIVE_INFO(AUTHUD) GUTGameAUTHUDNatives[] = 
{ 
	MAP_NATIVE(AUTHUD,execLinkToHudScene)
	MAP_NATIVE(AUTHUD,execDrawGlowText)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,AUTHUD);

NATIVE_INFO(UUTSimpleList) GUTGameUUTSimpleListNatives[] = 
{ 
	MAP_NATIVE(UUTSimpleList,execUpdateAnimation)
	MAP_NATIVE(UUTSimpleList,execSortList)
	MAP_NATIVE(UUTSimpleList,execFindTag)
	MAP_NATIVE(UUTSimpleList,execFind)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTSimpleList);

NATIVE_INFO(UUTUI_HudWidget) GUTGameUUTUI_HudWidgetNatives[] = 
{ 
	MAP_NATIVE(UUTUI_HudWidget,execStopAnimation)
	MAP_NATIVE(UUTUI_HudWidget,execPlayAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUI_HudWidget);

NATIVE_INFO(UUTUIButtonBar) GUTGameUUTUIButtonBarNatives[] = 
{ 
	MAP_NATIVE(UUTUIButtonBar,execCanAcceptFocus)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIButtonBar);

NATIVE_INFO(UUTUIButtonBarButton) GUTGameUUTUIButtonBarButtonNatives[] = 
{ 
	MAP_NATIVE(UUTUIButtonBarButton,execCanAcceptFocus)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIButtonBarButton);

NATIVE_INFO(UUTUIComboBox) GUTGameUUTUIComboBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIComboBox,execSaveSubscriberValue)
	MAP_NATIVE(UUTUIComboBox,execClearBoundDataStores)
	MAP_NATIVE(UUTUIComboBox,execGetBoundDataStores)
	MAP_NATIVE(UUTUIComboBox,execRefreshSubscriberValue)
	MAP_NATIVE(UUTUIComboBox,execGetDataStoreBinding)
	MAP_NATIVE(UUTUIComboBox,execSetDataStoreBinding)
	MAP_NATIVE(UUTUIComboBox,execSetupChildStyles)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIComboBox);

NATIVE_INFO(UUTUIDataProvider_MapInfo) GUTGameUUTUIDataProvider_MapInfoNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_MapInfo,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_MapInfo);

NATIVE_INFO(UUTUIDataProvider_MenuOption) GUTGameUUTUIDataProvider_MenuOptionNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_MenuOption,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_MenuOption);

NATIVE_INFO(UUTUIDataProvider_Mutator) GUTGameUUTUIDataProvider_MutatorNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataProvider_Mutator,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataProvider_Mutator);

NATIVE_INFO(UUTUIDataStore_CustomChar) GUTGameUUTUIDataStore_CustomCharNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_CustomChar,execGetValueFromProviderSet)
	MAP_NATIVE(UUTUIDataStore_CustomChar,execFindValueInProviderSet)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_CustomChar);

NATIVE_INFO(UUTUIDataStore_MenuItems) GUTGameUUTUIDataStore_MenuItemsNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetValueFromProviderSet)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execFindValueInProviderSet)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetAllResourceDataProviders)
	MAP_NATIVE(UUTUIDataStore_MenuItems,execGetProviderCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_MenuItems);

NATIVE_INFO(UUTUIDataStore_StringAliasMap) GUTGameUUTUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_StringAliasMap,execGetStringWithFieldName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_StringAliasMap);

NATIVE_INFO(UUTUIDataStore_StringList) GUTGameUUTUIDataStore_StringListNatives[] = 
{ 
	MAP_NATIVE(UUTUIDataStore_StringList,execGetList)
	MAP_NATIVE(UUTUIDataStore_StringList,execGetStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execFindStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execEmpty)
	MAP_NATIVE(UUTUIDataStore_StringList,execRemoveStrByIndex)
	MAP_NATIVE(UUTUIDataStore_StringList,execRemoveStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execInsertStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execAddStr)
	MAP_NATIVE(UUTUIDataStore_StringList,execGetFieldIndex)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIDataStore_StringList);

NATIVE_INFO(UUTUIEditBox) GUTGameUUTUIEditBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIEditBox,execSaveSubscriberValue)
	MAP_NATIVE(UUTUIEditBox,execRefreshSubscriberValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIEditBox);

NATIVE_INFO(UUTUIMenuList) GUTGameUUTUIMenuListNatives[] = 
{ 
	MAP_NATIVE(UUTUIMenuList,execRefreshSubscriberValue)
	MAP_NATIVE(UUTUIMenuList,execFindCellFieldString)
	MAP_NATIVE(UUTUIMenuList,execGetRowHeight)
	MAP_NATIVE(UUTUIMenuList,execGetCellFieldValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIMenuList);

NATIVE_INFO(UUTUIOptionButton) GUTGameUUTUIOptionButtonNatives[] = 
{ 
	MAP_NATIVE(UUTUIOptionButton,execSaveSubscriberValue)
	MAP_NATIVE(UUTUIOptionButton,execClearBoundDataStores)
	MAP_NATIVE(UUTUIOptionButton,execGetBoundDataStores)
	MAP_NATIVE(UUTUIOptionButton,execRefreshSubscriberValue)
	MAP_NATIVE(UUTUIOptionButton,execGetDataStoreBinding)
	MAP_NATIVE(UUTUIOptionButton,execSetDataStoreBinding)
	MAP_NATIVE(UUTUIOptionButton,execSetCurrentIndex)
	MAP_NATIVE(UUTUIOptionButton,execGetCurrentIndex)
	MAP_NATIVE(UUTUIOptionButton,execSetNextValue)
	MAP_NATIVE(UUTUIOptionButton,execSetPrevValue)
	MAP_NATIVE(UUTUIOptionButton,execHasNextValue)
	MAP_NATIVE(UUTUIOptionButton,execHasPrevValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIOptionButton);

NATIVE_INFO(UUTUIResourceDataProvider) GUTGameUUTUIResourceDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUTUIResourceDataProvider,execIsFiltered)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIResourceDataProvider);

NATIVE_INFO(UUTUIScene) GUTGameUUTUISceneNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene,execActivateLevelEvent)
	MAP_NATIVE(UUTUIScene,execStartDedicatedServer)
	MAP_NATIVE(UUTUIScene,execIsGame)
	MAP_NATIVE(UUTUIScene,execGetPlatform)
	MAP_NATIVE(UUTUIScene,execGetPRIOwner)
	MAP_NATIVE(UUTUIScene,execGetPawnOwner)
	MAP_NATIVE(UUTUIScene,execGetUTPlayerOwner)
	MAP_NATIVE(UUTUIScene,execGetWorldInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene);

NATIVE_INFO(UUTUIScene_Hud) GUTGameUUTUIScene_HudNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_Hud,execGetPlayerHud)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_Hud);

NATIVE_INFO(UUTUIScene_MessageBox) GUTGameUUTUIScene_MessageBoxNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_MessageBox,execBeginHide)
	MAP_NATIVE(UUTUIScene_MessageBox,execBeginShow)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_MessageBox);

NATIVE_INFO(UUTUIScene_WeaponQuickPick) GUTGameUUTUIScene_WeaponQuickPickNatives[] = 
{ 
	MAP_NATIVE(UUTUIScene_WeaponQuickPick,execRefreshCells)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,UUTUIScene_WeaponQuickPick);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UHudWidget_DeployableGroup)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_LocalMessages,MessageZones)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_LocalMessages,FontPool)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_LocalMessages)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_Map,OuterRing)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_Map,UTMapPanel)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_Map)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_PawnDoll,BaseImg)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_PawnDoll)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_QuickPickCell,AmmoBar)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_QuickPickCell,MyWeapon)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_QuickPickCell)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_TeamBar,Separator)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_TeamBar,TestTeamIndex)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_TeamBar)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_TeamScore,TeamScore)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_TeamScore,CurrentScore)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_TeamScore)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_WeaponBar,InactiveScale)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_WeaponBar,ActiveGroupOpacity)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_WeaponBar)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_WeaponGroup,AssociatedWeaponGroup)
VERIFY_CLASS_OFFSET_NODIE(U,HudWidget_WeaponGroup,HighlightStyleNames)
VERIFY_CLASS_SIZE_NODIE(UHudWidget_WeaponGroup)
VERIFY_CLASS_OFFSET_NODIE(U,MiniMapImage,CurrentState)
VERIFY_CLASS_SIZE_NODIE(UMiniMapImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawTeamColoredImage,TeamColors)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_DrawTeamColoredImage,EditorTeamIndex)
VERIFY_CLASS_SIZE_NODIE(UUIComp_DrawTeamColoredImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTDrawStateImage,ImageState)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTDrawStateImage)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTGlowString,GlowStyle)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTGlowString)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTUIMenuListPresenter,SelectedItemHeight)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_UTUIMenuListPresenter,InstancedPrefabs)
VERIFY_CLASS_SIZE_NODIE(UUIComp_UTUIMenuListPresenter)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjActive)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjBuilding)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjCritical)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjInactive)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjNeutral)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjProtected)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjStates)
VERIFY_CLASS_SIZE_NODIE(UUIState_UTObjUnderAttack)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPanel,Canvas)
VERIFY_CLASS_OFFSET_NODIE(U,UTDrawPanel,__DrawDelegate__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTDrawPanel)
VERIFY_CLASS_OFFSET_NODIE(U,UTGameUISceneClient,PreRenderTime)
VERIFY_CLASS_OFFSET_NODIE(U,UTGameUISceneClient,CurrentMissionData)
VERIFY_CLASS_SIZE_NODIE(UUTGameUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(A,UTHUD,PostRenderedActors)
VERIFY_CLASS_OFFSET_NODIE(A,UTHUD,TY)
VERIFY_CLASS_SIZE_NODIE(AUTHUD)
VERIFY_CLASS_OFFSET_NODIE(U,UTSeqObj_SPMission,MissionInfo)
VERIFY_CLASS_OFFSET_NODIE(U,UTSeqObj_SPMission,OldIndex)
VERIFY_CLASS_SIZE_NODIE(UUTSeqObj_SPMission)
VERIFY_CLASS_SIZE_NODIE(UUTSeqObj_SPRootMission)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleList,TextFont)
VERIFY_CLASS_OFFSET_NODIE(U,UTSimpleList,__OnSelectionChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTSimpleList)
VERIFY_CLASS_SIZE_NODIE(UUTTabPage)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_HudWidget,UTHudSceneOwner)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_HudWidget,Animations)
VERIFY_CLASS_SIZE_NODIE(UUTUI_HudWidget)
VERIFY_CLASS_OFFSET_NODIE(U,UTUI_Widget,UTSceneOwner)
VERIFY_CLASS_SIZE_NODIE(UUTUI_Widget)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIButtonBar,Buttons)
VERIFY_CLASS_SIZE_NODIE(UUTUIButtonBar)
VERIFY_CLASS_SIZE_NODIE(UUTUIButtonBarButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIComboBox,ToggleButtonStyleName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIComboBox,EditboxBGStyleName)
VERIFY_CLASS_SIZE_NODIE(UUTUIComboBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Character,CustomData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Character)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CharacterFaction,CustomData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_CharacterFaction)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CharacterPart,PartData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_CharacterPart)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CommunityMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_CommunityMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_CommunityMenuItem)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_DemoFile,Filename)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_DemoFile)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_GameModeInfo,GameMode)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_GameModeInfo,Prefix)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_GameModeInfo)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_KeyBinding,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_KeyBinding,Command)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_KeyBinding)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MainMenuItems,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MainMenuItems,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MainMenuItems)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MapInfo,MapID)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MapInfo,PreviewImageMarkup)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MapInfo)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MenuOption,OptionType)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MenuOption,RangeData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MenuOption)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MultiplayerMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_MultiplayerMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_MultiplayerMenuItem)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Mutator,ClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Mutator,UIConfigScene)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Mutator)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SearchResult,LockedImage)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SearchResult,FriendOnlineImage)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SearchResult)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SettingsMenuItem,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SettingsMenuItem,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SettingsMenuItem)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SimpleMenu,FieldName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_SimpleMenu,Options)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_SimpleMenu)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Weapon,ClassName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataProvider_Weapon,Description)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataProvider_Weapon)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_CustomChar,PartProviders)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_CustomChar,CurrentFaction)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_CustomChar)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_MenuItems,EnabledMutators)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_MenuItems,GameModeFilter)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_MenuItems)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_Options,OptionProviders)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_Options)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIDataStore_StringList,StringData)
VERIFY_CLASS_SIZE_NODIE(UUTUIDataStore_StringList)
VERIFY_CLASS_SIZE_NODIE(UUTUIEditBox)
VERIFY_CLASS_SIZE_NODIE(UUTUIList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMenuList,SelectedIndexDataSource)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIMenuList,PreviousItem)
VERIFY_CLASS_SIZE_NODIE(UUTUIMenuList)
VERIFY_CLASS_SIZE_NODIE(UUTUINumericEditBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIOptionButton,ArrowLeftButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIOptionButton,DataProvider)
VERIFY_CLASS_SIZE_NODIE(UUTUIOptionButton)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIResourceDataProvider,IniName)
VERIFY_CLASS_SIZE_NODIE(UUTUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene,MessageBoxScene)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene,__OnHideAnimationEnded__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_Campaign,ButtonBar)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Campaign)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_CMissionSelection,NextMission)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_CMissionSelection,SelectedMapPointSFXTemplate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_CMissionSelection)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Hud)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MapVote,MapList)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MapVote,VoteRI)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MapVote)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MessageBox,MessageLabel)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MessageBox,__OnMBInputKey__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MessageBox)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MOTD,TimeRemainingOnScreen)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_MOTD,Panel)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_MOTD)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_Pawns,__OnSceneTransitionFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Pawns)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_Scoreboard,MapName)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_Scoreboard,LastGoalScore)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_Scoreboard)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_UTPawn)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_VehicleHud,MyVehicle)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_VehicleHud)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_WeaponHud)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_WeaponQuickPick,Cells)
VERIFY_CLASS_OFFSET_NODIE(U,UTUIScene_WeaponQuickPick,RefreshFrequency)
VERIFY_CLASS_SIZE_NODIE(UUTUIScene_WeaponQuickPick)
VERIFY_CLASS_SIZE_NODIE(UUTUISlider)
VERIFY_CLASS_SIZE_NODIE(UUTUITabControl)
VERIFY_CLASS_OFFSET_NODIE(U,VHud_Scorpion,BoostBar)
VERIFY_CLASS_OFFSET_NODIE(U,VHud_Scorpion,EjectMarkup)
VERIFY_CLASS_SIZE_NODIE(UVHud_Scorpion)
VERIFY_CLASS_OFFSET_NODIE(U,WeapHud_RocketLauncher,DefaultCrosshairImage)
VERIFY_CLASS_OFFSET_NODIE(U,WeapHud_RocketLauncher,CrosshairRotationTime)
VERIFY_CLASS_SIZE_NODIE(UWeapHud_RocketLauncher)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
