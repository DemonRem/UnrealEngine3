/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum EVulnerabilityStatus
{
    VS_Vulnerable           =0,
    VS_InvulnerableByNearbyOrb=1,
    VS_InvulnerableToOrbCapture=2,
    VS_MAX                  =3,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName UTGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(IsConstructing)

#ifndef NAMES_ONLY

struct UTOnslaughtObjective_eventIsConstructing_Parms
{
    UBOOL ReturnValue;
    UTOnslaughtObjective_eventIsConstructing_Parms(EEventParm)
    {
    }
};
class AUTOnslaughtObjective : public AUTGameObjective
{
public:
    //## BEGIN PROPS UTOnslaughtObjective
    FLOAT LastAttackMessageTime;
    FLOAT LastAttackTime;
    FLOAT LastAttackExpirationTime;
    FLOAT LastAttackAnnouncementTime;
    INT LastAttackSwitch;
    BYTE FinalCoreDistance[2];
    class AUTPlayerReplicationInfo* LastDamagedBy;
    class APawn* LastAttacker;
    FLOAT DamageCapacity;
    FLOAT Health;
    FLOAT LinkHealMult;
    BITFIELD bIsNeutral:1;
    //## END PROPS UTOnslaughtObjective

    UBOOL eventIsConstructing()
    {
        UTOnslaughtObjective_eventIsConstructing_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UTGAME_IsConstructing),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AUTOnslaughtObjective,AUTGameObjective,0|CLASS_NativeReplication,UTGame)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

#define UCONST_MAXNUMLINKS 8

class AUTOnslaughtNodeObjective : public AUTOnslaughtObjective
{
public:
    //## BEGIN PROPS UTOnslaughtNodeObjective
    FLOAT ConstructionTime;
    class USoundCue* DestroyedSound;
    class USoundCue* ConstructedSound;
    class USoundCue* StartConstructionSound;
    class USoundCue* ActiveSound;
    class USoundCue* NeutralSound;
    class USoundCue* HealingSound;
    class USoundCue* HealedSound;
    BITFIELD bSevered:1;
    BITFIELD bWasSevered:1;
    BITFIELD bStandalone:1;
    FInterpCurveFloat AttackEffectCurve;
    class AUTOnslaughtNodeObjective* LinkedNodes[8];
    BYTE NumLinks;
    BYTE StandaloneSpawnPriority;
    TArrayNoInit<class AUTOnslaughtSpecialObjective*> ActivatedObjectives;
    FName NodeState;
    FLOAT ConstructionTimeElapsed;
    FLOAT SeveredDamagePerSecond;
    FLOAT HealingTime;
    INT ActivationMessageIndex;
    INT DestructionMessageIndex;
    FStringNoInit DestroyedEvent[4];
    FStringNoInit ConstructedEvent[2];
    class AController* Constructor;
    class AController* LastHealedBy;
    INT NodeNum;
    class UAudioComponent* AmbientSoundComponent;
    FLinearColor BeamColor[3];
    class UStaticMeshComponent* NodeBeamEffect;
    class UMaterialInstanceTimeVarying* BeamMaterialInstance;
    FName GodBeamAttackParameterName;
    class UParticleSystemComponent* ShieldedEffect;
    TArrayNoInit<class AUTOnslaughtNodeEnhancement*> Enhancements;
    TArrayNoInit<class AUTOnslaughtNodeTeleporter*> NodeTeleporters;
    class AUTOnslaughtFlagBase* FlagBase;
    class USoundCue* ShieldHitSound;
    INT ShieldDamageCounter;
    class AUTOnslaughtNodeHealEffectBase* HealEffect;
    class UClass* HealEffectClasses[2];
    class AUTOnslaughtPowerCore* StartingOwnerCore;
    FStringNoInit OutsideLocationPrefix;
    FStringNoInit OutsideLocationPostfix;
    FStringNoInit BetweenLocationPrefix;
    FStringNoInit BetweenLocationJoin;
    FStringNoInit BetweenLocationPostFix;
    //## END PROPS UTOnslaughtNodeObjective

    DECLARE_ABSTRACT_CLASS(AUTOnslaughtNodeObjective,AUTOnslaughtObjective,0,UTGame)
	virtual UBOOL ProscribePathTo(ANavigationPoint *Nav, AScout *Scout = NULL);
};

#define UCONST_DESTROYED_PANEL_BONE_SCALE 0.01

class AUTOnslaughtPanelNode : public AUTOnslaughtNodeObjective
{
public:
    //## BEGIN PROPS UTOnslaughtPanelNode
    class UUTSkelControl_MassBoneScaling* PanelBoneScaler;
    class UParticleSystem* PanelExplosionTemplates[2];
    INT PanelHealthMax;
    INT PanelHealthRemaining;
    INT NumPanelsBlownOff;
    INT ReplicatedNumPanelsBlownOff;
    FStringNoInit PanelBonePrefix;
    FVector PanelSphereOffset;
    class USkeletalMeshComponent* PanelMesh;
    class UParticleSystem* PanelHealEffectTemplates[2];
    TArrayNoInit<FName> PanelsBeingHealed;
    class UClass* PanelGibClass;
    //## END PROPS UTOnslaughtPanelNode

    DECLARE_ABSTRACT_CLASS(AUTOnslaughtPanelNode,AUTOnslaughtNodeObjective,0|CLASS_NativeReplication,UTGame)
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct FEnergyEffectInfo
{
    class UParticleSystemComponent* Effect;
    FName CurrentEndPointBones[2];
};

class AUTOnslaughtPowerCore : public AUTOnslaughtPanelNode
{
public:
    //## BEGIN PROPS UTOnslaughtPowerCore
    BITFIELD bWasVulnerable:1;
    BITFIELD bReverseForThisCore:1;
    BITFIELD bNoCoreSwitch:1;
    BITFIELD bNecrisCore:1;
    INT ProcessedTarydium;
    class USkeletalMeshComponent* BaseMesh;
    class UMaterialInstanceConstant* BaseMaterialInstance;
    FLinearColor BaseMaterialColors[2];
    class UParticleSystemComponent* InnerCoreEffect;
    class UParticleSystem* InnerCoreEffectTemplates[2];
    struct FEnergyEffectInfo EnergyEffects[6];
    FLOAT MaxEnergyEffectDist;
    FName EnergyEndPointParameterNames[2];
    FStringNoInit EnergyEndPointBonePrefix;
    class UParticleSystem* EnergyEffectTemplates[2];
    class UParticleSystem* DestructionEffectTemplates[2];
    class UPhysicsAsset* DestroyedPhysicsAsset;
    class UParticleSystemComponent* ShieldEffects[3];
    class UParticleSystem* ShieldEffectTemplates[2];
    FColor EnergyLightColors[2];
    class UPointLightComponent* EnergyEffectLight;
    class USoundCue* ShieldOnSound;
    class USoundCue* ShieldOffSound;
    class USoundCue* ShieldedAmbientSound;
    class USoundCue* UnshieldedAmbientSound;
    class USoundCue* DamageWarningSound;
    FLOAT OldHealth;
    FLOAT LastDamageWarningTime;
    FLOAT LastDamagedTime;
    FStringNoInit NamePrefix;
    class UClass* ONSAnnouncerMessagesClass;
    class UClass* ONSOrbMessagesClass;
    class ASkeletalMeshActorSpawnable* KismetMeshActor;
    class UClass* CoreMessageClass;
    class UClass* RedMessageClass;
    class UClass* BlueMessageClass;
    //## END PROPS UTOnslaughtPowerCore

    DECLARE_ABSTRACT_CLASS(AUTOnslaughtPowerCore,AUTOnslaughtPanelNode,0|CLASS_NativeReplication,UTGame)
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void TickSpecial(FLOAT DeltaTime);
};

class AUTOnslaughtPowernode : public AUTOnslaughtPanelNode
{
public:
    //## BEGIN PROPS UTOnslaughtPowernode
    class USkeletalMeshComponent* EnergySphere;
    class UStaticMeshComponent* NodeBase;
    class UStaticMeshComponent* NodeBaseSpinner;
    TArrayNoInit<class UMaterialInstanceConstant*> GlowMaterialInstances;
    FLinearColor TeamGlowColors[2];
    FLinearColor NeutralGlowColor;
    class UCylinderComponent* EnergySphereCollision;
    class UParticleSystemComponent* AmbientEffect;
    class UMaterialInstanceConstant* NodeMaterialInstance;
    FLOAT YawRotationRate;
    FLOAT ConstructedCapacity;
    class UParticleSystem* NeutralEffectTemplate;
    class UParticleSystem* ConstructingEffectTemplates[2];
    class UParticleSystem* ActiveEffectTemplates[2];
    class UParticleSystem* ShieldedActiveEffectTemplates[2];
    class UParticleSystemComponent* OrbCaptureComponent;
    class UParticleSystem* OrbCaptureTemplate[2];
    class UParticleSystem* ShieldedEffectTemplates[2];
    class UParticleSystem* VulnerableEffectTemplates[2];
    class UParticleSystemComponent* InvulnerableToOrbEffect;
    class UParticleSystem* InvulnerableToOrbTemplates[2];
    BITFIELD bPlayDamagedEffect:1;
    BITFIELD bPlayingNecrisEffects:1;
    class UParticleSystemComponent* DamagedEffect;
    class UParticleSystem* DamagedEffectTemplates[2];
    class UParticleSystem* DestroyedEffectTemplate;
    FLOAT PanelTravelTime;
    class AUTOnslaughtFlag* ControllingFlag;
    BYTE Vulnerability;
    FLOAT InvulnerableRadius;
    class AUTEmitter* FlagLinkEffect;
    FLOAT CaptureReturnRadius;
    class UAudioComponent* OrbNearbySound;
    FLOAT InvEffectZOffset;
    INT OrbHealingPerSecond;
    FLOAT OrbCaptureInvulnerabilityDuration;
    FLOAT LastOrbCaptureTime;
    class UStaticMeshComponent* NecrisCapturePipesLarge;
    class UMaterialInstanceTimeVarying* MITV_NecrisCapturePipesLarge;
    FInterpCurveFloat MITV_NecrisCapturePipes_FadeIn;
    FInterpCurveFloat MITV_NecrisCapturePipes_FadeIn2;
    FInterpCurveFloat NecrisCapturePipes_FadeOut_Fast;
    FInterpCurveFloat NecrisCapturePuddle_FadeIn50;
    FInterpCurveFloat NecrisCapturePuddle_FadeIn100;
    FInterpCurveFloat NecrisCapturePuddle_FadeOut;
    class UStaticMeshComponent* NecrisCapturePipesSmall;
    class UMaterialInstanceTimeVarying* MITV_NecrisCapturePipesSmall;
    class UUTParticleSystemComponent* PSC_NecrisCapture;
    class UUTParticleSystemComponent* PSC_NecrisGooPuddle;
    class UMaterialInstanceTimeVarying* MITV_NecrisCaptureGoo;
    TArrayNoInit<FName> LinkToSockets;
    //## END PROPS UTOnslaughtPowernode

    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL);
    DECLARE_ABSTRACT_CLASS(AUTOnslaughtPowernode,AUTOnslaughtPanelNode,0,UTGame)
	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class AUTOnslaughtFlag : public AUTCarriedObject
{
public:
    //## BEGIN PROPS UTOnslaughtFlag
    class UStaticMeshComponent* Mesh;
    class UMaterial* FlagMaterials[2];
    class UParticleSystem* FlagEffect[2];
    class UParticleSystemComponent* FlagEffectComp;
    FColor LightColors[2];
    FLOAT GraceDist;
    class AUTOnslaughtGodBeam* MyGodBeam;
    class AUTOnslaughtFlagBase* StartingHomeBase;
    class UClass* GodBeamClass;
    FLOAT MaxSpringDistance;
    FVector OldLocation;
    class UClass* ReturnedEffectClasses[2];
    FLOAT NormalOrbScale;
    FLOAT HoverboardOrbScale;
    class UParticleSystemComponent* TetherEffect;
    FName TetherEffectEndPointName;
    class UParticleSystem* TetherEffectTemplates[2];
    FLOAT Prebuildtime;
    FLOAT BuildTime;
    BYTE RemainingDropTime;
    FLOAT BuildStartTime;
    class AUTGameObjective* LastNearbyObjective;
    FLOAT LastIncomingWarning;
    FLOAT LastGraceDistance;
    class AUTOnslaughtPowernode* LockedNode;
    //## END PROPS UTOnslaughtFlag

    DECLARE_ABSTRACT_CLASS(AUTOnslaughtFlag,AUTCarriedObject,0,UTGame)
	virtual void TickSpecial( FLOAT DeltaSeconds );
};

class AUTOnslaughtGodBeam : public AActor
{
public:
    //## BEGIN PROPS UTOnslaughtGodBeam
    class UStaticMeshComponent* NodeBeamEffect;
    class UMaterialInstanceConstant* BeamMaterialInstance;
    //## END PROPS UTOnslaughtGodBeam

    DECLARE_CLASS(AUTOnslaughtGodBeam,AActor,0,UTGame)
    NO_DEFAULT_CONSTRUCTOR(AUTOnslaughtGodBeam)
};

struct FFullNodeLink
{
    class AUTOnslaughtNodeObjective* FromNode;
    class AUTOnslaughtNodeObjective* ToNode;
};

struct FNodeStartingOwner
{
    class AUTOnslaughtNodeObjective* Node;
    class AUTOnslaughtPowerCore* StartingOwnerCore;
};

struct FLinkSetup
{
    FName SetupName;
    TArrayNoInit<struct FFullNodeLink> NodeLinks;
    TArrayNoInit<class AUTOnslaughtNodeObjective*> StandaloneNodes;
    TArrayNoInit<struct FNodeStartingOwner> NodeStartingOwners;
    TArrayNoInit<class AActor*> DeactivatedActors;
    TArrayNoInit<FName> DeactivatedGroups;
    TArrayNoInit<class AActor*> ActivatedActors;
    TArrayNoInit<FName> ActivatedGroups;

    /** Constructors */
    FLinkSetup() {}
    FLinkSetup(EEventParm)
    {
        appMemzero(this, sizeof(FLinkSetup));
    }
};

class UUTOnslaughtMapInfo : public UUTMapInfo
{
public:
    //## BEGIN PROPS UTOnslaughtMapInfo
    TArrayNoInit<struct FLinkSetup> LinkSetups;
    FName ActiveSetupName;
    BITFIELD bEnableEditorPreview:1;
    FName EditorPreviewSetup;
    //## END PROPS UTOnslaughtMapInfo

    DECLARE_CLASS(UUTOnslaughtMapInfo,UUTMapInfo,0,UTGame)
	virtual void CheckForErrors();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

#endif

AUTOGENERATE_FUNCTION(AUTOnslaughtPowernode,-1,execGetTargetLocation);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UTGAME_ONSLAUGHT_NATIVE_DEFS
#define UTGAME_ONSLAUGHT_NATIVE_DEFS

DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtFlag);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtGodBeam);
DECLARE_NATIVE_TYPE(UTGame,UUTOnslaughtMapInfo);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtNodeObjective);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtObjective);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtPanelNode);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtPowerCore);
DECLARE_NATIVE_TYPE(UTGame,AUTOnslaughtPowernode);

#define AUTO_INITIALIZE_REGISTRANTS_UTGAME_ONSLAUGHT \
	AUTOnslaughtFlag::StaticClass(); \
	AUTOnslaughtGodBeam::StaticClass(); \
	UUTOnslaughtMapInfo::StaticClass(); \
	AUTOnslaughtNodeObjective::StaticClass(); \
	AUTOnslaughtObjective::StaticClass(); \
	AUTOnslaughtPanelNode::StaticClass(); \
	AUTOnslaughtPowerCore::StaticClass(); \
	AUTOnslaughtPowernode::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindUTGameAUTOnslaughtPowernodeNative; \

#endif // UTGAME_ONSLAUGHT_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AUTOnslaughtPowernode) GUTGameAUTOnslaughtPowernodeNatives[] = 
{ 
	MAP_NATIVE(AUTOnslaughtPowernode,execGetTargetLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(UTGame,AUTOnslaughtPowernode);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtFlag,Mesh)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtFlag,LockedNode)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtFlag)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtGodBeam,NodeBeamEffect)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtGodBeam,BeamMaterialInstance)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtGodBeam)
VERIFY_CLASS_OFFSET_NODIE(U,UTOnslaughtMapInfo,LinkSetups)
VERIFY_CLASS_OFFSET_NODIE(U,UTOnslaughtMapInfo,EditorPreviewSetup)
VERIFY_CLASS_SIZE_NODIE(UUTOnslaughtMapInfo)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtNodeObjective,ConstructionTime)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtNodeObjective,BetweenLocationPostFix)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtNodeObjective)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtObjective,LastAttackMessageTime)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtObjective,LinkHealMult)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtObjective)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPanelNode,PanelBoneScaler)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPanelNode,PanelGibClass)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtPanelNode)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPowerCore,ProcessedTarydium)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPowerCore,BlueMessageClass)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtPowerCore)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPowernode,EnergySphere)
VERIFY_CLASS_OFFSET_NODIE(A,UTOnslaughtPowernode,LinkToSockets)
VERIFY_CLASS_SIZE_NODIE(AUTOnslaughtPowernode)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
