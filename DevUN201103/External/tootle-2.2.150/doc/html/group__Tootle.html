<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Tootle: Tootle</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Tootle</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcf36772621801e40000ab1832017c339"></a><!-- doxytag: member="Tootle::TOOTLE_DEFAULT_VCACHE_SIZE" ref="gcf36772621801e40000ab1832017c339" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#gcf36772621801e40000ab1832017c339">TOOTLE_DEFAULT_VCACHE_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default vertex cache size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g55ecb0e57d6292b04a74456da55b1044"></a><!-- doxytag: member="Tootle::TOOTLE_MAX_FACES" ref="g55ecb0e57d6292b04a74456da55b1044" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g55ecb0e57d6292b04a74456da55b1044">TOOTLE_MAX_FACES</a>&nbsp;&nbsp;&nbsp;0x7fffffff</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum allowed number of faces in the mesh. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9b1a591e0cf93bb6e5edb2fefd480104"></a><!-- doxytag: member="Tootle::TOOTLE_MAX_VERTICES" ref="g9b1a591e0cf93bb6e5edb2fefd480104" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g9b1a591e0cf93bb6e5edb2fefd480104">TOOTLE_MAX_VERTICES</a>&nbsp;&nbsp;&nbsp;0x7fffffff</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum allowed number of vertices in the mesh. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g6da0fca5ae1840fc6a958301c5900b62">TOOTLE_DEFAULT_ALPHA</a>&nbsp;&nbsp;&nbsp;0.75f</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912feb5d541d789ebb1366f09f325b12ab423">NA_TOOTLE_RESULT</a>, 
<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fe478827720db95bd08f0932a559d6d4d5">TOOTLE_OK</a>, 
<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fecccd0bd843e260ebdfcfb1cf60d1768f">TOOTLE_INVALID_ARGS</a>, 
<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fe5f770ab616d493a7e6e7e7bcb1fec85c">TOOTLE_OUT_OF_MEMORY</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fe6626a39aa81eeb6fd00ad06232a95a60">TOOTLE_3D_API_ERROR</a>, 
<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fee5e5dd679e87ad2ae35dc2cd37d98aad">TOOTLE_INTERNAL_ERROR</a>, 
<a class="el" href="group__Tootle.html#ggc595dd665ead03e00053661fa3a912fe2703d39789bf1bd7f19341de9d4c937b">TOOTLE_NOT_INITIALIZED</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for Tootle return codes.  <a href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a> { <a class="el" href="group__Tootle.html#gg97b9c97d2bf8645e489772f589b5ba80cb68efe54a0706a6a73f72a0c163d939">NA_TOOTLE_FACE_WINDING</a>, 
<a class="el" href="group__Tootle.html#gg97b9c97d2bf8645e489772f589b5ba808298fc7ab4d9bbddc05ae8ca75ab6be9">TOOTLE_CCW</a>, 
<a class="el" href="group__Tootle.html#gg97b9c97d2bf8645e489772f589b5ba8049ba919134f90a817013a6a50e03c585">TOOTLE_CW</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for face winding order.  <a href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#gg66557053f4f5f93361f20cdc707181fdb66c69e03ce0c87b480efa328944d0e4">NA_TOOTLE_VCACHE_OPTIMIZER</a>, 
<a class="el" href="group__Tootle.html#gg66557053f4f5f93361f20cdc707181fd376df2136579221201490a5f78753da9">TOOTLE_VCACHE_AUTO</a>, 
<a class="el" href="group__Tootle.html#gg66557053f4f5f93361f20cdc707181fd3635d5908dd9ee80d2a16be94598f7e3">TOOTLE_VCACHE_DIRECT3D</a>, 
<a class="el" href="group__Tootle.html#gg66557053f4f5f93361f20cdc707181fd12da90b0de312aa4466546f8231d82b1">TOOTLE_VCACHE_LSTRIPS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#gg66557053f4f5f93361f20cdc707181fd0bf07a034203fde7cf1f6c38183b5a99">TOOTLE_VCACHE_TIPSY</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for the algorithm for vertex optimization.  <a href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#gg394ff5247b00d55a189fb8586c715e7ed28694d1f167896b736712df3ee01762">NA_TOOTLE_OVERDRAW_OPTIMIZER</a>, 
<a class="el" href="group__Tootle.html#gg394ff5247b00d55a189fb8586c715e7ec6cde9af88c70c8feada559b93a01f85">TOOTLE_OVERDRAW_AUTO</a>, 
<a class="el" href="group__Tootle.html#gg394ff5247b00d55a189fb8586c715e7e233c1a1aa34302ab85748bfa47b090bd">TOOTLE_OVERDRAW_DIRECT3D</a>, 
<a class="el" href="group__Tootle.html#gg394ff5247b00d55a189fb8586c715e7edbe5450f7975d5a0aab9436260318601">TOOTLE_OVERDRAW_RAYTRACE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__Tootle.html#gg394ff5247b00d55a189fb8586c715e7e54b4080208caca51551d7f8178c3e39a">TOOTLE_OVERDRAW_FAST</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for the algorithm for overdraw optimization.  <a href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc8c3714bfa7d6f5b837a0ad387c7929b"></a><!-- doxytag: member="Tootle::TootleInit" ref="gc8c3714bfa7d6f5b837a0ad387c7929b" args="()" -->
<a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#gc8c3714bfa7d6f5b837a0ad387c7929b">TootleInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one-time initialization required by Tootle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#ga6192a1213607cacadbcdc949eb815f7">TootleOptimizeVCache</a> (const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, unsigned int *pnIBOut, unsigned int *pnFaceRemapOut, <a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a> eVCacheOptimizer=TOOTLE_VCACHE_AUTO)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g8561971e74d7041db9ed1c34135b5e7a">TootleClusterMesh</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nTargetClusters, unsigned int *pnClusteredIBOut, unsigned int *pnFaceClustersOut, unsigned int *pnFaceRemapOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g135bdcf062e1a0a7c040901a5cff9f43">TootleFastOptimizeVCacheAndClusterMesh</a> (const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, unsigned int *pnIBOut, unsigned int *pnClustersOut, unsigned int *pnNumClustersOut, float fAlpha=TOOTLE_DEFAULT_ALPHA)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#gadac5eaaca7b60781dc469b87e9050e4">TootleOptimizeOverdraw</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, const float *pfViewpoint, unsigned int nViewpoints, <a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a> eFrontWinding, const unsigned int *pnFaceClusters, unsigned int *pnIBOut, unsigned int *pnClusterRemapOut, <a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a> eOverdrawOptimizer=TOOTLE_OVERDRAW_FAST)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g8fefb332bf726e45b49362bc63237036">TootleCleanup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all resources held by Tootle.  <a href="#g8fefb332bf726e45b49362bc63237036"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g513fe18a45425732ae1d2e9c7fb02b13">TootleOptimize</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nCacheSize, const float *pViewpoints, unsigned int nViewpoints, <a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a> eFrontWinding, unsigned int *pnIBOut, unsigned int *pnNumClustersOut, <a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a> eVCacheOptimizer=TOOTLE_VCACHE_AUTO, <a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a> eOverdrawOptimizer=TOOTLE_OVERDRAW_FAST)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g599f0739b7e2d9167421216fb5f712bb">TootleFastOptimize</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nCacheSize, <a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a> eFrontWinding, unsigned int *pnIBOut, unsigned int *pnNumClustersOut, float fAlpha=TOOTLE_DEFAULT_ALPHA)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#ge77a13942a64bedbf877cda55a2d0575">TootleVCacheClusters</a> (const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, const unsigned int *pnFaceClusters, unsigned int *pnIBOut, unsigned int *pnFaceRemapOut, <a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a> eVCacheOptimizer=TOOTLE_VCACHE_AUTO)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g5bc4337f60a4409a5ede0d519bd3809b">TootleMeasureCacheEfficiency</a> (const unsigned int *pnIB, unsigned int nFaces, unsigned int nCacheSize, float *pfEfficiencyOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#g663c75bee772c1c500f922d5055297a7">TootleMeasureOverdraw</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, const float *pfViewpoint, unsigned int nViewpoints, <a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a> eFrontWinding, float *pfAvgODOut, float *pfMaxODOut, <a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a> eOverdrawOptimizer=TOOTLE_OVERDRAW_DIRECT3D)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Tootle.html#ga27896331f4f9a4ff187204a2c2996a2">TootleOptimizeVertexMemory</a> (const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, void *pVBOut, unsigned int *pnIBOut, unsigned int *pnVertexRemapOut)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g6da0fca5ae1840fc6a958301c5900b62"></a><!-- doxytag: member="tootlelib.h::TOOTLE_DEFAULT_ALPHA" ref="g6da0fca5ae1840fc6a958301c5900b62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOOTLE_DEFAULT_ALPHA&nbsp;&nbsp;&nbsp;0.75f          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The parameter for TootleFastOptimize to create more clusters (lower number generates more clusters). This parameter decides where to put extra breaks to create more clusters (refer to the SIGGRAPH 2007 paper for the full description of the parameter. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g97b9c97d2bf8645e489772f589b5ba80"></a><!-- doxytag: member="tootlelib.h::TootleFaceWinding" ref="g97b9c97d2bf8645e489772f589b5ba80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for face winding order. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg97b9c97d2bf8645e489772f589b5ba80cb68efe54a0706a6a73f72a0c163d939"></a><!-- doxytag: member="NA_TOOTLE_FACE_WINDING" ref="gg97b9c97d2bf8645e489772f589b5ba80cb68efe54a0706a6a73f72a0c163d939" args="" -->NA_TOOTLE_FACE_WINDING</em>&nbsp;</td><td>
Default invalid choice. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg97b9c97d2bf8645e489772f589b5ba808298fc7ab4d9bbddc05ae8ca75ab6be9"></a><!-- doxytag: member="TOOTLE_CCW" ref="gg97b9c97d2bf8645e489772f589b5ba808298fc7ab4d9bbddc05ae8ca75ab6be9" args="" -->TOOTLE_CCW</em>&nbsp;</td><td>
Face is ordered counter-clockwise. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg97b9c97d2bf8645e489772f589b5ba8049ba919134f90a817013a6a50e03c585"></a><!-- doxytag: member="TOOTLE_CW" ref="gg97b9c97d2bf8645e489772f589b5ba8049ba919134f90a817013a6a50e03c585" args="" -->TOOTLE_CW</em>&nbsp;</td><td>
Face is ordered clockwise. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g394ff5247b00d55a189fb8586c715e7e"></a><!-- doxytag: member="tootlelib.h::TootleOverdrawOptimizer" ref="g394ff5247b00d55a189fb8586c715e7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for the algorithm for overdraw optimization. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg394ff5247b00d55a189fb8586c715e7ed28694d1f167896b736712df3ee01762"></a><!-- doxytag: member="NA_TOOTLE_OVERDRAW_OPTIMIZER" ref="gg394ff5247b00d55a189fb8586c715e7ed28694d1f167896b736712df3ee01762" args="" -->NA_TOOTLE_OVERDRAW_OPTIMIZER</em>&nbsp;</td><td>
Default invalid choice. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg394ff5247b00d55a189fb8586c715e7ec6cde9af88c70c8feada559b93a01f85"></a><!-- doxytag: member="TOOTLE_OVERDRAW_AUTO" ref="gg394ff5247b00d55a189fb8586c715e7ec6cde9af88c70c8feada559b93a01f85" args="" -->TOOTLE_OVERDRAW_AUTO</em>&nbsp;</td><td>
Use either Direct3D or raytracing to reorder clusters (depending on the number of clusters). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg394ff5247b00d55a189fb8586c715e7e233c1a1aa34302ab85748bfa47b090bd"></a><!-- doxytag: member="TOOTLE_OVERDRAW_DIRECT3D" ref="gg394ff5247b00d55a189fb8586c715e7e233c1a1aa34302ab85748bfa47b090bd" args="" -->TOOTLE_OVERDRAW_DIRECT3D</em>&nbsp;</td><td>
Use Direct3D rendering to reorder clusters to optimize overdraw (slow O(N^2)). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg394ff5247b00d55a189fb8586c715e7edbe5450f7975d5a0aab9436260318601"></a><!-- doxytag: member="TOOTLE_OVERDRAW_RAYTRACE" ref="gg394ff5247b00d55a189fb8586c715e7edbe5450f7975d5a0aab9436260318601" args="" -->TOOTLE_OVERDRAW_RAYTRACE</em>&nbsp;</td><td>
Use CPU raytracing to reorder clusters to optimize overdraw (slow O(N^2)). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg394ff5247b00d55a189fb8586c715e7e54b4080208caca51551d7f8178c3e39a"></a><!-- doxytag: member="TOOTLE_OVERDRAW_FAST" ref="gg394ff5247b00d55a189fb8586c715e7e54b4080208caca51551d7f8178c3e39a" args="" -->TOOTLE_OVERDRAW_FAST</em>&nbsp;</td><td>
Use a fast approximation algorithm (from SIGGRAPH 2007) to reorder clusters. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc595dd665ead03e00053661fa3a912fe"></a><!-- doxytag: member="tootlelib.h::TootleResult" ref="gc595dd665ead03e00053661fa3a912fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for Tootle return codes. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912feb5d541d789ebb1366f09f325b12ab423"></a><!-- doxytag: member="NA_TOOTLE_RESULT" ref="ggc595dd665ead03e00053661fa3a912feb5d541d789ebb1366f09f325b12ab423" args="" -->NA_TOOTLE_RESULT</em>&nbsp;</td><td>
Default invalid choice. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fe478827720db95bd08f0932a559d6d4d5"></a><!-- doxytag: member="TOOTLE_OK" ref="ggc595dd665ead03e00053661fa3a912fe478827720db95bd08f0932a559d6d4d5" args="" -->TOOTLE_OK</em>&nbsp;</td><td>
All is well. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fecccd0bd843e260ebdfcfb1cf60d1768f"></a><!-- doxytag: member="TOOTLE_INVALID_ARGS" ref="ggc595dd665ead03e00053661fa3a912fecccd0bd843e260ebdfcfb1cf60d1768f" args="" -->TOOTLE_INVALID_ARGS</em>&nbsp;</td><td>
Illegal arguments were passed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fe5f770ab616d493a7e6e7e7bcb1fec85c"></a><!-- doxytag: member="TOOTLE_OUT_OF_MEMORY" ref="ggc595dd665ead03e00053661fa3a912fe5f770ab616d493a7e6e7e7bcb1fec85c" args="" -->TOOTLE_OUT_OF_MEMORY</em>&nbsp;</td><td>
Tootle ran out of memory while trying to complete the call. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fe6626a39aa81eeb6fd00ad06232a95a60"></a><!-- doxytag: member="TOOTLE_3D_API_ERROR" ref="ggc595dd665ead03e00053661fa3a912fe6626a39aa81eeb6fd00ad06232a95a60" args="" -->TOOTLE_3D_API_ERROR</em>&nbsp;</td><td>
Errors occurred while setting up the 3D API. This generally means that D3D isn't installed properly </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fee5e5dd679e87ad2ae35dc2cd37d98aad"></a><!-- doxytag: member="TOOTLE_INTERNAL_ERROR" ref="ggc595dd665ead03e00053661fa3a912fee5e5dd679e87ad2ae35dc2cd37d98aad" args="" -->TOOTLE_INTERNAL_ERROR</em>&nbsp;</td><td>
Something happened that really, really shouldn't. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc595dd665ead03e00053661fa3a912fe2703d39789bf1bd7f19341de9d4c937b"></a><!-- doxytag: member="TOOTLE_NOT_INITIALIZED" ref="ggc595dd665ead03e00053661fa3a912fe2703d39789bf1bd7f19341de9d4c937b" args="" -->TOOTLE_NOT_INITIALIZED</em>&nbsp;</td><td>
Tootle was not initialized before a function call. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g66557053f4f5f93361f20cdc707181fd"></a><!-- doxytag: member="tootlelib.h::TootleVCacheOptimizer" ref="g66557053f4f5f93361f20cdc707181fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for the algorithm for vertex optimization. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg66557053f4f5f93361f20cdc707181fdb66c69e03ce0c87b480efa328944d0e4"></a><!-- doxytag: member="NA_TOOTLE_VCACHE_OPTIMIZER" ref="gg66557053f4f5f93361f20cdc707181fdb66c69e03ce0c87b480efa328944d0e4" args="" -->NA_TOOTLE_VCACHE_OPTIMIZER</em>&nbsp;</td><td>
Default invalid choice. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg66557053f4f5f93361f20cdc707181fd376df2136579221201490a5f78753da9"></a><!-- doxytag: member="TOOTLE_VCACHE_AUTO" ref="gg66557053f4f5f93361f20cdc707181fd376df2136579221201490a5f78753da9" args="" -->TOOTLE_VCACHE_AUTO</em>&nbsp;</td><td>
If vertex cache size is less than 7, use TSTRIPS algorithm otherwise TIPSY. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg66557053f4f5f93361f20cdc707181fd3635d5908dd9ee80d2a16be94598f7e3"></a><!-- doxytag: member="TOOTLE_VCACHE_DIRECT3D" ref="gg66557053f4f5f93361f20cdc707181fd3635d5908dd9ee80d2a16be94598f7e3" args="" -->TOOTLE_VCACHE_DIRECT3D</em>&nbsp;</td><td>
Use D3DXOptimizeFaces to optimize faces. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg66557053f4f5f93361f20cdc707181fd12da90b0de312aa4466546f8231d82b1"></a><!-- doxytag: member="TOOTLE_VCACHE_LSTRIPS" ref="gg66557053f4f5f93361f20cdc707181fd12da90b0de312aa4466546f8231d82b1" args="" -->TOOTLE_VCACHE_LSTRIPS</em>&nbsp;</td><td>
Build a list like triangle strips to optimize faces. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg66557053f4f5f93361f20cdc707181fd0bf07a034203fde7cf1f6c38183b5a99"></a><!-- doxytag: member="TOOTLE_VCACHE_TIPSY" ref="gg66557053f4f5f93361f20cdc707181fd0bf07a034203fde7cf1f6c38183b5a99" args="" -->TOOTLE_VCACHE_TIPSY</em>&nbsp;</td><td>
Use TIPSY (the algorithm from SIGGRAPH 2007) to optimize faces. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g8fefb332bf726e45b49362bc63237036"></a><!-- doxytag: member="tootlelib.h::TootleCleanup" ref="g8fefb332bf726e45b49362bc63237036" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TOOTLE_DLL TootleCleanup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees all resources held by Tootle. 
<p>
This method should be called when the application is finished Tootling. Failure to call this function when the application is finished Tootling will result in resource leaks 
</div>
</div><p>
<a class="anchor" name="g8561971e74d7041db9ed1c34135b5e7a"></a><!-- doxytag: member="tootlelib.h::TootleClusterMesh" ref="g8561971e74d7041db9ed1c34135b5e7a" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nTargetClusters, unsigned int *pnClusteredIBOut, unsigned int *pnFaceClustersOut, unsigned int *pnFaceRemapOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleClusterMesh           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nTargetClusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnClusteredIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceClustersOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceRemapOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function partitions a mesh into a set of connected, roughly planar clusters. It generates a new mesh that is re-arranged in cluster order. This clustering is required as a pre-cursor to overdraw optimization. This function returns a mesh that is clustered. That is, the faces are sorted in ascending order by cluster ID. The number of clusters in the mesh will be equal to pFaceClustersOut[ nFaces-1 ] + 1<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>An index buffer. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>Number of vertices. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>Number of faces. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nTargetClusters</em>&nbsp;</td><td>A target number of clusters. The clustering algorithm will create at least this many clusters, but not more than nFaces. This value is only a hint. More clusters may be created if Tootle considers it necessary. (for example, if there are numerous connected components in the mesh). Passing 0 for this value causes Tootle to use an automatic method to determine when to stop creating clusters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnClusteredIBOut</em>&nbsp;</td><td>An array that will receive a copy of the index buffer, sorted by cluster ID. May not be NULL. May equal pIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceClustersOut</em>&nbsp;</td><td>An array of nFaces+1 unsigned ints, that will be filled with the cluster ID that was assigned to each face in the output index buffer. The last element of the array contains the number of cluster. This is of a full format type. May not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceRemapOut</em>&nbsp;</td><td>An array that will receive a face re-mapping. May be NULL. If not NULL, must be an array of size nFaces. The i'th element of the output array contains the position of input face i in the new face ordering. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY, TOOTLE_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="g599f0739b7e2d9167421216fb5f712bb"></a><!-- doxytag: member="tootlelib.h::TootleFastOptimize" ref="g599f0739b7e2d9167421216fb5f712bb" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nCacheSize, TootleFaceWinding eFrontWinding, unsigned int *pnIBOut, unsigned int *pnNumClustersOut, float fAlpha=TOOTLE_DEFAULT_ALPHA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleFastOptimize           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a>&nbsp;</td>
          <td class="paramname"> <em>eFrontWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnNumClustersOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fAlpha</em> = <code>TOOTLE_DEFAULT_ALPHA</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a utility function that performs the entire optimization using the new algorithm from SIGGRAPH 2007. This function performs vertex cache optimization and clustering, then optimize overdraw on the clusters generated. It generates a new indices for faces that is optimized for post-transform vertex cache and overdraw.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The input index buffer: 3 unsigned int per triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the vertex buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the index buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>Hardware cache size (12 to 24 are good options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eFrontWinding</em>&nbsp;</td><td>The winding order of front-faces in the model. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>The updated index buffer (the output). May not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnNumClustersOut</em>&nbsp;</td><td>The number of output clusters. May be NULL if not requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fAlpha</em>&nbsp;</td><td>a linear parameter to compute lambda term from the algorithm. Pass TOOTLE_DEFAULT_ALPHA as a default.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY or TOOTLE_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="g135bdcf062e1a0a7c040901a5cff9f43"></a><!-- doxytag: member="tootlelib.h::TootleFastOptimizeVCacheAndClusterMesh" ref="g135bdcf062e1a0a7c040901a5cff9f43" args="(const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, unsigned int *pnIBOut, unsigned int *pnClustersOut, unsigned int *pnNumClustersOut, float fAlpha=TOOTLE_DEFAULT_ALPHA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleFastOptimizeVCacheAndClusterMesh           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnClustersOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnNumClustersOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fAlpha</em> = <code>TOOTLE_DEFAULT_ALPHA</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs vertex cache optimization and clustering the mesh based on the algorithm from SIGGRAPH 2007. It produces the re-ordered index buffer and an array of the resulting clusters. The result can be used as inputs to TootleOptimizeOverdraw.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The input index buffer: 3 unsigned int per triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the index buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the vertex buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>Hardware cache size (12 to 24 are good options). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>The updated index buffer (the output). May not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnClustersOut</em>&nbsp;</td><td>The output clusters which is an array of nFaces+1 unsigned ints. It is of a compact format type. Entry i and i+1 mark the all face ids in [i, i+1) to be in cluster i. The last element of the array contains the number of clusters. May not be NULL. This has to be pre-allocated of size nFaces+1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnNumClustersOut</em>&nbsp;</td><td>The total number of clusters in pnClustersOut. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fAlpha</em>&nbsp;</td><td>a linear parameter to compute lambda term from the algorithm. Pass TOOTLE_DEFAULT_ALPHA as a default.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY or TOOTLE_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5bc4337f60a4409a5ede0d519bd3809b"></a><!-- doxytag: member="tootlelib.h::TootleMeasureCacheEfficiency" ref="g5bc4337f60a4409a5ede0d519bd3809b" args="(const unsigned int *pnIB, unsigned int nFaces, unsigned int nCacheSize, float *pfEfficiencyOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleMeasureCacheEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pfEfficiencyOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A utility function to simulate vertex processing and measures the cache efficiency of an index buffer. The return cache efficiency is the ACMR (Average Cache Miss Ratio) of the mesh. It ranges between 0.5 to 3. 0.5 is the best optimal value, 3 is the worst ratio.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The index buffer whose efficiency should be measured. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the index buffer. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>The number of vertices that will fit in cache. If the application doesn't know or care, it should use TOOTLE_DEFAULT_VCACHE_SIZE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfEfficiencyOut</em>&nbsp;</td><td>A pointer to receive the vertex cache efficiency. This is defined as the number of cache misses per triangle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_OK, TOOTLE_OUT_OF_MEMORY, TOOTLE_INVALID_ARGS </dd></dl>

</div>
</div><p>
<a class="anchor" name="g663c75bee772c1c500f922d5055297a7"></a><!-- doxytag: member="tootlelib.h::TootleMeasureOverdraw" ref="g663c75bee772c1c500f922d5055297a7" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, const float *pfViewpoint, unsigned int nViewpoints, TootleFaceWinding eFrontWinding, float *pfAvgODOut, float *pfMaxODOut, TootleOverdrawOptimizer eOverdrawOptimizer=TOOTLE_OVERDRAW_DIRECT3D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleMeasureOverdraw           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>pfViewpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nViewpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a>&nbsp;</td>
          <td class="paramname"> <em>eFrontWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pfAvgODOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pfMaxODOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eOverdrawOptimizer</em> = <code>TOOTLE_OVERDRAW_DIRECT3D</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A utility function to measure the amount of overdraw that occurs over a set of views. Overdraw is defined as the number of pixels rendered divided by the number of pixels covered by an object, minus one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The index buffer. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of indices. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfViewpoint</em>&nbsp;</td><td>An array of viewpoints to use to measure overdraw. Each viewpoint must be a point on or in the unit sphere. When measuring overdraw, the mesh will be scaled and translated so that it lies inside the unit sphere. The mesh will be rendered with orthographic projections, with the camera centered at the given point looking at the origin. If this argument is NULL, a default viewpoint set will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nViewpoints</em>&nbsp;</td><td>The number of viewpoints in the viewpoint array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eFrontWinding</em>&nbsp;</td><td>The winding order of front-faces in the model. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfAvgODOut</em>&nbsp;</td><td>A pointer to a variable to receive the average overdraw per pixel. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfMaxODOut</em>&nbsp;</td><td>A pointer to a variable to receive the maximum overdraw per pixel. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eOverdrawOptimizer</em>&nbsp;</td><td>The algorithm selection for optimizing overdraw. Pass either TOOTLE_OVERDRAW_DIRECT3D (default) or TOOTLE_OVERDRAW_RAYTRACE. If you pass any other tokens, it will default to TOOTLE_OVERDRAW_DIRECT3D. For software only build, it will automatically choose TOOTLE_OVERDRAW_RAYTRACE.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY, TOOTLE_NOT_INITIALIZED, or TOOTLE_OK. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g513fe18a45425732ae1d2e9c7fb02b13"></a><!-- doxytag: member="tootlelib.h::TootleOptimize" ref="g513fe18a45425732ae1d2e9c7fb02b13" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, unsigned int nCacheSize, const float *pViewpoints, unsigned int nViewpoints, TootleFaceWinding eFrontWinding, unsigned int *pnIBOut, unsigned int *pnNumClustersOut, TootleVCacheOptimizer eVCacheOptimizer=TOOTLE_VCACHE_AUTO, TootleOverdrawOptimizer eOverdrawOptimizer=TOOTLE_OVERDRAW_FAST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleOptimize           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>pViewpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nViewpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a>&nbsp;</td>
          <td class="paramname"> <em>eFrontWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnNumClustersOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eVCacheOptimizer</em> = <code>TOOTLE_VCACHE_AUTO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eOverdrawOptimizer</em> = <code>TOOTLE_OVERDRAW_FAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a utility function that is provided for developers to perform the entire optimization for a mesh. The function calls the three core functions to create clusters for the mesh (TootleClusterMesh), optimize vertex cache for each cluster (TootleVCacheClusters), and reorder the clusters to optimize overdraw (TootleOptimizeOverdraw). It generates a new indices for faces that is optimized for post-transform vertex cache and overdraw. For the eVCacheOptimizer, it controls the selection of the vertex cache optimization algorithm which are: (1) TOOTLE_VCACHE_AUTO : if vertex cache size input is less than 7, it will use TSTRIPS otherwise TIPSY. (2) TOOTLE_VCACHE_DIRECT3D : use D3DXOptimizeFaces to optimize indices. (3) TOOTLE_VCACHE_LSTRIPS : use LSTRIPS (triangle strips) to optimize indices. (4) TOOTLE_VCACHE_TIPSY : use TIPSY (a new algorithm from SIGGRAPH 2007) to optimize indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>An index buffer. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>Number of vertices. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>Number of faces. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>The number of vertices that will fit in cache. If the application does not know or care about the vertex cache size, then it should pass TOOTLE_DEFAULT_VCACHE_SIZE. This value must be non-zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pViewpoints</em>&nbsp;</td><td>An array of viewpoints to use to measure overdraw. Each viewpoint must be a point on or in the unit sphere. When measuring overdraw, the mesh will be scaled and translated so that it lies inside the unit sphere. The mesh will be rendered with orthographic projections, with the camera centered at the given point looking at the origin. If this argument is NULL, a default viewpoint set will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nViewpoints</em>&nbsp;</td><td>The number of viewpoints in the viewpoint array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eFrontWinding</em>&nbsp;</td><td>The winding order of front-faces in the model. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eVCacheOptimizer</em>&nbsp;</td><td>The selection for choosing the algorithm to optimize vertex cache. There are four choices: TOOTLE_VCACHE_AUTO, TOOTLE_VCACHE_DIRECT3D, TOOTLE_VCACHE_LSTRIPS or TOOTLE_VCACHE_TIPSY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>A pointer that will be filled with an optimized index buffer. May not be NULL. May equal pIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnNumClustersOut</em>&nbsp;</td><td>The number of clusters generated by the algorithm. May be NULL if the output is not requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eOverdrawOptimizer</em>&nbsp;</td><td>The algorithm selection for optimizing overdraw. Pass either TOOTLE_OVERDRAW_FAST (default), TOOTLE_OVERDRAW_AUTO, TOOTLE_OVERDRAW_DIRECT3D, or TOOTLE_OVERDRAW_RAYTRACE.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY, TOOTLE_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="gadac5eaaca7b60781dc469b87e9050e4"></a><!-- doxytag: member="tootlelib.h::TootleOptimizeOverdraw" ref="gadac5eaaca7b60781dc469b87e9050e4" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, const float *pfViewpoint, unsigned int nViewpoints, TootleFaceWinding eFrontWinding, const unsigned int *pnFaceClusters, unsigned int *pnIBOut, unsigned int *pnClusterRemapOut, TootleOverdrawOptimizer eOverdrawOptimizer=TOOTLE_OVERDRAW_FAST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleOptimizeOverdraw           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>pfViewpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nViewpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g97b9c97d2bf8645e489772f589b5ba80">TootleFaceWinding</a>&nbsp;</td>
          <td class="paramname"> <em>eFrontWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceClusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnClusterRemapOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g394ff5247b00d55a189fb8586c715e7e">TootleOverdrawOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eOverdrawOptimizer</em> = <code>TOOTLE_OVERDRAW_FAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a clustered mesh, this function computes a cluster ordering that minimizes expected overdraw, and sorts the clusters according to this ordering. The input is a mesh whose faces are seperated into clusters. The clustering can be obtained by calling TootleClusterMesh, or the application can supply its own clustering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The mesh index buffer. This must be a triangle list. The faces must be clustered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the mesh. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the mesh. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfViewpoint</em>&nbsp;</td><td>An array of viewpoints to use to measure overdraw. Each viewpoint must be a point on or in the unit sphere. When measuring overdraw, the mesh will be scaled and translated so that it lies inside the unit sphere. The mesh will be rendered with orthographic projections, with the camera centered at the given point looking at the origin. If this argument is NULL, a default viewpoint set will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nViewpoints</em>&nbsp;</td><td>The number of viewpoints in the viewpoint array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eFrontWinding</em>&nbsp;</td><td>The winding order of front-faces in the mesh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceClusters</em>&nbsp;</td><td>This array of nFaces+1 size can be either of two types: a full format (the output of TootleClusterMesh) or a compact format (the output of TootleFastOptimizeVCacheAndClusterMesh). The full format is an array of mapping for each face to the cluster ID. The entry i of this array contains the cluster ID of face i. The compact format is an array that maps every face ID between entry i and i+1 to be in cluster i. For both format, the last entry of the array ( pnFaceClusters[ nFaces ] ) should contains the number of total clusters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>An array that will receive the re-ordered index buffer. May be NULL. May equal pnIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnClusterRemapOut</em>&nbsp;</td><td>An array that will receive the cluster ordering. May be NULL. If non-null, the size of the array must be equal to the number of clusters in the mesh. pClusterRemapOut[i] will be set to the ID of the cluster that should come i'th in the draw order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eOverdrawOptimizer</em>&nbsp;</td><td>The algorithm selection for optimizing overdraw. Pass either TOOTLE_OVERDRAW_FAST (default), TOOTLE_OVERDRAW_AUTO, TOOTLE_OVERDRAW_DIRECT3D, or TOOTLE_OVERDRAW_RAYTRACE. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_OK, TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY, TOOTLE_3D_API_ERROR, or TOOTLE_NOT_INITIALIZED </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga6192a1213607cacadbcdc949eb815f7"></a><!-- doxytag: member="tootlelib.h::TootleOptimizeVCache" ref="ga6192a1213607cacadbcdc949eb815f7" args="(const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, unsigned int *pnIBOut, unsigned int *pnFaceRemapOut, TootleVCacheOptimizer eVCacheOptimizer=TOOTLE_VCACHE_AUTO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleOptimizeVCache           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceRemapOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eVCacheOptimizer</em> = <code>TOOTLE_VCACHE_AUTO</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs vertex cache optimization on an index buffer. It returns a face re-mapping if requested. There are several choices for the vertex cache optimization: (1) TOOTLE_VCACHE_AUTO : if vertex cache size input is less than 7, it will use TSTRIPS otherwise TIPSY. (2) TOOTLE_VCACHE_DIRECT3D : use D3DXOptimizeFaces to optimize indices. (3) TOOTLE_VCACHE_LSTRIPS : use LSTRIPS (a list like triangle strips) to optimize indices. (4) TOOTLE_VCACHE_TIPSY : use TIPSY (a new algorithm from SIGGRAPH 2007) to optimize indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The index buffer to optimize. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the index buffer. This must non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the model. This must non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>The number of vertices that will fit in cache. If the application does not know or care about the vertex cache size, then it should pass TOOTLE_DEFAULT_VCACHE_SIZE. This value must be non-zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>A pointer that will be filled with an optimized index buffer. May be NULL. May equal pnIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceRemapOut</em>&nbsp;</td><td>A pointer to an array that will be filled with a face re-mapping. May be NULL. This is an array of nFaces elements. Element i in the array will contain the position of input face i in the output face ordering. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eVCacheOptimizer</em>&nbsp;</td><td>The selection for choosing the algorithm to optimize vertex cache. There are four choices: TOOTLE_VCACHE_AUTO, TOOTLE_VCACHE_DIRECT3D, TOOTLE_VCACHE_LSTRIPS or TOOTLE_VCACHE_TIPSY.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_OK, TOOTLE_OUT_OF_MEMORY, TOOTLE_INVALID_ARGS </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga27896331f4f9a4ff187204a2c2996a2"></a><!-- doxytag: member="tootlelib.h::TootleOptimizeVertexMemory" ref="ga27896331f4f9a4ff187204a2c2996a2" args="(const void *pVB, const unsigned int *pnIB, unsigned int nVertices, unsigned int nFaces, unsigned int nVBStride, void *pVBOut, unsigned int *pnIBOut, unsigned int *pnVertexRemapOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleOptimizeVertexMemory           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pVB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVBStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pVBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnVertexRemapOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function rearrange the vertex buffer's memory location based on the index buffer. Call this function after you have optimized the index buffer for vertex cache post-tranform and/or overdraw. The idea is to rearrange the memory location for vertex buffer such that it will be optimized for vertex prefetch cache. Typically vertices are fetched in a cacheline (more than one vertex at a time). Thus, the vertex in the next memory location will come for free if they are processed next in line. This is what we want to exploit. It will compute a new Vertex Buffer and Index Buffer (since the vertices have been reordered).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVB</em>&nbsp;</td><td>A pointer to the vertex buffer. The pointer pVB must point to the vertex position. The vertex position must be a 3-component floating point value (X,Y,Z). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The mesh index buffer. This must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the mesh. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the mesh. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVBStride</em>&nbsp;</td><td>The distance between successive vertices in the vertex buffer, in bytes. This must be at least 3*sizeof(float). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pVBOut</em>&nbsp;</td><td>The output vertex buffer. May not be NULL. May equal pVB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>The output index buffer. May not be NULL. May equal pnIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnVertexRemapOut</em>&nbsp;</td><td>An array that will receive a vertex re-mapping. May be NULL if the output is not requested. If not NULL, must be an array of size nVertices. The i'th element of the output array contains the position of the input vertex i in the new vertex re-ordering.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_INVALID_ARGS, TOOTLE_OUT_OF_MEMORY, or TOOTLE_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge77a13942a64bedbf877cda55a2d0575"></a><!-- doxytag: member="tootlelib.h::TootleVCacheClusters" ref="ge77a13942a64bedbf877cda55a2d0575" args="(const unsigned int *pnIB, unsigned int nFaces, unsigned int nVertices, unsigned int nCacheSize, const unsigned int *pnFaceClusters, unsigned int *pnIBOut, unsigned int *pnFaceRemapOut, TootleVCacheOptimizer eVCacheOptimizer=TOOTLE_VCACHE_AUTO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Tootle.html#gc595dd665ead03e00053661fa3a912fe">TootleResult</a> TOOTLE_DLL TootleVCacheClusters           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceClusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnIBOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>pnFaceRemapOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tootle.html#g66557053f4f5f93361f20cdc707181fd">TootleVCacheOptimizer</a>&nbsp;</td>
          <td class="paramname"> <em>eVCacheOptimizer</em> = <code>TOOTLE_VCACHE_AUTO</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a utility function to optimize vertex cache on a clustered index buffer. This function simply calls TootleOptimizeVCache repeatedly. The faces within each cluster will be re-ordered, but the clustering will be maintained For the eVCacheOptimizer, it controls the selection of the vertex cache optimization algorithm which are: (1) TOOTLE_VCACHE_AUTO : if vertex cache size input is less than 7, it will use TSTRIPS otherwise TIPSY. (2) TOOTLE_VCACHE_DIRECT3D : use D3DXOptimizeFaces to optimize indices. (3) TOOTLE_VCACHE_TSTRIPS : use TSTRIPS (triangle strips) to optimize indices. (4) TOOTLE_VCACHE_TIPSY : use TIPSY (a new algorithm from SIGGRAPH 2007) to optimize indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnIB</em>&nbsp;</td><td>The index buffer to optimize. Must be a triangle list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFaces</em>&nbsp;</td><td>The number of faces in the index buffer. This must be non-zero and less than TOOTLE_MAX_FACES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nVertices</em>&nbsp;</td><td>The number of vertices in the model. This must be non-zero and less than TOOTLE_MAX_VERTICES. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>The number of vertices that will fit in cache. If the application does not know or care about the vertex cache size, then it should pass TOOTLE_DEFAULT_VCACHE_SIZE. This value must be non-zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceClusters</em>&nbsp;</td><td>An array giving the cluster ID for each face. All faces in a particular cluster should appear consecutively in the index buffer, as well as in this array. It should be of size nFaces+1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnIBOut</em>&nbsp;</td><td>A pointer that will be filled with an optimized index buffer. May be NULL. May equal pnIB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnFaceRemapOut</em>&nbsp;</td><td>A pointer to an array that will be filled with a face re-mapping. May be NULL. This is an array of nFaces elements. Element i in the array will contain the position of input face i in the output face ordering. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eVCacheOptimizer</em>&nbsp;</td><td>The selection for choosing the algorithm to optimize vertex cache. There are four choices: TOOTLE_VCACHE_AUTO, TOOTLE_VCACHE_DIRECT3D, TOOTLE_VCACHE_LSTRIPS or TOOTLE_VCACHE_TIPSY. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Possible return codes: TOOTLE_OK, TOOTLE_OUT_OF_MEMORY, TOOTLE_INVALID_ARGS </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 9 10:30:24 2009 for Tootle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
