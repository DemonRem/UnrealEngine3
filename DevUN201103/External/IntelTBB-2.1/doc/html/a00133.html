<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::task_group_context Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00181.html">tbb</a>::<a class="el" href="a00133.html">task_group_context</a></div>
<h1>tbb::task_group_context Class Reference<br>
<small>
[<a class="el" href="a00188.html">Task Scheduling</a>]</small>
</h1><!-- doxytag: class="tbb::task_group_context" -->Used to form groups of tasks.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00276.html">task.h</a>&gt;</code>
<p>
<a href="a00055.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5af85179a348162d4ddd66b6fc0d60fb4fda16c4f77defd3d0f6aad87fceed4"></a><!-- doxytag: member="tbb::task_group_context::isolated" ref="d5af85179a348162d4ddd66b6fc0d60fb4fda16c4f77defd3d0f6aad87fceed4" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>isolated</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5af85179a348162d4ddd66b6fc0d60fc7f37e067ba1fca8a5c809d20522662b"></a><!-- doxytag: member="tbb::task_group_context::bound" ref="d5af85179a348162d4ddd66b6fc0d60fc7f37e067ba1fca8a5c809d20522662b" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>bound</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>kind_type</b> { <b>isolated</b>, 
<b>bound</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#6fc0ba6f3abcdb4d43277c05bd67bdd4">task_group_context</a> (kind_type relation_with_parent=bound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default &amp; binding constructor.  <a href="#6fc0ba6f3abcdb4d43277c05bd67bdd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#6d30d16bf1cd22f86c6afaf29c2b430c">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forcefully reinitializes context object after an algorithm it was used with finished.  <a href="#6d30d16bf1cd22f86c6afaf29c2b430c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#8bcdfdf4e6bfb76125b6de15c00b571d">cancel_group_execution</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates cancellation of all tasks in this cancellation group and its subordinate groups.  <a href="#8bcdfdf4e6bfb76125b6de15c00b571d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4db72f16210b0a991b2c134d6763a4cc"></a><!-- doxytag: member="tbb::task_group_context::is_group_execution_cancelled" ref="4db72f16210b0a991b2c134d6763a4cc" args="() const " -->
bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#4db72f16210b0a991b2c134d6763a4cc">is_group_execution_cancelled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the context received cancellation request. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#49a55352084fd44b8863d182e839e6dc">init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Out-of-line part of the constructor.  <a href="#49a55352084fd44b8863d182e839e6dc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e656073628561c8fd68f6134d527e2de"></a><!-- doxytag: member="tbb::task_group_context::task" ref="e656073628561c8fd68f6134d527e2de" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>task</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ecedb9436fb30df30cb3a52c64bb97e5"></a><!-- doxytag: member="tbb::task_group_context::internal::allocate_root_with_context_proxy" ref="ecedb9436fb30df30cb3a52c64bb97e5" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_with_context_proxy</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Used to form groups of tasks. 
<p>
The context services explicit cancellation requests from user code, and unhandled exceptions intercepted during tasks execution. Intercepting an exception results in generating internal cancellation requests (which is processed in exactly the same way as external ones).<p>
The context is associated with one or more root tasks and defines the cancellation group that includes all the descendants of the corresponding root task(s). Association is established when a context object is passed as an argument to the <a class="el" href="a00132.html#23acb0da0afd690da797f9f882027d34">task::allocate_root()</a> method. See <a class="el" href="a00133.html#6fc0ba6f3abcdb4d43277c05bd67bdd4">task_group_context::task_group_context</a> for more details.<p>
The context can be bound to another one, and other contexts can be bound to it, forming a tree-like structure: parent -&gt; this -&gt; children. Arrows here designate cancellation propagation direction. If a task in a cancellation group is canceled all the other tasks in this group and groups bound to it (as children) get canceled too. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6fc0ba6f3abcdb4d43277c05bd67bdd4"></a><!-- doxytag: member="tbb::task_group_context::task_group_context" ref="6fc0ba6f3abcdb4d43277c05bd67bdd4" args="(kind_type relation_with_parent=bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tbb::task_group_context::task_group_context           </td>
          <td>(</td>
          <td class="paramtype">kind_type&nbsp;</td>
          <td class="paramname"> <em>relation_with_parent</em> = <code>bound</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default &amp; binding constructor. 
<p>
By default a bound context is created. That is this context will be bound (as child) to the context of the task calling task::allocate_root(this_context) method. Cancellation requests passed to the parent context are propagated to all the contexts bound to it.<p>
If task_group_context::isolated is used as the argument, then the tasks associated with this context will never be affected by events in any other context.<p>
Creating isolated context is involves much less overhead, but they have limited utility. Normally when an exception occur in an algorithm that has nested algorithms running one would want all the nested ones canceled as well. Such behavior requires nested algorithms to use bound contexts.<p>
There is one good place where using isolated algorithms is beneficial. It is a master thread. That is if a particular algorithm is invoked directly from the master thread (not from a TBB task), supplying it with explicitly created isolated context will result in a faster algorithm startup. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8bcdfdf4e6bfb76125b6de15c00b571d"></a><!-- doxytag: member="tbb::task_group_context::cancel_group_execution" ref="8bcdfdf4e6bfb76125b6de15c00b571d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool __TBB_EXPORTED_METHOD tbb::task_group_context::cancel_group_execution           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates cancellation of all tasks in this cancellation group and its subordinate groups. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>false if cancellation has already been requested, true otherwise.</dd></dl>
Note that canceling never fails. When false is returned, it just means that another thread (or this one) has already sent cancellation request to this context or to one of its ancestors (if this context is bound). It is guaranteed that when this method is called on the same context, true may be returned by at most one invocation. 
</div>
</div><p>
<a class="anchor" name="49a55352084fd44b8863d182e839e6dc"></a><!-- doxytag: member="tbb::task_group_context::init" ref="49a55352084fd44b8863d182e839e6dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_group_context::init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Out-of-line part of the constructor. 
<p>
Separated to facilitate future support for backward binary compatibility. 
</div>
</div><p>
<a class="anchor" name="6d30d16bf1cd22f86c6afaf29c2b430c"></a><!-- doxytag: member="tbb::task_group_context::reset" ref="6d30d16bf1cd22f86c6afaf29c2b430c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_group_context::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forcefully reinitializes context object after an algorithm it was used with finished. 
<p>
Because the method assumes that the all the tasks that used to be associated with this context have already finished, you must be extremely careful to not invalidate the context while it is still in use somewhere in the task hierarchy.<p>
IMPORTANT: It is assumed that this method is not used concurrently!<p>
The method does not change the context's parent if it is set. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00276.html">task.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2009 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
