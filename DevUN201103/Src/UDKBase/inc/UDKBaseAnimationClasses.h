/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "UDKBaseNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UDKBASE_ANIMATION_ENUMS
#define INCLUDED_UDKBASE_ANIMATION_ENUMS 1

enum EBlendFallTypes
{
    FBT_Up                  =0,
    FBT_Down                =1,
    FBT_PreLand             =2,
    FBT_Land                =3,
    FBT_DblJumpUp           =4,
    FBT_DblJumpDown         =5,
    FBT_DblJumpPreLand      =6,
    FBT_DblJumpLand         =7,
    FBT_None                =8,
    FBT_MAX                 =9,
};
#define FOREACH_ENUM_EBLENDFALLTYPES(op) \
    op(FBT_Up) \
    op(FBT_Down) \
    op(FBT_PreLand) \
    op(FBT_Land) \
    op(FBT_DblJumpUp) \
    op(FBT_DblJumpDown) \
    op(FBT_DblJumpPreLand) \
    op(FBT_DblJumpLand) \
    op(FBT_None) 
enum EFlyingState
{
    Flying_NotFlying        =0,
    Flying_OpeningWings     =1,
    Flying_Flying           =2,
    Flying_ClosingWings     =3,
    Flying_MAX              =4,
};
#define FOREACH_ENUM_EFLYINGSTATE(op) \
    op(Flying_NotFlying) \
    op(Flying_OpeningWings) \
    op(Flying_Flying) \
    op(Flying_ClosingWings) 

#endif // !INCLUDED_UDKBASE_ANIMATION_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_UDKBASE_ANIMATION_CLASSES
#define INCLUDED_UDKBASE_ANIMATION_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct UDKAnimBlendBase_eventTickAnim_Parms
{
    FLOAT DeltaSeconds;
    UDKAnimBlendBase_eventTickAnim_Parms(EEventParm)
    {
    }
};
class UUDKAnimBlendBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS UDKAnimBlendBase
    FLOAT BlendTime;
    TArrayNoInit<FLOAT> ChildBlendTimes;
    BITFIELD bTickAnimInScript:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKAnimBlendBase

    FLOAT GetBlendTime(INT ChildIndex,UBOOL bGetDefault=FALSE);
    FLOAT GetAnimDuration(INT ChildIndex);
    DECLARE_FUNCTION(execGetBlendTime)
    {
        P_GET_INT(ChildIndex);
        P_GET_UBOOL_OPTX(bGetDefault,FALSE);
        P_FINISH;
        *(FLOAT*)Result=this->GetBlendTime(ChildIndex,bGetDefault);
    }
    DECLARE_FUNCTION(execGetAnimDuration)
    {
        P_GET_INT(ChildIndex);
        P_FINISH;
        *(FLOAT*)Result=this->GetAnimDuration(ChildIndex);
    }
    void eventTickAnim(FLOAT DeltaSeconds)
    {
        UDKAnimBlendBase_eventTickAnim_Parms Parms(EC_EventParm);
        Parms.DeltaSeconds=DeltaSeconds;
        ProcessEvent(FindFunctionChecked(UDKBASE_TickAnim),&Parms);
    }
    DECLARE_CLASS(UUDKAnimBlendBase,UAnimNodeBlendList,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);

	// AnimTree editor interface
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
};

class UUDKAnimBlendByFall : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByFall
    BITFIELD bIgnoreDoubleJumps:1;
    BITFIELD bDidDoubleJump:1;
    BITFIELD bDodgeFall:1;
    FLOAT PreLandTime;
    FLOAT PreLandStartUprightTime;
    FLOAT ToDblJumpUprightTime;
    BYTE FallState;
    FLOAT LastFallingVelocity;
    class UUDKAnimNodeJumpLeanOffset* CachedLeanNode;
    //## END PROPS UDKAnimBlendByFall

    DECLARE_CLASS(UUDKAnimBlendByFall,UUDKAnimBlendBase,0,UDKBase)
	virtual void DeferredInitAnim();
	virtual	void TickAnim(FLOAT DeltaSeconds);
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	virtual void ChangeFallState(EBlendFallTypes NewState);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void RenameChildConnectors();
	virtual void OnCeaseRelevant();
};

class UUDKAnimBlendByHoverJump : public UUDKAnimBlendByFall
{
public:
    //## BEGIN PROPS UDKAnimBlendByHoverJump
    class APawn* OwnerP;
    class AUDKVehicle* OwnerHV;
    //## END PROPS UDKAnimBlendByHoverJump

    DECLARE_CLASS(UUDKAnimBlendByHoverJump,UUDKAnimBlendByFall,0,UDKBase)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByFlying : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByFlying
    BYTE FlyingState;
    class AUDKPawn* Pawn;
    class UUDKAnimBlendBase* FlyingMode;
    class UAnimNodeAimOffset* FlyingDir;
    FName StartingAnimName;
    BITFIELD bHasStartingAnim:1;
    BITFIELD bHasEndingAnim:1;
    FName EndingAnimName;
    //## END PROPS UDKAnimBlendByFlying

    virtual void UpdateFlyingState();
    DECLARE_FUNCTION(execUpdateFlyingState)
    {
        P_FINISH;
        this->UpdateFlyingState();
    }
    DECLARE_CLASS(UUDKAnimBlendByFlying,UUDKAnimBlendBase,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
	
	void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent );

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	
	void TestBlend();
};

class UUDKAnimBlendByHoverboarding : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByHoverboarding
    INT LastActiveChildIndex;
    FLOAT BoardLeanAmount;
    FLOAT FallTimeBeforeAnim;
    //## END PROPS UDKAnimBlendByHoverboarding

    DECLARE_CLASS(UUDKAnimBlendByHoverboarding,UUDKAnimBlendBase,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
};

class UUDKAnimBlendByIdle : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByIdle
    //## END PROPS UDKAnimBlendByIdle

    DECLARE_CLASS(UUDKAnimBlendByIdle,UUDKAnimBlendBase,0,UDKBase)
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByPhysics : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByPhysics
    INT PhysicsMap[12];
    INT LastPhysics;
    FLOAT LandBlendDelay;
    INT PendingChildIndex;
    FLOAT PendingTimeToGo;
    //## END PROPS UDKAnimBlendByPhysics

    DECLARE_CLASS(UUDKAnimBlendByPhysics,UUDKAnimBlendBase,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

struct FPhysicsVolumeParams
{
    INT ChildIndex;
    BITFIELD bWaterVolume:1;
    BITFIELD bCheckGravity:1;
    FLOAT MinGravity;
    FLOAT MaxGravity;

    /** Constructors */
    FPhysicsVolumeParams() {}
    FPhysicsVolumeParams(EEventParm)
    {
        appMemzero(this, sizeof(FPhysicsVolumeParams));
    }
};

struct UDKAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms
{
    class APhysicsVolume* NewVolume;
    UDKAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms(EEventParm)
    {
    }
};
class UUDKAnimBlendByPhysicsVolume : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByPhysicsVolume
    TArrayNoInit<struct FPhysicsVolumeParams> PhysicsParamList;
    class APhysicsVolume* LastPhysicsVolume;
    //## END PROPS UDKAnimBlendByPhysicsVolume

    void eventPhysicsVolumeChanged(class APhysicsVolume* NewVolume)
    {
        UDKAnimBlendByPhysicsVolume_eventPhysicsVolumeChanged_Parms Parms(EC_EventParm);
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(UDKBASE_PhysicsVolumeChanged),&Parms);
    }
    DECLARE_CLASS(UUDKAnimBlendByPhysicsVolume,UUDKAnimBlendBase,0,UDKBase)
	virtual void RenameChildConnectors();
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByPosture : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByPosture
    //## END PROPS UDKAnimBlendByPosture

    DECLARE_CLASS(UUDKAnimBlendByPosture,UUDKAnimBlendBase,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByTurnInPlace : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByTurnInPlace
    FLOAT RootYawSpeedThresh;
    FLOAT TurnInPlaceBlendSpeed;
    class AUDKPawn* OwnerUTP;
    //## END PROPS UDKAnimBlendByTurnInPlace

    DECLARE_CLASS(UUDKAnimBlendByTurnInPlace,UUDKAnimBlendBase,0,UDKBase)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds);
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUDKAnimBlendByVehicle : public UUDKAnimBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByVehicle
    BITFIELD bLastPawnDriving:1;
    class AVehicle* LastVehicle;
    //## END PROPS UDKAnimBlendByVehicle

    virtual void UpdateVehicleState();
    DECLARE_FUNCTION(execUpdateVehicleState)
    {
        P_FINISH;
        this->UpdateVehicleState();
    }
    DECLARE_CLASS(UUDKAnimBlendByVehicle,UUDKAnimBlendBase,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByDriving : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UDKAnimBlendByDriving
    //## END PROPS UDKAnimBlendByDriving

    virtual void UpdateDrivingState();
    DECLARE_FUNCTION(execUpdateDrivingState)
    {
        P_FINISH;
        this->UpdateDrivingState();
    }
    DECLARE_CLASS(UUDKAnimBlendByDriving,UAnimNodeBlend,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendByHoverboardTilt : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByHoverboardTilt
    FVector UpVector;
    FLOAT TiltScale;
    FLOAT TiltDeadZone;
    FLOAT TiltYScale;
    FName UpperBodyName;
    //## END PROPS UDKAnimBlendByHoverboardTilt

    DECLARE_CLASS(UUDKAnimBlendByHoverboardTilt,UAnimNodeBlendBase,0,UDKBase)
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);

	virtual INT GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UUDKAnimBlendByHoverboardTurn : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UDKAnimBlendByHoverboardTurn
    FLOAT TurnScale;
    FLOAT MaxBlendPerSec;
    FLOAT CurrentAnimWeight;
    //## END PROPS UDKAnimBlendByHoverboardTurn

    DECLARE_CLASS(UUDKAnimBlendByHoverboardTurn,UAnimNodeBlendBase,0,UDKBase)
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendBySlotActive : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UDKAnimBlendBySlotActive
    class UAnimNodeSlot* ChildSlot;
    //## END PROPS UDKAnimBlendBySlotActive

    DECLARE_CLASS(UUDKAnimBlendBySlotActive,UAnimNodeBlendPerBone,0,UDKBase)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UUDKAnimBlendBySpeed : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS UDKAnimBlendBySpeed
    FLOAT MinSpeed;
    FLOAT MaxSpeed;
    //## END PROPS UDKAnimBlendBySpeed

    DECLARE_CLASS(UUDKAnimBlendBySpeed,UAnimNodeBlend,0,UDKBase)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

struct UDKAnimBlendByWeapon_eventAnimStopFire_Parms
{
    FLOAT SpecialBlendTime;
    UDKAnimBlendByWeapon_eventAnimStopFire_Parms(EEventParm)
    {
    }
};
class UUDKAnimBlendByWeapon : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UDKAnimBlendByWeapon
    BITFIELD bLooping:1;
    FName LoopingAnim;
    FLOAT BlendTime;
    //## END PROPS UDKAnimBlendByWeapon

    void eventAnimStopFire(FLOAT SpecialBlendTime=0)
    {
        UDKAnimBlendByWeapon_eventAnimStopFire_Parms Parms(EC_EventParm);
        Parms.SpecialBlendTime=SpecialBlendTime;
        ProcessEvent(FindFunctionChecked(UDKBASE_AnimStopFire),&Parms);
    }
    DECLARE_CLASS(UUDKAnimBlendByWeapon,UAnimNodeBlendPerBone,0,UDKBase)
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUDKAnimBlendByWeapType : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS UDKAnimBlendByWeapType
    //## END PROPS UDKAnimBlendByWeapType

    DECLARE_CLASS(UUDKAnimBlendByWeapType,UAnimNodeBlendPerBone,0,UDKBase)
	void WeapTypeChanged(FName NewAimProfileName);
};

struct FBoneCopyInfo
{
    FName SrcBoneName;
    FName DstBoneName;
    INT SrcBoneIndex;
    INT DstBoneIndex;

    /** Constructors */
    FBoneCopyInfo() {}
    FBoneCopyInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBoneCopyInfo));
    }
};

class UUDKAnimNodeCopyBoneTranslation : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS UDKAnimNodeCopyBoneTranslation
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    TArrayNoInit<struct FBoneCopyInfo> DefaultBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> DualWieldBoneCopyArray;
    TArrayNoInit<struct FBoneCopyInfo> ActiveBoneCopyArray;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<class UUDKAnimNodeSeqWeap*> SeqWeaps;
    TArrayNoInit<class UUDKAnimBlendByWeapType*> WeapTypeBlends;
    //## END PROPS UDKAnimNodeCopyBoneTranslation

    DECLARE_CLASS(UUDKAnimNodeCopyBoneTranslation,UAnimNodeBlendBase,0,UDKBase)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void UpdateListOfRequiredBones(FName AimProfileName);

	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual void TickAnim(FLOAT DeltaSeconds);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
};

class UUDKAnimNodeFramePlayer : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UDKAnimNodeFramePlayer
    //## END PROPS UDKAnimNodeFramePlayer

    virtual void SetAnimation(FName Sequence,FLOAT RateScale);
    virtual void SetAnimPosition(FLOAT Perc);
    DECLARE_FUNCTION(execSetAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(RateScale);
        P_FINISH;
        this->SetAnimation(Sequence,RateScale);
    }
    DECLARE_FUNCTION(execSetAnimPosition)
    {
        P_GET_FLOAT(Perc);
        P_FINISH;
        this->SetAnimPosition(Perc);
    }
    DECLARE_CLASS(UUDKAnimNodeFramePlayer,UAnimNodeSequence,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKAnimNodeFramePlayer)
};

class UUDKAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS UDKAnimNodeJumpLeanOffset
    FLOAT JumpLeanStrength;
    FLOAT MaxLeanChangeSpeed;
    BITFIELD bMultiplyByZVelocity:1;
    BITFIELD bDodging:1;
    BITFIELD bOldDodging:1;
    BITFIELD bDoubleJumping:1;
    BITFIELD bOldDoubleJumping:1;
    class UAnimNodeAimOffset* CachedAimNode;
    FName OldAimProfileName;
    FVector2D PreBlendAim;
    FLOAT LeanWeight;
    FLOAT LeanWeightTarget;
    FLOAT BlendTimeToGo;
    //## END PROPS UDKAnimNodeJumpLeanOffset

    void SetLeanWeight(FLOAT WeightTarget,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetLeanWeight)
    {
        P_GET_FLOAT(WeightTarget);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        this->SetLeanWeight(WeightTarget,BlendTime);
    }
    DECLARE_CLASS(UUDKAnimNodeJumpLeanOffset,UAnimNodeAimOffset,0,UDKBase)
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds);	
};

class UUDKAnimNodeSequence : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS UDKAnimNodeSequence
    BITFIELD bAutoStart:1;
    BITFIELD bLoopLastSequence:1;
    TArrayNoInit<FName> SeqStack;
    //## END PROPS UDKAnimNodeSequence

    virtual void PlayAnimation(FName Sequence,FLOAT SeqRate,UBOOL bSeqLoop);
    virtual void PlayAnimationSet(const TArray<FName>& Sequences,FLOAT SeqRate,UBOOL bLoopLast);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bSeqLoop);
        P_FINISH;
        this->PlayAnimation(Sequence,SeqRate,bSeqLoop);
    }
    DECLARE_FUNCTION(execPlayAnimationSet)
    {
        P_GET_TARRAY(FName,Sequences);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bLoopLast);
        P_FINISH;
        this->PlayAnimationSet(Sequences,SeqRate,bLoopLast);
    }
    DECLARE_CLASS(UUDKAnimNodeSequence,UAnimNodeSequence,0,UDKBase)
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);
};

class UUDKAnimNodeSeqWeap : public UUDKAnimNodeSequence
{
public:
    //## BEGIN PROPS UDKAnimNodeSeqWeap
    FName DefaultAnim;
    FName DualPistolAnim;
    FName SinglePistolAnim;
    FName ShoulderRocketAnim;
    FName StingerAnim;
    //## END PROPS UDKAnimNodeSeqWeap

    DECLARE_CLASS(UUDKAnimNodeSeqWeap,UUDKAnimNodeSequence,0,UDKBase)
	virtual FString GetNodeTitle();

	void WeapTypeChanged(FName NewAimProfileName);
};

struct UDKSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms
{
    FVector ReturnValue;
    UDKSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms(EEventParm)
    {
    }
};
class UUDKSkelControl_CantileverBeam : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UDKSkelControl_CantileverBeam
    FVector WorldSpaceGoal;
    FVector InitialWorldSpaceGoalOffset;
    FVector Velocity;
    FLOAT SpringStiffness;
    FLOAT SpringDamping;
    FLOAT PercentBeamVelocityTransfer;
    FScriptDelegate __EntireBeamVelocity__Delegate;
    //## END PROPS UDKSkelControl_CantileverBeam

    FVector delegateEntireBeamVelocity()
    {
        UDKSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessDelegate(UDKBASE_EntireBeamVelocity,&__EntireBeamVelocity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUDKSkelControl_CantileverBeam,USkelControlLookAt,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct UDKSkelControl_Damage_eventRestorePart_Parms
{
    FLOAT ReturnValue;
    UDKSkelControl_Damage_eventRestorePart_Parms(EEventParm)
    {
    }
};
struct UDKSkelControl_Damage_eventBreakApartOnDeath_Parms
{
    FVector PartLocation;
    UBOOL bIsVisible;
    UDKSkelControl_Damage_eventBreakApartOnDeath_Parms(EEventParm)
    {
    }
};
struct UDKSkelControl_Damage_eventBreakApart_Parms
{
    FVector PartLocation;
    UBOOL bIsVisible;
    UDKSkelControl_Damage_eventBreakApart_Parms(EEventParm)
    {
    }
};
class UUDKSkelControl_Damage : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_Damage
    BITFIELD bInitialized:1;
    BITFIELD bOnDamageActive:1;
    BITFIELD bControlStrFollowsHealth:1;
    BITFIELD bIsBroken:1;
    BITFIELD bIsBreaking:1;
    BITFIELD bOnDeathActive:1;
    BITFIELD bOnDeathUseForSecondaryExplosion:1;
    class AUDKVehicle* OwnerVehicle;
    FLOAT HealthPerc;
    FLOAT DamageBoneScale;
    INT DamageMax;
    FLOAT ActivationThreshold;
    class UStaticMesh* BreakMesh;
    FLOAT BreakThreshold;
    FLOAT BreakTime;
    FVector DefaultBreakDir;
    FVector DamageScale;
    class UParticleSystem* PS_DamageOnBreak;
    class UParticleSystem* PS_DamageTrail;
    FName BrokenBone;
    FLOAT BreakTimer;
    FLOAT OwnerVehicleMaxHealth;
    FVector BreakSpeed;
    FLOAT DeathPercentToActuallySpawn;
    FLOAT DeathBoneScale;
    class UStaticMesh* DeathStaticMesh;
    FVector DeathImpulseDir;
    FVector DeathScale;
    class UParticleSystem* PS_DeathOnBreak;
    class UParticleSystem* PS_DeathTrail;
    //## END PROPS UDKSkelControl_Damage

    FLOAT eventRestorePart()
    {
        UDKSkelControl_Damage_eventRestorePart_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(UDKBASE_RestorePart),&Parms);
        return Parms.ReturnValue;
    }
    void eventBreakApartOnDeath(FVector PartLocation,UBOOL bIsVisible)
    {
        UDKSkelControl_Damage_eventBreakApartOnDeath_Parms Parms(EC_EventParm);
        Parms.PartLocation=PartLocation;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_BreakApartOnDeath),&Parms);
    }
    void eventBreakApart(FVector PartLocation,UBOOL bIsVisible)
    {
        UDKSkelControl_Damage_eventBreakApart_Parms Parms(EC_EventParm);
        Parms.PartLocation=PartLocation;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_BreakApart),&Parms);
    }
    DECLARE_CLASS(UUDKSkelControl_Damage,USkelControlSingleBone,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_DamageHinge : public UUDKSkelControl_Damage
{
public:
    //## BEGIN PROPS UDKSkelControl_DamageHinge
    FLOAT MaxAngle;
    BYTE PivotAxis;
    FLOAT AVModifier;
    FLOAT CurrentAngle;
    FLOAT SpringStiffness;
    //## END PROPS UDKSkelControl_DamageHinge

    DECLARE_CLASS(UUDKSkelControl_DamageHinge,UUDKSkelControl_Damage,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_DamageSpring : public UUDKSkelControl_Damage
{
public:
    //## BEGIN PROPS UDKSkelControl_DamageSpring
    FRotator MaxAngle;
    FRotator MinAngle;
    FLOAT Falloff;
    FLOAT SpringStiffness;
    FLOAT AVModifier;
    FRotator CurrentAngle;
    FLOAT RandomPortion;
    FVector LastHitMomentum;
    FLOAT LastHitTime;
    FLOAT MomentumPortion;
    //## END PROPS UDKSkelControl_DamageSpring

    DECLARE_CLASS(UUDKSkelControl_DamageSpring,UUDKSkelControl_Damage,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual INT CalcAxis(INT &InAngle, FLOAT CurVelocity, FLOAT MinAngle, FLOAT MaxAngle);
	virtual UBOOL InitializeControl(USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_HoverboardSuspension : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_HoverboardSuspension
    FLOAT TransIgnore;
    FLOAT TransScale;
    FLOAT TransOffset;
    FLOAT MaxTrans;
    FLOAT MinTrans;
    FLOAT RotScale;
    FLOAT MaxRot;
    FLOAT MaxRotRate;
    FLOAT CurrentRot;
    //## END PROPS UDKSkelControl_HoverboardSuspension

    DECLARE_CLASS(UUDKSkelControl_HoverboardSuspension,USkelControlSingleBone,0,UDKBase)
	// SkelControl interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_HoverboardSwing : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_HoverboardSwing
    INT SwingHistoryWindow;
    INT SwingHistorySlot;
    TArrayNoInit<FLOAT> SwingHistory;
    FLOAT SwingScale;
    FLOAT MaxSwing;
    FLOAT MaxUseVel;
    FLOAT CurrentSwing;
    //## END PROPS UDKSkelControl_HoverboardSwing

    DECLARE_CLASS(UUDKSkelControl_HoverboardSwing,USkelControlSingleBone,0,UDKBase)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
};

class UUDKSkelControl_HoverboardVibration : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_HoverboardVibration
    FLOAT VibFrequency;
    FLOAT VibSpeedAmpScale;
    FLOAT VibTurnAmpScale;
    FLOAT VibMaxAmplitude;
    FLOAT VibInput;
    //## END PROPS UDKSkelControl_HoverboardVibration

    DECLARE_CLASS(UUDKSkelControl_HoverboardVibration,USkelControlSingleBone,0,UDKBase)
	// SkelControlWheel interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
};

class UUDKSkelControl_HugGround : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_HugGround
    FLOAT DesiredGroundDist;
    FLOAT MaxDist;
    FName ParentBone;
    BITFIELD bOppositeFromParent:1;
    FLOAT XYDistFromParentBone;
    FLOAT ZDistFromParentBone;
    FLOAT MaxTranslationPerSec;
    FLOAT LastUpdateTime;
    //## END PROPS UDKSkelControl_HugGround

    DECLARE_CLASS(UUDKSkelControl_HugGround,USkelControlSingleBone,0,UDKBase)
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
};

class UUDKSkelControl_LockRotation : public USkelControlBase
{
public:
    //## BEGIN PROPS UDKSkelControl_LockRotation
    BITFIELD bLockPitch:1;
    BITFIELD bLockYaw:1;
    BITFIELD bLockRoll:1;
    SCRIPT_ALIGN;
    FRotator LockRotation;
    FRotator MaxDelta;
    BYTE LockRotationSpace;
    FName RotationSpaceBoneName;
    //## END PROPS UDKSkelControl_LockRotation

    DECLARE_CLASS(UUDKSkelControl_LockRotation,USkelControlBase,0,UDKBase)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
};

class UUDKSkelControl_LookAt : public USkelControlLookAt
{
public:
    //## BEGIN PROPS UDKSkelControl_LookAt
    BITFIELD bLimitYaw:1;
    BITFIELD bLimitPitch:1;
    BITFIELD bLimitRoll:1;
    BITFIELD bShowPerAxisLimits:1;
    FLOAT YawLimit;
    FLOAT PitchLimit;
    FLOAT RollLimit;
    //## END PROPS UDKSkelControl_LookAt

    DECLARE_CLASS(UUDKSkelControl_LookAt,USkelControlLookAt,0,UDKBase)
protected:
	virtual UBOOL	ApplyLookDirectionLimits(FVector& DesiredLookDir, const FVector &CurrentLookDir, INT BoneIndex, USkeletalMeshComponent* SkelComp);
public:
	virtual void	TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void	DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class UUDKSkelControl_MassBoneScaling : public USkelControlBase
{
public:
    //## BEGIN PROPS UDKSkelControl_MassBoneScaling
    TArrayNoInit<FLOAT> BoneScales;
    //## END PROPS UDKSkelControl_MassBoneScaling

    void SetBoneScale(FName BoneName,FLOAT Scale);
    FLOAT GetBoneScale(FName BoneName);
    DECLARE_FUNCTION(execSetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        this->SetBoneScale(BoneName,Scale);
    }
    DECLARE_FUNCTION(execGetBoneScale)
    {
        P_GET_NAME(BoneName);
        P_FINISH;
        *(FLOAT*)Result=this->GetBoneScale(BoneName);
    }
    DECLARE_CLASS(UUDKSkelControl_MassBoneScaling,USkelControlBase,0,UDKBase)
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_PropellerBlade : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_PropellerBlade
    FLOAT MaxRotationsPerSecond;
    FLOAT SpinUpTime;
    BITFIELD bCounterClockwise:1;
    FLOAT RotationsPerSecond;
    FLOAT DesiredRotationsPerSecond;
    //## END PROPS UDKSkelControl_PropellerBlade

    DECLARE_CLASS(UUDKSkelControl_PropellerBlade,USkelControlSingleBone,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_Rotate : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_Rotate
    FRotator DesiredBoneRotation;
    FRotator DesiredBoneRotationRate;
    //## END PROPS UDKSkelControl_Rotate

    DECLARE_CLASS(UUDKSkelControl_Rotate,USkelControlSingleBone,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_SpinControl : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_SpinControl
    FLOAT DegreesPerSecond;
    FVector Axis;
    //## END PROPS UDKSkelControl_SpinControl

    DECLARE_CLASS(UUDKSkelControl_SpinControl,USkelControlSingleBone,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct FTurretConstraintData
{
    INT PitchConstraint;
    INT YawConstraint;
    INT RollConstraint;

    /** Constructors */
    FTurretConstraintData() {}
    FTurretConstraintData(EEventParm)
    {
        appMemzero(this, sizeof(FTurretConstraintData));
    }
};

struct FTurretStepData
{
    INT StepStartAngle;
    INT StepEndAngle;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;

    /** Constructors */
    FTurretStepData() {}
    FTurretStepData(EEventParm)
    {
        appMemzero(this, sizeof(FTurretStepData));
    }
};

struct UDKSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms
{
    UBOOL bIsMoving;
    UDKSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms(EEventParm)
    {
    }
};
class UUDKSkelControl_TurretConstrained : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_TurretConstrained
    BITFIELD bConstrainPitch:1;
    BITFIELD bConstrainYaw:1;
    BITFIELD bConstrainRoll:1;
    BITFIELD bInvertPitch:1;
    BITFIELD bInvertYaw:1;
    BITFIELD bInvertRoll:1;
    BITFIELD bFixedWhenFiring:1;
    BITFIELD bResetWhenUnattended:1;
    BITFIELD bIsInMotion:1;
    SCRIPT_ALIGN;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
    TArrayNoInit<struct FTurretStepData> Steps;
    FLOAT LagDegreesPerSecond;
    FLOAT PitchSpeedScale;
    FRotator DesiredBoneRotation;
    INT AssociatedSeatIndex;
    FRotator ConstrainedBoneRotation;
    FScriptDelegate __OnTurretStatusChange__Delegate;
    //## END PROPS UDKSkelControl_TurretConstrained

    void InitTurret(FRotator InitRot,class USkeletalMeshComponent* SkelComp);
    UBOOL WouldConstrainPitch(INT TestPitch,class USkeletalMeshComponent* SkelComp);
    DECLARE_FUNCTION(execInitTurret)
    {
        P_GET_STRUCT(FRotator,InitRot);
        P_GET_OBJECT(USkeletalMeshComponent,SkelComp);
        P_FINISH;
        this->InitTurret(InitRot,SkelComp);
    }
    DECLARE_FUNCTION(execWouldConstrainPitch)
    {
        P_GET_INT(TestPitch);
        P_GET_OBJECT(USkeletalMeshComponent,SkelComp);
        P_FINISH;
        *(UBOOL*)Result=this->WouldConstrainPitch(TestPitch,SkelComp);
    }
    void delegateOnTurretStatusChange(UBOOL bIsMoving)
    {
        UDKSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms Parms(EC_EventParm);
        Parms.bIsMoving=bIsMoving ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(UDKBASE_OnTurretStatusChange,&__OnTurretStatusChange__Delegate,&Parms);
    }
    DECLARE_CLASS(UUDKSkelControl_TurretConstrained,USkelControlSingleBone,0,UDKBase)
	/** handles constraining the passed in local space rotator based on the turret's parameters */
	FRotator GetClampedLocalDesiredRotation(const FRotator& UnclampedLocalDesired);
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UUDKSkelControl_VehicleFlap : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS UDKSkelControl_VehicleFlap
    FLOAT maxPitch;
    FLOAT OldZPitch;
    FLOAT MaxPitchTime;
    FLOAT MaxPitchChange;
    FName RightFlapControl;
    FName LeftFlapControl;
    //## END PROPS UDKSkelControl_VehicleFlap

    DECLARE_CLASS(UUDKSkelControl_VehicleFlap,USkelControlSingleBone,0,UDKBase)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_UDKBASE_ANIMATION_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUDKAnimBlendBase,-1,execGetAnimDuration);
AUTOGENERATE_FUNCTION(UUDKAnimBlendBase,-1,execGetBlendTime);
AUTOGENERATE_FUNCTION(UUDKAnimBlendByFlying,-1,execUpdateFlyingState);
AUTOGENERATE_FUNCTION(UUDKAnimBlendByVehicle,-1,execUpdateVehicleState);
AUTOGENERATE_FUNCTION(UUDKAnimBlendByDriving,-1,execUpdateDrivingState);
AUTOGENERATE_FUNCTION(UUDKAnimNodeFramePlayer,-1,execSetAnimPosition);
AUTOGENERATE_FUNCTION(UUDKAnimNodeFramePlayer,-1,execSetAnimation);
AUTOGENERATE_FUNCTION(UUDKAnimNodeJumpLeanOffset,-1,execSetLeanWeight);
AUTOGENERATE_FUNCTION(UUDKAnimNodeSequence,-1,execPlayAnimationSet);
AUTOGENERATE_FUNCTION(UUDKAnimNodeSequence,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(UUDKSkelControl_MassBoneScaling,-1,execGetBoneScale);
AUTOGENERATE_FUNCTION(UUDKSkelControl_MassBoneScaling,-1,execSetBoneScale);
AUTOGENERATE_FUNCTION(UUDKSkelControl_TurretConstrained,-1,execWouldConstrainPitch);
AUTOGENERATE_FUNCTION(UUDKSkelControl_TurretConstrained,-1,execInitTurret);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UDKBASE_ANIMATION_NATIVE_DEFS
#define UDKBASE_ANIMATION_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_UDKBASE_ANIMATION \
	UUDKAnimBlendBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimBlendBase"), GUDKBaseUUDKAnimBlendBaseNatives); \
	UUDKAnimBlendByFall::StaticClass(); \
	UUDKAnimBlendByHoverJump::StaticClass(); \
	UUDKAnimBlendByFlying::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimBlendByFlying"), GUDKBaseUUDKAnimBlendByFlyingNatives); \
	UUDKAnimBlendByHoverboarding::StaticClass(); \
	UUDKAnimBlendByIdle::StaticClass(); \
	UUDKAnimBlendByPhysics::StaticClass(); \
	UUDKAnimBlendByPhysicsVolume::StaticClass(); \
	UUDKAnimBlendByPosture::StaticClass(); \
	UUDKAnimBlendByTurnInPlace::StaticClass(); \
	UUDKAnimBlendByVehicle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimBlendByVehicle"), GUDKBaseUUDKAnimBlendByVehicleNatives); \
	UUDKAnimBlendByDriving::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimBlendByDriving"), GUDKBaseUUDKAnimBlendByDrivingNatives); \
	UUDKAnimBlendByHoverboardTilt::StaticClass(); \
	UUDKAnimBlendByHoverboardTurn::StaticClass(); \
	UUDKAnimBlendBySlotActive::StaticClass(); \
	UUDKAnimBlendBySpeed::StaticClass(); \
	UUDKAnimBlendByWeapon::StaticClass(); \
	UUDKAnimBlendByWeapType::StaticClass(); \
	UUDKAnimNodeCopyBoneTranslation::StaticClass(); \
	UUDKAnimNodeFramePlayer::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimNodeFramePlayer"), GUDKBaseUUDKAnimNodeFramePlayerNatives); \
	UUDKAnimNodeJumpLeanOffset::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimNodeJumpLeanOffset"), GUDKBaseUUDKAnimNodeJumpLeanOffsetNatives); \
	UUDKAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKAnimNodeSequence"), GUDKBaseUUDKAnimNodeSequenceNatives); \
	UUDKAnimNodeSeqWeap::StaticClass(); \
	UUDKSkelControl_CantileverBeam::StaticClass(); \
	UUDKSkelControl_Damage::StaticClass(); \
	UUDKSkelControl_DamageHinge::StaticClass(); \
	UUDKSkelControl_DamageSpring::StaticClass(); \
	UUDKSkelControl_HoverboardSuspension::StaticClass(); \
	UUDKSkelControl_HoverboardSwing::StaticClass(); \
	UUDKSkelControl_HoverboardVibration::StaticClass(); \
	UUDKSkelControl_HugGround::StaticClass(); \
	UUDKSkelControl_LockRotation::StaticClass(); \
	UUDKSkelControl_LookAt::StaticClass(); \
	UUDKSkelControl_MassBoneScaling::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKSkelControl_MassBoneScaling"), GUDKBaseUUDKSkelControl_MassBoneScalingNatives); \
	UUDKSkelControl_PropellerBlade::StaticClass(); \
	UUDKSkelControl_Rotate::StaticClass(); \
	UUDKSkelControl_SpinControl::StaticClass(); \
	UUDKSkelControl_TurretConstrained::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKSkelControl_TurretConstrained"), GUDKBaseUUDKSkelControl_TurretConstrainedNatives); \
	UUDKSkelControl_VehicleFlap::StaticClass(); \

#endif // UDKBASE_ANIMATION_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GUDKBaseUUDKAnimBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimBlendBase, execGetAnimDuration)
	MAP_NATIVE(UUDKAnimBlendBase, execGetBlendTime)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimBlendByFlyingNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimBlendByFlying, execUpdateFlyingState)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimBlendByVehicleNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimBlendByVehicle, execUpdateVehicleState)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimBlendByDrivingNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimBlendByDriving, execUpdateDrivingState)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimNodeFramePlayerNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimNodeFramePlayer, execSetAnimPosition)
	MAP_NATIVE(UUDKAnimNodeFramePlayer, execSetAnimation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimNodeJumpLeanOffsetNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimNodeJumpLeanOffset, execSetLeanWeight)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UUDKAnimNodeSequence, execPlayAnimationSet)
	MAP_NATIVE(UUDKAnimNodeSequence, execPlayAnimation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKSkelControl_MassBoneScalingNatives[] = 
{ 
	MAP_NATIVE(UUDKSkelControl_MassBoneScaling, execGetBoneScale)
	MAP_NATIVE(UUDKSkelControl_MassBoneScaling, execSetBoneScale)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKSkelControl_TurretConstrainedNatives[] = 
{ 
	MAP_NATIVE(UUDKSkelControl_TurretConstrained, execWouldConstrainPitch)
	MAP_NATIVE(UUDKSkelControl_TurretConstrained, execInitTurret)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendBase,UDKAnimBlendBase,BlendTime)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendBase,UDKAnimBlendBase,ChildBlendTimes)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendBase)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByFall,UDKAnimBlendByFall,PreLandTime)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByFall,UDKAnimBlendByFall,CachedLeanNode)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByFall)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverJump,UDKAnimBlendByHoverJump,OwnerP)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverJump,UDKAnimBlendByHoverJump,OwnerHV)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByHoverJump)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByFlying,UDKAnimBlendByFlying,FlyingState)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByFlying,UDKAnimBlendByFlying,EndingAnimName)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByFlying)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboarding,UDKAnimBlendByHoverboarding,LastActiveChildIndex)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboarding,UDKAnimBlendByHoverboarding,FallTimeBeforeAnim)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByHoverboarding)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByIdle)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByPhysics,UDKAnimBlendByPhysics,PhysicsMap)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByPhysics,UDKAnimBlendByPhysics,PendingTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByPhysics)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByPhysicsVolume,UDKAnimBlendByPhysicsVolume,PhysicsParamList)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByPhysicsVolume,UDKAnimBlendByPhysicsVolume,LastPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByPosture)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByTurnInPlace,UDKAnimBlendByTurnInPlace,RootYawSpeedThresh)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByTurnInPlace,UDKAnimBlendByTurnInPlace,OwnerUTP)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByTurnInPlace)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByVehicle,UDKAnimBlendByVehicle,LastVehicle)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByVehicle)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByDriving)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboardTilt,UDKAnimBlendByHoverboardTilt,UpVector)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboardTilt,UDKAnimBlendByHoverboardTilt,UpperBodyName)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByHoverboardTilt)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboardTurn,UDKAnimBlendByHoverboardTurn,TurnScale)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByHoverboardTurn,UDKAnimBlendByHoverboardTurn,CurrentAnimWeight)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByHoverboardTurn)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendBySlotActive,UDKAnimBlendBySlotActive,ChildSlot)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendBySlotActive)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendBySpeed,UDKAnimBlendBySpeed,MinSpeed)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendBySpeed,UDKAnimBlendBySpeed,MaxSpeed)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByWeapon,UDKAnimBlendByWeapon,LoopingAnim)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimBlendByWeapon,UDKAnimBlendByWeapon,BlendTime)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByWeapon)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimBlendByWeapType)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeCopyBoneTranslation,UDKAnimNodeCopyBoneTranslation,CachedAimNode)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeCopyBoneTranslation,UDKAnimNodeCopyBoneTranslation,WeapTypeBlends)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimNodeCopyBoneTranslation)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimNodeFramePlayer)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeJumpLeanOffset,UDKAnimNodeJumpLeanOffset,JumpLeanStrength)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeJumpLeanOffset,UDKAnimNodeJumpLeanOffset,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimNodeJumpLeanOffset)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeSequence,UDKAnimNodeSequence,SeqStack)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimNodeSequence)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeSeqWeap,UDKAnimNodeSeqWeap,DefaultAnim)
VERIFY_CLASS_OFFSET_NODIE(UUDKAnimNodeSeqWeap,UDKAnimNodeSeqWeap,StingerAnim)
VERIFY_CLASS_SIZE_NODIE(UUDKAnimNodeSeqWeap)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_CantileverBeam,UDKSkelControl_CantileverBeam,WorldSpaceGoal)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_CantileverBeam,UDKSkelControl_CantileverBeam,__EntireBeamVelocity__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_CantileverBeam)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_Damage,UDKSkelControl_Damage,OwnerVehicle)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_Damage,UDKSkelControl_Damage,PS_DeathTrail)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_Damage)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_DamageHinge,UDKSkelControl_DamageHinge,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_DamageHinge,UDKSkelControl_DamageHinge,SpringStiffness)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_DamageHinge)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_DamageSpring,UDKSkelControl_DamageSpring,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_DamageSpring,UDKSkelControl_DamageSpring,MomentumPortion)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_DamageSpring)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardSuspension,UDKSkelControl_HoverboardSuspension,TransIgnore)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardSuspension,UDKSkelControl_HoverboardSuspension,CurrentRot)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_HoverboardSuspension)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardSwing,UDKSkelControl_HoverboardSwing,SwingHistoryWindow)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardSwing,UDKSkelControl_HoverboardSwing,CurrentSwing)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_HoverboardSwing)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardVibration,UDKSkelControl_HoverboardVibration,VibFrequency)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HoverboardVibration,UDKSkelControl_HoverboardVibration,VibInput)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_HoverboardVibration)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HugGround,UDKSkelControl_HugGround,DesiredGroundDist)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_HugGround,UDKSkelControl_HugGround,LastUpdateTime)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_HugGround)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_LockRotation,UDKSkelControl_LockRotation,LockRotation)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_LockRotation,UDKSkelControl_LockRotation,RotationSpaceBoneName)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_LockRotation)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_LookAt,UDKSkelControl_LookAt,YawLimit)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_LookAt,UDKSkelControl_LookAt,RollLimit)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_LookAt)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_MassBoneScaling,UDKSkelControl_MassBoneScaling,BoneScales)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_MassBoneScaling)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_PropellerBlade,UDKSkelControl_PropellerBlade,MaxRotationsPerSecond)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_PropellerBlade,UDKSkelControl_PropellerBlade,DesiredRotationsPerSecond)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_PropellerBlade)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_Rotate,UDKSkelControl_Rotate,DesiredBoneRotation)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_Rotate,UDKSkelControl_Rotate,DesiredBoneRotationRate)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_Rotate)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_SpinControl,UDKSkelControl_SpinControl,DegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_SpinControl,UDKSkelControl_SpinControl,Axis)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_SpinControl)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_TurretConstrained,UDKSkelControl_TurretConstrained,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_TurretConstrained,UDKSkelControl_TurretConstrained,__OnTurretStatusChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_TurretConstrained)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_VehicleFlap,UDKSkelControl_VehicleFlap,maxPitch)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkelControl_VehicleFlap,UDKSkelControl_VehicleFlap,LeftFlapControl)
VERIFY_CLASS_SIZE_NODIE(UUDKSkelControl_VehicleFlap)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
