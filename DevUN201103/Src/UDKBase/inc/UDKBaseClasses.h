/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "UDKBaseNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UDKBASE_ENUMS
#define INCLUDED_UDKBASE_ENUMS 1

enum ECrossfadeType
{
    CFT_BeginningOfMeasure  =0,
    CFT_EndOfMeasure        =1,
    CFT_MAX                 =2,
};
#define FOREACH_ENUM_ECROSSFADETYPE(op) \
    op(CFT_BeginningOfMeasure) \
    op(CFT_EndOfMeasure) 
enum EUTOptionType
{
    UTOT_ComboReadOnly      =0,
    UTOT_ComboNumeric       =1,
    UTOT_CheckBox           =2,
    UTOT_Slider             =3,
    UTOT_Spinner            =4,
    UTOT_EditBox            =5,
    UTOT_CollectionCheckBox =6,
    UTOT_MAX                =7,
};
#define FOREACH_ENUM_EUTOPTIONTYPE(op) \
    op(UTOT_ComboReadOnly) \
    op(UTOT_ComboNumeric) \
    op(UTOT_CheckBox) \
    op(UTOT_Slider) \
    op(UTOT_Spinner) \
    op(UTOT_EditBox) \
    op(UTOT_CollectionCheckBox) 

#endif // !INCLUDED_UDKBASE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_UDKBASE_CLASSES
#define INCLUDED_UDKBASE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UUDKAIDecisionComponent : public UActorComponent
{
public:
    //## BEGIN PROPS UDKAIDecisionComponent
    BITFIELD bTriggered:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKAIDecisionComponent

    DECLARE_CLASS(UUDKAIDecisionComponent,UActorComponent,0,UDKBase)
	virtual void Tick(FLOAT DeltaTime);
};

struct FEnemyPosition
{
    FVector Position;
    FVector Velocity;
    FLOAT Time;

    /** Constructors */
    FEnemyPosition() {}
    FEnemyPosition(EEventParm)
    {
        appMemzero(this, sizeof(FEnemyPosition));
    }
};

struct UDKBot_eventDelayedLeaveVehicle_Parms
{
    UDKBot_eventDelayedLeaveVehicle_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventDelayedWarning_Parms
{
    UDKBot_eventDelayedWarning_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventMissedDodge_Parms
{
    UDKBot_eventMissedDodge_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventAdjustAimError_Parms
{
    FLOAT TargetDist;
    UBOOL bInstantProj;
    FLOAT ReturnValue;
    UDKBot_eventAdjustAimError_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventSuperDesireability_Parms
{
    class APickupFactory* P;
    FLOAT ReturnValue;
    UDKBot_eventSuperDesireability_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventSpecialJumpCost_Parms
{
    FLOAT RequiredJumpZ;
    FLOAT Cost;
    UBOOL ReturnValue;
    UDKBot_eventSpecialJumpCost_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventMayDodgeToMoveTarget_Parms
{
    UDKBot_eventMayDodgeToMoveTarget_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventTimeDJReset_Parms
{
    UDKBot_eventTimeDJReset_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventMonitoredPawnAlert_Parms
{
    UDKBot_eventMonitoredPawnAlert_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventWhatToDoNext_Parms
{
    UDKBot_eventWhatToDoNext_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventReceiveRunOverWarning_Parms
{
    class AUDKVehicle* V;
    FLOAT projSpeed;
    FVector VehicleDir;
    UDKBot_eventReceiveRunOverWarning_Parms(EEventParm)
    {
    }
};
struct UDKBot_eventExecuteWhatToDoNext_Parms
{
    UDKBot_eventExecuteWhatToDoNext_Parms(EEventParm)
    {
    }
};
class AUDKBot : public AAIController
{
public:
    //## BEGIN PROPS UDKBot
    class AUDKSquadAI* Squad;
    class UUDKAIDecisionComponent* DecisionComponent;
    class AActor* TemporaryFocus;
    BITFIELD bExecutingWhatToDoNext:1;
    BITFIELD bScriptSpecialJumpCost:1;
    BITFIELD bForceRefreshRoute:1;
    BITFIELD bTargetAlternateLoc:1;
    BITFIELD bEnemyInfoValid:1;
    BITFIELD bEnemyIsVisible:1;
    BITFIELD bLeadTarget:1;
    BITFIELD bJumpOverWall:1;
    BITFIELD bPlannedJump:1;
    BITFIELD bInDodgeMove:1;
    BITFIELD bEnemyAcquired:1;
    BITFIELD bNeedDelayedLeaveVehicle:1;
    BITFIELD bAllowRouteReuse:1;
    BITFIELD bUsingSquadRoute:1;
    BITFIELD bUsePreviousSquadRoute:1;
    SCRIPT_ALIGN;
    BYTE ScriptedFireMode;
    FLOAT EnemyVisibilityTime;
    class APawn* VisibleEnemy;
    class AVehicle* LastBlockingVehicle;
    class APawn* CurrentlyTrackedEnemy;
    TArrayNoInit<struct FEnemyPosition> SavedPositions;
    FVector ImpactVelocity;
    INT AcquisitionYawRate;
    FLOAT HearingThreshold;
    FLOAT RespawnPredictionTime;
    FLOAT WarningDelay;
    class AProjectile* WarningProjectile;
    FVector MonitorStartLoc;
    class APawn* MonitoredPawn;
    FLOAT MonitorMaxDistSq;
    FVector LastSeenPos;
    FVector LastSeeingPos;
    FLOAT LastSeenTime;
    FLOAT TrackingReactionTime;
    FLOAT BaseTrackingReactionTime;
    FVector TrackedVelocity;
    class ANavigationPoint* SquadRouteGoal;
    class APawn* BlockedAimTarget;
    FLOAT LastIterativeCheck;
    FLOAT AimUpdateFrequency;
    FLOAT LastAimUpdateTime;
    FLOAT ErrorUpdateFrequency;
    FLOAT LastErrorUpdateTime;
    FLOAT CurrentAimError;
    FLOAT DodgeLandZ;
    class AActor* FearSpots[2];
    FLOAT DodgeToGoalPct;
    FLOAT MultiJumpZ;
    //## END PROPS UDKBot

    void WaitToSeeEnemy();
    void LatentWhatToDoNext();
    UBOOL CanMakePathTo(class AActor* A);
    class AActor* FindBestInventoryPath(FLOAT& MinWeight);
    class AActor* FindPathToSquadRoute(UBOOL bWeightDetours=FALSE);
    void BuildSquadRoute();
    virtual class AActor* FindBestSuperPickup(FLOAT MaxDist);
    DECLARE_FUNCTION(execWaitToSeeEnemy)
    {
        P_FINISH;
        this->WaitToSeeEnemy();
    }
    DECLARE_FUNCTION(execLatentWhatToDoNext)
    {
        P_FINISH;
        this->LatentWhatToDoNext();
    }
    DECLARE_FUNCTION(execCanMakePathTo)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=this->CanMakePathTo(A);
    }
    DECLARE_FUNCTION(execFindBestInventoryPath)
    {
        P_GET_FLOAT_REF(MinWeight);
        P_FINISH;
        *(class AActor**)Result=this->FindBestInventoryPath(MinWeight);
    }
    DECLARE_FUNCTION(execFindPathToSquadRoute)
    {
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_FINISH;
        *(class AActor**)Result=this->FindPathToSquadRoute(bWeightDetours);
    }
    DECLARE_FUNCTION(execBuildSquadRoute)
    {
        P_FINISH;
        this->BuildSquadRoute();
    }
    DECLARE_FUNCTION(execFindBestSuperPickup)
    {
        P_GET_FLOAT(MaxDist);
        P_FINISH;
        *(class AActor**)Result=this->FindBestSuperPickup(MaxDist);
    }
    void eventDelayedLeaveVehicle()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_DelayedLeaveVehicle),NULL);
    }
    void eventDelayedWarning()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_DelayedWarning),NULL);
    }
    void eventMissedDodge()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_MissedDodge),NULL);
    }
    FLOAT eventAdjustAimError(FLOAT TargetDist,UBOOL bInstantProj)
    {
        UDKBot_eventAdjustAimError_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TargetDist=TargetDist;
        Parms.bInstantProj=bInstantProj ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_AdjustAimError),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventSuperDesireability(class APickupFactory* P)
    {
        UDKBot_eventSuperDesireability_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(UDKBASE_SuperDesireability),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSpecialJumpCost(FLOAT RequiredJumpZ,FLOAT& Cost)
    {
        UDKBot_eventSpecialJumpCost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.RequiredJumpZ=RequiredJumpZ;
        Parms.Cost=Cost;
        ProcessEvent(FindFunctionChecked(UDKBASE_SpecialJumpCost),&Parms);
        Cost=Parms.Cost;
        return Parms.ReturnValue;
    }
    void eventMayDodgeToMoveTarget()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_MayDodgeToMoveTarget),NULL);
    }
    void eventTimeDJReset()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_TimeDJReset),NULL);
    }
    void eventMonitoredPawnAlert()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_MonitoredPawnAlert),NULL);
    }
    void eventWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_WhatToDoNext),NULL);
    }
    void eventReceiveRunOverWarning(class AUDKVehicle* V,FLOAT projSpeed,FVector VehicleDir)
    {
        UDKBot_eventReceiveRunOverWarning_Parms Parms(EC_EventParm);
        Parms.V=V;
        Parms.projSpeed=projSpeed;
        Parms.VehicleDir=VehicleDir;
        ProcessEvent(FindFunctionChecked(UDKBASE_ReceiveRunOverWarning),&Parms);
    }
    void eventExecuteWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_ExecuteWhatToDoNext),NULL);
    }
    DECLARE_CLASS(AUDKBot,AAIController,0,UDKBase)
	DECLARE_FUNCTION(execPollWaitToSeeEnemy);
	DECLARE_FUNCTION(execPollLatentWhatToDoNext);
	UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	virtual void UpdateEnemyInfo(APawn* AcquiredEnemy);
	virtual void PrePollMove();
	virtual void PostPollMove();
	void CheckFears();
	virtual void PreAirSteering(FLOAT DeltaTime);
	virtual void PostAirSteering(FLOAT DeltaTime);
	virtual void PostPhysFalling(FLOAT DeltaTime);
	virtual UBOOL AirControlFromWall(FLOAT DeltaTime, FVector& RealAcceleration);
	virtual UReachSpec* PrepareForMove(ANavigationPoint *NavGoal, UReachSpec* CurrentPath);
	virtual void AdjustFromWall(FVector HitNormal, AActor* HitActor);
	virtual void JumpOverWall(FVector WallNormal);
	virtual void NotifyJumpApex();
	virtual FRotator SetRotationRate(FLOAT deltaTime);
	virtual DWORD LineOfSightTo(const AActor* Other, INT bUseLOSFlag = 0, const FVector* chkLocation = NULL, UBOOL bTryAlternateTargetLoc = FALSE);
	FLOAT SpecialJumpCost(FLOAT RequiredJumpZ);
	virtual UBOOL ForceReached(ANavigationPoint *Nav, const FVector& TestPosition);
	virtual void UpdatePawnRotation();
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	virtual UBOOL OverridePathTo(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation, UBOOL bWeightDetours, FLOAT& BestWeight);
	virtual void FailMove();

	// Seeing and hearing checks
	virtual UBOOL ShouldCheckVisibilityOf(AController* C);
	virtual DWORD SeePawn(APawn* Other, UBOOL bMaySkipChecks = TRUE);
	virtual UBOOL CanHear(const FVector& NoiseLoc, FLOAT Loudness, AActor *Other);
	virtual void HearNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType);
};

struct UDKCarriedObject_eventOnBaseChainChanged_Parms
{
    UDKCarriedObject_eventOnBaseChainChanged_Parms(EEventParm)
    {
    }
};
struct UDKCarriedObject_eventNotReachableBy_Parms
{
    class APawn* P;
    UDKCarriedObject_eventNotReachableBy_Parms(EEventParm)
    {
    }
};
class AUDKCarriedObject : public AActor
{
public:
    //## BEGIN PROPS UDKCarriedObject
    class ATeamInfo* Team;
    class ANavigationPoint* LastAnchor;
    FLOAT LastValidAnchorTime;
    class USkeletalMeshComponent* SkelMesh;
    BITFIELD bHome:1;
    class AUDKGameObjective* HomeBase;
    FVector HomeBaseOffset;
    class AActor* OldBase;
    class AActor* OldBaseBase;
    FVector HUDLocation;
    //## END PROPS UDKCarriedObject

    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual BYTE GetTeamNum();
    void eventOnBaseChainChanged()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_OnBaseChainChanged),NULL);
    }
    void eventNotReachableBy(class APawn* P)
    {
        UDKCarriedObject_eventNotReachableBy_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(UDKBASE_NotReachableBy),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AUDKCarriedObject,AActor,0,UDKBase)
	/*
	 * Special handling of network replication
	 */
	virtual void PostNetReceiveBase(AActor* NewBase);
	virtual void PostNetReceiveLocation();

	/*
	 * Route finding notifications (sent to target)
	 */
	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder);
	virtual void TickSpecial(FLOAT DeltaSeconds);

	virtual void ForceUpdateComponents(UBOOL bCollisionUpdate = FALSE,UBOOL bTransformOnly = TRUE);
};

class UUDKDataStore_GameSearchBase : public UUIDataStore_OnlineGameSearch
{
public:
    //## BEGIN PROPS UDKDataStore_GameSearchBase
    class UUDKUIDataProvider_ServerDetails* ServerDetailsProvider;
    //## END PROPS UDKDataStore_GameSearchBase

    virtual UBOOL GetEnabledMutators(TArray<INT>& MutatorIndices);
    DECLARE_FUNCTION(execGetEnabledMutators)
    {
        P_GET_TARRAY_REF(INT,MutatorIndices);
        P_FINISH;
        *(UBOOL*)Result=this->GetEnabledMutators(MutatorIndices);
    }
    DECLARE_ABSTRACT_CLASS(UUDKDataStore_GameSearchBase,UUIDataStore_OnlineGameSearch,0|CLASS_Transient,UDKBase)
	/**
	 * Initializes the dataproviders for all of the various character parts.
	 */
	virtual void InitializeDataStore();

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/* === UIListElementProvider === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

   	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );
};

class AUDKEmitCameraEffect : public AEmitter
{
public:
    //## BEGIN PROPS UDKEmitCameraEffect
    FLOAT DistFromCamera;
    class AUDKPlayerController* Cam;
    //## END PROPS UDKEmitCameraEffect

    virtual void UpdateLocation(const FVector& CamLoc,const FRotator& CamRot,FLOAT CamFOVDeg);
    DECLARE_FUNCTION(execUpdateLocation)
    {
        P_GET_STRUCT_REF(FVector,CamLoc);
        P_GET_STRUCT_REF(FRotator,CamRot);
        P_GET_FLOAT(CamFOVDeg);
        P_FINISH;
        this->UpdateLocation(CamLoc,CamRot,CamFOVDeg);
    }
    DECLARE_ABSTRACT_CLASS(AUDKEmitCameraEffect,AEmitter,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(AUDKEmitCameraEffect)
};

struct FAttachedExplosionLight
{
    class UUDKExplosionLight* Light;
    class AActor* Base;
    FVector RelativeLocation;

    /** Constructors */
    FAttachedExplosionLight() {}
    FAttachedExplosionLight(EEventParm)
    {
        appMemzero(this, sizeof(FAttachedExplosionLight));
    }
};

class AUDKEmitterPool : public AEmitterPool
{
public:
    //## BEGIN PROPS UDKEmitterPool
    TArrayNoInit<struct FAttachedExplosionLight> RelativeExplosionLights;
    //## END PROPS UDKEmitterPool

    DECLARE_CLASS(AUDKEmitterPool,AEmitterPool,0|CLASS_Transient|CLASS_Config,UDKBase)
	virtual void TickSpecial(FLOAT DeltaTime);
};

struct FLightValues
{
    FLOAT StartTime;
    FLOAT Radius;
    FLOAT Brightness;
    FColor LightColor;

    /** Constructors */
    FLightValues() {}
    FLightValues(EEventParm)
    {
        appMemzero(this, sizeof(FLightValues));
    }
};

struct UDKExplosionLight_eventOnLightFinished_Parms
{
    class UUDKExplosionLight* Light;
    UDKExplosionLight_eventOnLightFinished_Parms(EEventParm)
    {
    }
};
class UUDKExplosionLight : public UPointLightComponent
{
public:
    //## BEGIN PROPS UDKExplosionLight
    BITFIELD bCheckFrameRate:1;
    BITFIELD bInitialized:1;
    FLOAT HighDetailFrameTime;
    FLOAT Lifetime;
    INT TimeShiftIndex;
    TArrayNoInit<struct FLightValues> TimeShift;
    FScriptDelegate __OnLightFinished__Delegate;
    //## END PROPS UDKExplosionLight

    void ResetLight();
    DECLARE_FUNCTION(execResetLight)
    {
        P_FINISH;
        this->ResetLight();
    }
    void delegateOnLightFinished(class UUDKExplosionLight* Light)
    {
        UDKExplosionLight_eventOnLightFinished_Parms Parms(EC_EventParm);
        Parms.Light=Light;
        ProcessDelegate(UDKBASE_OnLightFinished,&__OnLightFinished__Delegate,&Parms);
    }
    DECLARE_CLASS(UUDKExplosionLight,UPointLightComponent,0,UDKBase)
	virtual void Attach();
	virtual void Tick(FLOAT DeltaTime);
};

class AUDKForcedDirectionVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS UDKForcedDirectionVolume
    class UClass* TypeToForce;
    BITFIELD bIgnoreHoverboards:1;
    BITFIELD bDenyExit:1;
    BITFIELD bBlockPawns:1;
    BITFIELD bBlockSpectators:1;
    class UArrowComponent* Arrow;
    FVector ArrowDirection;
    TArrayNoInit<class AUDKVehicle*> TouchingVehicles;
    //## END PROPS UDKForcedDirectionVolume

    DECLARE_CLASS(AUDKForcedDirectionVolume,APhysicsVolume,0,UDKBase)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	UBOOL IgnoreBlockingBy( const AActor *Other ) const;
	virtual void TickSpecial(FLOAT DeltaSeconds );
};

class AUDKGame : public AFrameworkGame
{
public:
    //## BEGIN PROPS UDKGame
    //## END PROPS UDKGame

    DECLARE_CLASS(AUDKGame,AFrameworkGame,0|CLASS_Config,UDKBase)
	/**
	  *  Initializes the supported game types for a level (its GameTypesSupportedOnThisMap) based on the level filename
	  * and the DefaultMapPrefixes array.  Avoids LDs having to set supported game types up manually (needed for knowing what to cook).
	  */
	virtual void AddSupportedGameTypes(AWorldInfo* Info, const TCHAR* WorldFilename) const;
};

struct UDKGameInteraction_eventBlockUIInput_Parms
{
    UBOOL bBlock;
    UDKGameInteraction_eventBlockUIInput_Parms(EEventParm)
    {
    }
};
struct UDKGameInteraction_eventClearUIInputBlocks_Parms
{
    UDKGameInteraction_eventClearUIInputBlocks_Parms(EEventParm)
    {
    }
};
class UUDKGameInteraction : public UUIInteraction
{
public:
    //## BEGIN PROPS UDKGameInteraction
    INT BlockUIInputSemaphore;
    //## END PROPS UDKGameInteraction

    UBOOL ShouldProcessUIInput() const;
    DECLARE_FUNCTION(execShouldProcessUIInput)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldProcessUIInput();
    }
    void eventBlockUIInput(UBOOL bBlock)
    {
        UDKGameInteraction_eventBlockUIInput_Parms Parms(EC_EventParm);
        Parms.bBlock=bBlock ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_BlockUIInput),&Parms);
    }
    void eventClearUIInputBlocks()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_ClearUIInputBlocks),NULL);
    }
    DECLARE_CLASS(UUDKGameInteraction,UUIInteraction,0|CLASS_Transient|CLASS_Config,UDKBase)
	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);
};

struct UDKGameObjective_eventGetBestViewTarget_Parms
{
    class AActor* ReturnValue;
    UDKGameObjective_eventGetBestViewTarget_Parms(EEventParm)
    {
    }
};
class AUDKGameObjective : public ANavigationPoint
{
public:
    //## BEGIN PROPS UDKGameObjective
    TArrayNoInit<class ANavigationPoint*> ShootSpots;
    BITFIELD bAllowOnlyShootable:1;
    BITFIELD bUnderAttack:1;
    SCRIPT_ALIGN;
    FVector HUDLocation;
    class UTexture2D* IconHudTexture;
    struct FTextureCoordinates IconCoords;
    BYTE DefenderTeamIndex;
    SCRIPT_ALIGN;
    //## END PROPS UDKGameObjective

    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual void DrawIcon(class UCanvas* Canvas,FVector IconLocation,FLOAT IconWidth,FLOAT IconAlpha,class AUDKPlayerController* PlayerOwner,FLinearColor DrawColor);
    virtual BYTE GetTeamNum();
    DECLARE_FUNCTION(execDrawIcon)
    {
        P_GET_OBJECT(UCanvas,Canvas);
        P_GET_STRUCT(FVector,IconLocation);
        P_GET_FLOAT(IconWidth);
        P_GET_FLOAT(IconAlpha);
        P_GET_OBJECT(AUDKPlayerController,PlayerOwner);
        P_GET_STRUCT(FLinearColor,DrawColor);
        P_FINISH;
        this->DrawIcon(Canvas,IconLocation,IconWidth,IconAlpha,PlayerOwner,DrawColor);
    }
    class AActor* eventGetBestViewTarget()
    {
        UDKGameObjective_eventGetBestViewTarget_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(UDKBASE_GetBestViewTarget),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AUDKGameObjective,ANavigationPoint,0|CLASS_NativeReplication,UDKBase)
#if WITH_EDITOR
	virtual void CheckForErrors();
	virtual void SetNetworkID(INT InNetworkID);
#endif
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void AddForcedSpecs(AScout* Scout);
};

class UUDKGameSettingsCommon : public UOnlineGameSettings
{
public:
    //## BEGIN PROPS UDKGameSettingsCommon
    //## END PROPS UDKGameSettingsCommon

    UBOOL StringToBlob(const FString& InString,FString& OutBlob);
    FString BlobToString(const FString& InBlob);
    DECLARE_FUNCTION(execStringToBlob)
    {
        P_GET_STR_REF(InString);
        P_GET_STR_REF(OutBlob);
        P_FINISH;
        *(UBOOL*)Result=this->StringToBlob(InString,OutBlob);
    }
    DECLARE_FUNCTION(execBlobToString)
    {
        P_GET_STR_REF(InBlob);
        P_FINISH;
        *(FString*)Result=this->BlobToString(InBlob);
    }
    DECLARE_CLASS(UUDKGameSettingsCommon,UOnlineGameSettings,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKGameSettingsCommon)
};

class UUDKGameViewportClient : public UGameViewportClient
{
public:
    //## BEGIN PROPS UDKGameViewportClient
    FStringNoInit HintLocFileName;
    //## END PROPS UDKGameViewportClient

    FString LoadRandomLocalizedHintMessage(const FString& Category1Name,const FString& Category2Name);
    DECLARE_FUNCTION(execLoadRandomLocalizedHintMessage)
    {
        P_GET_STR(Category1Name);
        P_GET_STR(Category2Name);
        P_FINISH;
        *(FString*)Result=this->LoadRandomLocalizedHintMessage(Category1Name,Category2Name);
    }
    DECLARE_CLASS(UUDKGameViewportClient,UGameViewportClient,0|CLASS_Transient|CLASS_Config,UDKBase)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UUDKGameViewportClient)
};

class AUDKHUD : public AMobileHUD
{
public:
    //## BEGIN PROPS UDKHUD
    class UFont* GlowFonts[2];
    FLOAT PulseDuration;
    FLOAT PulseSplit;
    FLOAT PulseMultiplier;
    struct FFontRenderInfo TextRenderInfo;
    class UFont* ConsoleIconFont;
    class UFont* BindTextFont;
    //## END PROPS UDKHUD

    virtual void DrawGlowText(const FString& Text,FLOAT X,FLOAT Y,FLOAT MaxHeightInPixels=0.000000,FLOAT PulseTime=-100.000000,UBOOL bRightJustified=FALSE);
    void TranslateBindToFont(const FString& InBindStr,class UFont*& DrawFont,FString& OutBindStr);
    DECLARE_FUNCTION(execDrawGlowText)
    {
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT_OPTX(MaxHeightInPixels,0.000000);
        P_GET_FLOAT_OPTX(PulseTime,-100.000000);
        P_GET_UBOOL_OPTX(bRightJustified,FALSE);
        P_FINISH;
        this->DrawGlowText(Text,X,Y,MaxHeightInPixels,PulseTime,bRightJustified);
    }
    DECLARE_FUNCTION(execTranslateBindToFont)
    {
        P_GET_STR(InBindStr);
        P_GET_OBJECT_REF(UFont,DrawFont);
        P_GET_STR_REF(OutBindStr);
        P_FINISH;
        this->TranslateBindToFont(InBindStr,DrawFont,OutBindStr);
    }
    DECLARE_CLASS(AUDKHUD,AMobileHUD,0|CLASS_Transient|CLASS_Config,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(AUDKHUD)
};

class AUDKJumpPad : public ANavigationPoint
{
public:
    //## BEGIN PROPS UDKJumpPad
    FVector JumpVelocity;
    class APathNode* JumpTarget;
    class USoundCue* JumpSound;
    FLOAT JumpTime;
    FLOAT JumpAirControl;
    class UAudioComponent* JumpAmbientSound;
    //## END PROPS UDKJumpPad

    DECLARE_CLASS(AUDKJumpPad,ANavigationPoint,0,UDKBase)
#if WITH_EDITOR
	virtual void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
#endif
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);
	UBOOL CalculateJumpVelocity(AScout *Scout);
};

struct UDKKActorBreakable_eventOnEncroach_Parms
{
    class AActor* Other;
    UBOOL ReturnValue;
    UDKKActorBreakable_eventOnEncroach_Parms(EEventParm)
    {
    }
};
struct UDKKActorBreakable_eventOnBreakApart_Parms
{
    UDKKActorBreakable_eventOnBreakApart_Parms(EEventParm)
    {
    }
};
class AUDKKActorBreakable : public AKActor
{
public:
    //## BEGIN PROPS UDKKActorBreakable
    BITFIELD bHasHealth:1;
    BITFIELD bDamageOnEncroachment:1;
    BITFIELD bResetDOEWhenAsleep:1;
    BITFIELD bTakeDamageOnEncroachment:1;
    BITFIELD bBreakWhenCausingDamage:1;
    BITFIELD bBroken:1;
    INT Health;
    INT EncroachDamage_Other;
    INT EncroachDamage_Self;
    class UClass* DmgTypeClass;
    INT DOEResetThreshold;
    class UParticleSystem* BrokenTemplate;
    class AController* InstigatorController;
    FScriptDelegate __OnBreakApart__Delegate;
    FScriptDelegate __OnEncroach__Delegate;
    //## END PROPS UDKKActorBreakable

    UBOOL delegateOnEncroach(class AActor* Other)
    {
        UDKKActorBreakable_eventOnEncroach_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Other=Other;
        ProcessDelegate(UDKBASE_OnEncroach,&__OnEncroach__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnBreakApart()
    {
        ProcessDelegate(UDKBASE_OnBreakApart,&__OnBreakApart__Delegate,NULL);
    }
    DECLARE_CLASS(AUDKKActorBreakable,AKActor,0,UDKBase)
	// AActor interface
	virtual void physRigidBody(FLOAT DeltaTime);
};

class UUDKMapInfo : public UMapInfo
{
public:
    //## BEGIN PROPS UDKMapInfo
    FLOAT VisibilityModifier;
    //## END PROPS UDKMapInfo

    DECLARE_CLASS(UUDKMapInfo,UMapInfo,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKMapInfo)
};

struct FMusicSegment
{
    FLOAT TempoOverride;
    BYTE CrossfadeRule;
    INT CrossfadeToMeNumMeasuresDuration;
    class USoundCue* TheCue;

    /** Constructors */
    FMusicSegment() {}
    FMusicSegment(EEventParm)
    {
        appMemzero(this, sizeof(FMusicSegment));
    }
};

struct FStingersForAMap
{
    class USoundCue* Died;
    class USoundCue* DoubleKill;
    class USoundCue* EnemyGrabFlag;
    class USoundCue* FirstKillingSpree;
    class USoundCue* FlagReturned;
    class USoundCue* GrabFlag;
    class USoundCue* Kill;
    class USoundCue* LongKillingSpree;
    class USoundCue* MajorKill;
    class USoundCue* MonsterKill;
    class USoundCue* MultiKill;
    class USoundCue* ReturnFlag;
    class USoundCue* ScoreLosing;
    class USoundCue* ScoreTie;
    class USoundCue* ScoreWinning;

    /** Constructors */
    FStingersForAMap() {}
    FStingersForAMap(EEventParm)
    {
        appMemzero(this, sizeof(FStingersForAMap));
    }
};

struct FMusicForAMap
{
    FLOAT Tempo;
    struct FMusicSegment Action;
    struct FMusicSegment Ambient;
    struct FMusicSegment Intro;
    struct FMusicSegment Suspense;
    struct FMusicSegment Tension;
    struct FMusicSegment Victory;

    /** Constructors */
    FMusicForAMap() {}
    FMusicForAMap(EEventParm)
    {
        appMemzero(this, sizeof(FMusicForAMap));
    }
};

class UUDKMapMusicInfo : public UObject
{
public:
    //## BEGIN PROPS UDKMapMusicInfo
    struct FMusicForAMap MapMusic;
    struct FStingersForAMap MapStingers;
    //## END PROPS UDKMapMusicInfo

    DECLARE_CLASS(UUDKMapMusicInfo,UObject,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKMapMusicInfo)
};

class UUDKParticleSystemComponent : public UParticleSystemComponent
{
public:
    //## BEGIN PROPS UDKParticleSystemComponent
private:
    FLOAT FOV;
    BITFIELD bHasSavedScale3D:1;
    SCRIPT_ALIGN;
    FVector SavedScale3D;
public:
    //## END PROPS UDKParticleSystemComponent

    void SetFOV(FLOAT NewFOV);
    DECLARE_FUNCTION(execSetFOV)
    {
        P_GET_FLOAT(NewFOV);
        P_FINISH;
        this->SetFOV(NewFOV);
    }
    DECLARE_CLASS(UUDKParticleSystemComponent,UParticleSystemComponent,0,UDKBase)
private:
	/** Override LocalToWorld with custom FOV changes */
	virtual void SetTransformedToWorld();
	virtual void InitParticles();
};

struct FMaterialImpactEffect
{
    FName MaterialType;
    class USoundCue* Sound;
    TArrayNoInit<class UMaterialInterface*> DecalMaterials;
    FLOAT DurationOfDecal;
    FName DecalDissolveParamName;
    FLOAT DecalWidth;
    FLOAT DecalHeight;
    class UParticleSystem* ParticleTemplate;

    /** Constructors */
    FMaterialImpactEffect() {}
    FMaterialImpactEffect(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialImpactEffect));
    }
};

struct FMaterialSoundEffect
{
    FName MaterialType;
    class USoundCue* Sound;

    /** Constructors */
    FMaterialSoundEffect() {}
    FMaterialSoundEffect(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialSoundEffect));
    }
};

struct FMaterialParticleEffect
{
    FName MaterialType;
    class UParticleSystem* ParticleTemplate;

    /** Constructors */
    FMaterialParticleEffect() {}
    FMaterialParticleEffect(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialParticleEffect));
    }
};

struct FDistanceBasedParticleTemplate
{
    class UParticleSystem* Template;
    FLOAT MinDistance;

    /** Constructors */
    FDistanceBasedParticleTemplate() {}
    FDistanceBasedParticleTemplate(EEventParm)
    {
        appMemzero(this, sizeof(FDistanceBasedParticleTemplate));
    }
};

struct FPlayEmoteInfo
{
    FName EmoteTag;
    INT EmoteID;
    BITFIELD bNewData:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FPlayEmoteInfo() {}
    FPlayEmoteInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPlayEmoteInfo));
    }
};

struct FUTTakeHitInfo
{
    INT Damage;
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    FName HitBone;

    /** Constructors */
    FUTTakeHitInfo() {}
    FUTTakeHitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FUTTakeHitInfo));
    }
};

struct FEmoteInfo
{
    FName CategoryName;
    FName EmoteTag;
    FStringNoInit EmoteName;
    FName EmoteAnim;
    BITFIELD bVictoryEmote:1;
    BITFIELD bTopHalfEmote:1;
    FName Command;
    BITFIELD bRequiresPlayer:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FEmoteInfo() {}
    FEmoteInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEmoteInfo));
    }
};

struct FDrivenWeaponPawnInfo
{
    class AUDKVehicle* BaseVehicle;
    BYTE SeatIndex;
    class APlayerReplicationInfo* PRI;

    /** Constructors */
    FDrivenWeaponPawnInfo() {}
    FDrivenWeaponPawnInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDrivenWeaponPawnInfo));
    }
};

struct UDKPawn_eventStuckFalling_Parms
{
    UDKPawn_eventStuckFalling_Parms(EEventParm)
    {
    }
};
struct UDKPawn_eventUpdateEyeHeight_Parms
{
    FLOAT DeltaTime;
    UDKPawn_eventUpdateEyeHeight_Parms(EEventParm)
    {
    }
};
struct UDKPawn_eventTakeHitBlendedOut_Parms
{
    UDKPawn_eventTakeHitBlendedOut_Parms(EEventParm)
    {
    }
};
struct UDKPawn_eventStartFeignDeathRecoveryAnim_Parms
{
    UDKPawn_eventStartFeignDeathRecoveryAnim_Parms(EEventParm)
    {
    }
};
struct UDKPawn_eventStoppedFalling_Parms
{
    UDKPawn_eventStoppedFalling_Parms(EEventParm)
    {
    }
};
struct UDKPawn_eventHoldGameObject_Parms
{
    class AUDKCarriedObject* UDKGameObj;
    UDKPawn_eventHoldGameObject_Parms(EEventParm)
    {
    }
};
class AUDKPawn : public AGamePawn
{
public:
    //## BEGIN PROPS UDKPawn
    BITFIELD bReadyToDoubleJump:1;
    BITFIELD bRequiresDoubleJump:1;
    BITFIELD bCanDoubleJump:1;
    BITFIELD bNoJumpAdjust:1;
    BITFIELD bIsHoverboardAnimPawn:1;
    BITFIELD bFeigningDeath:1;
    BITFIELD bNotifyStopFalling:1;
    BITFIELD bIsInvisible:1;
    BITFIELD bSmoothNetUpdates:1;
    BITFIELD bPuttingDownWeapon:1;
    BITFIELD bPlayingFeignDeathRecovery:1;
    BITFIELD bCanPlayFallingImpacts:1;
    BITFIELD bEnableFootPlacement:1;
    BITFIELD bPostRenderOtherTeam:1;
    BITFIELD bBlendOutTakeHitPhysics:1;
    BITFIELD bUpdateEyeheight:1;
    BITFIELD bTearOffGibs:1;
    FLOAT MaxDoubleJumpHeight;
    INT MultiJumpRemaining;
    INT MaxMultiJump;
    INT MultiJumpBoost;
    FLOAT CustomGravityScaling;
    struct FPlayEmoteInfo EmoteRepInfo;
    FLOAT LastEmoteTime;
    FLOAT MinTimeBetweenEmotes;
    BYTE BigTeleportCount;
    BYTE WeaponOverlayFlags;
    SCRIPT_ALIGN;
    struct FUTTakeHitInfo LastTakeHitInfo;
    FLOAT LastTakeHitTimeout;
    FLOAT FireRateMultiplier;
    FLOAT HeadScale;
    FLOAT MaxSmoothNetUpdateDist;
    FLOAT NoSmoothNetUpdateDist;
    FLOAT SmoothNetUpdateTime;
    FVector MeshTranslationOffset;
    FLOAT OldZ;
    class UAudioComponent* PawnAmbientSound;
    class USoundCue* PawnAmbientSoundCue;
    struct FDrivenWeaponPawnInfo DrivenWeaponPawn;
    class UAudioComponent* WeaponAmbientSound;
    class USoundCue* WeaponAmbientSoundCue;
    class UMaterial* ReplicatedBodyMaterial;
    TArrayNoInit<class UMaterialInstanceConstant*> BodyMaterialInstances;
    class UMaterialInterface* OverlayMaterialInstance;
    class USkelControlSingleBone* RootRotControl;
    class UAnimNodeAimOffset* AimNode;
    class UGameSkelCtrl_Recoil* GunRecoilNode;
    class UGameSkelCtrl_Recoil* LeftRecoilNode;
    class UGameSkelCtrl_Recoil* RightRecoilNode;
    TArrayNoInit<class AUDKBot*> Trackers;
    FLOAT BodyMatFadeDuration;
    FLinearColor CurrentBodyMatColor;
    FLOAT RemainingBodyMatDuration;
    FLOAT ClientBodyMatDuration;
    FLinearColor BodyMatColor;
    FRotator CompressedBodyMatColor;
    FLOAT StartFallImpactTime;
    FName TorsoBoneName;
    class USoundCue* FallImpactSound;
    FLOAT FallSpeedThreshold;
    class UStaticMeshComponent* BlobShadow;
    class USkeletalMeshComponent* OverlayMesh;
    FName LeftFootBone;
    FName RightFootBone;
    FName LeftFootControlName;
    FName RightFootControlName;
    FLOAT BaseTranslationOffset;
    FLOAT CrouchTranslationOffset;
    FLOAT OldLocationZ;
    FLOAT ZSmoothingRate;
    FLOAT MaxFootPlacementDistSquared;
    class USkelControlFootPlacement* LeftLegControl;
    class USkelControlFootPlacement* RightLegControl;
    class USkelControlLimb* LeftHandIK;
    class USkelControlLimb* RightHandIK;
    FName DamageParameterName;
    FName SaturationParameterName;
    FLOAT LastPostRenderTraceTime;
    FLOAT TeamBeaconMaxDist;
    FLOAT StartedFallingTime;
    FLOAT SlopeBoostFriction;
    class UAnimNodeAimOffset* FlyingDirOffset;
    INT MaxLeanRoll;
    FLOAT FeignDeathPhysicsBlendOutSpeed;
    FLOAT SwimmingZOffset;
    FLOAT SwimmingZOffsetSpeed;
    FLOAT CrouchMeshZOffset;
    FLOAT TakeHitPhysicsBlendOutSpeed;
    class UUDKSkeletalMeshComponent* ArmsMesh[2];
    INT RootYaw;
    FLOAT RootYawSpeed;
    INT MaxYawAim;
    FVector2D CurrentSkelAim;
    FVector HUDLocation;
    //## END PROPS UDKPawn

    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    virtual void RestorePreRagdollCollisionComponent();
    virtual void EnsureOverlayComponentLast();
    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    virtual UBOOL IsInvisible();
    virtual UBOOL SuggestJumpVelocity(FVector& JumpVelocity,FVector Destination,FVector Start,UBOOL bRequireFallLanding=FALSE);
    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual void NativePostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir);
    DECLARE_FUNCTION(execRestorePreRagdollCollisionComponent)
    {
        P_FINISH;
        this->RestorePreRagdollCollisionComponent();
    }
    DECLARE_FUNCTION(execEnsureOverlayComponentLast)
    {
        P_FINISH;
        this->EnsureOverlayComponentLast();
    }
    void eventStuckFalling()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_StuckFalling),NULL);
    }
    void eventUpdateEyeHeight(FLOAT DeltaTime)
    {
        UDKPawn_eventUpdateEyeHeight_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_UpdateEyeHeight)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(UDKBASE_UpdateEyeHeight),&Parms);
        }
    }
    void eventTakeHitBlendedOut()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_TakeHitBlendedOut),NULL);
    }
    void eventStartFeignDeathRecoveryAnim()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_StartFeignDeathRecoveryAnim),NULL);
    }
    void eventStoppedFalling()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_StoppedFalling),NULL);
    }
    void eventHoldGameObject(class AUDKCarriedObject* UDKGameObj)
    {
        UDKPawn_eventHoldGameObject_Parms Parms(EC_EventParm);
        Parms.UDKGameObj=UDKGameObj;
        ProcessEvent(FindFunctionChecked(UDKBASE_HoldGameObject),&Parms);
    }
    DECLARE_CLASS(AUDKPawn,AGamePawn,0|CLASS_Config|CLASS_NativeReplication,UDKBase)
	virtual UBOOL TryJumpUp(FVector Dir, FVector Destination, DWORD TraceFlags, UBOOL bNoVisibility);
	virtual ETestMoveResult FindJumpUp(FVector Direction, FVector &CurrentPosition);
	virtual INT calcMoveFlags();
 
 	virtual FLOAT DampenNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType=NAME_None );
	void RequestTrackingFor(AUDKBot *Bot);
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual void TickSimulated( FLOAT DeltaSeconds );

	virtual UBOOL SetHighJumpFlag();
	UBOOL UseFootPlacementThisTick();
	void EnableFootPlacement(UBOOL bEnabled);
	void DoFootPlacement(FLOAT DeltaSeconds);
	FLOAT GetGravityZ();
	void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual FVector CalculateSlopeSlide(const FVector& Adjusted, const FCheckResult& Hit);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor* SourceActor, DWORD TraceFlags);
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual void physFalling(FLOAT deltaTime, INT Iterations);

	virtual UBOOL HasAudibleAmbientSound(const FVector& SrcLocation);
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	// camera
	virtual void UpdateEyeHeight(FLOAT DeltaSeconds);
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
	virtual void SmoothCorrection(const FVector& OldLocation);

protected:
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);
};

class AUDKPickupFactory : public APickupFactory
{
public:
    //## BEGIN PROPS UDKPickupFactory
    BITFIELD bIsRespawning:1;
    BITFIELD bPulseBase:1;
    BITFIELD bIsDisabled:1;
    BITFIELD bFloatingPickup:1;
    BITFIELD bRandomStart:1;
    BITFIELD bRotatingPickup:1;
    BITFIELD bUpdatingPickup:1;
    BITFIELD bDoVisibilityFadeIn:1;
    class UStaticMeshComponent* BaseMesh;
    class UMaterialInstanceConstant* BaseMaterialInstance;
    FLinearColor BaseBrightEmissive;
    FLinearColor BaseDimEmissive;
    FLOAT BasePulseRate;
    FLOAT BasePulseTime;
    FLOAT PulseThreshold;
    FLinearColor BaseTargetEmissive;
    FLinearColor BaseEmissive;
    FName BaseMaterialParamName;
    FLOAT BobTimer;
    FLOAT BobOffset;
    FLOAT BobSpeed;
    FLOAT BobBaseOffset;
    FLOAT YawRotationRate;
    FVector PivotTranslation;
    FName VisibilityParamName;
    class UMaterialInstanceConstant* MIC_Visibility;
    class UMaterialInstanceConstant* MIC_VisibilitySecondMaterial;
    class UParticleSystemComponent* Glow;
    FName GlowEmissiveParam;
    class UPrimitiveComponent* Spinner;
    class UUDKParticleSystemComponent* SpinningParticleEffects;
    //## END PROPS UDKPickupFactory

    DECLARE_ABSTRACT_CLASS(AUDKPickupFactory,APickupFactory,0|CLASS_NativeReplication,UDKBase)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual void PostEditMove(UBOOL bFinished);
	virtual void Spawned();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct FObjectiveAnnouncementInfo
{
    class USoundNodeWave* AnnouncementSound;
    FStringNoInit AnnouncementText;

    /** Constructors */
    FObjectiveAnnouncementInfo() {}
    FObjectiveAnnouncementInfo(EEventParm)
    {
        appMemzero(this, sizeof(FObjectiveAnnouncementInfo));
    }
};

class AUDKPlayerController : public AGamePlayerController
{
public:
    //## BEGIN PROPS UDKPlayerController
    class UCameraAnimInst* CameraAnimPlayer;
    class AUDKEmitCameraEffect* CameraEffect;
    BITFIELD bDedicatedServerSpectator:1;
    BITFIELD bAcuteHearing:1;
    BITFIELD bConsolePlayer:1;
    BITFIELD bPulseTeamColor:1;
    BITFIELD bUsePhysicsRotation:1;
    SCRIPT_ALIGN;
    FVector ShakeOffset;
    FRotator ShakeRot;
    struct FPostProcessSettings CamOverridePostProcess;
    struct FPostProcessSettings PostProcessModifier;
    TArrayNoInit<class AActor*> PotentiallyHiddenActors;
    FLOAT VehicleCheckRadiusScaling;
    FLOAT PulseTimer;
    //## END PROPS UDKPlayerController

    virtual void SetGamma(FLOAT GammaValue);
    virtual void SetHardwarePhysicsEnabled(UBOOL bEnabled);
    virtual UBOOL IsKeyboardAvailable() const;
    virtual UBOOL IsMouseAvailable() const;
    virtual class APawn* GetTargetAdhesionFrictionTarget(FLOAT MaxDistance,const FVector& CamLoc,const FRotator& CamRot);
    virtual UBOOL IsControllerTiltActive() const;
    virtual void SetControllerTiltDesiredIfAvailable(UBOOL bActive);
    virtual void SetControllerTiltActive(UBOOL bActive);
    virtual void SetOnlyUseControllerTiltInput(UBOOL bActive);
    virtual void SetUseTiltForwardAndBack(UBOOL bActive);
    DECLARE_FUNCTION(execSetGamma)
    {
        P_GET_FLOAT(GammaValue);
        P_FINISH;
        this->SetGamma(GammaValue);
    }
    DECLARE_FUNCTION(execSetHardwarePhysicsEnabled)
    {
        P_GET_UBOOL(bEnabled);
        P_FINISH;
        this->SetHardwarePhysicsEnabled(bEnabled);
    }
    DECLARE_FUNCTION(execGetTargetAdhesionFrictionTarget)
    {
        P_GET_FLOAT(MaxDistance);
        P_GET_STRUCT_REF(FVector,CamLoc);
        P_GET_STRUCT_REF(FRotator,CamRot);
        P_FINISH;
        *(class APawn**)Result=this->GetTargetAdhesionFrictionTarget(MaxDistance,CamLoc,CamRot);
    }
    DECLARE_CLASS(AUDKPlayerController,AGamePlayerController,0|CLASS_Config,UDKBase)
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	virtual UBOOL HearSound(USoundCue* InSoundCue, AActor* SoundPlayer, const FVector& SoundLocation, UBOOL bStopWhenOwnerDestroyed);
	virtual UBOOL MoveWithInterpMoveTrack(UInterpTrackMove* MoveTrack, UInterpTrackInstMove* MoveInst, FLOAT CurTime, FLOAT DeltaTime);
	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;
	virtual void UpdateHiddenActors(const FVector& ViewLocation);
	virtual void PreSave();

	/**
	 * This will score both Adhesion and Friction targets.  We want the same scoring function as we
	 * don't want the two different systems fighting over targets that are close.
	 **/
	virtual FLOAT ScoreTargetAdhesionFrictionTarget( const APawn* P, FLOAT MaxDistance, const FVector& CamLoc, const FRotator& CamRot ) const;

	/** Determines whether this Pawn can be used for TargetAdhesion **/
	virtual UBOOL IsValidTargetAdhesionFrictionTarget( APawn* P, FLOAT MaxDistance );
};

class UUDKPlayerInput : public UMobilePlayerInput
{
public:
    //## BEGIN PROPS UDKPlayerInput
    //## END PROPS UDKPlayerInput

    virtual FString GetUDKBindNameFromCommand(const FString& BindCommand);
    DECLARE_FUNCTION(execGetUDKBindNameFromCommand)
    {
        P_GET_STR(BindCommand);
        P_FINISH;
        *(FString*)Result=this->GetUDKBindNameFromCommand(BindCommand);
    }
    DECLARE_CLASS(UUDKPlayerInput,UMobilePlayerInput,0|CLASS_Transient|CLASS_Config,UDKBase)
    DECLARE_WITHIN(AUDKPlayerController)
    NO_DEFAULT_CONSTRUCTOR(UUDKPlayerInput)
};

class UUDKProfileSettings : public UOnlineProfileSettings
{
public:
    //## BEGIN PROPS UDKProfileSettings
    //## END PROPS UDKProfileSettings

    virtual void ResetToDefault(INT ProfileId);
    void ResetKeysToDefault(class ULocalPlayer* InPlayerOwner=NULL);
    DECLARE_FUNCTION(execResetToDefault)
    {
        P_GET_INT(ProfileId);
        P_FINISH;
        this->ResetToDefault(ProfileId);
    }
    DECLARE_FUNCTION(execResetKeysToDefault)
    {
        P_GET_OBJECT_OPTX(ULocalPlayer,InPlayerOwner,NULL);
        P_FINISH;
        this->ResetKeysToDefault(InPlayerOwner);
    }
    DECLARE_CLASS(UUDKProfileSettings,UOnlineProfileSettings,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKProfileSettings)
};

struct UDKProjectile_eventCreateProjectileLight_Parms
{
    UDKProjectile_eventCreateProjectileLight_Parms(EEventParm)
    {
    }
};
class AUDKProjectile : public AProjectile
{
public:
    //## BEGIN PROPS UDKProjectile
    BITFIELD bWideCheck:1;
    BITFIELD bShuttingDown:1;
    BITFIELD bCheckProjectileLight:1;
    BITFIELD bNotBlockedByShield:1;
    FLOAT CheckRadius;
    FLOAT AccelRate;
    class AActor* SeekTarget;
    FLOAT BaseTrackingStrength;
    FLOAT HomingTrackingStrength;
    FVector InitialDir;
    FLOAT LastLockWarningTime;
    FLOAT LockWarningInterval;
    FLOAT TerminalVelocity;
    FLOAT Buoyancy;
    FLOAT CustomGravityScaling;
    class AVehicle* InstigatorBaseVehicle;
    //## END PROPS UDKProjectile

    virtual FLOAT GetTerminalVelocity();
    void eventCreateProjectileLight()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_CreateProjectileLight),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AUDKProjectile,AProjectile,0|CLASS_NativeReplication,UDKBase)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual void GetNetBuoyancy(FLOAT &NetBuoyancy, FLOAT &NetFluidFriction);
	virtual FLOAT GetGravityZ();
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

class AUDKScout : public AScout
{
public:
    //## BEGIN PROPS UDKScout
    BITFIELD bRequiresDoubleJump:1;
    FLOAT MaxDoubleJumpHeight;
    class UClass* PrototypePawnClass;
    FName SizePersonFindName;
    //## END PROPS UDKScout

    virtual UBOOL SuggestJumpVelocity(FVector& JumpVelocity,FVector Destination,FVector Start,UBOOL bRequireFallLanding=FALSE);
    DECLARE_CLASS(AUDKScout,AScout,0|CLASS_Transient|CLASS_Config,UDKBase)
	virtual ETestMoveResult FindJumpUp(FVector Direction, FVector &CurrentPosition);
	virtual UBOOL SetHighJumpFlag();
	virtual void SetPrototype();
	virtual ETestMoveResult FindBestJump(FVector Dest, FVector &CurrentPosition);

	virtual void SetPathColor(UReachSpec* ReachSpec)
	{
		FVector CommonSize = GetSize(FName(TEXT("Common"),FNAME_Find));
		if ( ReachSpec->CollisionRadius >= CommonSize.X )
		{
			FVector MaxSize = GetSize(FName(TEXT("Vehicle"),FNAME_Find));
			ReachSpec->PathColorIndex = ( ReachSpec->CollisionRadius >= MaxSize.X ) ? 2 : 1;
		}
		else
		{
			ReachSpec->PathColorIndex = 0;
		}
	}
};

struct UDKScriptedNavigationPoint_eventNotifyAnchorFindingResult_Parms
{
    class ANavigationPoint* EndAnchor;
    class APawn* RouteFinder;
    UDKScriptedNavigationPoint_eventNotifyAnchorFindingResult_Parms(EEventParm)
    {
    }
};
struct UDKScriptedNavigationPoint_eventSpecifyEndAnchor_Parms
{
    class APawn* RouteFinder;
    class ANavigationPoint* ReturnValue;
    UDKScriptedNavigationPoint_eventSpecifyEndAnchor_Parms(EEventParm)
    {
    }
};
class AUDKScriptedNavigationPoint : public ANavigationPoint
{
public:
    //## BEGIN PROPS UDKScriptedNavigationPoint
    BITFIELD bScriptSpecifyEndAnchor:1;
    BITFIELD bScriptNotifyAnchorFindingResult:1;
    BITFIELD bAnchorMustBeReachable:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKScriptedNavigationPoint

    void eventNotifyAnchorFindingResult(class ANavigationPoint* EndAnchor,class APawn* RouteFinder)
    {
        UDKScriptedNavigationPoint_eventNotifyAnchorFindingResult_Parms Parms(EC_EventParm);
        Parms.EndAnchor=EndAnchor;
        Parms.RouteFinder=RouteFinder;
        ProcessEvent(FindFunctionChecked(UDKBASE_NotifyAnchorFindingResult),&Parms);
    }
    class ANavigationPoint* eventSpecifyEndAnchor(class APawn* RouteFinder)
    {
        UDKScriptedNavigationPoint_eventSpecifyEndAnchor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.RouteFinder=RouteFinder;
        ProcessEvent(FindFunctionChecked(UDKBASE_SpecifyEndAnchor),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AUDKScriptedNavigationPoint,ANavigationPoint,0,UDKBase)
	virtual class ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder);
	virtual UBOOL AnchorNeedNotBeReachable();
};

struct UDKSkeletalMeshComponent_eventPreloadTextures_Parms
{
    UBOOL bForcePreload;
    FLOAT ClearTime;
    UDKSkeletalMeshComponent_eventPreloadTextures_Parms(EEventParm)
    {
    }
};
class UUDKSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS UDKSkeletalMeshComponent
    FLOAT FOV;
    BITFIELD bForceLoadTextures:1;
    FLOAT ClearStreamingTime;
    //## END PROPS UDKSkeletalMeshComponent

    void SetFOV(FLOAT NewFOV);
    DECLARE_FUNCTION(execSetFOV)
    {
        P_GET_FLOAT(NewFOV);
        P_FINISH;
        this->SetFOV(NewFOV);
    }
    void eventPreloadTextures(UBOOL bForcePreload,FLOAT ClearTime)
    {
        UDKSkeletalMeshComponent_eventPreloadTextures_Parms Parms(EC_EventParm);
        Parms.bForcePreload=bForcePreload ? FIRST_BITFIELD : FALSE;
        Parms.ClearTime=ClearTime;
        ProcessEvent(FindFunctionChecked(UDKBASE_PreloadTextures),&Parms);
    }
    DECLARE_CLASS(UUDKSkeletalMeshComponent,USkeletalMeshComponent,0|CLASS_Config,UDKBase)
	/** Creates a FUDKSkeletalMeshSceneProxy (defined in UTWeapon.cpp) */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void Tick(FLOAT DeltaTime);
};

class AUDKTeamOwnedInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS UDKTeamOwnedInfo
    class ATeamInfo* Team;
    //## END PROPS UDKTeamOwnedInfo

    virtual BYTE GetTeamNum();
    DECLARE_CLASS(AUDKTeamOwnedInfo,AReplicationInfo,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(AUDKTeamOwnedInfo)
};

struct FAlternateRoute
{
    TArrayNoInit<class ANavigationPoint*> RouteCache;

    /** Constructors */
    FAlternateRoute() {}
    FAlternateRoute(EEventParm)
    {
        appMemzero(this, sizeof(FAlternateRoute));
    }
};

class AUDKSquadAI : public AUDKTeamOwnedInfo
{
public:
    //## BEGIN PROPS UDKSquadAI
    class AUDKGameObjective* SquadObjective;
    class ANavigationPoint* RouteObjective;
    TArrayNoInit<class ANavigationPoint*> ObjectiveRouteCache;
    TArrayNoInit<class ANavigationPoint*> PreviousObjectiveRouteCache;
    class AUDKBot* PendingSquadRouteMaker;
    INT SquadRouteIteration;
    TArrayNoInit<struct FAlternateRoute> SquadRoutes;
    INT MaxSquadRoutes;
    //## END PROPS UDKSquadAI

    DECLARE_CLASS(AUDKSquadAI,AUDKTeamOwnedInfo,0,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(AUDKSquadAI)
};

class AUDKTeamPlayerStart : public APlayerStart
{
public:
    //## BEGIN PROPS UDKTeamPlayerStart
    BYTE TeamNumber;
    TArrayNoInit<class UTexture2D*> TeamSprites;
    //## END PROPS UDKTeamPlayerStart

    DECLARE_CLASS(AUDKTeamPlayerStart,APlayerStart,0,UDKBase)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void Spawned();
};

class AUDKTeleporterBase : public ATeleporter
{
public:
    //## BEGIN PROPS UDKTeleporterBase
    class USceneCaptureComponent* PortalCaptureComponent;
    class UTextureRenderTarget2D* TextureTarget;
    INT TextureResolutionX;
    INT TextureResolutionY;
    class AActor* PortalViewTarget;
    class UMaterialInterface* PortalMaterial;
    class UMaterialInstanceConstant* PortalMaterialInstance;
    FName PortalTextureParameter;
    class USoundCue* TeleportingSound;
    //## END PROPS UDKTeleporterBase

    DECLARE_ABSTRACT_CLASS(AUDKTeleporterBase,ATeleporter,0,UDKBase)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void TickSpecial(FLOAT DeltaTime);
};

class UUDKTrajectoryReachSpec : public UAdvancedReachSpec
{
public:
    //## BEGIN PROPS UDKTrajectoryReachSpec
    //## END PROPS UDKTrajectoryReachSpec

    DECLARE_ABSTRACT_CLASS(UUDKTrajectoryReachSpec,UAdvancedReachSpec,0,UDKBase)
	virtual void AddToDebugRenderProxy(class FDebugRenderSceneProxy* DRSP);
	virtual FVector GetInitialVelocity() { return FVector(0.f,0.f,0.f); };
};

class UUDKJumpPadReachSpec : public UUDKTrajectoryReachSpec
{
public:
    //## BEGIN PROPS UDKJumpPadReachSpec
    //## END PROPS UDKJumpPadReachSpec

    DECLARE_CLASS(UUDKJumpPadReachSpec,UUDKTrajectoryReachSpec,0,UDKBase)
	virtual FVector GetInitialVelocity();
	virtual INT CostFor(APawn* P);
};

class UUDKUIDataProvider_SearchResult : public UUIDataProvider_Settings
{
public:
    //## BEGIN PROPS UDKUIDataProvider_SearchResult
    FName PlayerRatioTag;
    FName GameModeFriendlyNameTag;
    FName ServerFlagsTag;
    FName MapNameTag;
    FStringNoInit IconFontPathName;
    //## END PROPS UDKUIDataProvider_SearchResult

    virtual UBOOL IsPrivateServer();
    DECLARE_FUNCTION(execIsPrivateServer)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPrivateServer();
    }
    DECLARE_CLASS(UUDKUIDataProvider_SearchResult,UUIDataProvider_Settings,0|CLASS_Transient,UDKBase)
	/**
	 * @return	TRUE if server corresponding to this search result allows players to use keyboard & mouse.
	 */
	UBOOL AllowsKeyboardMouse();

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue(const FString& FieldName,FUIProviderFieldValue& out_FieldValue,INT ArrayIndex = INDEX_NONE);

	/**
	 * Builds a list of available fields from the array of properties in the
	 * game settings object
	 *
	 * @param OutFields	out value that receives the list of exposed properties
	 */
	virtual void GetSupportedDataFields(TArray<FUIDataProviderField>& OutFields);

	/**
	 * Gets the list of data fields (and their localized friendly name) for the fields exposed this provider.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the name/friendly name pairs for all data fields in this provider.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );
};

class UUDKUIDataProvider_SimpleElementProvider : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UDKUIDataProvider_SimpleElementProvider
    //## END PROPS UDKUIDataProvider_SimpleElementProvider

    virtual INT GetElementCount();
    DECLARE_FUNCTION(execGetElementCount)
    {
        P_FINISH;
        *(INT*)Result=this->GetElementCount();
    }
    DECLARE_CLASS(UUDKUIDataProvider_SimpleElementProvider,UUIDataProvider,0|CLASS_Transient,UDKBase)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/* === UIDataProvider interface === */
	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Parses the data store reference and resolves it into a value that can be used by the UI.
	 *
	 * @param	MarkupString	a markup string that can be resolved to a data field contained by this data provider, or one of its
	 *							internal data providers.
	 * @param	out_FieldValue	receives the value of the data field resolved from MarkupString.  If the specified property corresponds
	 *							to a value that can be rendered as a string, the field value should be assigned to the StringValue member;
	 *							if the specified property corresponds to a value that can only be rendered as an image, such as an object
	 *							or image reference, the field value should be assigned to the ImageValue member.
	 *							Data stores can optionally manually create a UIStringNode_Text or UIStringNode_Image containing the appropriate
	 *							value, in order to have greater control over how the string node is initialized.  Generally, this is not necessary.
	 *
	 * @return	TRUE if this data store (or one of its internal data providers) successfully resolved the string specified into a data field
	 *			and assigned the value to the out_FieldValue parameter; false if this data store could not resolve the markup string specified.
	 */
	virtual UBOOL GetDataStoreValue( const FString& MarkupString, struct FUIProviderFieldValue& out_FieldValue )
	{
		return GetFieldValue(MarkupString,out_FieldValue);
	}
};

class UUDKUIDataProvider_ServerDetails : public UUDKUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UDKUIDataProvider_ServerDetails
    INT SearchResultsRow;
    //## END PROPS UDKUIDataProvider_ServerDetails

    virtual class UUIDataProvider_Settings* GetSearchResultsProvider();
    virtual INT GetElementCount();
    DECLARE_FUNCTION(execGetSearchResultsProvider)
    {
        P_FINISH;
        *(class UUIDataProvider_Settings**)Result=this->GetSearchResultsProvider();
    }
    DECLARE_CLASS(UUDKUIDataProvider_ServerDetails,UUDKUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UDKBase)
public:
	/**
	 * Determines whether the specified field should be included when the user requests to see a list of this server's details.
	 */
	static UBOOL ShouldDisplayField( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUDKUIDataProvider_StringArray : public UUDKUIDataProvider_SimpleElementProvider
{
public:
    //## BEGIN PROPS UDKUIDataProvider_StringArray
    TArrayNoInit<FString> Strings;
    //## END PROPS UDKUIDataProvider_StringArray

    virtual INT GetElementCount();
    DECLARE_CLASS(UUDKUIDataProvider_StringArray,UUDKUIDataProvider_SimpleElementProvider,0|CLASS_Transient,UDKBase)

public:
	/* === IUIListElementCellProvider interface === */
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

struct UDKUIDataStore_MenuItems_eventInitializeListElementProviders_Parms
{
    UDKUIDataStore_MenuItems_eventInitializeListElementProviders_Parms(EEventParm)
    {
    }
};
class UUDKUIDataStore_MenuItems : public UUIDataStore_GameResource, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UDKUIDataStore_MenuItems
    class UClass* MapInfoDataProviderClass;
    TArrayNoInit<INT> EnabledMutators;
    TArrayNoInit<INT> MapCycle;
    TArrayNoInit<INT> WeaponPriority;
    INT GameModeFilter;
    //## END PROPS UDKUIDataStore_MenuItems

    virtual INT GetProviderCount(FName FieldName) const;
    virtual UBOOL IsProviderFiltered(FName FieldName,INT ProviderIdx);
    void GetAllResourceDataProviders(class UClass* ProviderClass,TArray<class UUDKUIResourceDataProvider*>& Providers);
    virtual INT FindValueInProviderSet(FName ProviderFieldName,FName SearchTag,const FString& SearchValue);
    virtual UBOOL GetValueFromProviderSet(FName ProviderFieldName,FName SearchTag,INT ListIndex,FString& OutValue);
    virtual UBOOL GetProviderSet(FName ProviderFieldName,TArray<class UUDKUIResourceDataProvider*>& OutProviders);
    virtual void RemoveListElementProvidersKey(FName KeyName);
    virtual void AddListElementProvidersKey(FName KeyName,class UUDKUIResourceDataProvider* Provider);
    DECLARE_FUNCTION(execIsProviderFiltered)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(ProviderIdx);
        P_FINISH;
        *(UBOOL*)Result=this->IsProviderFiltered(FieldName,ProviderIdx);
    }
    DECLARE_FUNCTION(execGetAllResourceDataProviders)
    {
        P_GET_OBJECT(UClass,ProviderClass);
        P_GET_TARRAY_REF(class UUDKUIResourceDataProvider*,Providers);
        P_FINISH;
        this->GetAllResourceDataProviders(ProviderClass,Providers);
    }
    DECLARE_FUNCTION(execFindValueInProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_STR(SearchValue);
        P_FINISH;
        *(INT*)Result=this->FindValueInProviderSet(ProviderFieldName,SearchTag,SearchValue);
    }
    DECLARE_FUNCTION(execGetValueFromProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_NAME(SearchTag);
        P_GET_INT(ListIndex);
        P_GET_STR_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetValueFromProviderSet(ProviderFieldName,SearchTag,ListIndex,OutValue);
    }
    DECLARE_FUNCTION(execGetProviderSet)
    {
        P_GET_NAME(ProviderFieldName);
        P_GET_TARRAY_REF(class UUDKUIResourceDataProvider*,OutProviders);
        P_FINISH;
        *(UBOOL*)Result=this->GetProviderSet(ProviderFieldName,OutProviders);
    }
    DECLARE_FUNCTION(execRemoveListElementProvidersKey)
    {
        P_GET_NAME(KeyName);
        P_FINISH;
        this->RemoveListElementProvidersKey(KeyName);
    }
    DECLARE_FUNCTION(execAddListElementProvidersKey)
    {
        P_GET_NAME(KeyName);
        P_GET_OBJECT(UUDKUIResourceDataProvider,Provider);
        P_FINISH;
        this->AddListElementProvidersKey(KeyName,Provider);
    }
    void eventInitializeListElementProviders()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_InitializeListElementProviders),NULL);
    }
    DECLARE_CLASS(UUDKUIDataStore_MenuItems,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UDKBase)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
	/**
	 * Finds or creates the UIResourceDataProvider instances referenced by ElementProviderTypes, and stores the result
	 * into the ListElementProvider map.
	 */
	virtual void InitializeListElementProviders();

protected:
	/**
	 * Sorts the list of map and mutator data providers according to whether they're official or not, then alphabetically.
	 */
	void SortRelevantProviders();

public:

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUDKUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );


// IUIListElement interface

	/**
	 * Returns the names of the exposed members in the first entry in the array
	 * of search results
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param OutCellTags the columns supported by this row
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

};

class UUDKUIDataStore_Options : public UUIDataStore_GameResource
{
public:
    //## BEGIN PROPS UDKUIDataStore_Options
    TMultiMap<FName, class UUDKUIResourceDataProvider*> OptionProviders;
    TArrayNoInit<class UUDKUIResourceDataProvider*> DynamicProviders;
    //## END PROPS UDKUIDataStore_Options

    virtual void ClearSet(FName SetName);
    virtual void AppendToSet(FName SetName,INT NumOptions);
    virtual void GetSet(FName SetName,TArray<class UUDKUIResourceDataProvider*>& OutProviders);
    DECLARE_FUNCTION(execClearSet)
    {
        P_GET_NAME(SetName);
        P_FINISH;
        this->ClearSet(SetName);
    }
    DECLARE_FUNCTION(execAppendToSet)
    {
        P_GET_NAME(SetName);
        P_GET_INT(NumOptions);
        P_FINISH;
        this->AppendToSet(SetName,NumOptions);
    }
    DECLARE_FUNCTION(execGetSet)
    {
        P_GET_NAME(SetName);
        P_GET_TARRAY_REF(class UUDKUIResourceDataProvider*,OutProviders);
        P_FINISH;
        this->GetSet(SetName,OutProviders);
    }
    DECLARE_CLASS(UUDKUIDataStore_Options,UUIDataStore_GameResource,0|CLASS_Transient|CLASS_Config,UDKBase)
	/**
	 * Called when this data store is added to the data store manager's list of active data stores.
	 *
	 * @param	PlayerOwner		the player that will be associated with this DataStore.  Only relevant if this data store is
	 *							associated with a particular player; NULL if this is a global data store.
	 */
	virtual void OnRegister( ULocalPlayer* PlayerOwner );

	/**
	 * Gets the list of element providers for a fieldname with filtered elements removed.
	 *
	 * @param FieldName				Fieldname to use to search for providers.
	 * @param OutElementProviders	Array to store providers in.
	 */
	void GetFilteredElementProviders(FName FieldName, TArray<class UUDKUIResourceDataProvider*> &OutElementProviders);

	/* === IUIListElementProvider interface === */
	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();


	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/* === UIDataProvider interface === */
	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 *
	 * @todo - not yet implemented
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );
};

struct FControllerMap
{
    FName KeyName;
    FStringNoInit XBoxMapping;
    FStringNoInit PS3Mapping;

    /** Constructors */
    FControllerMap() {}
    FControllerMap(EEventParm)
    {
        appMemzero(this, sizeof(FControllerMap));
    }
};

struct FBindCacheElement
{
    FName KeyName;
    FStringNoInit MappingString;
    INT FieldIndex;

    /** Constructors */
    FBindCacheElement() {}
    FBindCacheElement(EEventParm)
    {
        appMemzero(this, sizeof(FBindCacheElement));
    }
};

#define UCONST_SABM_FIND_FIRST_BIND -2

class UUDKUIDataStore_StringAliasBindingMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS UDKUIDataStore_StringAliasBindingMap
    INT FakePlatform;
    TMap<FName, FBindCacheElement> CommandToBindNames;
    TArrayNoInit<struct FControllerMap> ControllerMapArray;
    //## END PROPS UDKUIDataStore_StringAliasBindingMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    virtual INT GetBoundStringWithFieldName(const FString& FieldName,FString& MappedString,INT* StartIndex=NULL,FString* BindString=NULL);
    UBOOL FindMappingInBoundKeyCache(const FString& Command,FString& MappingStr,INT& FieldIndex);
    void AddMappingToBoundKeyCache(const FString& Command,const FString& MappingStr,INT FieldIndex);
    void ClearBoundKeyCache();
    DECLARE_FUNCTION(execGetBoundStringWithFieldName)
    {
        P_GET_STR(FieldName);
        P_GET_STR_REF(MappedString);
        P_GET_INT_OPTX_REF(StartIndex,0);
        P_GET_STR_OPTX_REF(BindString,TEXT(""));
        P_FINISH;
        *(INT*)Result=this->GetBoundStringWithFieldName(FieldName,MappedString,pStartIndex ? &StartIndex : NULL,pBindString ? &BindString : NULL);
    }
    DECLARE_FUNCTION(execFindMappingInBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR_REF(MappingStr);
        P_GET_INT_REF(FieldIndex);
        P_FINISH;
        *(UBOOL*)Result=this->FindMappingInBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execAddMappingToBoundKeyCache)
    {
        P_GET_STR(Command);
        P_GET_STR(MappingStr);
        P_GET_INT(FieldIndex);
        P_FINISH;
        this->AddMappingToBoundKeyCache(Command,MappingStr,FieldIndex);
    }
    DECLARE_FUNCTION(execClearBoundKeyCache)
    {
        P_FINISH;
        this->ClearBoundKeyCache();
    }
    DECLARE_CLASS(UUDKUIDataStore_StringAliasBindingMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKUIDataStore_StringAliasBindingMap)
};

class UUDKUIDataStore_StringAliasMap : public UUIDataStore_StringAliasMap
{
public:
    //## BEGIN PROPS UDKUIDataStore_StringAliasMap
    INT FakePlatform;
    //## END PROPS UDKUIDataStore_StringAliasMap

    virtual INT GetStringWithFieldName(const FString& FieldName,FString& MappedString);
    DECLARE_CLASS(UUDKUIDataStore_StringAliasMap,UUIDataStore_StringAliasMap,0|CLASS_Transient|CLASS_Config,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKUIDataStore_StringAliasMap)
};

struct FEStringListData
{
    FName Tag;
    FStringNoInit ColumnHeaderText;
    FStringNoInit CurrentValue;
    INT DefaultValueIndex;
    TArrayNoInit<FString> Strings;
    class UUDKUIDataProvider_StringArray* DataProvider;

    /** Constructors */
    FEStringListData() {}
    FEStringListData(EEventParm)
    {
        appMemzero(this, sizeof(FEStringListData));
    }
};

#define UCONST_INVALIDFIELD -1

struct UDKUIDataStore_StringList_eventNum_Parms
{
    FName FieldName;
    INT ReturnValue;
    UDKUIDataStore_StringList_eventNum_Parms(EEventParm)
    {
    }
};
struct UDKUIDataStore_StringList_eventSetCurrentValueIndex_Parms
{
    FName FieldName;
    INT NewValueIndex;
    INT ReturnValue;
    UDKUIDataStore_StringList_eventSetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UDKUIDataStore_StringList_eventGetCurrentValueIndex_Parms
{
    FName FieldName;
    INT ReturnValue;
    UDKUIDataStore_StringList_eventGetCurrentValueIndex_Parms(EEventParm)
    {
    }
};
struct UDKUIDataStore_StringList_eventGetCurrentValue_Parms
{
    FName FieldName;
    FString out_Value;
    UBOOL ReturnValue;
    UDKUIDataStore_StringList_eventGetCurrentValue_Parms(EEventParm)
    {
    }
};
class UUDKUIDataStore_StringList : public UUIDataStore_StringBase, public IUIListElementProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UDKUIDataStore_StringList
    TArrayNoInit<struct FEStringListData> StringData;
    //## END PROPS UDKUIDataStore_StringList

    virtual INT GetFieldIndex(FName FieldName);
    virtual void AddStr(FName FieldName,const FString& NewString,UBOOL bBatchOp=FALSE);
    virtual void InsertStr(FName FieldName,const FString& NewString,INT InsertIndex,UBOOL bBatchOp=FALSE);
    virtual void RemoveStr(FName FieldName,const FString& StringToRemove,UBOOL bBatchOp=FALSE);
    virtual void RemoveStrByIndex(FName FieldName,INT Index,INT Count=1,UBOOL bBatchOp=FALSE);
    virtual void Empty(FName FieldName,UBOOL bBatchOp=FALSE);
    virtual INT FindStr(FName FieldName,const FString& SearchString);
    virtual FString GetStr(FName FieldName,INT StrIndex);
    virtual TArray<FString> GetList(FName FieldName);
    DECLARE_FUNCTION(execGetFieldIndex)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(INT*)Result=this->GetFieldIndex(FieldName);
    }
    DECLARE_FUNCTION(execAddStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        this->AddStr(FieldName,NewString,bBatchOp);
    }
    DECLARE_FUNCTION(execInsertStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(NewString);
        P_GET_INT(InsertIndex);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        this->InsertStr(FieldName,NewString,InsertIndex,bBatchOp);
    }
    DECLARE_FUNCTION(execRemoveStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(StringToRemove);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        this->RemoveStr(FieldName,StringToRemove,bBatchOp);
    }
    DECLARE_FUNCTION(execRemoveStrByIndex)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(Index);
        P_GET_INT_OPTX(Count,1);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        this->RemoveStrByIndex(FieldName,Index,Count,bBatchOp);
    }
    DECLARE_FUNCTION(execEmpty)
    {
        P_GET_NAME(FieldName);
        P_GET_UBOOL_OPTX(bBatchOp,FALSE);
        P_FINISH;
        this->Empty(FieldName,bBatchOp);
    }
    DECLARE_FUNCTION(execFindStr)
    {
        P_GET_NAME(FieldName);
        P_GET_STR(SearchString);
        P_FINISH;
        *(INT*)Result=this->FindStr(FieldName,SearchString);
    }
    DECLARE_FUNCTION(execGetStr)
    {
        P_GET_NAME(FieldName);
        P_GET_INT(StrIndex);
        P_FINISH;
        *(FString*)Result=this->GetStr(FieldName,StrIndex);
    }
    DECLARE_FUNCTION(execGetList)
    {
        P_GET_NAME(FieldName);
        P_FINISH;
        *(TArray<FString>*)Result=this->GetList(FieldName);
    }
    INT eventNum(FName FieldName)
    {
        UDKUIDataStore_StringList_eventNum_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UDKBASE_Num),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSetCurrentValueIndex(FName FieldName,INT NewValueIndex)
    {
        UDKUIDataStore_StringList_eventSetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        Parms.NewValueIndex=NewValueIndex;
        ProcessEvent(FindFunctionChecked(UDKBASE_SetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    INT eventGetCurrentValueIndex(FName FieldName)
    {
        UDKUIDataStore_StringList_eventGetCurrentValueIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.FieldName=FieldName;
        ProcessEvent(FindFunctionChecked(UDKBASE_GetCurrentValueIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGetCurrentValue(FName FieldName,FString& out_Value)
    {
        UDKUIDataStore_StringList_eventGetCurrentValue_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.FieldName=FieldName;
        Parms.out_Value=out_Value;
        ProcessEvent(FindFunctionChecked(UDKBASE_GetCurrentValue),&Parms);
        out_Value=Parms.out_Value;
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUDKUIDataStore_StringList,UUIDataStore_StringBase,0|CLASS_Transient|CLASS_Config,UDKBase)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === UIListElementProvider === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data field that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

   	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );


/* === UIListElementCellProvider === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element, along with the human-readable,
	 * localized string that should be used in the header for each cell tag (in lists which have column headers enabled).
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( FName FieldName, const FName& CellTag, BYTE& out_CellFieldType );

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( FName FieldName, const FName& CellTag, INT ListIndex, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );



/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Adds a new field to the list
	 *
	 * @param	FieldName		the data field to resolve the value for
	 * @param	NewString		The first string to add.
	 * @param bBatchOp		if TRUE, doesn't call RefreshSubscribers()
	 */
	virtual INT AddNewField(FName FieldName, const FString &NewString, UBOOL bBatchOp=FALSE);


};

struct UDKUIResourceDataProvider_eventShouldBeFiltered_Parms
{
    UBOOL ReturnValue;
    UDKUIResourceDataProvider_eventShouldBeFiltered_Parms(EEventParm)
    {
    }
};
class UUDKUIResourceDataProvider : public UUIResourceDataProvider
{
public:
    //## BEGIN PROPS UDKUIResourceDataProvider
    FStringNoInit FriendlyName;
    BITFIELD bSearchAllInis:1;
    BITFIELD bRemoveOn360:1;
    BITFIELD bRemoveOnPC:1;
    BITFIELD bRemoveOnPS3:1;
    FStringNoInit IniName;
    //## END PROPS UDKUIResourceDataProvider

    virtual UBOOL IsFiltered();
    DECLARE_FUNCTION(execIsFiltered)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsFiltered();
    }
    UBOOL eventShouldBeFiltered()
    {
        UDKUIResourceDataProvider_eventShouldBeFiltered_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_ShouldBeFiltered),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUDKUIResourceDataProvider,UUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UDKBase)
	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	FieldName		the name of the field the desired cell tags are associated with.  Used for cases where a single data provider
	 *							instance provides element cells for multiple collection data fields.
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( FName FieldName, TMap<FName,FString>& out_CellTags )
	{
		Super::GetElementCellTags(FieldName,out_CellTags);
	}
};

class UUDKUIDataProvider_MapInfo : public UUDKUIResourceDataProvider
{
public:
    //## BEGIN PROPS UDKUIDataProvider_MapInfo
    INT MapId;
    FStringNoInit MapName;
    FStringNoInit NumPlayers;
    FStringNoInit Description;
    FStringNoInit PreviewImageMarkup;
    //## END PROPS UDKUIDataProvider_MapInfo

    DECLARE_CLASS(UUDKUIDataProvider_MapInfo,UUDKUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UDKBase)
    NO_DEFAULT_CONSTRUCTOR(UUDKUIDataProvider_MapInfo)
};

class UUDKUIDataProvider_MenuOption : public UUDKUIResourceDataProvider
{
public:
    //## BEGIN PROPS UDKUIDataProvider_MenuOption
    BYTE OptionType;
    TArrayNoInit<FName> OptionSet;
    FStringNoInit DataStoreMarkup;
    FName RequiredGameMode;
    FStringNoInit CustomFriendlyName;
    FStringNoInit Description;
    BITFIELD bEditableCombo:1;
    BITFIELD bNumericCombo:1;
    BITFIELD bKeyboardOrMouseOption:1;
    BITFIELD bOnlineOnly:1;
    BITFIELD bOfflineOnly:1;
    INT EditBoxMaxLength;
    struct FUIRangeData RangeData;
    //## END PROPS UDKUIDataProvider_MenuOption

    DECLARE_CLASS(UUDKUIDataProvider_MenuOption,UUDKUIResourceDataProvider,0|CLASS_Transient|CLASS_Config,UDKBase)
	/** @return 	TRUE if this menu option's configuration isn't compatible with the desired game settings  */
	virtual UBOOL IsFiltered();
};

struct UDKVehicleBase_eventHoldGameObject_Parms
{
    class AUDKCarriedObject* GameObj;
    UDKVehicleBase_eventHoldGameObject_Parms(EEventParm)
    {
    }
};
class AUDKVehicleBase : public ASVehicle
{
public:
    //## BEGIN PROPS UDKVehicleBase
    BITFIELD bShouldEject:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKVehicleBase

    void eventHoldGameObject(class AUDKCarriedObject* GameObj)
    {
        UDKVehicleBase_eventHoldGameObject_Parms Parms(EC_EventParm);
        Parms.GameObj=GameObj;
        ProcessEvent(FindFunctionChecked(UDKBASE_HoldGameObject),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AUDKVehicleBase,ASVehicle,0|CLASS_Config,UDKBase)
	virtual UBOOL ReachedDesiredRotation();
};

struct FBurnOutDatum
{
    class UMaterialInstanceTimeVarying* MITV;
    FLOAT CurrValue;

    /** Constructors */
    FBurnOutDatum() {}
    FBurnOutDatum(EEventParm)
    {
        appMemzero(this, sizeof(FBurnOutDatum));
    }
};

struct FWeaponEffectInfo
{
    FName SocketName;
    FVector Offset;
    FVector Scale3D;
    class UStaticMeshComponent* Effect;

    /** Constructors */
    FWeaponEffectInfo() {}
    FWeaponEffectInfo(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponEffectInfo));
    }
};

struct FVehicleSeat
{
    class APawn* StoragePawn;
    class AVehicle* SeatPawn;
    class UClass* GunClass;
    class AUDKWeapon* Gun;
    TArrayNoInit<FName> GunSocket;
    TArrayNoInit<FName> GunPivotPoints;
    INT BarrelIndex;
    FStringNoInit TurretVarPrefix;
    TArrayNoInit<struct FWeaponEffectInfo> WeaponEffects;
    FName WeaponRotationName;
    FName FlashLocationName;
    FName FlashCountName;
    FName FiringModeName;
    FPointer WeaponRotationProperty;
    FPointer FlashLocationProperty;
    FPointer FlashCountProperty;
    FPointer FiringModeProperty;
    FRotator LastWeaponRotation;
    TArrayNoInit<FName> TurretControls;
    TArrayNoInit<class UUDKSkelControl_TurretConstrained*> TurretControllers;
    FVector AimPoint;
    class AActor* AimTarget;
    FLOAT PivotFireOffsetZ;
    BITFIELD bDisableOffsetZAdjust:1;
    FName CameraTag;
    FVector CameraBaseOffset;
    FVector CameraSafeOffset;
    FLOAT CameraOffset;
    FLOAT CameraEyeHeight;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    BITFIELD bSeatVisible:1;
    FName SeatBone;
    FVector SeatOffset;
    FRotator SeatRotation;
    FName SeatSocket;
    class UClass* MuzzleFlashLightClass;
    class UUDKExplosionLight* MuzzleFlashLight;
    class UClass* ImpactFlashLightClass;
    FLOAT DriverDamageMult;
    class UAudioComponent* SeatMotionAudio;
    class AUDKVehicleMovementEffect* SeatMovementEffect;
    FVector2D SeatIconPOS;

    /** Constructors */
    FVehicleSeat() {}
    FVehicleSeat(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleSeat));
    }
};

struct FVehicleAnim
{
    FName AnimTag;
    TArrayNoInit<FName> AnimSeqs;
    FLOAT AnimRate;
    BITFIELD bAnimLoopLastSeq:1;
    FName AnimPlayerName;

    /** Constructors */
    FVehicleAnim() {}
    FVehicleAnim(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleAnim));
    }
};

struct FVehicleSound
{
    FName SoundStartTag;
    FName SoundEndTag;
    class USoundCue* SoundTemplate;
    class UAudioComponent* SoundRef;

    /** Constructors */
    FVehicleSound() {}
    FVehicleSound(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleSound));
    }
};

struct FFDamageMorphTargets
{
    FName MorphNodeName;
    class UMorphNodeWeight* MorphNode;
    FName LinkedMorphNodeName;
    INT LinkedMorphNodeIndex;
    FName InfluenceBone;
    INT Health;
    TArrayNoInit<FName> DamagePropNames;

    /** Constructors */
    FFDamageMorphTargets() {}
    FFDamageMorphTargets(EEventParm)
    {
        appMemzero(this, sizeof(FFDamageMorphTargets));
    }
};

struct FDamageParamScales
{
    FName DamageParamName;
    FLOAT Scale;

    /** Constructors */
    FDamageParamScales() {}
    FDamageParamScales(EEventParm)
    {
        appMemzero(this, sizeof(FDamageParamScales));
    }
};

struct FVehicleEffect
{
    FName EffectStartTag;
    FName EffectEndTag;
    BITFIELD bRestartRunning:1;
    BITFIELD bHighDetailOnly:1;
    class UParticleSystem* EffectTemplate;
    class UParticleSystem* EffectTemplate_Blue;
    FName EffectSocket;
    class UParticleSystemComponent* EffectRef;

    /** Constructors */
    FVehicleEffect() {}
    FVehicleEffect(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleEffect));
    }
};

struct UDKVehicle_eventUpdateHoverboardDustEffect_Parms
{
    FLOAT DustHeight;
    UDKVehicle_eventUpdateHoverboardDustEffect_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventPostInitRigidBody_Parms
{
    class UPrimitiveComponent* PrimComp;
    UDKVehicle_eventPostInitRigidBody_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventTakeFireDamage_Parms
{
    UDKVehicle_eventTakeFireDamage_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventCheckReset_Parms
{
    UDKVehicle_eventCheckReset_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventTakeWaterDamage_Parms
{
    UDKVehicle_eventTakeWaterDamage_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventRBPenetrationDestroy_Parms
{
    UDKVehicle_eventRBPenetrationDestroy_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventMorphTargetDestroyed_Parms
{
    INT MorphNodeIndex;
    UDKVehicle_eventMorphTargetDestroyed_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventSelfDestruct_Parms
{
    class AActor* ImpactedActor;
    UDKVehicle_eventSelfDestruct_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventJumpOutCheck_Parms
{
    UDKVehicle_eventJumpOutCheck_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventReceivedHealthChange_Parms
{
    UDKVehicle_eventReceivedHealthChange_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventPlayTakeHitEffects_Parms
{
    UDKVehicle_eventPlayTakeHitEffects_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventOnPropertyChange_Parms
{
    FName PropName;
    UDKVehicle_eventOnPropertyChange_Parms(EEventParm)
    {
    }
};
struct UDKVehicle_eventLockOnWarning_Parms
{
    class AUDKProjectile* IncomingMissile;
    UDKVehicle_eventLockOnWarning_Parms(EEventParm)
    {
    }
};
class AUDKVehicle : public AUDKVehicleBase
{
public:
    //## BEGIN PROPS UDKVehicle
    BITFIELD bEjectKilledBodies:1;
    BITFIELD bHomingTarget:1;
    BITFIELD bFrontalCollision:1;
    BITFIELD bFrontalCollisionWithFixed:1;
    BITFIELD bNoZDampingInAir:1;
    BITFIELD bNoZDamping:1;
    BITFIELD bIsDisabled:1;
    BITFIELD bIsBurning:1;
    BITFIELD bEjectPassengersWhenFlipped:1;
    BITFIELD bIsScraping:1;
    BITFIELD bTakeWaterDamageWhileDriving:1;
    BITFIELD bIsInDestroyablePenetration:1;
    BITFIELD bDeadVehicle:1;
    BITFIELD bJostleWhileDriving:1;
    BITFIELD bFloatWhenDriven:1;
    BITFIELD bAllowedExit:1;
    BITFIELD bUseAlternatePaths:1;
    BITFIELD bShowLocked:1;
    BITFIELD bTeamLocked:1;
    BITFIELD bDisableRepulsorsAtMaxFallSpeed:1;
    BITFIELD bTrickJumping:1;
    BITFIELD bGrab1:1;
    BITFIELD bGrab2:1;
    BITFIELD bForceSpinWarmup:1;
    FLOAT RemainingBurn;
    TArrayNoInit<struct FBurnOutDatum> BurnOutMaterialInstances;
    class UAudioComponent* TireAudioComp;
    TArrayNoInit<struct FMaterialSoundEffect> TireSoundList;
    FName CurrentTireMaterial;
    FLOAT MaxWheelEffectDistSq;
    TArrayNoInit<struct FMaterialParticleEffect> WheelParticleEffects;
    FLOAT LastCheckUpsideDownTime;
    FLOAT FlippedCount;
    class UAudioComponent* ScrapeSound;
    FLOAT FireDamageThreshold;
    FLOAT FireDamagePerSec;
    FLOAT AccruedFireDamage;
    FLOAT UpsideDownDamagePerSec;
    FLOAT OccupiedUpsideDownDamagePerSec;
    FLOAT WaterDamage;
    FLOAT AccumulatedWaterDamage;
    TArrayNoInit<INT> GroundEffectIndices;
    FLOAT MaxGroundEffectDist;
    FName GroundEffectDistParameterName;
    class UParticleSystem* WaterGroundEffect;
    FRotator WeaponRotation;
    TArrayNoInit<struct FVehicleSeat> Seats;
    INT SeatMask;
    TArrayNoInit<struct FVehicleAnim> VehicleAnims;
    TArrayNoInit<struct FVehicleSound> VehicleSounds;
    FName DrivingAnim;
    FLOAT DestroyOnPenetrationThreshold;
    FLOAT DestroyOnPenetrationDuration;
    FLOAT TimeInDestroyablePenetration;
    FLOAT LastDeathImpactTime;
    class USoundCue* LargeChunkImpactSound;
    class USoundCue* MediumChunkImpactSound;
    class USoundCue* SmallChunkImpactSound;
    FLOAT CustomGravityScaling;
    TArrayNoInit<struct FDamageParamScales> DamageParamScaleLevels;
    TArrayNoInit<class UUDKSkelControl_Damage*> DamageSkelControls;
    TArrayNoInit<struct FFDamageMorphTargets> DamageMorphTargets;
    class UMaterialInstanceConstant* DamageMaterialInstance[2];
    struct FUTTakeHitInfo LastTakeHitInfo;
    FLOAT LastTakeHitTimeout;
    TArrayNoInit<struct FVehicleEffect> VehicleEffects;
    class AController* KillerController;
    FLOAT LastJumpOutCheck;
    FName WaterEffectType;
    TArrayNoInit<INT> ContrailEffectIndices;
    FName ContrailColorParameterName;
    FLOAT ObjectiveGetOutDist;
    TArrayNoInit<class AUDKBot*> Trackers;
    BYTE Team;
    FLOAT ExtraReachDownThreshold;
    FLOAT ResetTime;
    FLOAT MinRunOverSpeed;
    FLOAT LastRunOverWarningTime;
    FLOAT MinRunOverWarningAim;
    FLOAT TeamBeaconMaxDist;
    FLOAT LastPostRenderTraceTime;
    FLOAT ShowLockedMaxDist;
    FVector HUDLocation;
    class UParticleSystemComponent* HoverboardDust;
    //## END PROPS UDKVehicle

    virtual FRotator SeatWeaponRotation(INT SeatIndex,FRotator NewRot=FRotator(EC_EventParm),UBOOL bReadValue=FALSE);
    virtual FVector SeatFlashLocation(INT SeatIndex,FVector NewLoc=FVector(EC_EventParm),UBOOL bReadValue=FALSE);
    virtual BYTE SeatFlashCount(INT SeatIndex,BYTE NewCount=0,UBOOL bReadValue=FALSE);
    virtual BYTE SeatFiringMode(INT SeatIndex,BYTE NewFireMode=0,UBOOL bReadValue=FALSE);
    virtual void ForceWeaponRotation(INT SeatIndex,FRotator NewRotation);
    virtual FVector GetSeatPivotPoint(INT SeatIndex);
    virtual INT GetBarrelIndex(INT SeatIndex);
    virtual FLOAT GetGravityZ();
    virtual FLOAT GetMaxRiseForce();
    virtual UBOOL CheckAutoDestruct(class ATeamInfo* InstigatorTeam,FLOAT CheckRadius);
    virtual BYTE GetTeamNum();
    virtual void NativePostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir);
    virtual UBOOL InUseableRange(class AUDKPlayerController* PC,FLOAT Dist);
    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual void InitDamageSkel();
    virtual void UpdateDamageMaterial();
    virtual void ApplyMorphDamage(FVector HitLocation,INT Damage,FVector Momentum);
    DECLARE_FUNCTION(execSeatWeaponRotation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT_OPTX(FRotator,NewRot,FRotator(EC_EventParm));
        P_GET_UBOOL_OPTX(bReadValue,FALSE);
        P_FINISH;
        *(FRotator*)Result=this->SeatWeaponRotation(SeatIndex,NewRot,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFlashLocation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT_OPTX(FVector,NewLoc,FVector(EC_EventParm));
        P_GET_UBOOL_OPTX(bReadValue,FALSE);
        P_FINISH;
        *(FVector*)Result=this->SeatFlashLocation(SeatIndex,NewLoc,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFlashCount)
    {
        P_GET_INT(SeatIndex);
        P_GET_BYTE_OPTX(NewCount,0);
        P_GET_UBOOL_OPTX(bReadValue,FALSE);
        P_FINISH;
        *(BYTE*)Result=this->SeatFlashCount(SeatIndex,NewCount,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFiringMode)
    {
        P_GET_INT(SeatIndex);
        P_GET_BYTE_OPTX(NewFireMode,0);
        P_GET_UBOOL_OPTX(bReadValue,FALSE);
        P_FINISH;
        *(BYTE*)Result=this->SeatFiringMode(SeatIndex,NewFireMode,bReadValue);
    }
    DECLARE_FUNCTION(execForceWeaponRotation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        this->ForceWeaponRotation(SeatIndex,NewRotation);
    }
    DECLARE_FUNCTION(execGetSeatPivotPoint)
    {
        P_GET_INT(SeatIndex);
        P_FINISH;
        *(FVector*)Result=this->GetSeatPivotPoint(SeatIndex);
    }
    DECLARE_FUNCTION(execGetBarrelIndex)
    {
        P_GET_INT(SeatIndex);
        P_FINISH;
        *(INT*)Result=this->GetBarrelIndex(SeatIndex);
    }
    DECLARE_FUNCTION(execIsSeatControllerReplicationViewer);
    DECLARE_FUNCTION(execCheckAutoDestruct)
    {
        P_GET_OBJECT(ATeamInfo,InstigatorTeam);
        P_GET_FLOAT(CheckRadius);
        P_FINISH;
        *(UBOOL*)Result=this->CheckAutoDestruct(InstigatorTeam,CheckRadius);
    }
    DECLARE_FUNCTION(execInUseableRange)
    {
        P_GET_OBJECT(AUDKPlayerController,PC);
        P_GET_FLOAT(Dist);
        P_FINISH;
        *(UBOOL*)Result=this->InUseableRange(PC,Dist);
    }
    DECLARE_FUNCTION(execInitDamageSkel)
    {
        P_FINISH;
        this->InitDamageSkel();
    }
    DECLARE_FUNCTION(execUpdateDamageMaterial)
    {
        P_FINISH;
        this->UpdateDamageMaterial();
    }
    DECLARE_FUNCTION(execApplyMorphDamage)
    {
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_INT(Damage);
        P_GET_STRUCT(FVector,Momentum);
        P_FINISH;
        this->ApplyMorphDamage(HitLocation,Damage,Momentum);
    }
    void eventUpdateHoverboardDustEffect(FLOAT DustHeight)
    {
        UDKVehicle_eventUpdateHoverboardDustEffect_Parms Parms(EC_EventParm);
        Parms.DustHeight=DustHeight;
        ProcessEvent(FindFunctionChecked(UDKBASE_UpdateHoverboardDustEffect),&Parms);
    }
    void eventPostInitRigidBody(class UPrimitiveComponent* PrimComp)
    {
        UDKVehicle_eventPostInitRigidBody_Parms Parms(EC_EventParm);
        Parms.PrimComp=PrimComp;
        ProcessEvent(FindFunctionChecked(UDKBASE_PostInitRigidBody),&Parms);
    }
    void eventTakeFireDamage()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_TakeFireDamage),NULL);
    }
    void eventCheckReset()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_CheckReset),NULL);
    }
    void eventTakeWaterDamage()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_TakeWaterDamage),NULL);
    }
    void eventRBPenetrationDestroy()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_RBPenetrationDestroy),NULL);
    }
    void eventMorphTargetDestroyed(INT MorphNodeIndex)
    {
        UDKVehicle_eventMorphTargetDestroyed_Parms Parms(EC_EventParm);
        Parms.MorphNodeIndex=MorphNodeIndex;
        ProcessEvent(FindFunctionChecked(UDKBASE_MorphTargetDestroyed),&Parms);
    }
    void eventSelfDestruct(class AActor* ImpactedActor)
    {
        UDKVehicle_eventSelfDestruct_Parms Parms(EC_EventParm);
        Parms.ImpactedActor=ImpactedActor;
        ProcessEvent(FindFunctionChecked(UDKBASE_SelfDestruct),&Parms);
    }
    void eventJumpOutCheck()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_JumpOutCheck),NULL);
    }
    void eventReceivedHealthChange()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_ReceivedHealthChange),NULL);
    }
    void eventPlayTakeHitEffects()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_PlayTakeHitEffects),NULL);
    }
    void eventOnPropertyChange(FName PropName)
    {
        UDKVehicle_eventOnPropertyChange_Parms Parms(EC_EventParm);
        Parms.PropName=PropName;
        ProcessEvent(FindFunctionChecked(UDKBASE_OnPropertyChange),&Parms);
    }
    void eventLockOnWarning(class AUDKProjectile* IncomingMissile)
    {
        UDKVehicle_eventLockOnWarning_Parms Parms(EC_EventParm);
        Parms.IncomingMissile=IncomingMissile;
        ProcessEvent(FindFunctionChecked(UDKBASE_LockOnWarning),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AUDKVehicle,AUDKVehicleBase,0|CLASS_Config|CLASS_NativeReplication,UDKBase)
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void TickSpecial(FLOAT DeltaTime);
	virtual void ApplyWeaponRotation(INT SeatIndex, FRotator NewRotation);
	void RequestTrackingFor(AUDKBot *Bot);
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	virtual FVector GetDampingForce(const FVector& InForce);
	virtual UBOOL JumpOutCheck(AActor *GoalActor, FLOAT Distance, FLOAT ZDiff);
	virtual UBOOL ReachThresholdTest(const FVector& TestPosition, const FVector& Dest, AActor* GoalActor, FLOAT UpThresholdAdjust, FLOAT DownThresholdAdjust, FLOAT ThresholdAdjust);
	virtual void VehicleUnpackRBState();

#if WITH_NOVODEX
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
#endif // WITH_NOVODEX
};

class AUDKWeaponPawn : public AUDKVehicleBase
{
public:
    //## BEGIN PROPS UDKWeaponPawn
    class AUDKVehicle* MyVehicle;
    class AUDKWeapon* MyVehicleWeapon;
    INT MySeatIndex;
    //## END PROPS UDKWeaponPawn

    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    DECLARE_CLASS(AUDKWeaponPawn,AUDKVehicleBase,0|CLASS_Config|CLASS_NativeReplication,UDKBase)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual AVehicle* GetVehicleBase();
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct UDKVehicleFactory_eventSpawnVehicle_Parms
{
    UDKVehicleFactory_eventSpawnVehicle_Parms(EEventParm)
    {
    }
};
class AUDKVehicleFactory : public ANavigationPoint
{
public:
    //## BEGIN PROPS UDKVehicleFactory
    FStringNoInit VehicleClassPath;
    BITFIELD bHasLockedVehicle:1;
    BITFIELD bReplicateChildVehicle:1;
    class UClass* VehicleClass;
    class AUDKVehicle* ChildVehicle;
    FLOAT RespawnProgress;
    FVector HUDLocation;
    INT TeamNum;
    //## END PROPS UDKVehicleFactory

    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual BYTE GetTeamNum();
    void eventSpawnVehicle()
    {
        ProcessEvent(FindFunctionChecked(UDKBASE_SpawnVehicle),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AUDKVehicleFactory,ANavigationPoint,0|CLASS_NativeReplication,UDKBase)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void Spawned();
};

class AUDKVehicleMovementEffect : public AActor
{
public:
    //## BEGIN PROPS UDKVehicleMovementEffect
    class UStaticMeshComponent* AirEffect;
    FLOAT MinVelocityForAirEffect;
    FLOAT MaxVelocityForAirEffect;
    FName AirEffectScalar;
    FLOAT AirMaxDelta;
    FLOAT AirCurrentLevel;
    //## END PROPS UDKVehicleMovementEffect

    DECLARE_CLASS(AUDKVehicleMovementEffect,AActor,0,UDKBase)
	virtual void TickSpecial(FLOAT DeltaTime);
};

class UUDKVehicleSimCar : public USVehicleSimCar
{
public:
    //## BEGIN PROPS UDKVehicleSimCar
    FInterpCurveFloat TorqueVSpeedCurve;
    FInterpCurveFloat EngineRPMCurve;
    FLOAT LSDFactor;
    FLOAT ThrottleSpeed;
    FLOAT MinRPM;
    FLOAT MaxRPM;
    FLOAT ActualThrottle;
    BITFIELD bForceThrottle:1;
    BITFIELD bHasForcedThrottle:1;
    BITFIELD bDriverlessBraking:1;
    BITFIELD bAutoHandbrake:1;
    FLOAT SteeringReductionFactor;
    FLOAT SteeringReductionRampUpRate;
    FLOAT CurrentSteeringReduction;
    INT NumWheelsForFullSteering;
    FLOAT SteeringReductionSpeed;
    FLOAT SteeringReductionMinSpeed;
    FLOAT MinHardTurnSpeed;
    FLOAT HardTurnMotorTorque;
    FLOAT HandbrakeSpeed;
    FLOAT ActualHandbrake;
    FLOAT FrontalCollisionGripFactor;
    FLOAT ConsoleHardTurnGripFactor;
    FLOAT SpeedBasedTurnDamping;
    FLOAT AirControlTurnTorque;
    FLOAT InAirUprightTorqueFactor;
    FLOAT InAirUprightMaxTorque;
    //## END PROPS UDKVehicleSimCar

    DECLARE_CLASS(UUDKVehicleSimCar,USVehicleSimCar,0,UDKBase)
	// SVehicleSimBase interface.
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual FLOAT GetEngineOutput(ASVehicle* Vehicle);
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateHandbrake(ASVehicle* Vehicle);
};

class UUDKVehicleSimChopper : public USVehicleSimBase
{
public:
    //## BEGIN PROPS UDKVehicleSimChopper
    FLOAT MaxThrustForce;
    FLOAT MaxReverseForce;
    FLOAT LongDamping;
    FLOAT MaxStrafeForce;
    FLOAT LatDamping;
    FLOAT DirectionChangeForce;
    FLOAT MaxRiseForce;
    FLOAT UpDamping;
    FLOAT TurnTorqueFactor;
    FLOAT TurnTorqueMax;
    FLOAT TurnDamping;
    FLOAT MaxYawRate;
    FLOAT PitchTorqueFactor;
    FLOAT PitchTorqueMax;
    FLOAT PitchDamping;
    FLOAT RollTorqueTurnFactor;
    FLOAT RollTorqueStrafeFactor;
    FLOAT RollTorqueMax;
    FLOAT RollDamping;
    FLOAT StopThreshold;
    FLOAT MaxRandForce;
    FLOAT RandForceInterval;
    BITFIELD bAllowZThrust:1;
    BITFIELD bFullThrustOnDirectionChange:1;
    BITFIELD bShouldCutThrustMaxOnImpact:1;
    BITFIELD bRecentlyHit:1;
    BITFIELD bStrafeAffectsTurnDamping:1;
    BITFIELD bHeadingInitialized:1;
    BITFIELD bStabilizeStops:1;
    FLOAT StrafeTurnDamping;
    FLOAT TargetHeading;
    FLOAT TargetPitch;
    FLOAT PitchViewCorrelation;
    FVector RandForce;
    FVector RandTorque;
    FLOAT AccumulatedTime;
    FLOAT StabilizationForceMultiplier;
    FLOAT CurrentStabilizationMultiplier;
    FVector OldVelocity;
    FLOAT StoppedBrakeTorque;
    FLOAT HardLimitAirSpeedScale;
    //## END PROPS UDKVehicleSimChopper

    DECLARE_CLASS(UUDKVehicleSimChopper,USVehicleSimBase,0,UDKBase)
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual FVector StabilizationForce(ASVehicle* Vehicle, FLOAT DeltaTime, UBOOL bShouldStabilize);
	virtual FVector StabilizationTorque(ASVehicle* Vehicle, FLOAT DeltaTime, UBOOL bShouldStabilize);
	FLOAT GetEngineOutput(ASVehicle* Vehicle);
	virtual void GetRotationAxes(ASVehicle* Vehicle, FVector &DirX, FVector &DirY, FVector &DirZ);
};

class UUDKVehicleSimHover : public UUDKVehicleSimChopper
{
public:
    //## BEGIN PROPS UDKVehicleSimHover
    BITFIELD bDisableWheelsWhenOff:1;
    BITFIELD bRepulsorCollisionEnabled:1;
    BITFIELD bCanClimbSlopes:1;
    BITFIELD bUnPoweredDriving:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKVehicleSimHover

    DECLARE_CLASS(UUDKVehicleSimHover,UUDKVehicleSimChopper,0,UDKBase)
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	FLOAT GetEngineOutput(ASVehicle* Vehicle);
	virtual void GetRotationAxes(ASVehicle* Vehicle, FVector &DirX, FVector &DirY, FVector &DirZ);
};

class UUDKVehicleSimHoverboard : public USVehicleSimBase
{
public:
    //## BEGIN PROPS UDKVehicleSimHoverboard
    FLOAT MaxThrustForce;
    FLOAT MaxReverseForce;
    FLOAT MaxReverseVelocity;
    FLOAT LongDamping;
    FLOAT MaxStrafeForce;
    FLOAT LatDamping;
    FLOAT MaxRiseForce;
    FLOAT TurnTorqueFactor;
    FLOAT SpinTurnTorqueScale;
    FLOAT MaxTurnTorque;
    FInterpCurveFloat TurnDampingSpeedFunc;
    BITFIELD bIsOverDeepWater:1;
    BITFIELD bInAJump:1;
    BITFIELD bLeftGround:1;
    FLOAT StopThreshold;
    FLOAT WaterCheckLevel;
    class USoundCue* OverWaterSound;
    FVector GroundNormal;
    FLOAT TakeoffYaw;
    FLOAT TrickJumpWarmup;
    FLOAT SpinHeadingOffset;
    FLOAT AutoSpin;
    FLOAT SpinSpeed;
    FLOAT LandedCountdown;
    FLOAT CurrentSteerOffset;
    FLOAT HoverboardSlalomMaxAngle;
    FLOAT SlalomSpeed;
    FLOAT CurrentLookYaw;
    //## END PROPS UDKVehicleSimHoverboard

    virtual void InitWheels(class AUDKVehicle* Vehicle);
    virtual void UpdateLeanConstraint(class URB_ConstraintInstance* LeanUprightConstraintInstance,FVector LeanY,FVector LeanZ);
    DECLARE_FUNCTION(execInitWheels)
    {
        P_GET_OBJECT(AUDKVehicle,Vehicle);
        P_FINISH;
        this->InitWheels(Vehicle);
    }
    DECLARE_FUNCTION(execUpdateLeanConstraint)
    {
        P_GET_OBJECT(URB_ConstraintInstance,LeanUprightConstraintInstance);
        P_GET_STRUCT(FVector,LeanY);
        P_GET_STRUCT(FVector,LeanZ);
        P_FINISH;
        this->UpdateLeanConstraint(LeanUprightConstraintInstance,LeanY,LeanZ);
    }
    DECLARE_CLASS(UUDKVehicleSimHoverboard,USVehicleSimBase,0,UDKBase)
    virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	FLOAT GetEngineOutput(ASVehicle* Vehicle);
};

struct UDKVehicleWheel_eventSetParticleEffect_Parms
{
    class AUDKVehicle* OwnerVehicle;
    class UParticleSystem* NewTemplate;
    UDKVehicleWheel_eventSetParticleEffect_Parms(EEventParm)
    {
    }
};
class UUDKVehicleWheel : public USVehicleWheel
{
public:
    //## BEGIN PROPS UDKVehicleWheel
    BITFIELD bUseMaterialSpecificEffects:1;
    BITFIELD bDisableWheelOnDeath:1;
    class UParticleSystemComponent* OldWheelParticleComp;
    FLOAT EffectDesiredSpinDir;
    //## END PROPS UDKVehicleWheel

    void eventSetParticleEffect(class AUDKVehicle* OwnerVehicle,class UParticleSystem* NewTemplate)
    {
        UDKVehicleWheel_eventSetParticleEffect_Parms Parms(EC_EventParm);
        Parms.OwnerVehicle=OwnerVehicle;
        Parms.NewTemplate=NewTemplate;
        ProcessEvent(FindFunctionChecked(UDKBASE_SetParticleEffect),&Parms);
    }
    DECLARE_CLASS(UUDKVehicleWheel,USVehicleWheel,0,UDKBase)
	/** @return whether this wheel should have a particle component attached to it */
	virtual UBOOL WantsParticleComponent();
};

struct UDKWeapon_eventSetPosition_Parms
{
    class AUDKPawn* Holder;
    UDKWeapon_eventSetPosition_Parms(EEventParm)
    {
    }
};
struct UDKWeapon_eventIsAimCorrect_Parms
{
    UBOOL ReturnValue;
    UDKWeapon_eventIsAimCorrect_Parms(EEventParm)
    {
    }
};
class AUDKWeapon : public AWeapon
{
public:
    //## BEGIN PROPS UDKWeapon
    class UMeshComponent* OverlayMesh;
    BITFIELD bLeadTarget:1;
    BITFIELD bConsiderProjectileAcceleration:1;
    INT AmmoCount;
    BYTE HitEnemy;
    FLOAT AimTraceRange;
    TArrayNoInit<class AActor*> AimingTraceIgnoredActors;
    //## END PROPS UDKWeapon

    virtual void EnsureWeaponOverlayComponentLast();
    DECLARE_FUNCTION(execEnsureWeaponOverlayComponentLast)
    {
        P_FINISH;
        this->EnsureWeaponOverlayComponentLast();
    }
    void eventSetPosition(class AUDKPawn* Holder)
    {
        UDKWeapon_eventSetPosition_Parms Parms(EC_EventParm);
        Parms.Holder=Holder;
        ProcessEvent(FindFunctionChecked(UDKBASE_SetPosition),&Parms);
    }
    UBOOL eventIsAimCorrect()
    {
        UDKWeapon_eventIsAimCorrect_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UDKBASE_IsAimCorrect),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AUDKWeapon,AWeapon,0|CLASS_Config|CLASS_NativeReplication,UDKBase)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
};

class AUDKWeaponShield : public AActor
{
public:
    //## BEGIN PROPS UDKWeaponShield
    BITFIELD bIgnoreFlaggedProjectiles:1;
    SCRIPT_ALIGN;
    //## END PROPS UDKWeaponShield

    DECLARE_ABSTRACT_CLASS(AUDKWeaponShield,AActor,0,UDKBase)
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor* SourceActor, DWORD TraceFlags);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_UDKBASE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AUDKBot,-1,execFindBestSuperPickup);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execBuildSquadRoute);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execFindPathToSquadRoute);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execFindBestInventoryPath);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execCanMakePathTo);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execLatentWhatToDoNext);
AUTOGENERATE_FUNCTION(AUDKBot,-1,execWaitToSeeEnemy);
AUTOGENERATE_FUNCTION(AUDKCarriedObject,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AUDKCarriedObject,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(UUDKDataStore_GameSearchBase,-1,execGetEnabledMutators);
AUTOGENERATE_FUNCTION(AUDKEmitCameraEffect,-1,execUpdateLocation);
AUTOGENERATE_FUNCTION(UUDKExplosionLight,-1,execResetLight);
AUTOGENERATE_FUNCTION(UUDKGameInteraction,-1,execShouldProcessUIInput);
AUTOGENERATE_FUNCTION(AUDKGameObjective,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AUDKGameObjective,-1,execDrawIcon);
AUTOGENERATE_FUNCTION(AUDKGameObjective,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(UUDKGameSettingsCommon,-1,execBlobToString);
AUTOGENERATE_FUNCTION(UUDKGameSettingsCommon,-1,execStringToBlob);
AUTOGENERATE_FUNCTION(UUDKGameViewportClient,-1,execLoadRandomLocalizedHintMessage);
AUTOGENERATE_FUNCTION(AUDKHUD,-1,execTranslateBindToFont);
AUTOGENERATE_FUNCTION(AUDKHUD,-1,execDrawGlowText);
AUTOGENERATE_FUNCTION(UUDKParticleSystemComponent,-1,execSetFOV);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execNativePostRenderFor);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execSuggestJumpVelocity);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execIsInvisible);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execEnsureOverlayComponentLast);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execRestorePreRagdollCollisionComponent);
AUTOGENERATE_FUNCTION(AUDKPawn,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetUseTiltForwardAndBack);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetOnlyUseControllerTiltInput);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetControllerTiltActive);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetControllerTiltDesiredIfAvailable);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execIsControllerTiltActive);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execGetTargetAdhesionFrictionTarget);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execIsMouseAvailable);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execIsKeyboardAvailable);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetHardwarePhysicsEnabled);
AUTOGENERATE_FUNCTION(AUDKPlayerController,-1,execSetGamma);
AUTOGENERATE_FUNCTION(UUDKPlayerInput,-1,execGetUDKBindNameFromCommand);
AUTOGENERATE_FUNCTION(UUDKProfileSettings,-1,execResetKeysToDefault);
AUTOGENERATE_FUNCTION(UUDKProfileSettings,-1,execResetToDefault);
AUTOGENERATE_FUNCTION(AUDKProjectile,-1,execGetTerminalVelocity);
AUTOGENERATE_FUNCTION(AUDKScout,-1,execSuggestJumpVelocity);
AUTOGENERATE_FUNCTION(UUDKSkeletalMeshComponent,-1,execSetFOV);
AUTOGENERATE_FUNCTION(AUDKTeamOwnedInfo,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(UUDKUIDataProvider_SearchResult,-1,execIsPrivateServer);
AUTOGENERATE_FUNCTION(UUDKUIDataProvider_SimpleElementProvider,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUDKUIDataProvider_ServerDetails,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUDKUIDataProvider_ServerDetails,-1,execGetSearchResultsProvider);
AUTOGENERATE_FUNCTION(UUDKUIDataProvider_StringArray,-1,execGetElementCount);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execAddListElementProvidersKey);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execRemoveListElementProvidersKey);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execGetProviderSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execGetValueFromProviderSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execFindValueInProviderSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execGetAllResourceDataProviders);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execIsProviderFiltered);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_MenuItems,-1,execGetProviderCount);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_Options,-1,execGetSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_Options,-1,execAppendToSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_Options,-1,execClearSet);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasBindingMap,-1,execClearBoundKeyCache);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasBindingMap,-1,execAddMappingToBoundKeyCache);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasBindingMap,-1,execFindMappingInBoundKeyCache);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasBindingMap,-1,execGetBoundStringWithFieldName);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasBindingMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringAliasMap,-1,execGetStringWithFieldName);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execGetList);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execGetStr);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execFindStr);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execEmpty);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execRemoveStrByIndex);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execRemoveStr);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execInsertStr);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execAddStr);
AUTOGENERATE_FUNCTION(UUDKUIDataStore_StringList,-1,execGetFieldIndex);
AUTOGENERATE_FUNCTION(UUDKUIResourceDataProvider,-1,execIsFiltered);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execApplyMorphDamage);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execUpdateDamageMaterial);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execInitDamageSkel);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execInUseableRange);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execNativePostRenderFor);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execCheckAutoDestruct);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execGetMaxRiseForce);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(AUDKVehicle,999,execIsSeatControllerReplicationViewer);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execGetBarrelIndex);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execGetSeatPivotPoint);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execForceWeaponRotation);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execSeatFiringMode);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execSeatFlashCount);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execSeatFlashLocation);
AUTOGENERATE_FUNCTION(AUDKVehicle,-1,execSeatWeaponRotation);
AUTOGENERATE_FUNCTION(AUDKWeaponPawn,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AUDKVehicleFactory,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AUDKVehicleFactory,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(UUDKVehicleSimHoverboard,-1,execUpdateLeanConstraint);
AUTOGENERATE_FUNCTION(UUDKVehicleSimHoverboard,-1,execInitWheels);
AUTOGENERATE_FUNCTION(AUDKWeapon,-1,execEnsureWeaponOverlayComponentLast);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UDKBASE_NATIVE_DEFS
#define UDKBASE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_UDKBASE \
	UUDKAIDecisionComponent::StaticClass(); \
	AUDKBot::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKBot"), GUDKBaseAUDKBotNatives); \
	AUDKCarriedObject::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKCarriedObject"), GUDKBaseAUDKCarriedObjectNatives); \
	UUDKDataStore_GameSearchBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKDataStore_GameSearchBase"), GUDKBaseUUDKDataStore_GameSearchBaseNatives); \
	AUDKEmitCameraEffect::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKEmitCameraEffect"), GUDKBaseAUDKEmitCameraEffectNatives); \
	AUDKEmitterPool::StaticClass(); \
	UUDKExplosionLight::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKExplosionLight"), GUDKBaseUUDKExplosionLightNatives); \
	AUDKForcedDirectionVolume::StaticClass(); \
	AUDKGame::StaticClass(); \
	UUDKGameInteraction::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKGameInteraction"), GUDKBaseUUDKGameInteractionNatives); \
	AUDKGameObjective::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKGameObjective"), GUDKBaseAUDKGameObjectiveNatives); \
	UUDKGameSettingsCommon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKGameSettingsCommon"), GUDKBaseUUDKGameSettingsCommonNatives); \
	UUDKGameViewportClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKGameViewportClient"), GUDKBaseUUDKGameViewportClientNatives); \
	AUDKHUD::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKHUD"), GUDKBaseAUDKHUDNatives); \
	AUDKJumpPad::StaticClass(); \
	AUDKKActorBreakable::StaticClass(); \
	UUDKMapInfo::StaticClass(); \
	UUDKMapMusicInfo::StaticClass(); \
	UUDKParticleSystemComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKParticleSystemComponent"), GUDKBaseUUDKParticleSystemComponentNatives); \
	AUDKPawn::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKPawn"), GUDKBaseAUDKPawnNatives); \
	AUDKPickupFactory::StaticClass(); \
	AUDKPlayerController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKPlayerController"), GUDKBaseAUDKPlayerControllerNatives); \
	UUDKPlayerInput::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKPlayerInput"), GUDKBaseUUDKPlayerInputNatives); \
	UUDKProfileSettings::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKProfileSettings"), GUDKBaseUUDKProfileSettingsNatives); \
	AUDKProjectile::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKProjectile"), GUDKBaseAUDKProjectileNatives); \
	AUDKScout::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKScout"), GUDKBaseAUDKScoutNatives); \
	AUDKScriptedNavigationPoint::StaticClass(); \
	UUDKSkeletalMeshComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKSkeletalMeshComponent"), GUDKBaseUUDKSkeletalMeshComponentNatives); \
	AUDKTeamOwnedInfo::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKTeamOwnedInfo"), GUDKBaseAUDKTeamOwnedInfoNatives); \
	AUDKSquadAI::StaticClass(); \
	AUDKTeamPlayerStart::StaticClass(); \
	AUDKTeleporterBase::StaticClass(); \
	UUDKTrajectoryReachSpec::StaticClass(); \
	UUDKJumpPadReachSpec::StaticClass(); \
	UUDKUIDataProvider_SearchResult::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataProvider_SearchResult"), GUDKBaseUUDKUIDataProvider_SearchResultNatives); \
	UUDKUIDataProvider_SimpleElementProvider::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataProvider_SimpleElementProvider"), GUDKBaseUUDKUIDataProvider_SimpleElementProviderNatives); \
	UUDKUIDataProvider_ServerDetails::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataProvider_ServerDetails"), GUDKBaseUUDKUIDataProvider_ServerDetailsNatives); \
	UUDKUIDataProvider_StringArray::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataProvider_StringArray"), GUDKBaseUUDKUIDataProvider_StringArrayNatives); \
	UUDKUIDataStore_MenuItems::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataStore_MenuItems"), GUDKBaseUUDKUIDataStore_MenuItemsNatives); \
	UUDKUIDataStore_Options::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataStore_Options"), GUDKBaseUUDKUIDataStore_OptionsNatives); \
	UUDKUIDataStore_StringAliasBindingMap::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataStore_StringAliasBindingMap"), GUDKBaseUUDKUIDataStore_StringAliasBindingMapNatives); \
	UUDKUIDataStore_StringAliasMap::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataStore_StringAliasMap"), GUDKBaseUUDKUIDataStore_StringAliasMapNatives); \
	UUDKUIDataStore_StringList::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIDataStore_StringList"), GUDKBaseUUDKUIDataStore_StringListNatives); \
	UUDKUIResourceDataProvider::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKUIResourceDataProvider"), GUDKBaseUUDKUIResourceDataProviderNatives); \
	UUDKUIDataProvider_MapInfo::StaticClass(); \
	UUDKUIDataProvider_MenuOption::StaticClass(); \
	AUDKVehicleBase::StaticClass(); \
	AUDKVehicle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKVehicle"), GUDKBaseAUDKVehicleNatives); \
	AUDKWeaponPawn::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKWeaponPawn"), GUDKBaseAUDKWeaponPawnNatives); \
	AUDKVehicleFactory::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKVehicleFactory"), GUDKBaseAUDKVehicleFactoryNatives); \
	AUDKVehicleMovementEffect::StaticClass(); \
	UUDKVehicleSimCar::StaticClass(); \
	UUDKVehicleSimChopper::StaticClass(); \
	UUDKVehicleSimHover::StaticClass(); \
	UUDKVehicleSimHoverboard::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKVehicleSimHoverboard"), GUDKBaseUUDKVehicleSimHoverboardNatives); \
	UUDKVehicleWheel::StaticClass(); \
	AUDKWeapon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UDKWeapon"), GUDKBaseAUDKWeaponNatives); \
	AUDKWeaponShield::StaticClass(); \

#endif // UDKBASE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GUDKBaseAUDKBotNatives[] = 
{ 
	MAP_NATIVE(AUDKBot, execFindBestSuperPickup)
	MAP_NATIVE(AUDKBot, execBuildSquadRoute)
	MAP_NATIVE(AUDKBot, execFindPathToSquadRoute)
	MAP_NATIVE(AUDKBot, execFindBestInventoryPath)
	MAP_NATIVE(AUDKBot, execCanMakePathTo)
	MAP_NATIVE(AUDKBot, execLatentWhatToDoNext)
	MAP_NATIVE(AUDKBot, execWaitToSeeEnemy)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKCarriedObjectNatives[] = 
{ 
	MAP_NATIVE(AUDKCarriedObject, execGetTeamNum)
	MAP_NATIVE(AUDKCarriedObject, execSetHUDLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKDataStore_GameSearchBaseNatives[] = 
{ 
	MAP_NATIVE(UUDKDataStore_GameSearchBase, execGetEnabledMutators)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKEmitCameraEffectNatives[] = 
{ 
	MAP_NATIVE(AUDKEmitCameraEffect, execUpdateLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKExplosionLightNatives[] = 
{ 
	MAP_NATIVE(UUDKExplosionLight, execResetLight)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKGameInteractionNatives[] = 
{ 
	MAP_NATIVE(UUDKGameInteraction, execShouldProcessUIInput)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKGameObjectiveNatives[] = 
{ 
	MAP_NATIVE(AUDKGameObjective, execGetTeamNum)
	MAP_NATIVE(AUDKGameObjective, execDrawIcon)
	MAP_NATIVE(AUDKGameObjective, execSetHUDLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKGameSettingsCommonNatives[] = 
{ 
	MAP_NATIVE(UUDKGameSettingsCommon, execBlobToString)
	MAP_NATIVE(UUDKGameSettingsCommon, execStringToBlob)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKGameViewportClientNatives[] = 
{ 
	MAP_NATIVE(UUDKGameViewportClient, execLoadRandomLocalizedHintMessage)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKHUDNatives[] = 
{ 
	MAP_NATIVE(AUDKHUD, execTranslateBindToFont)
	MAP_NATIVE(AUDKHUD, execDrawGlowText)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKParticleSystemComponentNatives[] = 
{ 
	MAP_NATIVE(UUDKParticleSystemComponent, execSetFOV)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKPawnNatives[] = 
{ 
	MAP_NATIVE(AUDKPawn, execNativePostRenderFor)
	MAP_NATIVE(AUDKPawn, execSetHUDLocation)
	MAP_NATIVE(AUDKPawn, execSuggestJumpVelocity)
	MAP_NATIVE(AUDKPawn, execIsInvisible)
	MAP_NATIVE(AUDKPawn, execGetTargetLocation)
	MAP_NATIVE(AUDKPawn, execEnsureOverlayComponentLast)
	MAP_NATIVE(AUDKPawn, execRestorePreRagdollCollisionComponent)
	MAP_NATIVE(AUDKPawn, execGetBoundingCylinder)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKPlayerControllerNatives[] = 
{ 
	MAP_NATIVE(AUDKPlayerController, execSetUseTiltForwardAndBack)
	MAP_NATIVE(AUDKPlayerController, execSetOnlyUseControllerTiltInput)
	MAP_NATIVE(AUDKPlayerController, execSetControllerTiltActive)
	MAP_NATIVE(AUDKPlayerController, execSetControllerTiltDesiredIfAvailable)
	MAP_NATIVE(AUDKPlayerController, execIsControllerTiltActive)
	MAP_NATIVE(AUDKPlayerController, execGetTargetAdhesionFrictionTarget)
	MAP_NATIVE(AUDKPlayerController, execIsMouseAvailable)
	MAP_NATIVE(AUDKPlayerController, execIsKeyboardAvailable)
	MAP_NATIVE(AUDKPlayerController, execSetHardwarePhysicsEnabled)
	MAP_NATIVE(AUDKPlayerController, execSetGamma)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKPlayerInputNatives[] = 
{ 
	MAP_NATIVE(UUDKPlayerInput, execGetUDKBindNameFromCommand)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKProfileSettingsNatives[] = 
{ 
	MAP_NATIVE(UUDKProfileSettings, execResetKeysToDefault)
	MAP_NATIVE(UUDKProfileSettings, execResetToDefault)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKProjectileNatives[] = 
{ 
	MAP_NATIVE(AUDKProjectile, execGetTerminalVelocity)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKScoutNatives[] = 
{ 
	MAP_NATIVE(AUDKScout, execSuggestJumpVelocity)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKSkeletalMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UUDKSkeletalMeshComponent, execSetFOV)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKTeamOwnedInfoNatives[] = 
{ 
	MAP_NATIVE(AUDKTeamOwnedInfo, execGetTeamNum)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataProvider_SearchResultNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataProvider_SearchResult, execIsPrivateServer)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataProvider_SimpleElementProviderNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataProvider_SimpleElementProvider, execGetElementCount)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataProvider_ServerDetailsNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataProvider_ServerDetails, execGetElementCount)
	MAP_NATIVE(UUDKUIDataProvider_ServerDetails, execGetSearchResultsProvider)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataProvider_StringArrayNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataProvider_StringArray, execGetElementCount)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataStore_MenuItemsNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execAddListElementProvidersKey)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execRemoveListElementProvidersKey)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execGetProviderSet)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execGetValueFromProviderSet)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execFindValueInProviderSet)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execGetAllResourceDataProviders)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execIsProviderFiltered)
	MAP_NATIVE(UUDKUIDataStore_MenuItems, execGetProviderCount)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataStore_OptionsNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataStore_Options, execGetSet)
	MAP_NATIVE(UUDKUIDataStore_Options, execAppendToSet)
	MAP_NATIVE(UUDKUIDataStore_Options, execClearSet)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataStore_StringAliasBindingMapNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataStore_StringAliasBindingMap, execClearBoundKeyCache)
	MAP_NATIVE(UUDKUIDataStore_StringAliasBindingMap, execAddMappingToBoundKeyCache)
	MAP_NATIVE(UUDKUIDataStore_StringAliasBindingMap, execFindMappingInBoundKeyCache)
	MAP_NATIVE(UUDKUIDataStore_StringAliasBindingMap, execGetBoundStringWithFieldName)
	MAP_NATIVE(UUDKUIDataStore_StringAliasBindingMap, execGetStringWithFieldName)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataStore_StringAliasMapNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataStore_StringAliasMap, execGetStringWithFieldName)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIDataStore_StringListNatives[] = 
{ 
	MAP_NATIVE(UUDKUIDataStore_StringList, execGetList)
	MAP_NATIVE(UUDKUIDataStore_StringList, execGetStr)
	MAP_NATIVE(UUDKUIDataStore_StringList, execFindStr)
	MAP_NATIVE(UUDKUIDataStore_StringList, execEmpty)
	MAP_NATIVE(UUDKUIDataStore_StringList, execRemoveStrByIndex)
	MAP_NATIVE(UUDKUIDataStore_StringList, execRemoveStr)
	MAP_NATIVE(UUDKUIDataStore_StringList, execInsertStr)
	MAP_NATIVE(UUDKUIDataStore_StringList, execAddStr)
	MAP_NATIVE(UUDKUIDataStore_StringList, execGetFieldIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKUIResourceDataProviderNatives[] = 
{ 
	MAP_NATIVE(UUDKUIResourceDataProvider, execIsFiltered)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKVehicleNatives[] = 
{ 
	MAP_NATIVE(AUDKVehicle, execApplyMorphDamage)
	MAP_NATIVE(AUDKVehicle, execUpdateDamageMaterial)
	MAP_NATIVE(AUDKVehicle, execInitDamageSkel)
	MAP_NATIVE(AUDKVehicle, execSetHUDLocation)
	MAP_NATIVE(AUDKVehicle, execInUseableRange)
	MAP_NATIVE(AUDKVehicle, execNativePostRenderFor)
	MAP_NATIVE(AUDKVehicle, execGetTeamNum)
	MAP_NATIVE(AUDKVehicle, execCheckAutoDestruct)
	MAP_NATIVE(AUDKVehicle, execGetMaxRiseForce)
	MAP_NATIVE(AUDKVehicle, execGetGravityZ)
	MAP_NATIVE(AUDKVehicle, execIsSeatControllerReplicationViewer)
	MAP_NATIVE(AUDKVehicle, execGetBarrelIndex)
	MAP_NATIVE(AUDKVehicle, execGetSeatPivotPoint)
	MAP_NATIVE(AUDKVehicle, execForceWeaponRotation)
	MAP_NATIVE(AUDKVehicle, execSeatFiringMode)
	MAP_NATIVE(AUDKVehicle, execSeatFlashCount)
	MAP_NATIVE(AUDKVehicle, execSeatFlashLocation)
	MAP_NATIVE(AUDKVehicle, execSeatWeaponRotation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKWeaponPawnNatives[] = 
{ 
	MAP_NATIVE(AUDKWeaponPawn, execGetTargetLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKVehicleFactoryNatives[] = 
{ 
	MAP_NATIVE(AUDKVehicleFactory, execGetTeamNum)
	MAP_NATIVE(AUDKVehicleFactory, execSetHUDLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseUUDKVehicleSimHoverboardNatives[] = 
{ 
	MAP_NATIVE(UUDKVehicleSimHoverboard, execUpdateLeanConstraint)
	MAP_NATIVE(UUDKVehicleSimHoverboard, execInitWheels)
	{NULL, NULL}
};

FNativeFunctionLookup GUDKBaseAUDKWeaponNatives[] = 
{ 
	MAP_NATIVE(AUDKWeapon, execEnsureWeaponOverlayComponentLast)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UUDKAIDecisionComponent)
VERIFY_CLASS_OFFSET_NODIE(AUDKBot,UDKBot,Squad)
VERIFY_CLASS_OFFSET_NODIE(AUDKBot,UDKBot,MultiJumpZ)
VERIFY_CLASS_SIZE_NODIE(AUDKBot)
VERIFY_CLASS_OFFSET_NODIE(AUDKCarriedObject,UDKCarriedObject,Team)
VERIFY_CLASS_OFFSET_NODIE(AUDKCarriedObject,UDKCarriedObject,HUDLocation)
VERIFY_CLASS_SIZE_NODIE(AUDKCarriedObject)
VERIFY_CLASS_OFFSET_NODIE(UUDKDataStore_GameSearchBase,UDKDataStore_GameSearchBase,ServerDetailsProvider)
VERIFY_CLASS_SIZE_NODIE(UUDKDataStore_GameSearchBase)
VERIFY_CLASS_OFFSET_NODIE(AUDKEmitCameraEffect,UDKEmitCameraEffect,DistFromCamera)
VERIFY_CLASS_OFFSET_NODIE(AUDKEmitCameraEffect,UDKEmitCameraEffect,Cam)
VERIFY_CLASS_SIZE_NODIE(AUDKEmitCameraEffect)
VERIFY_CLASS_OFFSET_NODIE(AUDKEmitterPool,UDKEmitterPool,RelativeExplosionLights)
VERIFY_CLASS_SIZE_NODIE(AUDKEmitterPool)
VERIFY_CLASS_OFFSET_NODIE(UUDKExplosionLight,UDKExplosionLight,HighDetailFrameTime)
VERIFY_CLASS_OFFSET_NODIE(UUDKExplosionLight,UDKExplosionLight,__OnLightFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUDKExplosionLight)
VERIFY_CLASS_OFFSET_NODIE(AUDKForcedDirectionVolume,UDKForcedDirectionVolume,TypeToForce)
VERIFY_CLASS_OFFSET_NODIE(AUDKForcedDirectionVolume,UDKForcedDirectionVolume,TouchingVehicles)
VERIFY_CLASS_SIZE_NODIE(AUDKForcedDirectionVolume)
VERIFY_CLASS_SIZE_NODIE(AUDKGame)
VERIFY_CLASS_OFFSET_NODIE(UUDKGameInteraction,UDKGameInteraction,BlockUIInputSemaphore)
VERIFY_CLASS_SIZE_NODIE(UUDKGameInteraction)
VERIFY_CLASS_OFFSET_NODIE(AUDKGameObjective,UDKGameObjective,ShootSpots)
VERIFY_CLASS_OFFSET_NODIE(AUDKGameObjective,UDKGameObjective,DefenderTeamIndex)
VERIFY_CLASS_SIZE_NODIE(AUDKGameObjective)
VERIFY_CLASS_SIZE_NODIE(UUDKGameSettingsCommon)
VERIFY_CLASS_OFFSET_NODIE(UUDKGameViewportClient,UDKGameViewportClient,HintLocFileName)
VERIFY_CLASS_SIZE_NODIE(UUDKGameViewportClient)
VERIFY_CLASS_OFFSET_NODIE(AUDKHUD,UDKHUD,GlowFonts)
VERIFY_CLASS_OFFSET_NODIE(AUDKHUD,UDKHUD,BindTextFont)
VERIFY_CLASS_SIZE_NODIE(AUDKHUD)
VERIFY_CLASS_OFFSET_NODIE(AUDKJumpPad,UDKJumpPad,JumpVelocity)
VERIFY_CLASS_OFFSET_NODIE(AUDKJumpPad,UDKJumpPad,JumpAmbientSound)
VERIFY_CLASS_SIZE_NODIE(AUDKJumpPad)
VERIFY_CLASS_OFFSET_NODIE(AUDKKActorBreakable,UDKKActorBreakable,Health)
VERIFY_CLASS_OFFSET_NODIE(AUDKKActorBreakable,UDKKActorBreakable,__OnEncroach__Delegate)
VERIFY_CLASS_SIZE_NODIE(AUDKKActorBreakable)
VERIFY_CLASS_OFFSET_NODIE(UUDKMapInfo,UDKMapInfo,VisibilityModifier)
VERIFY_CLASS_SIZE_NODIE(UUDKMapInfo)
VERIFY_CLASS_OFFSET_NODIE(UUDKMapMusicInfo,UDKMapMusicInfo,MapMusic)
VERIFY_CLASS_OFFSET_NODIE(UUDKMapMusicInfo,UDKMapMusicInfo,MapStingers)
VERIFY_CLASS_SIZE_NODIE(UUDKMapMusicInfo)
VERIFY_CLASS_OFFSET_NODIE(UUDKParticleSystemComponent,UDKParticleSystemComponent,FOV)
VERIFY_CLASS_OFFSET_NODIE(UUDKParticleSystemComponent,UDKParticleSystemComponent,SavedScale3D)
VERIFY_CLASS_SIZE_NODIE(UUDKParticleSystemComponent)
VERIFY_CLASS_OFFSET_NODIE(AUDKPawn,UDKPawn,MaxDoubleJumpHeight)
VERIFY_CLASS_OFFSET_NODIE(AUDKPawn,UDKPawn,HUDLocation)
VERIFY_CLASS_SIZE_NODIE(AUDKPawn)
VERIFY_CLASS_OFFSET_NODIE(AUDKPickupFactory,UDKPickupFactory,BaseMesh)
VERIFY_CLASS_OFFSET_NODIE(AUDKPickupFactory,UDKPickupFactory,SpinningParticleEffects)
VERIFY_CLASS_SIZE_NODIE(AUDKPickupFactory)
VERIFY_CLASS_OFFSET_NODIE(AUDKPlayerController,UDKPlayerController,CameraAnimPlayer)
VERIFY_CLASS_OFFSET_NODIE(AUDKPlayerController,UDKPlayerController,PulseTimer)
VERIFY_CLASS_SIZE_NODIE(AUDKPlayerController)
VERIFY_CLASS_SIZE_NODIE(UUDKPlayerInput)
VERIFY_CLASS_SIZE_NODIE(UUDKProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(AUDKProjectile,UDKProjectile,CheckRadius)
VERIFY_CLASS_OFFSET_NODIE(AUDKProjectile,UDKProjectile,InstigatorBaseVehicle)
VERIFY_CLASS_SIZE_NODIE(AUDKProjectile)
VERIFY_CLASS_OFFSET_NODIE(AUDKScout,UDKScout,MaxDoubleJumpHeight)
VERIFY_CLASS_OFFSET_NODIE(AUDKScout,UDKScout,SizePersonFindName)
VERIFY_CLASS_SIZE_NODIE(AUDKScout)
VERIFY_CLASS_SIZE_NODIE(AUDKScriptedNavigationPoint)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkeletalMeshComponent,UDKSkeletalMeshComponent,FOV)
VERIFY_CLASS_OFFSET_NODIE(UUDKSkeletalMeshComponent,UDKSkeletalMeshComponent,ClearStreamingTime)
VERIFY_CLASS_SIZE_NODIE(UUDKSkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(AUDKTeamOwnedInfo,UDKTeamOwnedInfo,Team)
VERIFY_CLASS_SIZE_NODIE(AUDKTeamOwnedInfo)
VERIFY_CLASS_OFFSET_NODIE(AUDKSquadAI,UDKSquadAI,SquadObjective)
VERIFY_CLASS_OFFSET_NODIE(AUDKSquadAI,UDKSquadAI,MaxSquadRoutes)
VERIFY_CLASS_SIZE_NODIE(AUDKSquadAI)
VERIFY_CLASS_OFFSET_NODIE(AUDKTeamPlayerStart,UDKTeamPlayerStart,TeamNumber)
VERIFY_CLASS_OFFSET_NODIE(AUDKTeamPlayerStart,UDKTeamPlayerStart,TeamSprites)
VERIFY_CLASS_SIZE_NODIE(AUDKTeamPlayerStart)
VERIFY_CLASS_OFFSET_NODIE(AUDKTeleporterBase,UDKTeleporterBase,PortalCaptureComponent)
VERIFY_CLASS_OFFSET_NODIE(AUDKTeleporterBase,UDKTeleporterBase,TeleportingSound)
VERIFY_CLASS_SIZE_NODIE(AUDKTeleporterBase)
VERIFY_CLASS_SIZE_NODIE(UUDKTrajectoryReachSpec)
VERIFY_CLASS_SIZE_NODIE(UUDKJumpPadReachSpec)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_SearchResult,UDKUIDataProvider_SearchResult,PlayerRatioTag)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_SearchResult,UDKUIDataProvider_SearchResult,IconFontPathName)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_SearchResult)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_SimpleElementProvider)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_ServerDetails,UDKUIDataProvider_ServerDetails,SearchResultsRow)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_ServerDetails)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_StringArray,UDKUIDataProvider_StringArray,Strings)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_StringArray)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_MenuItems,UDKUIDataStore_MenuItems,MapInfoDataProviderClass)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_MenuItems,UDKUIDataStore_MenuItems,GameModeFilter)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataStore_MenuItems)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_Options,UDKUIDataStore_Options,OptionProviders)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_Options,UDKUIDataStore_Options,DynamicProviders)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataStore_Options)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_StringAliasBindingMap,UDKUIDataStore_StringAliasBindingMap,FakePlatform)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_StringAliasBindingMap,UDKUIDataStore_StringAliasBindingMap,ControllerMapArray)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataStore_StringAliasBindingMap)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_StringAliasMap,UDKUIDataStore_StringAliasMap,FakePlatform)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataStore_StringAliasMap)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataStore_StringList,UDKUIDataStore_StringList,StringData)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataStore_StringList)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIResourceDataProvider,UDKUIResourceDataProvider,FriendlyName)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIResourceDataProvider,UDKUIResourceDataProvider,IniName)
VERIFY_CLASS_SIZE_NODIE(UUDKUIResourceDataProvider)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_MapInfo,UDKUIDataProvider_MapInfo,MapId)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_MapInfo,UDKUIDataProvider_MapInfo,PreviewImageMarkup)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_MapInfo)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_MenuOption,UDKUIDataProvider_MenuOption,OptionType)
VERIFY_CLASS_OFFSET_NODIE(UUDKUIDataProvider_MenuOption,UDKUIDataProvider_MenuOption,RangeData)
VERIFY_CLASS_SIZE_NODIE(UUDKUIDataProvider_MenuOption)
VERIFY_CLASS_SIZE_NODIE(AUDKVehicleBase)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicle,UDKVehicle,RemainingBurn)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicle,UDKVehicle,HoverboardDust)
VERIFY_CLASS_SIZE_NODIE(AUDKVehicle)
VERIFY_CLASS_OFFSET_NODIE(AUDKWeaponPawn,UDKWeaponPawn,MyVehicle)
VERIFY_CLASS_OFFSET_NODIE(AUDKWeaponPawn,UDKWeaponPawn,MySeatIndex)
VERIFY_CLASS_SIZE_NODIE(AUDKWeaponPawn)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicleFactory,UDKVehicleFactory,VehicleClassPath)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicleFactory,UDKVehicleFactory,TeamNum)
VERIFY_CLASS_SIZE_NODIE(AUDKVehicleFactory)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicleMovementEffect,UDKVehicleMovementEffect,AirEffect)
VERIFY_CLASS_OFFSET_NODIE(AUDKVehicleMovementEffect,UDKVehicleMovementEffect,AirCurrentLevel)
VERIFY_CLASS_SIZE_NODIE(AUDKVehicleMovementEffect)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimCar,UDKVehicleSimCar,TorqueVSpeedCurve)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimCar,UDKVehicleSimCar,InAirUprightMaxTorque)
VERIFY_CLASS_SIZE_NODIE(UUDKVehicleSimCar)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimChopper,UDKVehicleSimChopper,MaxThrustForce)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimChopper,UDKVehicleSimChopper,HardLimitAirSpeedScale)
VERIFY_CLASS_SIZE_NODIE(UUDKVehicleSimChopper)
VERIFY_CLASS_SIZE_NODIE(UUDKVehicleSimHover)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimHoverboard,UDKVehicleSimHoverboard,MaxThrustForce)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleSimHoverboard,UDKVehicleSimHoverboard,CurrentLookYaw)
VERIFY_CLASS_SIZE_NODIE(UUDKVehicleSimHoverboard)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleWheel,UDKVehicleWheel,OldWheelParticleComp)
VERIFY_CLASS_OFFSET_NODIE(UUDKVehicleWheel,UDKVehicleWheel,EffectDesiredSpinDir)
VERIFY_CLASS_SIZE_NODIE(UUDKVehicleWheel)
VERIFY_CLASS_OFFSET_NODIE(AUDKWeapon,UDKWeapon,OverlayMesh)
VERIFY_CLASS_OFFSET_NODIE(AUDKWeapon,UDKWeapon,AimingTraceIgnoredActors)
VERIFY_CLASS_SIZE_NODIE(AUDKWeapon)
VERIFY_CLASS_SIZE_NODIE(AUDKWeaponShield)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
