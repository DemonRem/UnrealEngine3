/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_TERRAIN_ENUMS
#define INCLUDED_ENGINE_TERRAIN_ENUMS 1

enum ETerrainComponentNeighbors
{
    TCN_NW                  =0,
    TCN_N                   =1,
    TCN_NE                  =2,
    TCN_W                   =3,
    TCN_E                   =4,
    TCN_SW                  =5,
    TCN_S                   =6,
    TCN_SE                  =7,
    TCN_MAX                 =8,
};
#define FOREACH_ENUM_ETERRAINCOMPONENTNEIGHBORS(op) \
    op(TCN_NW) \
    op(TCN_N) \
    op(TCN_NE) \
    op(TCN_W) \
    op(TCN_E) \
    op(TCN_SW) \
    op(TCN_S) \
    op(TCN_SE) 
enum ETerrainMappingType
{
    TMT_Auto                =0,
    TMT_XY                  =1,
    TMT_XZ                  =2,
    TMT_YZ                  =3,
    TMT_MAX                 =4,
};
#define FOREACH_ENUM_ETERRAINMAPPINGTYPE(op) \
    op(TMT_Auto) \
    op(TMT_XY) \
    op(TMT_XZ) \
    op(TMT_YZ) 

#endif // !INCLUDED_ENGINE_TERRAIN_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_TERRAIN_CLASSES
#define INCLUDED_ENGINE_TERRAIN_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FLandscapeLayerInfo
{
    FName LayerName;
    FLOAT Hardness;
    BITFIELD bNoWeightBlend:1;
    class UMaterialInstanceConstant* ThumbnailMIC;
    INT DebugColorChannel;

		// tor
		FLandscapeLayerInfo()
		:	LayerName(NAME_None)
		,	Hardness(0.5f)
		,	bNoWeightBlend(FALSE)
		,	ThumbnailMIC(NULL)
		,	DebugColorChannel(0)
		{}
		FLandscapeLayerInfo(FName InName)
		:	LayerName(InName)
		,	Hardness(0.5f)
		,	bNoWeightBlend(FALSE)
		,	ThumbnailMIC(NULL)
		,	DebugColorChannel(0)
		{}
		FLandscapeLayerInfo(FName InName, FLOAT InHardness, UBOOL InNoWeightBlend)
		:	LayerName(InName)
		,	Hardness(InHardness)
		,	bNoWeightBlend(InNoWeightBlend)
		,	ThumbnailMIC(NULL)
		,	DebugColorChannel(0)
		{}
	
};

struct FLandscapeWeightmapUsage
{
    class ULandscapeComponent* ChannelUsage[4];

		// tor
		FLandscapeWeightmapUsage()
		{
			ChannelUsage[0] = NULL;
			ChannelUsage[1] = NULL;
			ChannelUsage[2] = NULL;
			ChannelUsage[3] = NULL;
		}

		// Serializer
		friend FArchive& operator<<( FArchive& Ar, FLandscapeWeightmapUsage& U );

		INT FreeChannelCount() const
		{
			return	((ChannelUsage[0] == NULL) ? 1 : 0) + 
					((ChannelUsage[1] == NULL) ? 1 : 0) + 
					((ChannelUsage[2] == NULL) ? 1 : 0) + 
					((ChannelUsage[3] == NULL) ? 1 : 0);
		}
	
};

class ALandscape : public AInfo
{
public:
    //## BEGIN PROPS Landscape
    class UMaterialInterface* LandscapeMaterial;
    INT MaxLODLevel;
    TArrayNoInit<FName> LayerNames_DEPRECATED;
    TArrayNoInit<struct FLandscapeLayerInfo> LayerInfos;
    TMap< FString ,class UMaterialInstanceConstant* > MaterialInstanceConstantMap;
    FLightmassPrimitiveSettings LightmassSettings;
    INT StaticLightingResolution;
    FLOAT StreamingDistanceMultiplier;
    TArrayNoInit<class ULandscapeComponent*> LandscapeComponents;
    TArrayNoInit<class ULandscapeHeightfieldCollisionComponent*> CollisionComponents;
    TMap< QWORD,class ULandscapeComponent* > XYtoComponentMap;
    TMap< QWORD,class ULandscapeHeightfieldCollisionComponent* > XYtoCollisionComponentMap;
    TMap< UTexture2D*,struct FLandscapeWeightmapUsage > WeightmapUsageMap;
    struct FLandscapeDataInterface* DataInterface;
    INT ComponentSizeQuads;
    INT SubsectionSizeQuads;
    INT NumSubsections;
    //## END PROPS Landscape

    DECLARE_CLASS(ALandscape,AInfo,0,Engine)
	// Make a key for XYtoComponentMap
	static QWORD MakeKey( INT X, INT Y ) { return ((QWORD)(*(DWORD*)(&X)) << 32) | (*(DWORD*)(&Y) & 0xffffffff); }
	static void UnpackKey( QWORD Key, INT& OutX, INT& OutY ) { *(DWORD*)(&OutX) = (Key >> 32); *(DWORD*)(&OutY) = Key&0xffffffff; }

	// AActor interface
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
	virtual void ClearComponents();
	virtual void InitRBPhys();
#if WITH_EDITOR
	virtual void InitRBPhysEditor();

	// ALandscape interface
	UBOOL ImportFromOldTerrain(class ATerrain* OldTerrain);
	void Import(INT VertsX, INT VertsY, INT ComponentSizeQuads, INT NumSubsections, INT SubsectionSizeQuads, WORD* HeightData, TArray<FLandscapeLayerInfo> ImportLayerInfos, BYTE* AlphaDataPointers[] );
	struct FLandscapeDataInterface* GetDataInterface();
	void GetComponentsInRegion(INT X1, INT Y1, INT X2, INT Y2, TSet<ULandscapeComponent*>& OutComponents);
	UBOOL GetLandscapeExtent(INT& MinX, INT& MinY, INT& MaxX, INT& MaxY);
	void Export(TArray<FString>& Filenames);
	void DeleteLayer(FName LayerName);

	void UpdateDebugColorMaterial();

	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);
#endif
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void PostLoad();
};

struct FCachedTerrainMaterialArray
{
    TArrayNoInit<FTerrainMaterialResource*> CachedMaterials;

    /** Constructors */
    FCachedTerrainMaterialArray() {}
    FCachedTerrainMaterialArray(EEventParm)
    {
        appMemzero(this, sizeof(FCachedTerrainMaterialArray));
    }
};

class ATerrain : public AInfo
{
public:
    //## BEGIN PROPS Terrain
    TArrayNoInit<FTerrainHeight> Heights;
    TArrayNoInit<FTerrainInfoData> InfoData;
    TArrayNoInit<FTerrainLayer> Layers;
    INT NormalMapLayer;
    TArrayNoInit<FTerrainDecoLayer> DecoLayers;
    TArrayNoInit<FAlphaMap> AlphaMaps;
    TArrayNoInit<class UTerrainComponent*> TerrainComponents;
    INT NumSectionsX;
    INT NumSectionsY;
    TArrayNoInit<FTerrainWeightedMaterial> WeightedMaterials;
    TArrayNoInit<class UTerrainWeightMapTexture*> WeightedTextureMaps;
    INT MaxTesselationLevel;
    INT MinTessellationLevel;
    FLOAT TesselationDistanceScale;
    FLOAT TessellationCheckDistance;
    INT CollisionTesselationLevel;
    struct FCachedTerrainMaterialArray CachedTerrainMaterials[2];
    INT NumVerticesX;
    INT NumVerticesY;
    INT NumPatchesX;
    INT NumPatchesY;
    INT MaxComponentSize;
    INT StaticLightingResolution;
    BITFIELD bIsOverridingLightResolution:1;
    BITFIELD bBilinearFilterLightmapGeneration:1;
    BITFIELD bCastShadow:1;
    BITFIELD bForceDirectLightMap:1;
    BITFIELD bCastDynamicShadow:1;
    BITFIELD bEnableSpecular:1;
    BITFIELD bBlockRigidBody:1;
    BITFIELD bAllowRigidBodyUnderneath:1;
    BITFIELD bAcceptsDynamicLights:1;
    BITFIELD bMorphingEnabled:1;
    BITFIELD bMorphingGradientsEnabled:1;
    BITFIELD bLocked:1;
    BITFIELD bHeightmapLocked:1;
    BITFIELD bShowingCollision:1;
    BITFIELD bUseWorldOriginTextureUVs:1;
    BITFIELD bShowWireframe:1;
    class UPhysicalMaterial* TerrainPhysMaterialOverride;
    FLightingChannelContainer LightingChannels;
    FLightmassPrimitiveSettings LightmassSettings;
    FRenderCommandFence* ReleaseResourcesFence;
    INT EditorTessellationLevel;
    TArrayNoInit<FSelectedTerrainVertex> SelectedVertices;
    FColor WireframeColor;
    FGuid LightingGuid;
    //## END PROPS Terrain

    void CalcLayerBounds();
    DECLARE_FUNCTION(execCalcLayerBounds)
    {
        P_FINISH;
        this->CalcLayerBounds();
    }
    DECLARE_CLASS(ATerrain,AInfo,0,Engine)
    // UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PreEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);

protected:
	void HandleLegacyTextureReferences();
public:

	virtual void PostLoad();

	/**
	 * @return		Sum of the size of textures referenced by this material.
	 */
	virtual INT GetResourceSize();

	/**
	 *	Called before the Actor is saved.
	 */
	virtual void PreSave();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	virtual void ClearWeightMaps();
	virtual void TouchWeightMapResources();

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	// AActor interface

	virtual void Spawned();
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();

	/**
	 * Function that is called from CheckForErrors - specifically checks for material errors.
	 */
	void CheckForMaterialErrors();
#endif
	virtual void ClearComponents();

	/** Called by the lighting system to allow actors to order their components for deterministic lighting */
	virtual void OrderComponentsForDeterministicLighting();

protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
	virtual void UpdatePatchBounds(INT MinX,INT MinY,INT MaxX,INT MaxY);

	void WeldEdgesToOtherTerrains();

	virtual UBOOL ActorLineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// CompactAlphaMaps - Cleans up alpha maps that are no longer used.

	void CompactAlphaMaps();

	// CacheWeightMaps - Generates the weightmaps from the layer stack and filtered materials.

	void CacheWeightMaps(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// CacheDecorations - Generates a set of decoration components for an area of the terrain.
	void CacheDecorations(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// UpdateRenderData - Updates the weightmaps, displacements, decorations, vertex buffers and bounds when the heightmap, an alphamap or a terrain property changes.
	void UpdateRenderData(INT MinX,INT MinY,INT MaxX,INT MaxY);

	/** updates decoration components to account for terrain/layer property changes */
	void UpdateDecorationComponents();

	/** Clamps the vertex index to a valid vertex index (0 to NumVerticesX - 1, 0 to NumVerticesY - 1) that can be used to address the vertex collection.
	 * An invalid vertex index is something like (-1,-1) which would cause an array out of bounds exception.
	 *
	 * @param	OutX	The clamped X coordinate.
	 * @param	OutY	The clamped Y coordinate.
	 */
	void ClampVertexIndex(INT& OutX, INT& OutY) const;

	/**
	 * Allocates and initializes resolution dependent persistent data. (height-map, alpha-map, components)
	 * Keeps the old height-map and alpha-map data, cropping and extending as necessary.
	 * Uses DesiredSizeX, DesiredSizeY to determine the desired resolution.
	 * DesiredSectionSize determines the size of the components the terrain is split into.
	 */
	void Allocate();

	/**
	  * Recreates all the components
	  */
	void RecreateComponents();

	/**
	 *	Split a terrain along the X or Y axis
	 *	Returns the new terrain if successful
	 */
	ATerrain* SplitTerrain( UBOOL SplitOnXAxis, INT RemainingPatches );
	void SplitTerrainPreview( class FPrimitiveDrawInterface* PDI, UBOOL SplitOnXAxis, INT RemainingPatches );

	/**
	 *	Merges this terrain with another specified terrain if possible
	 *	Returns success TRUE/FALSE
	 */
	UBOOL MergeTerrain( ATerrain* Other );
	UBOOL MergeTerrainPreview( class FPrimitiveDrawInterface* PDI, ATerrain* Other );

	/**
	 *	Add or remove sectors to the terrain
	 *
	 *	@param	CountX		The number of sectors in the X-direction. If negative,
	 *						they will go to the left, otherwise to the right.
	 *	@param	CountY		The number of sectors in the Y-direction. If negative,
	 *						they will go to the bottom, otherwise to the top.
	 *	@param	bRemove		If TRUE, remove the sectors, otherwise add them.
	 *
	 *	@return	UBOOL		TRUE if successful.
	 */
	UBOOL AddRemoveSectors(INT CountX, INT CountY, UBOOL bRemove);

	// Internal functions for adding/removing sectos
	void StoreOldData(TArray<FTerrainHeight>& OldHeights, TArray<FTerrainInfoData>& OldInfoData, TArray<FAlphaMap>& OldAlphaMaps);
	void SetupSizeData();
	UBOOL AddSectors_X(INT Count);
	UBOOL AddSectors_Y(INT Count);
	UBOOL RemoveSectors_X(INT Count);
	UBOOL RemoveSectors_Y(INT Count);

	// Data access.

	//
	//	ATerrain::Height
	//
	inline const WORD& Height(INT X,INT Y) const
	{
		X = Clamp(X,0,NumVerticesX - 1);
		Y = Clamp(Y,0,NumVerticesY - 1);
		return Heights(Y * NumVerticesX + X).Value;
	}

	//
	//	ATerrain::Height
	//
	inline WORD& Height(INT X,INT Y)
	{
		X = Clamp(X,0,NumVerticesX - 1);
		Y = Clamp(Y,0,NumVerticesY - 1);
		return Heights(Y * NumVerticesX + X).Value;
	}

	inline WORD BilinearHeight(FLOAT fX,FLOAT fY)
	{
		INT X = appFloor(fX);
		INT Y = appFloor(fY);
		FLOAT tx = fX - (FLOAT)X;
		FLOAT ty = fY - (FLOAT)Y;

		return appRound(
				Lerp(
				Lerp( (FLOAT)Height(X,Y), (FLOAT)Height(X+1,Y), tx),
				Lerp( (FLOAT)Height(X,Y+1), (FLOAT)Height(X+1,Y+1), tx),
				ty) );
	}

	inline FTerrainInfoData* GetInfoData(INT X, INT Y)
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline const FTerrainInfoData* GetInfoData(INT X, INT Y) const
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline UBOOL IsTerrainQuadVisible(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsVisible();
	}

	inline UBOOL IsTerrainQuadFlipped(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsOrientationFlipped();
	}

	/**
	 *	Returns TRUE is the component at the given X,Y has ANY patches contained in are visible.
	 */
	UBOOL IsTerrainComponentVisible(INT InBaseX, INT InBaseY, INT InSizeX, INT InSizeY);
	UBOOL IsTerrainComponentVisible(UTerrainComponent* InComponent);

	FVector GetLocalVertex(INT X,INT Y) const; // Returns a vertex in actor-local space.
	FVector GetWorldVertex(INT X,INT Y) const; // Returns a vertex in world space.

	FTerrainPatch GetPatch(INT X,INT Y) const;
	FVector GetCollisionVertex(const FTerrainPatch& Patch,UINT PatchX,UINT PatchY,UINT SubX,UINT SubY,UINT TesselationLevel) const;

	BYTE Alpha(INT AlphaMapIndex,INT X,INT Y) const;		// If AlphaMapIndex == INDEX_NONE, returns 0.
	BYTE& Alpha(INT& AlphaMapIndex,INT X,INT Y);			// If AlphaMapIndex == INDEX_NONE, creates a new alphamap and places the index in AlphaMapIndex.

	/**
	* Returns a cached terrain material containing a given set of weighted materials.
	* Generates a new entry if not found
	*
	* @param Mask - bitmask combination of weight materials to be used
	* @param bIsTerrainResource - [out] TRUE if the material resource returned is a terrain material, FALSE if fallback
	* @return terrain material resource render proxy or error material render proxy
	*/
	FMaterialRenderProxy* GetCachedMaterial(const FTerrainMaterialMask& Mask, UBOOL& bIsTerrainResource);

	/**
	* Creates new cached terrain material entry if it doesn't exist for the given mask
	*
	* @param Mask - bitmask combination of weight materials to be used
	* @param MatPlatform - EMaterialShaderPlatform material platform to generate cached entries for
	* @return new terrain material resource
	*/
	FTerrainMaterialResource* GenerateCachedMaterial(const FTerrainMaterialMask& Mask, EMaterialShaderPlatform MatPlatform);

	/**
	 *	RetrieveReleaseResourcesFence
	 *
	 *	This function will grab the ReleaseResourcesFence.
	 *	If it is NULL, it will create one.
	 *	Should be used when a fence is required.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* RetrieveReleaseResourcesFence()
	{
		if (ReleaseResourcesFence == NULL)
		{
			ReleaseResourcesFence = ::new FRenderCommandFence();
			check(ReleaseResourcesFence);
		}
		return ReleaseResourcesFence;
	}

	/**
	 *	GetReleaseResourcesFence
	 *
	 *	This function will grab the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* GetReleaseResourcesFence()
	{
		return ReleaseResourcesFence;
	}

	/**
	 *	FreeReleaseResourcesFence
	 *
	 *	This function will free the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	void FreeReleaseResourcesFence()
	{
		if (ReleaseResourcesFence != NULL)
		{
			delete ReleaseResourcesFence;
			ReleaseResourcesFence = NULL;
		}
	}

	/**
	 *	MaterialUpdateCallback
	 *
	 *	Called when materials are edited to propagate the change to terrain materials.
	 *
	 *	@param	InMaterial		The material that was edited.
	 *
	 */
	static void MaterialUpdateCallback(UMaterial* InMaterial);

	/**
	 *	BuildCollisionData
	 *
	 *	Helper function to force the re-building of the collision date.
	 */
	void BuildCollisionData();

	/**
	 *	RecacheMaterials
	 *
	 *	Helper function that tosses the cached materials and regenerates them.
	 */
	void RecacheMaterials();

	/**
	 *	UpdateLayerSetup
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to update.
	 */
	void UpdateLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	RemoveLayerSetup
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to remove.
	 */
	void RemoveLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	UpdateTerrainMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to update.
	 */
	void UpdateTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	RemoveTerrainMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to Remove.
	 */
	void RemoveTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	UpdateMaterialInstance
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMatInst	The material instance to update.
	 */
	void UpdateMaterialInstance(UMaterialInterface* InMatInst);

	/**
	 *	UpdateCachedMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMat		The material instance to update.
	 */
	void UpdateCachedMaterial(UMaterial* InMat);

	/**
	 *	RemoveCachedMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InMat		The material instance to remove.
	 */
	void RemoveCachedMaterial(UMaterial* InMat);

	/**
	 *	Tessellate the terrain up in detail
	 *	Also used for converting old terrain to the new hi-res model
	 *
	 *	REQUIRES UPDATING TERRAIN MATERIAL MAPPING SCALES BY HAND!
	 *
	 *	@param	InTessellationlevel		The tessellation level to increase it to
	 *
	 *	@return	UBOOL					TRUE if successful
	 */
	UBOOL TessellateTerrainUp(INT InTessellationlevel = 2, UBOOL bRegenerateComponents = TRUE);

	/**
	 *	Tessellate the terrain down in detail.
	 *	Will remove patches while retaining the 'shape' of the terrain.
	 *
	 *	REQUIRES UPDATING TERRAIN MATERIAL MAPPING SCALES BY HAND!
	 */
	UBOOL TessellateTerrainDown();

	/**
	 *	GetClosestVertex
	 *
	 *	Determine the vertex that is closest to the given location.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);

	/**
	 *	GetClosestLocalSpaceVertex
	 *
	 *	Determine the vertex that is closest to the given location in local space.
	 *	The returned position is also in local space.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestLocalSpaceVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);

	/**
	 *	ShowCollisionCallback
	 *
	 *	Called when SHOW terrain collision is toggled.
	 *
	 *	@param	bShow		Whether to show it or not.
	 *
	 */
	static void ShowCollisionCallback(UBOOL bShow);

	/**
	 *	Show/Hide terrain collision overlay
	 *
	 *	@param	bShow				Show or hide
	 */
	void ShowCollisionOverlay(UBOOL bShow);

	/**
	 *	Update the given selected vertex in the list.
	 *	If the vertex is not present, then add it to the list (provided Weight > 0)
	 *
	 *	@param	X
	 *	@param	Y
	 *	@param	Weight
	 *
	 */
	void UpdateSelectedVertex(INT X, INT Y, FLOAT Weight);

	/**
	 *	Internal function for getting a selected vertex from the list
	 */
	INT FindSelectedVertexInList(INT X, INT Y, FSelectedTerrainVertex*& SelectedVert);

	/**
	 *	Clear all selected vertices
	 */
	void ClearSelectedVertexList();

	/**
	 *	Retrieve the component(s) that contain the given vertex point
	 *	The components will be added (using AddUniqueItem) to the supplied array.
	 *
	 *	@param	X				The X position of interest
	 *	@param	Y				The Y position of interest
	 *	@param	ComponentList	The array to add found components to
	 *
	 *	@return	UBOOL			TRUE if any components were found.
	 *							FALSE if none were found
	 */
	UBOOL GetComponentsAtXY(INT X, INT Y, TArray<UTerrainComponent*>& ComponentList);

	/**
	 *	Recache the visibility flags - used when changing tessellation levels.
	 */
	void RecacheVisibilityFlags();

	/**
	* Get the array of cached terrain material resource for the shader platform
	*
	* @param MatShaderPlatform - material platform for compiled shader code
	* @param MaterialIdx - index of layer material
	* @param ref to the array of cached terrain materials
	*/
	FORCEINLINE TArrayNoInit<FTerrainMaterialResource*>& GetCachedTerrainMaterials(EMaterialShaderPlatform MatShaderPlatform)
	{
		checkSlow(MatShaderPlatform < MSP_MAX);
		return CachedTerrainMaterials[MatShaderPlatform].CachedMaterials;
	}

	/**
	* Delete the entries in the cached terrain materials
	*/
	void ClearCachedTerrainMaterials( UBOOL bOtherShaderPlatformsOnly = FALSE );

	/**
	* Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	*
	* @param ShaderPlatform - platform to compile for
	* @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	* @param bForceAllPlatforms - compile for all platforms, not just the current.
	*/
	void CacheResourceShaders(EShaderPlatform ShaderPlatform, UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bForceAllPlatforms=FALSE);
};

struct FWeightmapLayerAllocationInfo
{
    FName LayerName;
    BYTE WeightmapTextureIndex;
    BYTE WeightmapTextureChannel;
    SCRIPT_ALIGN;

		FWeightmapLayerAllocationInfo(FName InLayerName)
		:	LayerName(InLayerName)
		,	WeightmapTextureIndex(255)	// Indicates an invalid allocation
		,	WeightmapTextureChannel(255)
		{}
	
};

class ULandscapeComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LandscapeComponent
    INT SectionBaseX;
    INT SectionBaseY;
    INT ComponentSizeQuads;
    INT SubsectionSizeQuads;
    INT NumSubsections;
    class UMaterialInstanceConstant* MaterialInstance;
    TArrayNoInit<struct FWeightmapLayerAllocationInfo> WeightmapLayerAllocations;
    TArrayNoInit<class UTexture2D*> WeightmapTextures;
    FVector4 WeightmapScaleBias;
    FLOAT WeightmapSubsectionOffset;
    FVector4 HeightmapScaleBias;
    FLOAT HeightmapSubsectionOffset;
    FVector2D LayerUVPan;
    class UTexture2D* HeightmapTexture;
    FBoxSphereBounds CachedBoxSphereBounds;
    INT StaticLightingResolution;
    FGuid LightingGuid;
    TArrayNoInit<class UShadowMap2D*> ShadowMaps;
    TArrayNoInit<FGuid> IrrelevantLights;
    FLightMapRef LightMap;
    struct FLandscapeEditToolRenderData* EditToolRenderData;
    INT CollisionMipLevel;
    class ULandscapeComponent* Neighbors[8];
    //## END PROPS LandscapeComponent

    DECLARE_CLASS(ULandscapeComponent,UPrimitiveComponent,0,Engine)
	// UObject interface
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
#if WITH_EDITOR
	virtual void PostLoad();
	virtual void PostEditImport();

	// Register ourselves with the actor.
	void SetupActor();
#endif

	// UPrimitiveComponent interface
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;
	virtual void UpdateBounds();
	void SetParentToWorld(const FMatrix& ParentToWorld);

#if WITH_EDITOR
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	virtual UBOOL GetLightMapResolution( INT& Width, INT& Height ) const;
	virtual void GetStaticTriangles(FPrimitiveTriangleDefinitionInterface* PTDI) const;
#endif
	virtual void InvalidateLightingCache();
	/**
	 *	Requests whether the component will use texture, vertex or no lightmaps.
	 *
	 *	@return	ELightMapInteractionType		The type of lightmap interaction the component will use.
	 */
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Texture;	}
	virtual void GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

	// ULandscapeComponent Interface

	/** Return's the landscape actor associated with this component. */
	class ALandscape* GetLandscapeActor() const
	{
		return CastChecked<ALandscape>(GetOuter());
	}

#if WITH_EDITOR
	/** Initialize the landscape component */
	void Init(INT InBaseX,INT InBaseY,INT InComponentSizeQuads, INT InNumSubsections,INT InSubsectionSizeQuads);

	/**
	 * Recalculate cached bounds using height values.
	 */
	void UpdateCachedBounds();

	/**
	 * Update the MaterialInstance parameters to match the layer and weightmaps for this component
	 * Creates the MaterialInstance if it doesn't exist.
	 */
	void UpdateMaterialInstances();

	/**
	 * Generate mipmaps for height and tangent data.
	 * @param HeightmapTextureMipData - array of pointers to the locked mip data. 
	 *           This should only include the mips that are generated directly from this component's data
	 *           ie where each subsection has at least 2 vertices.
	 */
	void GenerateHeightmapMips(TArray<FColor*>& HeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT,struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);

	/**
	 * Generates empty mipmaps for weightmap
	 */
	static void ULandscapeComponent::CreateEmptyWeightmapMips(UTexture2D* WeightmapTexture);

	/**
	 * Generate mipmaps for weightmap
	 * Assumes all weightmaps are unique to this component.
	 * @param WeightmapTextureBaseMipData: array of pointers to each of the weightmaps' base locked mip data.
	 */
	static void GenerateWeightmapMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, FColor* BaseMipData);

	/**
	 * Update mipmaps for existing weightmap texture
	 */
	static void UpdateWeightmapMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, TArray<FColor*>& WeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);

	/**
	 * Creates or updates collision component
	 * @param HeightmapTextureMipData: heightmap data
	 * @param ComponentX1, ComponentY1, ComponentX2, ComponentY2: region to update
	 * @param Whether to update bounds from render component.
	 */
	void UpdateCollisionComponent(FColor* HeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, UBOOL bUpdateBounds=FALSE);

	/**
	 * Creates weightmaps for this component for the layers specified in the WeightmapLayerAllocations array
	 */
	void ReallocateWeightmaps(struct FLandscapeEditDataInterface* DataInterface=NULL);

	/**
	 * Generate a key for this component's layer allocations to use with MaterialInstanceConstantMap.
	 */
	FString GetLayerAllocationKey() const;
	FString GetLayerDebugColorKey(INT& R, INT& G, INT& B) const;

#endif

	friend class FLandscapeComponentSceneProxy;
	friend struct FLandscapeComponentDataInterface;
};

class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LandscapeHeightfieldCollisionComponent
    FWordBulkData CollisionHeightData;
    INT SectionBaseX;
    INT SectionBaseY;
    INT CollisionSizeQuads;
    FLOAT CollisionScale;
    TArrayNoInit<BYTE> CollisionQuadFlags;
    TArrayNoInit<class UPhysicalMaterial*> PhysicalMaterials;
    class NxHeightField* RBHeightfield;
    FBoxSphereBounds CachedBoxSphereBounds;
    //## END PROPS LandscapeHeightfieldCollisionComponent

    DECLARE_CLASS(ULandscapeHeightfieldCollisionComponent,UPrimitiveComponent,0,Engine)
	enum ECollisionQuadFlags
	{
		QF_PhysicalMaterialMask = 63,	// Mask value for the physical material index, stored in the lower 6 bits.
		QF_EdgeTurned = 64,				// This quad's diagonal has been turned.
		QF_NoCollision = 128,			// This quad has no collision.
	};

	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach(UBOOL bWillReattach);

	// UPrimitiveComponent interface.
	virtual void UpdateBounds();
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void InitComponentRBPhys(UBOOL bFixed);
	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual UBOOL LineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// UObject Interface
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
#if WITH_EDITOR
	virtual void ExportCustomProperties(FOutputDevice& Out, UINT Indent);
	virtual void ImportCustomProperties(const TCHAR* SourceText, FFeedbackContext* Warn);
	virtual void PostLoad();
	virtual void PostEditImport();

	// Register ourselves with the actor.
	void SetupActor();
#endif

	/** Return's the landscape actor associated with this component. */
	class ALandscape* GetLandscapeActor() const
	{
		return CastChecked<ALandscape>(GetOuter());
	}

	/** Recreate heightfield and restart physics */
	void RecreateHeightfield();
};

class UTerrainComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS TerrainComponent
    TArrayNoInit<class UShadowMap2D*> ShadowMaps;
    TArrayNoInit<FGuid> IrrelevantLights;
    struct FTerrainObject* TerrainObject;
    INT SectionBaseX;
    INT SectionBaseY;
    INT SectionSizeX;
    INT SectionSizeY;
    INT TrueSectionSizeX;
    INT TrueSectionSizeY;
    FLightMapRef LightMap;
    TArrayNoInit<FTerrainPatchBounds> PatchBounds;
    TArrayNoInit<FTerrainMaterialMask> BatchMaterials;
    INT FullBatch;
    FTerrainBVTree BVTree;
    TArrayNoInit<FVector> CollisionVertices;
    class NxHeightField* RBHeightfield;
    BITFIELD bDisplayCollisionLevel:1;
    SCRIPT_ALIGN;
    //## END PROPS TerrainComponent

    DECLARE_CLASS(UTerrainComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Builds the collision data for this terrain
	 */
	void BuildCollisionData(void);

	/**
	 * @return Whether or not the collision data for this component is dirty.
	 */
	UBOOL IsCollisionDataDirty() const
	{
		// @todo: Replace this with a proper flag, this is only a stub function right now.

		return TRUE;
	}

	// UObject interface.

	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void PostLoad();
	virtual void FinishDestroy();
	/**
	* @return		Sum of the size of textures referenced by this material.
	*/
	virtual INT GetResourceSize();

	/**
	 * Rebuilds the collision data for saving
	 */
	virtual void PreSave(void);

	// UPrimitiveComponent interface.

	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual UBOOL LineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);
	virtual void UpdateBounds();
	
	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	virtual void InitComponentRBPhys(UBOOL bFixed);

	/**
	 * Returns the MAX number of triangle this component will render.
	 *
	 *	@return	UINT		Maximum number of triangle that could be rendered.
	 */
	virtual UINT GetMaxTriangleCount( ) const;

	/**
	 * Returns the lightmap resolution used for this primivite instnace in the case of it supporting texture light/ shadow maps.
	 * 0 if not supported or no static shadowing.
	 *
	 * @param	Width	[out]	Width of light/shadow map
	 * @param	Height	[out]	Height of light/shadow map
	 *
	 * @return	UBOOL			TRUE if LightMap values are padded, FALSE if not
	 */
	virtual UBOOL GetLightMapResolution( INT& Width, INT& Height ) const;

	/**
	 *	Returns the static lightmap resolution used for this primitive.
	 *	0 if not supported or no static shadowing.
	 *
	 * @return	INT		The StaticLightmapResolution for the component
	 */
	virtual INT GetStaticLightMapResolution() const;

	/**
	 * Returns the light and shadow map memory for this primite in its out variables.
	 *
	 * Shadow map memory usage is per light whereof lightmap data is independent of number of lights, assuming at least one.
	 *
	 * @param [out] LightMapMemoryUsage		Memory usage in bytes for light map (either texel or vertex) data
	 * @param [out]	ShadowMapMemoryUsage	Memory usage in bytes for shadow map (either texel or vertex) data
	 */
	virtual void GetLightAndShadowMapMemoryUsage( INT& LightMapMemoryUsage, INT& ShadowMapMemoryUsage ) const;

	friend struct FTerrainObject;
	friend class FTerrainComponentSceneProxy;

	// UActorComponent interface.
protected:
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );

	/**
	* Only valid for cases when the primitive will be reattached
	* @return	TRUE if the base primitive component should handle reattaching decals when the primitive is attached
	*/
	virtual UBOOL AllowDecalAutomaticReAttach() const
	{
		// always detach decals for terrain since we trigger a manual reattach
		return FALSE;
	}

public:
	virtual void InvalidateLightingCache();

	// UPrimitiveComponent interface.
	virtual void GenerateDecalRenderData(class FDecalState* Decal, TArray< FDecalRenderData* >& OutDecalRenderDatas) const;
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	/**
	 *	Requests whether the component will use texture, vertex or no lightmaps.
	 *
	 *	@return	ELightMapInteractionType		The type of lightmap interaction the component will use.
	 */
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Texture;	}
	virtual void GetStaticTriangles(FPrimitiveTriangleDefinitionInterface* PTDI) const;
	virtual void GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

	// Init

	void Init(INT InBaseX,INT InBaseY,INT InSizeX,INT InSizeY,INT InTrueSizeX,INT InTrueSizeY);

	// UpdatePatchBounds

	void UpdatePatchBounds();

	/** builds/updates a list of unique blended material combinations used by quads in this terrain section and puts them in the PatchBatches array.
	 * Also updates FullBatch with the index of the mask for the full set.
	 */
	void UpdatePatchBatches();

	/** Return's the terrain actor associated with the terrain component. */
	class ATerrain* GetTerrain() const
	{
		return CastChecked<ATerrain>(GetOuter());
	}

	/** Returns a vertex in the component's local space. */
	FVector GetLocalVertex(INT X,INT Y) const;

	/** Returns a vertex in the component's local space. */
	FVector GetWorldVertex(INT X,INT Y) const;

	// 
	void RenderPatches(const FSceneView* View,FPrimitiveDrawInterface* PDI);

	/**
	 * Gets the terrain collision data needed to pass to Novodex or to the
	 * kDOP code. Note: this code generates vertices/indices based on the
	 * Terrain->CollisionTessellationLevel
	 *
	 * @param OutVertices		[out] The array that gets each vert in the terrain
	 * @param OutIndices		[out] The array that holds the generated indices
	 */
	void GetCollisionData(TArray<FVector>& OutVertices,TArray<INT>& OutIndices) const;

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	UINT GetTriangleCount();
	UINT GetTriangleCountForDecal( UDecalComponent * DecalComponent );
};

class UTerrainWeightMapTexture : public UTexture2D
{
public:
    //## BEGIN PROPS TerrainWeightMapTexture
    class ATerrain* ParentTerrain;
    TArrayNoInit<struct FTerrainWeightedMaterial*> WeightedMaterials;
    //## END PROPS TerrainWeightMapTexture

    DECLARE_CLASS(UTerrainWeightMapTexture,UTexture2D,0,Engine)
    // UObject interface
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	void Initialize(ATerrain* InTerrain);
	void UpdateData();
};

class UTerrainLayerSetup : public UObject
{
public:
    //## BEGIN PROPS TerrainLayerSetup
    TArrayNoInit<FTerrainFilteredMaterial> Materials;
    //## END PROPS TerrainLayerSetup

    DECLARE_CLASS(UTerrainLayerSetup,UObject,0,Engine)
	/** returns the alpha that should be used in the weighting for the given material in this layer at the given world vertex
	 * @param Material the filtered material that is being weighted
	 * @param WorldVertex the world location of the vertex
	 * @return the alpha to use for weighting
	 */
	virtual FLOAT GetMaterialAlpha(const FTerrainFilteredMaterial* Material, const FVector& WorldVertex) { return Material->Alpha; }

	// UObject interface.

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	/**
	 * Called after serialization. Ensures that there are only 64 materials.
	 */
	virtual void PostLoad();
};

class UTerrainMaterial : public UObject
{
public:
    //## BEGIN PROPS TerrainMaterial
    FMatrix LocalToMapping;
    BYTE MappingType;
    FLOAT MappingScale;
    FLOAT MappingRotation;
    FLOAT MappingPanU;
    FLOAT MappingPanV;
    class UMaterialInterface* Material;
    class UTexture2D* DisplacementMap;
    FLOAT DisplacementScale;
    //## END PROPS TerrainMaterial

    DECLARE_CLASS(UTerrainMaterial,UObject,0,Engine)
	// UpdateMappingTransform

	void UpdateMappingTransform();

	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_TERRAIN_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ATerrain,-1,execCalcLayerBounds);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_TERRAIN_NATIVE_DEFS
#define ENGINE_TERRAIN_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_TERRAIN \
	ALandscape::StaticClass(); \
	ATerrain::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Terrain"), GEngineATerrainNatives); \
	ULandscapeComponent::StaticClass(); \
	ULandscapeHeightfieldCollisionComponent::StaticClass(); \
	UTerrainComponent::StaticClass(); \
	UTerrainWeightMapTexture::StaticClass(); \
	UTerrainLayerSetup::StaticClass(); \
	UTerrainMaterial::StaticClass(); \

#endif // ENGINE_TERRAIN_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineATerrainNatives[] = 
{ 
	MAP_NATIVE(ATerrain, execCalcLayerBounds)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ALandscape,Landscape,LandscapeMaterial)
VERIFY_CLASS_OFFSET_NODIE(ALandscape,Landscape,NumSubsections)
VERIFY_CLASS_SIZE_NODIE(ALandscape)
VERIFY_CLASS_OFFSET_NODIE(ATerrain,Terrain,Heights)
VERIFY_CLASS_OFFSET_NODIE(ATerrain,Terrain,LightingGuid)
VERIFY_CLASS_SIZE_NODIE(ATerrain)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeComponent,LandscapeComponent,SectionBaseX)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeComponent,LandscapeComponent,Neighbors)
VERIFY_CLASS_SIZE_NODIE(ULandscapeComponent)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeHeightfieldCollisionComponent,LandscapeHeightfieldCollisionComponent,CollisionHeightData)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeHeightfieldCollisionComponent,LandscapeHeightfieldCollisionComponent,CachedBoxSphereBounds)
VERIFY_CLASS_SIZE_NODIE(ULandscapeHeightfieldCollisionComponent)
VERIFY_CLASS_OFFSET_NODIE(UTerrainComponent,TerrainComponent,ShadowMaps)
VERIFY_CLASS_OFFSET_NODIE(UTerrainComponent,TerrainComponent,RBHeightfield)
VERIFY_CLASS_SIZE_NODIE(UTerrainComponent)
VERIFY_CLASS_OFFSET_NODIE(UTerrainWeightMapTexture,TerrainWeightMapTexture,ParentTerrain)
VERIFY_CLASS_OFFSET_NODIE(UTerrainWeightMapTexture,TerrainWeightMapTexture,WeightedMaterials)
VERIFY_CLASS_SIZE_NODIE(UTerrainWeightMapTexture)
VERIFY_CLASS_OFFSET_NODIE(UTerrainLayerSetup,TerrainLayerSetup,Materials)
VERIFY_CLASS_SIZE_NODIE(UTerrainLayerSetup)
VERIFY_CLASS_OFFSET_NODIE(UTerrainMaterial,TerrainMaterial,LocalToMapping)
VERIFY_CLASS_OFFSET_NODIE(UTerrainMaterial,TerrainMaterial,DisplacementScale)
VERIFY_CLASS_SIZE_NODIE(UTerrainMaterial)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
