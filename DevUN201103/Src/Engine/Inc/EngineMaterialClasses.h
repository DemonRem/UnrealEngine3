/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_MATERIAL_ENUMS
#define INCLUDED_ENGINE_MATERIAL_ENUMS 1

enum ECustomMaterialOutputType
{
    CMOT_Float1             =0,
    CMOT_Float2             =1,
    CMOT_Float3             =2,
    CMOT_Float4             =3,
    CMOT_MAX                =4,
};
#define FOREACH_ENUM_ECUSTOMMATERIALOUTPUTTYPE(op) \
    op(CMOT_Float1) \
    op(CMOT_Float2) \
    op(CMOT_Float3) \
    op(CMOT_Float4) 
enum EDepthOfFieldFunctionValue
{
    TDOF_NearAndFarMask     =0,
    TDOF_NearMask           =1,
    TDOF_FarMask            =2,
    TDOF_MAX                =3,
};
#define FOREACH_ENUM_EDEPTHOFFIELDFUNCTIONVALUE(op) \
    op(TDOF_NearAndFarMask) \
    op(TDOF_NearMask) \
    op(TDOF_FarMask) 
enum ESceneTextureType
{
    SceneTex_Lighting       =0,
    SceneTex_MAX            =1,
};
#define FOREACH_ENUM_ESCENETEXTURETYPE(op) \
    op(SceneTex_Lighting) 
enum ETerrainCoordMappingType
{
    TCMT_Auto               =0,
    TCMT_XY                 =1,
    TCMT_XZ                 =2,
    TCMT_YZ                 =3,
    TCMT_MAX                =4,
};
#define FOREACH_ENUM_ETERRAINCOORDMAPPINGTYPE(op) \
    op(TCMT_Auto) \
    op(TCMT_XY) \
    op(TCMT_XZ) \
    op(TCMT_YZ) 
enum ETextureColorChannel
{
    TCC_Red                 =0,
    TCC_Green               =1,
    TCC_Blue                =2,
    TCC_Alpha               =3,
    TCC_MAX                 =4,
};
#define FOREACH_ENUM_ETEXTURECOLORCHANNEL(op) \
    op(TCC_Red) \
    op(TCC_Green) \
    op(TCC_Blue) \
    op(TCC_Alpha) 
enum EMaterialVectorCoordTransform
{
    TRANSFORM_World         =0,
    TRANSFORM_View          =1,
    TRANSFORM_Local         =2,
    TRANSFORM_Tangent       =3,
    TRANSFORM_MAX           =4,
};
#define FOREACH_ENUM_EMATERIALVECTORCOORDTRANSFORM(op) \
    op(TRANSFORM_World) \
    op(TRANSFORM_View) \
    op(TRANSFORM_Local) \
    op(TRANSFORM_Tangent) 
enum EMaterialVectorCoordTransformSource
{
    TRANSFORMSOURCE_World   =0,
    TRANSFORMSOURCE_Local   =1,
    TRANSFORMSOURCE_Tangent =2,
    TRANSFORMSOURCE_MAX     =3,
};
#define FOREACH_ENUM_EMATERIALVECTORCOORDTRANSFORMSOURCE(op) \
    op(TRANSFORMSOURCE_World) \
    op(TRANSFORMSOURCE_Local) \
    op(TRANSFORMSOURCE_Tangent) 
enum EMaterialPositionTransform
{
    TRANSFORMPOS_World      =0,
    TRANSFORMPOS_MAX        =1,
};
#define FOREACH_ENUM_EMATERIALPOSITIONTRANSFORM(op) \
    op(TRANSFORMPOS_World) 
enum EMaterialUsage
{
    MATUSAGE_SkeletalMesh   =0,
    MATUSAGE_FracturedMeshes=1,
    MATUSAGE_ParticleSprites=2,
    MATUSAGE_BeamTrails     =3,
    MATUSAGE_ParticleSubUV  =4,
    MATUSAGE_SpeedTree      =5,
    MATUSAGE_StaticLighting =6,
    MATUSAGE_GammaCorrection=7,
    MATUSAGE_LensFlare      =8,
    MATUSAGE_InstancedMeshParticles=9,
    MATUSAGE_FluidSurface   =10,
    MATUSAGE_Decals         =11,
    MATUSAGE_MaterialEffect =12,
    MATUSAGE_MorphTargets   =13,
    MATUSAGE_FogVolumes     =14,
    MATUSAGE_RadialBlur     =15,
    MATUSAGE_InstancedMeshes=16,
    MATUSAGE_SplineMesh     =17,
    MATUSAGE_ScreenDoorFade =18,
    MATUSAGE_APEXMesh       =19,
    MATUSAGE_Terrain        =20,
    MATUSAGE_Landscape      =21,
    MATUSAGE_MAX            =22,
};
#define FOREACH_ENUM_EMATERIALUSAGE(op) \
    op(MATUSAGE_SkeletalMesh) \
    op(MATUSAGE_FracturedMeshes) \
    op(MATUSAGE_ParticleSprites) \
    op(MATUSAGE_BeamTrails) \
    op(MATUSAGE_ParticleSubUV) \
    op(MATUSAGE_SpeedTree) \
    op(MATUSAGE_StaticLighting) \
    op(MATUSAGE_GammaCorrection) \
    op(MATUSAGE_LensFlare) \
    op(MATUSAGE_InstancedMeshParticles) \
    op(MATUSAGE_FluidSurface) \
    op(MATUSAGE_Decals) \
    op(MATUSAGE_MaterialEffect) \
    op(MATUSAGE_MorphTargets) \
    op(MATUSAGE_FogVolumes) \
    op(MATUSAGE_RadialBlur) \
    op(MATUSAGE_InstancedMeshes) \
    op(MATUSAGE_SplineMesh) \
    op(MATUSAGE_ScreenDoorFade) \
    op(MATUSAGE_APEXMesh) \
    op(MATUSAGE_Terrain) \
    op(MATUSAGE_Landscape) 

#endif // !INCLUDED_ENGINE_MATERIAL_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_MATERIAL_CLASSES
#define INCLUDED_ENGINE_MATERIAL_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UMaterialExpressionAbs : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAbs
    FExpressionInput Input;
    //## END PROPS MaterialExpressionAbs

    DECLARE_CLASS(UMaterialExpressionAbs,UMaterialExpression,0,Engine)
    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler );

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionAdd : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAdd
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAdd

    DECLARE_CLASS(UMaterialExpressionAdd,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionAppendVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAppendVector
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAppendVector

    DECLARE_CLASS(UMaterialExpressionAppendVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionBumpOffset : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionBumpOffset
    FExpressionInput Coordinate;
    FExpressionInput Height;
    FLOAT HeightRatio;
    FLOAT ReferencePlane;
    //## END PROPS MaterialExpressionBumpOffset

    DECLARE_CLASS(UMaterialExpressionBumpOffset,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCameraVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraVector
    //## END PROPS MaterialExpressionCameraVector

    DECLARE_CLASS(UMaterialExpressionCameraVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCameraWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraWorldPosition
    //## END PROPS MaterialExpressionCameraWorldPosition

    DECLARE_CLASS(UMaterialExpressionCameraWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCeil : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCeil
    FExpressionInput Input;
    //## END PROPS MaterialExpressionCeil

    DECLARE_CLASS(UMaterialExpressionCeil,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionClamp
    FExpressionInput Input;
    FExpressionInput Min;
    FExpressionInput Max;
    //## END PROPS MaterialExpressionClamp

    DECLARE_CLASS(UMaterialExpressionClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionComment : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComment
    INT PosX;
    INT PosY;
    INT SizeX;
    INT SizeY;
    FStringNoInit Text;
    //## END PROPS MaterialExpressionComment

    DECLARE_CLASS(UMaterialExpressionComment,UMaterialExpression,0,Engine)
	/**
	 * Text description of this expression.
	 */
	virtual FString GetCaption() const;

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionComponentMask : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComponentMask
    FExpressionInput Input;
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionComponentMask

    DECLARE_CLASS(UMaterialExpressionComponentMask,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCompound : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCompound
    TArrayNoInit<class UMaterialExpression*> MaterialExpressions;
    FStringNoInit Caption;
    BITFIELD bExpanded:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionCompound

    DECLARE_CLASS(UMaterialExpressionCompound,UMaterialExpression,0,Engine)
	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;
	
	/**
	 * Recursively gathers all UMaterialExpression objects referenced by this expression.
	 * Including self.
	 *
	 * @param	Expressions	- Reference to array of material expressions to add to
	 */	
	virtual void GetExpressions( TArray<const UMaterialExpression*>& Expressions ) const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionConstant : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant
    FLOAT R;
    //## END PROPS MaterialExpressionConstant

    DECLARE_CLASS(UMaterialExpressionConstant,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant2Vector
    FLOAT R;
    FLOAT G;
    //## END PROPS MaterialExpressionConstant2Vector

    DECLARE_CLASS(UMaterialExpressionConstant2Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant3Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    //## END PROPS MaterialExpressionConstant3Vector

    DECLARE_CLASS(UMaterialExpressionConstant3Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant4Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    FLOAT A;
    //## END PROPS MaterialExpressionConstant4Vector

    DECLARE_CLASS(UMaterialExpressionConstant4Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstantBiasScale
    FExpressionInput Input;
    FLOAT Bias;
    FLOAT Scale;
    //## END PROPS MaterialExpressionConstantBiasScale

    DECLARE_CLASS(UMaterialExpressionConstantBiasScale,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionConstantClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstantClamp
    FExpressionInput Input;
    FLOAT Min;
    FLOAT Max;
    //## END PROPS MaterialExpressionConstantClamp

    DECLARE_CLASS(UMaterialExpressionConstantClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCosine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCosine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionCosine

    DECLARE_CLASS(UMaterialExpressionCosine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCrossProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCrossProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionCrossProduct

    DECLARE_CLASS(UMaterialExpressionCrossProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

struct FCustomInput
{
    FStringNoInit InputName;
    FExpressionInput Input;

    /** Constructors */
    FCustomInput() {}
    FCustomInput(EEventParm)
    {
        appMemzero(this, sizeof(FCustomInput));
    }
};

class UMaterialExpressionCustom : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCustom
    FStringNoInit Code;
    BYTE OutputType;
    FStringNoInit Description;
    TArrayNoInit<struct FCustomInput> Inputs;
    //## END PROPS MaterialExpressionCustom

    DECLARE_CLASS(UMaterialExpressionCustom,UMaterialExpression,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	// UMaterialExpression interface
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	void SwapReferenceTo( UMaterialExpression* OldExpression, UMaterialExpression* NewExpression );
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;
};

class UMaterialExpressionCustomTexture : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCustomTexture
    class UTexture* Texture;
    //## END PROPS MaterialExpressionCustomTexture

    DECLARE_CLASS(UMaterialExpressionCustomTexture,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual INT CompilePreview(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedAlpha
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedAlpha

    DECLARE_CLASS(UMaterialExpressionDepthBiasedAlpha,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput RGB;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasedBlend,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 *	Get the outputs associated with the expression
	 *
	 *	@param	Outputs		The array that contains the output expression
	 */	
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthOfFieldFunction
    BYTE FunctionValue;
    SCRIPT_ALIGN;
    FExpressionInput Depth;
    //## END PROPS MaterialExpressionDepthOfFieldFunction

    DECLARE_CLASS(UMaterialExpressionDepthOfFieldFunction,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDeriveNormalZ
    FExpressionInput InXY;
    //## END PROPS MaterialExpressionDeriveNormalZ

    DECLARE_CLASS(UMaterialExpressionDeriveNormalZ,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDesaturation : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDesaturation
    FExpressionInput Input;
    FExpressionInput Percent;
    FLinearColor LuminanceFactors;
    //## END PROPS MaterialExpressionDesaturation

    DECLARE_CLASS(UMaterialExpressionDesaturation,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const
	{
		return TEXT("Desaturation");
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDestColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestColor
    //## END PROPS MaterialExpressionDestColor

    DECLARE_CLASS(UMaterialExpressionDestColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionDestDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestDepth
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionDestDepth

    DECLARE_CLASS(UMaterialExpressionDestDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDistance
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDistance

    DECLARE_CLASS(UMaterialExpressionDistance,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDivide : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDivide
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDivide

    DECLARE_CLASS(UMaterialExpressionDivide,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDotProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDotProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDotProduct

    DECLARE_CLASS(UMaterialExpressionDotProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDynamicParameter
    TArrayNoInit<FString> ParamNames;
    //## END PROPS MaterialExpressionDynamicParameter

    DECLARE_CLASS(UMaterialExpressionDynamicParameter,UMaterialExpression,0,Engine)
	// UObject interface.

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UMaterialExpression interface.

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler );

	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionMeshEmitterDynamicParameter : public UMaterialExpressionDynamicParameter
{
public:
    //## BEGIN PROPS MaterialExpressionMeshEmitterDynamicParameter
    //## END PROPS MaterialExpressionMeshEmitterDynamicParameter

    DECLARE_CLASS(UMaterialExpressionMeshEmitterDynamicParameter,UMaterialExpressionDynamicParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFloor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFloor
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFloor

    DECLARE_CLASS(UMaterialExpressionFloor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFluidNormal : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFluidNormal
    FExpressionInput Coordinates;
    //## END PROPS MaterialExpressionFluidNormal

    DECLARE_CLASS(UMaterialExpressionFluidNormal,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFmod : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFmod
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionFmod

    DECLARE_CLASS(UMaterialExpressionFmod,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFoliageImpulseDirection : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFoliageImpulseDirection
    //## END PROPS MaterialExpressionFoliageImpulseDirection

    DECLARE_CLASS(UMaterialExpressionFoliageImpulseDirection,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFoliageNormalizedRotationAxisAndAngle : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFoliageNormalizedRotationAxisAndAngle
    //## END PROPS MaterialExpressionFoliageNormalizedRotationAxisAndAngle

    DECLARE_CLASS(UMaterialExpressionFoliageNormalizedRotationAxisAndAngle,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFontSample
    class UFont* Font;
    INT FontTexturePage;
    //## END PROPS MaterialExpressionFontSample

    DECLARE_CLASS(UMaterialExpressionFontSample,UMaterialExpression,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	* List of outputs from this expression
	* @param Outputs - out list of expression
	*/
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	* Width of the thumbnail for this expression int he material editor
	* @return size in pixels
	*/
	virtual INT GetWidth() const;

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;

	/**
	* Padding for the text lable
	* @return size in pixels
	*/
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
public:
    //## BEGIN PROPS MaterialExpressionFontSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionFontSampleParameter

    DECLARE_CLASS(UMaterialExpressionFontSampleParameter,UMaterialExpressionFontSample,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;
	
	/**
	 *	Sets the default Font if none is set
	 */
	virtual void SetDefaultFont();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionFrac : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFrac
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFrac

    DECLARE_CLASS(UMaterialExpressionFrac,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFresnel : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFresnel
    FLOAT Exponent;
    FExpressionInput Normal;
    //## END PROPS MaterialExpressionFresnel

    DECLARE_CLASS(UMaterialExpressionFresnel,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const
	{
		return FString(TEXT("Fresnel"));
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionIf : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionIf
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput AGreaterThanB;
    FExpressionInput AEqualsB;
    FExpressionInput ALessThanB;
    //## END PROPS MaterialExpressionIf

    DECLARE_CLASS(UMaterialExpressionIf,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionLensFlareIntensity : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareIntensity
    //## END PROPS MaterialExpressionLensFlareIntensity

    DECLARE_CLASS(UMaterialExpressionLensFlareIntensity,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareOcclusion
    //## END PROPS MaterialExpressionLensFlareOcclusion

    DECLARE_CLASS(UMaterialExpressionLensFlareOcclusion,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRadialDistance
    //## END PROPS MaterialExpressionLensFlareRadialDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRadialDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRayDistance
    //## END PROPS MaterialExpressionLensFlareRayDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRayDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareSourceDistance
    //## END PROPS MaterialExpressionLensFlareSourceDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareSourceDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightmapUVs
    //## END PROPS MaterialExpressionLightmapUVs

    DECLARE_CLASS(UMaterialExpressionLightmapUVs,UMaterialExpression,0,Engine)
	// UMaterialExpression interface.
    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler );

	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;
};

class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightmassReplace
    FExpressionInput Realtime;
    FExpressionInput Lightmass;
    //## END PROPS MaterialExpressionLightmassReplace

    DECLARE_CLASS(UMaterialExpressionLightmassReplace,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionLightVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightVector
    //## END PROPS MaterialExpressionLightVector

    DECLARE_CLASS(UMaterialExpressionLightVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLinearInterpolate
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput Alpha;
    //## END PROPS MaterialExpressionLinearInterpolate

    DECLARE_CLASS(UMaterialExpressionLinearInterpolate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMeshEmitterVertexColor
    //## END PROPS MaterialExpressionMeshEmitterVertexColor

    DECLARE_CLASS(UMaterialExpressionMeshEmitterVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
};

class UMaterialExpressionMultiply : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMultiply
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionMultiply

    DECLARE_CLASS(UMaterialExpressionMultiply,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionNormalize : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionNormalize
    FExpressionInput VectorInput;
    //## END PROPS MaterialExpressionNormalize

    DECLARE_CLASS(UMaterialExpressionNormalize,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const { return TEXT("Normalize"); }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectOrientation
    //## END PROPS MaterialExpressionObjectOrientation

    DECLARE_CLASS(UMaterialExpressionObjectOrientation,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionObjectRadius : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectRadius
    //## END PROPS MaterialExpressionObjectRadius

    DECLARE_CLASS(UMaterialExpressionObjectRadius,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionObjectWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectWorldPosition
    //## END PROPS MaterialExpressionObjectWorldPosition

    DECLARE_CLASS(UMaterialExpressionObjectWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionOcclusionPercentage : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionOcclusionPercentage
    //## END PROPS MaterialExpressionOcclusionPercentage

    DECLARE_CLASS(UMaterialExpressionOcclusionPercentage,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler);
	
	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionOneMinus : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionOneMinus
    FExpressionInput Input;
    //## END PROPS MaterialExpressionOneMinus

    DECLARE_CLASS(UMaterialExpressionOneMinus,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionPanner : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPanner
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT SpeedX;
    FLOAT SpeedY;
    //## END PROPS MaterialExpressionPanner

    DECLARE_CLASS(UMaterialExpressionPanner,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return Time.Expression==NULL && (SpeedX != 0.f || SpeedY != 0.f); }
};

class UMaterialExpressionParameter : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionParameter

    DECLARE_CLASS(UMaterialExpressionParameter,UMaterialExpression,0,Engine)
	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionScalarParameter
    FLOAT DefaultValue;
    //## END PROPS MaterialExpressionScalarParameter

    DECLARE_CLASS(UMaterialExpressionScalarParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticComponentMaskParameter
    FExpressionInput Input;
    BITFIELD DefaultR:1;
    BITFIELD DefaultG:1;
    BITFIELD DefaultB:1;
    BITFIELD DefaultA:1;
    SCRIPT_ALIGN;
    const FStaticComponentMaskParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticComponentMaskParameter

    DECLARE_CLASS(UMaterialExpressionStaticComponentMaskParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif
};

class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticSwitchParameter
    BITFIELD DefaultValue:1;
    BITFIELD ExtendedCaptionDisplay:1;
    SCRIPT_ALIGN;
    FExpressionInput A;
    FExpressionInput B;
    const FStaticSwitchParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticSwitchParameter

    DECLARE_CLASS(UMaterialExpressionStaticSwitchParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif
};

class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionVectorParameter
    FLinearColor DefaultValue;
    //## END PROPS MaterialExpressionVectorParameter

    DECLARE_CLASS(UMaterialExpressionVectorParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionParticleMacroUV
    BITFIELD bUseViewSpace:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionParticleMacroUV

    DECLARE_CLASS(UMaterialExpressionParticleMacroUV,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPerInstanceRandom
    //## END PROPS MaterialExpressionPerInstanceRandom

    DECLARE_CLASS(UMaterialExpressionPerInstanceRandom,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionPixelDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPixelDepth
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionPixelDepth

    DECLARE_CLASS(UMaterialExpressionPixelDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual FString GetCaption() const;
};

class UMaterialExpressionPower : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPower
    FExpressionInput Base;
    FExpressionInput Exponent;
    //## END PROPS MaterialExpressionPower

    DECLARE_CLASS(UMaterialExpressionPower,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionReflectionVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionReflectionVector
    //## END PROPS MaterialExpressionReflectionVector

    DECLARE_CLASS(UMaterialExpressionReflectionVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionRotateAboutAxis
    FExpressionInput NormalizedRotationAxisAndAngle;
    FExpressionInput PositionOnAxis;
    FExpressionInput Position;
    //## END PROPS MaterialExpressionRotateAboutAxis

    DECLARE_CLASS(UMaterialExpressionRotateAboutAxis,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionRotator : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionRotator
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT Speed;
    //## END PROPS MaterialExpressionRotator

    DECLARE_CLASS(UMaterialExpressionRotator,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return Time.Expression==NULL && Speed != 0.f; }
};

class UMaterialExpressionSceneDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneDepth
    FExpressionInput Coordinates;
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionSceneDepth

    DECLARE_CLASS(UMaterialExpressionSceneDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionSceneTexture : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneTexture
    FExpressionInput Coordinates;
    BYTE SceneTextureType;
    SCRIPT_ALIGN;
    BITFIELD ScreenAlign:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionSceneTexture

    DECLARE_CLASS(UMaterialExpressionSceneTexture,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionScreenPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionScreenPosition
    BITFIELD ScreenAlign:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionScreenPosition

    DECLARE_CLASS(UMaterialExpressionScreenPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionSine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionSine

    DECLARE_CLASS(UMaterialExpressionSine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSphereMask : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSphereMask
    FExpressionInput A;
    FExpressionInput B;
    FLOAT AttenuationRadius;
    FLOAT HardnessPercent;
    //## END PROPS MaterialExpressionSphereMask

    DECLARE_CLASS(UMaterialExpressionSphereMask,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSquareRoot : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSquareRoot
    FExpressionInput Input;
    //## END PROPS MaterialExpressionSquareRoot

    DECLARE_CLASS(UMaterialExpressionSquareRoot,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSubtract : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSubtract
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionSubtract

    DECLARE_CLASS(UMaterialExpressionSubtract,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTerrainLayerCoords : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTerrainLayerCoords
    BYTE MappingType;
    FLOAT MappingScale;
    FLOAT MappingRotation;
    FLOAT MappingPanU;
    FLOAT MappingPanV;
    //## END PROPS MaterialExpressionTerrainLayerCoords

    DECLARE_CLASS(UMaterialExpressionTerrainLayerCoords,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTerrainLayerWeight : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTerrainLayerWeight
    const FStaticTerrainLayerWeightParameter* InstanceOverride;
    FExpressionInput Base;
    FExpressionInput Layer;
    FName ParameterName;
    FLOAT PreviewWeight;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionTerrainLayerWeight

    DECLARE_CLASS(UMaterialExpressionTerrainLayerWeight,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif
};

class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureCoordinate
    INT CoordinateIndex;
    FLOAT UTiling;
    FLOAT VTiling;
    BITFIELD UnMirrorU:1;
    BITFIELD UnMirrorV:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTextureCoordinate

    DECLARE_CLASS(UMaterialExpressionTextureCoordinate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSample
    class UTexture* Texture;
    FExpressionInput Coordinates;
    //## END PROPS MaterialExpressionTextureSample

    DECLARE_CLASS(UMaterialExpressionTextureSample,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Updates the material's cached reference to the resource for a given texture.
	 * @param Texture - The UTexture which has a new FTexture.
	 */
	void UpdateTextureResource(class UTexture* Texture);

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionDepthBiasBlend : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasBlend,UMaterialExpressionTextureSample,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler);

	/**
	 *	Get the outputs associated with the expression
	 *
	 *	@param	Outputs		The array that contains the output expression
	 */	
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFlipBookSample : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionFlipBookSample
    //## END PROPS MaterialExpressionFlipBookSample

    DECLARE_CLASS(UMaterialExpressionFlipBookSample,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionMeshSubUV
    //## END PROPS MaterialExpressionMeshSubUV

    DECLARE_CLASS(UMaterialExpressionMeshSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionMeshSubUVBlend : public UMaterialExpressionMeshSubUV
{
public:
    //## BEGIN PROPS MaterialExpressionMeshSubUVBlend
    //## END PROPS MaterialExpressionMeshSubUVBlend

    DECLARE_CLASS(UMaterialExpressionMeshSubUVBlend,UMaterialExpressionMeshSubUV,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionParticleSubUV
    //## END PROPS MaterialExpressionParticleSubUV

    DECLARE_CLASS(UMaterialExpressionParticleSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionTextureSampleParameter

    DECLARE_ABSTRACT_CLASS(UMaterialExpressionTextureSampleParameter,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter2D
    //## END PROPS MaterialExpressionTextureSampleParameter2D

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameter2D,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionAntialiasedTextureMask
    FLOAT Threshold;
    BYTE Channel;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionAntialiasedTextureMask

    DECLARE_CLASS(UMaterialExpressionAntialiasedTextureMask,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	virtual void SetDefaultTexture();

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTextureSampleParameterMeshSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMeshSubUV
    //## END PROPS MaterialExpressionTextureSampleParameterMeshSubUV

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMeshSubUV,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterMeshSubUVBlend : public UMaterialExpressionTextureSampleParameterMeshSubUV
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMeshSubUVBlend
    //## END PROPS MaterialExpressionTextureSampleParameterMeshSubUVBlend

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMeshSubUVBlend,UMaterialExpressionTextureSampleParameterMeshSubUV,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterSubUV
    //## END PROPS MaterialExpressionTextureSampleParameterSubUV

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterSubUV,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterCube
    //## END PROPS MaterialExpressionTextureSampleParameterCube

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterCube,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionTextureSampleParameterMovie : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMovie
    //## END PROPS MaterialExpressionTextureSampleParameterMovie

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMovie,UMaterialExpressionTextureSampleParameter,0,Engine)
	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Return true if the texture is a movie texture
	 *
	 * @param	InTexture - texture to test
	 * @return	true/false
	 */	
	virtual UBOOL TextureIsValid( UTexture* InTexture );

    /**
	 * Called when TextureIsValid==false
	 *
	 * @return	Descriptive error text
	 */	
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterNormal : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterNormal
    const FNormalParameter* InstanceOverride;
    //## END PROPS MaterialExpressionTextureSampleParameterNormal

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterNormal,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();

	/**
	 *	Since there are no input expressions, the ClearInputExpressions function is not required.
	 */
};

class UMaterialExpressionTime : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTime
    BITFIELD bIgnorePause:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTime

    DECLARE_CLASS(UMaterialExpressionTime,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return TRUE; }
};

class UMaterialExpressionTransform : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransform
    FExpressionInput Input;
    BYTE TransformSourceType;
    BYTE TransformType;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTransform

    DECLARE_CLASS(UMaterialExpressionTransform,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTransformPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransformPosition
    FExpressionInput Input;
    BYTE TransformType;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTransformPosition

    DECLARE_CLASS(UMaterialExpressionTransformPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTwoSidedSign
    //## END PROPS MaterialExpressionTwoSidedSign

    DECLARE_CLASS(UMaterialExpressionTwoSidedSign,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionVertexColor
    //## END PROPS MaterialExpressionVertexColor

    DECLARE_CLASS(UMaterialExpressionVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
};

class UMaterialExpressionWindDirectionAndSpeed : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWindDirectionAndSpeed
    //## END PROPS MaterialExpressionWindDirectionAndSpeed

    DECLARE_CLASS(UMaterialExpressionWindDirectionAndSpeed,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionWorldNormal : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWorldNormal
    //## END PROPS MaterialExpressionWorldNormal

    DECLARE_CLASS(UMaterialExpressionWorldNormal,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;
};

class UMaterialExpressionWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWorldPosition
    //## END PROPS MaterialExpressionWorldPosition

    DECLARE_CLASS(UMaterialExpressionWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

struct FLightmassMaterialInterfaceSettings
{
    BITFIELD bCastShadowAsMasked:1;
    FLOAT EmissiveBoost;
    FLOAT DiffuseBoost;
    FLOAT SpecularBoost;
    FLOAT ExportResolutionScale;
    FLOAT DistanceFieldPenumbraScale;
    BITFIELD bOverrideCastShadowAsMasked:1;
    BITFIELD bOverrideEmissiveBoost:1;
    BITFIELD bOverrideDiffuseBoost:1;
    BITFIELD bOverrideSpecularBoost:1;
    BITFIELD bOverrideExportResolutionScale:1;
    BITFIELD bOverrideDistanceFieldPenumbraScale:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLightmassMaterialInterfaceSettings() {}
    FLightmassMaterialInterfaceSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassMaterialInterfaceSettings));
    }
};

class UMaterialInterface : public USurface
{
public:
    //## BEGIN PROPS MaterialInterface
    FRenderCommandFence ParentRefFence;
protected:
    struct FLightmassMaterialInterfaceSettings LightmassSettings;
public:
    FStringNoInit PreviewMesh;
    FGuid LightingGuid;
    BITFIELD bAutoFlattenMobile:1;
    BITFIELD bMobileAllowFog:1;
    BITFIELD bUseMobileSpecular:1;
    BITFIELD bUseMobileVertexSpecular_DEPRECATED:1;
    BITFIELD bUseMobilePixelSpecular:1;
    BITFIELD bUseMobileBumpOffset:1;
    BITFIELD bLockColorBlending:1;
    BITFIELD bUseMobileUniformColorMultiply:1;
    BITFIELD bUseMobileVertexColorMultiply:1;
    BITFIELD bUseMobileTextureTransform:1;
    BITFIELD bUseMobileWaveVertexMovement:1;
    class UTexture* MobileBaseTexture;
    class UTexture* FlattenedTexture_DEPRECATED;
    BYTE MobileBaseTextureTexCoordsSource;
    BYTE MobileAmbientOcclusionSource;
    BYTE MobileSpecularMask;
    BYTE MobileEmissiveColorSource;
    BYTE MobileEmissiveMaskSource;
    BYTE MobileEnvironmentMaskSource;
    BYTE MobileEnvironmentBlendMode;
    BYTE MobileRimLightingMaskSource;
    BYTE MobileMaskTextureTexCoordsSource;
    BYTE MobileDetailTextureTexCoordsSource;
    BYTE MobileTextureBlendFactorSource;
    BYTE MobileTextureTransformTarget;
    class UTexture* MobileNormalTexture;
    FLinearColor MobileSpecularColor;
    FLOAT MobileSpecularPower;
    class UTexture* MobileEmissiveTexture;
    FLinearColor MobileEmissiveColor;
    class UTexture* MobileEnvironmentTexture;
    FLOAT MobileEnvironmentAmount;
    FLinearColor MobileEnvironmentColor;
    FLOAT MobileEnvironmentFresnelAmount;
    FLOAT MobileEnvironmentFresnelExponent;
    FLOAT MobileRimLightingStrength;
    FLOAT MobileRimLightingExponent;
    FLinearColor MobileRimLightingColor;
    FLOAT MobileBumpOffsetReferencePlane;
    FLOAT MobileBumpOffsetHeightRatio;
    class UTexture* MobileMaskTexture;
    class UTexture* MobileDetailTexture;
    FLinearColor DefaultUniformColor;
    FLOAT TransformCenterX;
    FLOAT TransformCenterY;
    FLOAT PannerSpeedX;
    FLOAT PannerSpeedY;
    FLOAT RotateSpeed;
    FLOAT FixedScaleX;
    FLOAT FixedScaleY;
    FLOAT SineScaleX;
    FLOAT SineScaleY;
    FLOAT SineScaleFrequencyMultipler;
    FLOAT MobileTangentVertexFrequencyMultiplier;
    FLOAT MobileVerticalFrequencyMultiplier;
    FLOAT MobileMaxVertexMovementAmplitude;
    FLOAT MobileSwayFrequencyMultiplier;
    FLOAT MobileSwayMaxAngle;
    //## END PROPS MaterialInterface

    virtual UBOOL GetParameterDesc(FName ParameterName,FString& OutDesc);
    virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetVectorCurveParameterValue(FName ParameterName,FInterpCurveVector& OutValue);
    virtual void SetForceMipLevelsToBeResident(UBOOL OverrideForceMiplevelsToBeResident,UBOOL bForceMiplevelsToBeResidentValue,FLOAT ForceDuration,INT CinematicTextureGroups=0);
    DECLARE_FUNCTION(execGetMaterial);
    DECLARE_FUNCTION(execGetPhysicalMaterial);
    DECLARE_FUNCTION(execGetParameterDesc)
    {
        P_GET_NAME(ParameterName);
        P_GET_STR_REF(OutDesc);
        P_FINISH;
        *(UBOOL*)Result=this->GetParameterDesc(ParameterName,OutDesc);
    }
    DECLARE_FUNCTION(execGetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UFont,OutFontValue);
        P_GET_INT_REF(OutFontPage);
        P_FINISH;
        *(UBOOL*)Result=this->GetFontParameterValue(ParameterName,OutFontValue,OutFontPage);
    }
    DECLARE_FUNCTION(execGetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetScalarParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetScalarCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UTexture,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetTextureParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetVectorParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveVector,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetVectorCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execSetForceMipLevelsToBeResident)
    {
        P_GET_UBOOL(OverrideForceMiplevelsToBeResident);
        P_GET_UBOOL(bForceMiplevelsToBeResidentValue);
        P_GET_FLOAT(ForceDuration);
        P_GET_INT_OPTX(CinematicTextureGroups,0);
        P_FINISH;
        this->SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident,bForceMiplevelsToBeResidentValue,ForceDuration,CinematicTextureGroups);
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInterface,USurface,0,Engine)
	/**
	 * Get the material which this is an instance of.
	 * Warning - This is platform dependent!  Do not call GetMaterial(GCurrentMaterialPlatform) and save that reference,
	 * as it will be different depending on the current platform.  Instead call GetMaterial(MSP_BASE) to get the base material and save that.
	 * When getting the material for rendering/checking usage, GetMaterial(GCurrentMaterialPlatform) is fine.
	 *
	 * @param Platform - The platform to get material for.
	 */
	virtual class UMaterial* GetMaterial(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform) PURE_VIRTUAL(UMaterialInterface::GetMaterial,return NULL;);

	/**Fix up for deprecated properties*/
	virtual void PostLoad ();

	/**
	* Tests this material for dependency on a given material.
	* @param	TestDependency - The material to test for dependency upon.
	* @return	True if the material is dependent on TestDependency.
	*/
	virtual UBOOL IsDependent(UMaterialInterface* TestDependency) { return TestDependency == this; }

	/**
	* Returns a pointer to the FMaterialRenderProxy used for rendering.
	*
	* @param	Selected	specify TRUE to return an alternate material used for rendering this material when part of a selection
	*						@note: only valid in the editor!
	*
	* @return	The resource to use for rendering this material instance.
	*/
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const PURE_VIRTUAL(UMaterialInterface::GetRenderProxy,return NULL;);

	/**
	* Returns a pointer to the physical material used by this material instance.
	* @return The physical material.
	*/
	virtual UPhysicalMaterial* GetPhysicalMaterial() const PURE_VIRTUAL(UMaterialInterface::GetPhysicalMaterial,return NULL;);

	/** Returns the textures used to render this material for the given platform. */
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, EMaterialShaderPlatform Platform = MSP_BASE, UBOOL bAllPlatforms = FALSE) 
		PURE_VIRTUAL(UMaterialInterface::GetUsedTextures,);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture) PURE_VIRTUAL(UMaterialInterface::UsesTexture,return FALSE;);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( UTexture* InTextureToOverride, UTexture* OverrideTexture ) PURE_VIRTUAL(UMaterialInterface::OverrideTexture,return;);

	/**
	 * Checks if the material can be used with the given usage flag.  
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(EMaterialUsage Usage) PURE_VIRTUAL(UMaterialInterface::CheckMaterialUsage,return FALSE;);

	/**
	* Allocates a new material resource
	* @return	The allocated resource
	*/
	virtual FMaterialResource* AllocateResource() PURE_VIRTUAL(UMaterialInterface::AllocateResource,return NULL;);

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform) { return NULL; }

	/**
	 * @return the flattened texture for the material
	 */
	virtual UTexture* GetMobileTexture(const INT /* EMobileTextureUnit */ MobileTextureUnit);

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	virtual UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters, 
		FMaterialResource* StaticPermutation, 
		EShaderPlatform Platform, 
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump)
		PURE_VIRTUAL(UMaterialInterface::CompileStaticPermutation,return FALSE;);

	/**
	* Gets the value of the given static switch parameter
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticSwitchParameterValue,return FALSE;);

	/**
	* Gets the value of the given static component mask parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticComponentMaskParameterValue,return FALSE;);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid)
		PURE_VIRTUAL(UMaterialInterface::GetNormalParameterValue,return FALSE;);

	virtual UBOOL IsFallbackMaterial() { return FALSE; }

	/** @return The material's view relevance. */
	FMaterialViewRelevance GetViewRelevance();

	INT GetWidth() const;
	INT GetHeight() const;

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return GetWidth(); }
	virtual FLOAT GetSurfaceHeight() const { return GetHeight(); }

	// UObject interface
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void Serialize(FArchive& Ar);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Serialize the given shader map to the given archive
	 *
	 *	@param	InShaderMap				The shader map to serialize; when loading will be NULL.
	 *	@param	Ar						The archvie to serialize it to.
	 *
	 *	@return	FMaterialShaderMap*		The shader map serialized
	 */
	FMaterialShaderMap* SerializeShaderMap(FMaterialShaderMap* InShaderMap, FArchive& Ar);
	
	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking() { return FALSE; }
	
	/** @return The override bOverrideCastShadowAsMasked setting of the material. */
	inline UBOOL GetOverrideCastShadowAsMasked() const
	{
		return LightmassSettings.bOverrideCastShadowAsMasked;
	}
	/** @return The override emissive boost setting of the material. */
	inline UBOOL GetOverrideEmissiveBoost() const
	{
		return LightmassSettings.bOverrideEmissiveBoost;
	}
	/** @return The override diffuse boost setting of the material. */
	inline UBOOL GetOverrideDiffuseBoost() const
	{
		return LightmassSettings.bOverrideDiffuseBoost;
	}
	/** @return The override specular boost setting of the material. */
	inline UBOOL GetOverrideSpecularBoost() const
	{
		return LightmassSettings.bOverrideSpecularBoost;
	}
	/** @return The override export resolution scale setting of the material. */
	inline UBOOL GetOverrideExportResolutionScale() const
	{
		return LightmassSettings.bOverrideExportResolutionScale;
	}
	inline UBOOL GetOverrideDistanceFieldPenumbraScale() const
	{
		return LightmassSettings.bOverrideDistanceFieldPenumbraScale;
	}

	/** @return	The bCastShadowAsMasked value for this material. */
	virtual UBOOL GetCastShadowAsMasked() const
	{
		return LightmassSettings.bCastShadowAsMasked;
	}
	/** @return	The Emissive boost value for this material. */
	virtual FLOAT GetEmissiveBoost() const
	{
		return LightmassSettings.EmissiveBoost;
	}
	/** @return	The Diffuse boost value for this material. */
	virtual FLOAT GetDiffuseBoost() const
	{
		return LightmassSettings.DiffuseBoost;
	}
	/** @return	The Specular boost value for this material. */
	virtual FLOAT GetSpecularBoost() const
	{
		return LightmassSettings.SpecularBoost;
	}
	/** @return	The ExportResolutionScale value for this material. */
	virtual FLOAT GetExportResolutionScale() const
	{
		return LightmassSettings.ExportResolutionScale;
	}
	virtual FLOAT GetDistanceFieldPenumbraScale() const
	{
		return LightmassSettings.DistanceFieldPenumbraScale;
	}

	/** @param	bInOverrideCastShadowAsMasked	The override CastShadowAsMasked setting to set. */
	inline void SetOverrideCastShadowAsMasked(UBOOL bInOverrideCastShadowAsMasked)
	{
		LightmassSettings.bOverrideCastShadowAsMasked = bInOverrideCastShadowAsMasked;
	}
	/** @param	bInOverrideEmissiveBoost	The override emissive boost setting to set. */
	inline void SetOverrideEmissiveBoost(UBOOL bInOverrideEmissiveBoost)
	{
		LightmassSettings.bOverrideEmissiveBoost = bInOverrideEmissiveBoost;
	}
	/** @param bInOverrideDiffuseBoost		The override diffuse boost setting of the parent material. */
	inline void SetOverrideDiffuseBoost(UBOOL bInOverrideDiffuseBoost)
	{
		LightmassSettings.bOverrideDiffuseBoost = bInOverrideDiffuseBoost;
	}
	/** @param bInOverrideSpecularBoost		The override specular boost setting of the parent material. */
	inline void SetOverrideSpecularBoost(UBOOL bInOverrideSpecularBoost)
	{
		LightmassSettings.bOverrideSpecularBoost = bInOverrideSpecularBoost;
	}
	/** @param bInOverrideExportResolutionScale	The override export resolution scale setting of the parent material. */
	inline void SetOverrideExportResolutionScale(UBOOL bInOverrideExportResolutionScale)
	{
		LightmassSettings.bOverrideExportResolutionScale = bInOverrideExportResolutionScale;
	}
	inline void SetOverrideDistanceFieldPenumbraScale(UBOOL bInOverrideDistanceFieldPenumbraScale)
	{
		LightmassSettings.bOverrideDistanceFieldPenumbraScale = bInOverrideDistanceFieldPenumbraScale;
	}

	/** @param	InCastShadowAsMasked	The CastShadowAsMasked value for this material. */
	inline void SetCastShadowAsMasked(UBOOL InCastShadowAsMasked)
	{
		LightmassSettings.bCastShadowAsMasked = InCastShadowAsMasked;
	}
	/** @param	InEmissiveBoost		The Emissive boost value for this material. */
	inline void SetEmissiveBoost(FLOAT InEmissiveBoost)
	{
		LightmassSettings.EmissiveBoost = InEmissiveBoost;
	}
	/** @param	InDiffuseBoost		The Diffuse boost value for this material. */
	inline void SetDiffuseBoost(FLOAT InDiffuseBoost)
	{
		LightmassSettings.DiffuseBoost = InDiffuseBoost;
	}
	/** @param	InSpecularBoost		The Specular boost value for this material. */
	inline void SetSpecularBoost(FLOAT InSpecularBoost)
	{
		LightmassSettings.SpecularBoost = InSpecularBoost;
	}
	/** @param	InExportResolutionScale		The ExportResolutionScale value for this material. */
	inline void SetExportResolutionScale(FLOAT InExportResolutionScale)
	{
		LightmassSettings.ExportResolutionScale = InExportResolutionScale;
	}
	inline void SetDistanceFieldPenumbraScale(FLOAT InDistanceFieldPenumbraScale)
	{
		LightmassSettings.DistanceFieldPenumbraScale = InDistanceFieldPenumbraScale;
	}

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures,  TArray<FName>* OutTextureParamNames)
		PURE_VIRTUAL(UMaterialInterface::GetTexturesInPropertyChain,return FALSE;);

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const { return NULL; }

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const { return NULL; }

	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const { return NULL; }

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const { return -1; }

	/** 
	 * Returns True if this material has a valid physical material mask setup.
 	 */
	UBOOL HasValidPhysicalMaterialMask() const;

	/**
	 * Determines the texel on the physical material mask that was hit and returns the physical material corresponding to hit texel's color
	 * 
	 * @param HitUV the UV that was hit during collision.
	 */
	UPhysicalMaterial* DetermineMaskedPhysicalMaterialFromUV( const FVector2D& HitUV ) const;
};

class UMaterial : public UMaterialInterface
{
public:
    //## BEGIN PROPS Material
    class UPhysicalMaterial* PhysMaterial;
    class UClass* PhysicalMaterial;
    class UTexture2D* PhysMaterialMask;
    INT PhysMaterialMaskUVChannel;
    class UPhysicalMaterial* BlackPhysicalMaterial;
    class UPhysicalMaterial* WhitePhysicalMaterial;
    FColorMaterialInput DiffuseColor;
    FScalarMaterialInput DiffusePower;
    FColorMaterialInput SpecularColor;
    FScalarMaterialInput SpecularPower;
    FVectorMaterialInput Normal;
    FColorMaterialInput EmissiveColor;
    FScalarMaterialInput Opacity;
    FScalarMaterialInput OpacityMask;
    FLOAT OpacityMaskClipValue;
    FLOAT ShadowDepthBias;
    FVector2MaterialInput Distortion;
    BYTE BlendMode;
    BYTE LightingModel;
    BYTE D3D11TessellationMode;
    SCRIPT_ALIGN;
    FColorMaterialInput CustomLighting;
    FColorMaterialInput CustomSkylightDiffuse;
    FVectorMaterialInput AnisotropicDirection;
    FScalarMaterialInput TwoSidedLightingMask;
    FColorMaterialInput TwoSidedLightingColor;
    FVectorMaterialInput WorldPositionOffset;
    FVectorMaterialInput WorldDisplacement;
    FVector2MaterialInput TessellationFactors;
    FColorMaterialInput SubsurfaceInscatteringColor;
    FColorMaterialInput SubsurfaceAbsorptionColor;
    FScalarMaterialInput SubsurfaceScatteringRadius;
    BITFIELD EnableSubsurfaceScattering:1;
    BITFIELD EnableSeparateTranslucency:1;
    BITFIELD bEnableMaskedAntialiasing:1;
    BITFIELD TwoSided:1;
    BITFIELD TwoSidedSeparatePass:1;
    BITFIELD bDisableDepthTest:1;
    BITFIELD bAllowFog:1;
    BITFIELD bTranslucencyReceiveDominantShadowsFromStatic:1;
    BITFIELD bTranslucencyInheritDominantShadowsFromOpaque:1;
    BITFIELD bAllowTranslucencyDoF:1;
    BITFIELD bUseOneLayerDistortion:1;
    BITFIELD bUseLitTranslucencyDepthPass:1;
    BITFIELD bUseLitTranslucencyPostRenderDepthPass:1;
    BITFIELD bCastLitTranslucencyShadowAsMasked:1;
    BITFIELD bUsedAsLightFunction:1;
    BITFIELD bUsedWithFogVolumes:1;
    BITFIELD bUsedAsSpecialEngineMaterial:1;
    BITFIELD bUsedWithSkeletalMesh:1;
    BITFIELD bUsedWithTerrain:1;
    BITFIELD bUsedWithLandscape:1;
    BITFIELD bUsedWithFracturedMeshes:1;
    BITFIELD bUsedWithParticleSystem:1;
    BITFIELD bUsedWithParticleSprites:1;
    BITFIELD bUsedWithBeamTrails:1;
    BITFIELD bUsedWithParticleSubUV:1;
    BITFIELD bUsedWithSpeedTree:1;
    BITFIELD bUsedWithStaticLighting:1;
    BITFIELD bUsedWithLensFlare:1;
    BITFIELD bUsedWithGammaCorrection:1;
    BITFIELD bUsedWithInstancedMeshParticles:1;
    BITFIELD bUsedWithFluidSurfaces:1;
    BITFIELD bUsedWithDecals:1;
    BITFIELD bUsedWithMaterialEffect:1;
    BITFIELD bUsedWithMorphTargets:1;
    BITFIELD bUsedWithRadialBlur:1;
    BITFIELD bUsedWithInstancedMeshes:1;
    BITFIELD bUsedWithSplineMeshes:1;
    BITFIELD bUsedWithAPEXMeshes:1;
    BITFIELD bUsedWithScreenDoorFade:1;
    BITFIELD bUseImageBasedReflections:1;
    BITFIELD Wireframe:1;
    BITFIELD bPerPixelCameraVector:1;
    BITFIELD bAllowLightmapSpecular:1;
    BITFIELD bIsFallbackMaterial_DEPRECATED:1;
    BITFIELD bUsesDistortion:1;
    BITFIELD bIsMasked:1;
    BITFIELD bIsPreviewMaterial:1;
    FLOAT ImageReflectionNormalDampening;
    FMaterialResource* MaterialResources[2];
    class FDefaultMaterialInstance* DefaultMaterialInstances[3];
    INT EditorX;
    INT EditorY;
    INT EditorPitch;
    INT EditorYaw;
    TArrayNoInit<class UMaterialExpression*> Expressions;
    TArrayNoInit<class UMaterialExpressionComment*> EditorComments;
    TArrayNoInit<class UMaterialExpressionCompound*> EditorCompounds;
    TMap< FName, TArray<UMaterialExpression*> > EditorParameters;
    TArrayNoInit<class UTexture*> ReferencedTextures_DEPRECATED;
    TArrayNoInit<FGuid> ReferencedTextureGuids;
    //## END PROPS Material

    DECLARE_CLASS(UMaterial,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterial();

	/** @return TRUE if the material uses distortion */
	UBOOL HasDistortion() const;
	/** @return TRUE if the material uses the scene color texture */
	UBOOL UsesSceneColor() const;

	/**
	 * Allocates a material resource off the heap to be stored in MaterialResource.
	 */
	virtual FMaterialResource* AllocateResource();

	/** Returns the textures used to render this material for the given platform. */
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, EMaterialShaderPlatform Platform = MSP_BASE, UBOOL bAllPlatforms = FALSE);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( UTexture* InTextureToOverride, UTexture* OverrideTexture );

private:

	/** Sets the value associated with the given usage flag. */
	void SetUsageByFlag(EMaterialUsage Usage, UBOOL NewValue);

public:

	/** Gets the name of the given usage flag. */
	FString GetUsageName(EMaterialUsage Usage) const;

	/** Gets the value associated with the given usage flag. */
	UBOOL GetUsageByFlag(EMaterialUsage Usage) const;

	/**
	 * Checks if the material can be used with the given usage flag.
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(EMaterialUsage Usage);

	/**
	 * Sets the given usage flag.
	 * @param bNeedsRecompile - TRUE if the material was recompiled for the usage change
	 * @param Usage - The usage flag to set
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	UBOOL SetMaterialUsage(UBOOL &bNeedsRecompile, EMaterialUsage Usage);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of parameter names used in this material for the specified expression type.
	 */
	template<typename ExpressionType>
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	
	void GetAllVectorParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllScalarParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllTextureParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllFontParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllStaticSwitchParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllStaticComponentMaskParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllNormalParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllTerrainLayerWeightParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Attempts to find a expression by its GUID.
	 *
	 * @param InGUID GUID to search for.
	 *
	 * @return Returns a expression object pointer if one is found, otherwise NULL if nothing is found.
	 */
	template<typename ExpressionType>
	ExpressionType* FindExpressionByGUID(const FGuid &InGUID)
	{
		ExpressionType* Result = NULL;

		for(INT ExpressionIndex = 0;ExpressionIndex < Expressions.Num();ExpressionIndex++)
		{
			ExpressionType* ExpressionPtr =
				Cast<ExpressionType>(Expressions(ExpressionIndex));

			if(ExpressionPtr && ExpressionPtr->ExpressionGUID.IsValid() && ExpressionPtr->ExpressionGUID==InGUID)
			{
				Result = ExpressionPtr;
				break;
			}
		}

		return Result;
	}

	// UMaterialInterface interface.

	/**
	 * Get the material which this is an instance of.
	 * Warning - This is platform dependent!  Do not call GetMaterial(GCurrentMaterialPlatform) and save that reference,
	 * as it will be different depending on the current platform.  Instead call GetMaterial(MSP_BASE) to get the base material and save that.
	 * When getting the material for rendering/checking usage, GetMaterial(GCurrentMaterialPlatform) is fine.
	 *
	 * @param Platform - The platform to get material for.
	 */
	virtual UMaterial* GetMaterial(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);
    virtual UBOOL GetParameterDesc(FName ParameterName, FString& OutDesc);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);

	/**
	 * Gets the value of the given static switch parameter
	 *
	 * @param	ParameterName	The name of the static switch parameter
	 * @param	OutValue		Will contain the value of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	 * Gets the value of the given static component mask parameter
	 *
	 * @param	ParameterName	The name of the parameter
	 * @param	R, G, B, A		Will contain the values of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid);

	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters,
		FMaterialResource* StaticPermutation,
		EShaderPlatform Platform,
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump);

	/**
	 * Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	 *
	 * @param ShaderPlatform - platform to compile for
	 * @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	 * @param bForceAllPlatforms - compile for all platforms, not just the current.
	 */
	void CacheResourceShaders(EShaderPlatform Platform, UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bForceAllPlatforms=FALSE);

private:
	/**
	 * Flushes existing resource shader maps and resets the material resource's Ids.
	 */
	virtual void FlushResourceShaderMaps();

public:
	/**
	 * Gets the material resource based on the input platform
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);

	/** === USurface interface === */
	/**
	 * Method for retrieving the width of this surface.
	 *
	 * This implementation returns the maximum width of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the width of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceWidth() const;
	/**
	 * Method for retrieving the height of this surface.
	 *
	 * This implementation returns the maximum height of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the height of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	/**
	 * Called before serialization on save to propagate referenced textures. This is not done
	 * during content cooking as the material expressions used to retrieve this information will
	 * already have been dissociated via RemoveExpressions
	 */
	void PreSave();

	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
	virtual void Serialize(FArchive& Ar);
	virtual void PostDuplicate();
	virtual void PostLoad();
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	 * @return		Sum of the size of textures referenced by this material.
	 */
	virtual INT GetResourceSize();

	/**
	 * Null any material expression references for this material
	 *
	 * @param bRemoveAllExpressions If TRUE, the function will remove every expression and uniform expression from the material and its material resources
	 */
	void RemoveExpressions(UBOOL bRemoveAllExpressions=FALSE);

	UBOOL IsFallbackMaterial() { return bIsFallbackMaterial_DEPRECATED; }

	/**
	 * Goes through every material, flushes the specified types and re-initializes the material's shader maps.
	 */
	static void UpdateMaterialShaders(TArray<FShaderType*>& ShaderTypesToFlush, TArray<const FVertexFactoryType*>& VFTypesToFlush);

	/**
	 * Adds an expression node that represents a parameter to the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be inserted if it's a parameter type.
	 */
	virtual UBOOL AddExpressionParameter(UMaterialExpression* Expression);

	/**
	 * Removes an expression node that represents a parameter from the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be removed if it's a parameter type.
	 */
	virtual UBOOL RemoveExpressionParameter(UMaterialExpression* Expression);

	/**
	 * A parameter with duplicates has to update its peers so that they all have the same value. If this step isn't performed then
	 * the expression nodes will not accurately display the final compiled material.
	 *
	 * @param	Parameter	Pointer to the expression node whose state needs to be propagated.
	 */
	virtual void PropagateExpressionParameterChanges(UMaterialExpression* Parameter);

	/**
	 * This function removes the expression from the editor parameters list (if it exists) and then re-adds it.
	 *
	 * @param	Expression	The expression node that represents a parameter that needs updating.
	 */
	virtual void UpdateExpressionParameterName(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes in the material and finds any parameters to put in EditorParameters.
	 */
	virtual void BuildEditorParameterList();

	/**
	 * Returns TRUE if the provided expression parameter has duplicates.
	 *
	 * @param	Expression	The expression parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateParameters(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression dynamic parameter has duplicates.
	 *
	 * @param	Expression	The expression dynamic parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateDynamicParameters(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes and fixes up changed names on
	 * matching dynamic parameters when a name change occurs.
	 *
	 * @param	Expression	The expression dynamic parameter.
	 */
	virtual void UpdateExpressionDynamicParameterNames(UMaterialExpression* Expression);

	/**
	 * Gets the name of a parameter.
	 *
	 * @param	Expression	The expression to retrieve the name from.
	 * @param	OutName		The variable that will hold the parameter name.
	 * @return	TRUE if the expression is a parameter with a name.
	 */
	static UBOOL GetExpressionParameterName(UMaterialExpression* Expression, FName& OutName);

	/**
	 * Copies the values of an expression parameter to another expression parameter of the same class.
	 *
	 * @param	Source			The source parameter.
	 * @param	Destination		The destination parameter that will receive Source's values.
	 */
	static UBOOL CopyExpressionParameters(UMaterialExpression* Source, UMaterialExpression* Destination);

	/**
	 * Returns TRUE if the provided expression node is a parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsParameter(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression node is a dynamic parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsDynamicParameter(UMaterialExpression* Expression);

	/**
	 * Returns the number of parameter groups. NOTE: The number returned can be innaccurate if you have parameters of different types with the same name.
	 */
	inline INT GetNumEditorParameters() const
	{
		return EditorParameters.Num();
	}

	/**
	 * Empties the editor parameters for the material.
	 */
	inline void EmptyEditorParameters()
	{
		EditorParameters.Empty();
	}

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const { return PhysMaterialMask; }

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const { return BlackPhysicalMaterial; }

	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const { return WhitePhysicalMaterial; }

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const { return PhysMaterialMaskUVChannel; }

protected:
	/**
	 * Sets overrides in the material's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values
	 */
	void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	void ClearStaticParameterOverrides();

public:
	/** Helper functions for text output of properties... */
	static const TCHAR* GetMaterialLightingModelString(EMaterialLightingModel InMaterialLightingModel);
	static EMaterialLightingModel GetMaterialLightingModelFromString(const TCHAR* InMaterialLightingModelStr);
	static const TCHAR* GetBlendModeString(EBlendMode InBlendMode);
	static EBlendMode GetBlendModeFromString(const TCHAR* InBlendModeStr);

	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking();

	/**
	*	Get the expression input for the given property
	*
	*	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	*
	*	@return	FExpressionInput*		A pointer to the expression input of the property specified, 
	*									or NULL if an invalid property was requested.
	*/
	FExpressionInput* GetExpressionInputForProperty(EMaterialProperty InProperty);

	/**
	 *	Get the expression chain for the given property (ie fill in the given array with all expressions in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutExpressions			The array to fill in all of the expressions.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetExpressionsInPropertyChain(EMaterialProperty InProperty, TArray<UMaterialExpression*>& OutExpressions);

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures,  TArray<FName>* OutTextureParamNames);

protected:
	/**
	 *	Recursively retrieve the expressions contained in the chain of the given expression.
	 *
	 *	@param	InExpression			The expression to start at.
	 *	@param	InOutProcessedInputs	An array of processed expression inputs. (To avoid circular loops causing infinite recursion)
	 *	@param	OutExpressions			The array to fill in all of the expressions.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL RecursiveGetExpressionChain(UMaterialExpression* InExpression, TArray<FExpressionInput*>& InOutProcessedInputs, TArray<UMaterialExpression*>& OutExpressions);

	/**
	*	Recursively update the bRealtimePreview for each expression based on whether it is connected to something that is time-varying.
	*	This is determined based on the result of UMaterialExpression::NeedsRealtimePreview();
	*
	*	@param	InExpression				The expression to start at.
	*	@param	InOutExpressionsToProcess	Array of expressions we still need to process.
	*
	*/
	void RecursiveUpdateRealtimePreview(UMaterialExpression* InExpression, TArray<UMaterialExpression*>& InOutExpressionsToProcess);


	friend class FLightmassMaterialProxy;
};

class UMaterialInstance : public UMaterialInterface
{
public:
    //## BEGIN PROPS MaterialInstance
    class UPhysicalMaterial* PhysMaterial;
    class UMaterialInterface* Parent;
    class UTexture2D* PhysMaterialMask;
    INT PhysMaterialMaskUVChannel;
    class UPhysicalMaterial* BlackPhysicalMaterial;
    class UPhysicalMaterial* WhitePhysicalMaterial;
    BITFIELD bHasStaticPermutationResource:1;
    BITFIELD bStaticPermutationDirty:1;
    BITFIELD ReentrantFlag:1;
    BITFIELD bNeedsMaterialFlattening:1;
    SCRIPT_ALIGN;
    FStaticParameterSet* StaticParameters[2];
    FMaterialResource* StaticPermutationResources[2];
    class FMaterialInstanceResource* Resources[3];
    TArrayNoInit<class UTexture*> ReferencedTextures_DEPRECATED;
    TArrayNoInit<FGuid> ReferencedTextureGuids;
    FGuid ParentLightingGuid;
    //## END PROPS MaterialInstance

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,const FInterpCurveFloat& Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    virtual UBOOL IsInMapOrTransientPackage() const;
    DECLARE_FUNCTION(execSetParent)
    {
        P_GET_OBJECT(UMaterialInterface,NewParent);
        P_FINISH;
        this->SetParent(NewParent);
    }
    DECLARE_FUNCTION(execSetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,Value);
        P_FINISH;
        this->SetVectorParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetScalarParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,Value);
        P_FINISH;
        this->SetScalarCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UTexture,Value);
        P_FINISH;
        this->SetTextureParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UFont,FontValue);
        P_GET_INT(FontPage);
        P_FINISH;
        this->SetFontParameterValue(ParameterName,FontValue,FontPage);
    }
    DECLARE_FUNCTION(execClearParameterValues)
    {
        P_FINISH;
        this->ClearParameterValues();
    }
    DECLARE_FUNCTION(execIsInMapOrTransientPackage)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsInMapOrTransientPackage();
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInstance,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterialInstance();

	/**
	* Passes the allocation request up the MIC chain
	* @return	The allocated resource
	*/
	FMaterialResource* AllocateResource();

	/** Initializes the material instance's resources. */
	virtual void InitResources();

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);

	/**
	 * @return the flattened texture for the material instance, or the parent's if we don't have one
	 */
	virtual UTexture* GetMobileTexture(const INT MobileTextureUnit)
	{
		UTexture* MyTexture = UMaterialInterface::GetMobileTexture( MobileTextureUnit );
		return MyTexture ? MyTexture : Parent ? Parent->GetMobileTexture(MobileTextureUnit) : NULL;
	}

	// UMaterialInterface interface.

	/**
	 * Get the material which this is an instance of.
	 * Warning - This is platform dependent!  Do not call GetMaterial(GCurrentMaterialPlatform) and save that reference,
	 * as it will be different depending on the current platform.  Instead call GetMaterial(MSP_BASE) to get the base material and save that.
	 * When getting the material for rendering/checking usage, GetMaterial(GCurrentMaterialPlatform) is fine.
	 *
	 * @param Platform - The platform to get material for.
	 */
	virtual UMaterial* GetMaterial(EMaterialShaderPlatform Platform = GCurrentMaterialPlatform);

	/** Returns the textures used to render this material instance for the given platform. */
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, EMaterialShaderPlatform Platform = MSP_BASE, UBOOL bAllPlatforms = FALSE);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( UTexture* InTextureToOverride, UTexture* OverrideTexture );


	/**
	 * Checks if the material can be used with the given usage flag.
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(EMaterialUsage Usage);

	/**
	* Gets the value of the given static switch parameter.  If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	* Gets the value of the given static component mask parameter. If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A,FGuid &OutExpressionGuid);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid);

	virtual UBOOL IsDependent(UMaterialInterface* TestDependency);
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	* Makes a copy of all the instance's inherited and overridden static parameters
	*
	* @param StaticParameters - The set of static parameters to fill, must be empty
	*/
	void GetStaticParameterValues(FStaticParameterSet* StaticParameters);

	/**
	* Sets the instance's static parameters and marks it dirty if appropriate.
	*
	* @param	EditorParameters	The new static parameters.  If the set does not contain any static parameters,
	*								the static permutation resource will be released.
	* @return		TRUE if the static permutation resource has been marked dirty
	*/
	UBOOL SetStaticParameterValues(const FStaticParameterSet* EditorParameters);

	/**
	* Checks if any of the static parameter values are outdated based on what they reference (eg a normalmap has changed format)
	*
	* @param	EditorParameters	The new static parameters. 
	*/
	virtual void CheckStaticParameterValues(FStaticParameterSet* EditorParameters);

	/**
	* Compiles the static permutation resource if the base material has changed and updates dirty states
	*/
	void UpdateStaticPermutation();

	/**
	* Updates static parameters and recompiles the static permutation resource if necessary
	*/
	void InitStaticPermutation();

	/**
	* Compiles material resources for the given platform if the shader map for that resource didn't already exist.
	*
	* @param ShaderPlatform - the platform to compile for.
	* @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	* @param bForceAllPlatforms - compile for all platforms, not just the current.
	*/
	void CacheResourceShaders(EShaderPlatform ShaderPlatform, UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bForceAllPlatforms=FALSE, UBOOL bDebugDump=FALSE);

	/**
	 * Passes the compile request up the MIC chain
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param MaterialPlatform - The material platform to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* Permutation,
		FMaterialResource* StaticPermutation,
		EShaderPlatform Platform,
		EMaterialShaderPlatform MaterialPlatform,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump);

	/**
	* Allocates the static permutation resources for all platforms if they haven't been already.
	* Also updates the material resource's Material member as it may have changed.
	*/
	void AllocateStaticPermutations();

	/**
	* Releases the static permutation resource if it exists, in a thread safe way
	*/
	void ReleaseStaticPermutations();

	/** === USurface interface === */
	/**
	 * Method for retrieving the width of this surface.
	 *
	 * This implementation returns the maximum width of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the width of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceWidth() const;
	/**
	 * Method for retrieving the height of this surface.
	 *
	 * This implementation returns the maximum height of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the height of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
	void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

#if !FINAL_RELEASE
	/** Displays warning if this material instance is not safe to modify in the game (is in content package) */
	void CheckSafeToModifyInGame(const TCHAR* FuncName) const;
#endif

	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking();

	/** @return	The bCastShadowAsMasked value for this material. */
	virtual UBOOL GetCastShadowAsMasked() const;
	/** @return	The Emissive boost value for this material. */
	virtual FLOAT GetEmissiveBoost() const;
	/** @return	The Diffuse boost value for this material. */
	virtual FLOAT GetDiffuseBoost() const;
	/** @return	The Specular boost value for this material. */
	virtual FLOAT GetSpecularBoost() const;
	/** @return	The ExportResolutionScale value for this material. */
	virtual FLOAT GetExportResolutionScale() const;
	virtual FLOAT GetDistanceFieldPenumbraScale() const;

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures,  TArray<FName>* OutTextureParamNames);

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const;

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const;
	
	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const;

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information. Tries to get the parents UV channel if not present here. 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const;
};

struct FFontParameterValue
{
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
    FGuid ExpressionGUID;

    /** Constructors */
    FFontParameterValue() {}
    FFontParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FFontParameterValue));
    }
};

struct FScalarParameterValue
{
    FName ParameterName;
    FLOAT ParameterValue;
    FGuid ExpressionGUID;

    /** Constructors */
    FScalarParameterValue() {}
    FScalarParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FScalarParameterValue));
    }
};

struct FTextureParameterValue
{
    FName ParameterName;
    class UTexture* ParameterValue;
    FGuid ExpressionGUID;

    /** Constructors */
    FTextureParameterValue() {}
    FTextureParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FTextureParameterValue));
    }
};

struct FVectorParameterValue
{
    FName ParameterName;
    FLinearColor ParameterValue;
    FGuid ExpressionGUID;

    /** Constructors */
    FVectorParameterValue() {}
    FVectorParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FVectorParameterValue));
    }
};

class UMaterialInstanceConstant : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceConstant
    TArrayNoInit<struct FFontParameterValue> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValue> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValue> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValue> VectorParameterValues;
    //## END PROPS MaterialInstanceConstant

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    DECLARE_CLASS(UMaterialInstanceConstant,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceConstant();

	// UMaterialInstance interface.
	virtual void InitResources();

	/**
	* Checks if any of the static parameter values are outdated based on what they reference (eg a normalmap has changed format)
	*
	* @param	EditorParameters	The new static parameters. 
	*/
	virtual void CheckStaticParameterValues(FStaticParameterSet* EditorParameters);

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

	/**
	 *	Cleanup the TextureParameter lists in the instance
	 *
	 *	@param	InRefdTextureParamsMap		Map of actual TextureParams used by the parent.
	 *
	 *	NOTE: This is intended to be called only when cooking for stripped platforms!
	 */
	virtual void CleanupTextureParameterReferences(const TMap<FName,UTexture*>& InRefdTextureParamsMap);
};

struct FParameterValueOverTime
{
    FGuid ExpressionGUID;
    FLOAT StartTime;
    FName ParameterName;
    BITFIELD bLoop:1;
    BITFIELD bAutoActivate:1;
    FLOAT CycleTime;
    BITFIELD bNormalizeTime:1;
    FLOAT OffsetTime;
    BITFIELD bOffsetFromEnd:1;
    SCRIPT_ALIGN;

		/** Constructors */
		FParameterValueOverTime() {}
		FParameterValueOverTime(EEventParm)
		{
			appMemzero(this, sizeof(FParameterValueOverTime));
		}
		void InitToDefaults()
		{
			appMemzero(this, sizeof(FParameterValueOverTime));
			StartTime=-1.0f;
			bLoop=FALSE;
			bAutoActivate=FALSE;
			CycleTime=1.0f;
			bNormalizeTime=FALSE;
		}
		FParameterValueOverTime(ENativeConstructor)
		{
			InitToDefaults();
		}
	
};

struct FFontParameterValueOverTime : public FParameterValueOverTime
{
    class UFont* FontValue;
    INT FontPage;

    /** Constructors */
    FFontParameterValueOverTime() {}
    FFontParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FFontParameterValueOverTime));
    }
};

struct FScalarParameterValueOverTime : public FParameterValueOverTime
{
    FLOAT ParameterValue;
    FInterpCurveFloat ParameterValueCurve;

    /** Constructors */
    FScalarParameterValueOverTime() {}
    FScalarParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FScalarParameterValueOverTime));
    }
};

struct FTextureParameterValueOverTime : public FParameterValueOverTime
{
    class UTexture* ParameterValue;

    /** Constructors */
    FTextureParameterValueOverTime() {}
    FTextureParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FTextureParameterValueOverTime));
    }
};

struct FVectorParameterValueOverTime : public FParameterValueOverTime
{
    FLinearColor ParameterValue;
    FInterpCurveVector ParameterValueCurve;

    /** Constructors */
    FVectorParameterValueOverTime() {}
    FVectorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FVectorParameterValueOverTime));
    }
};

class UMaterialInstanceTimeVarying : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceTimeVarying
    BITFIELD bAutoActivateAll:1;
    FLOAT Duration;
    TArrayNoInit<struct FFontParameterValueOverTime> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValueOverTime> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValueOverTime> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValueOverTime> VectorParameterValues;
    //## END PROPS MaterialInstanceTimeVarying

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,const FInterpCurveFloat& Value);
    virtual void SetScalarStartTime(FName ParameterName,FLOAT Value);
    virtual void SetDuration(FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetVectorCurveParameterValue(FName ParameterName,const FInterpCurveVector& Value);
    virtual void SetVectorStartTime(FName ParameterName,FLOAT Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    virtual FLOAT GetMaxDurationFromAllParameters();
    DECLARE_FUNCTION(execSetScalarStartTime)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetScalarStartTime(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetDuration)
    {
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetDuration(Value);
    }
    DECLARE_FUNCTION(execSetVectorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveVector,Value);
        P_FINISH;
        this->SetVectorCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetVectorStartTime)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetVectorStartTime(ParameterName,Value);
    }
    DECLARE_FUNCTION(execGetMaxDurationFromAllParameters)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxDurationFromAllParameters();
    }
    DECLARE_CLASS(UMaterialInstanceTimeVarying,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceTimeVarying();

	// UMaterialInstance interface.
	virtual void InitResources();

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	/**
	 * For MITVs you can utilize both single Scalar values and InterpCurve values.
	 *
	 * If there is any data in the InterpCurve, then the MITV will utilize that. Else it will utilize the Scalar value
	 * of the same name.
	 **/
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
	virtual UBOOL GetVectorCurveParameterValue(FName ParameterName,FInterpCurveVector &OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

	/**
	 *	Cleanup the TextureParameter lists in the instance
	 *
	 *	@param	InRefdTextureParamsMap		Map of actual TextureParams used by the parent.
	 *
	 *	NOTE: This is intended to be called only when cooking for stripped platforms!
	 */
	virtual void CleanupTextureParameterReferences(const TMap<FName,UTexture*>& InRefdTextureParamsMap);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_MATERIAL_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execSetForceMipLevelsToBeResident);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetParameterDesc);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetPhysicalMaterial);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMaterial);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execIsInMapOrTransientPackage);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execGetMaxDurationFromAllParameters);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorStartTime);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetDuration);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarStartTime);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetParent);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_MATERIAL_NATIVE_DEFS
#define ENGINE_MATERIAL_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_MATERIAL \
	UMaterialExpressionAbs::StaticClass(); \
	UMaterialExpressionAdd::StaticClass(); \
	UMaterialExpressionAppendVector::StaticClass(); \
	UMaterialExpressionBumpOffset::StaticClass(); \
	UMaterialExpressionCameraVector::StaticClass(); \
	UMaterialExpressionCameraWorldPosition::StaticClass(); \
	UMaterialExpressionCeil::StaticClass(); \
	UMaterialExpressionClamp::StaticClass(); \
	UMaterialExpressionComment::StaticClass(); \
	UMaterialExpressionComponentMask::StaticClass(); \
	UMaterialExpressionCompound::StaticClass(); \
	UMaterialExpressionConstant::StaticClass(); \
	UMaterialExpressionConstant2Vector::StaticClass(); \
	UMaterialExpressionConstant3Vector::StaticClass(); \
	UMaterialExpressionConstant4Vector::StaticClass(); \
	UMaterialExpressionConstantBiasScale::StaticClass(); \
	UMaterialExpressionConstantClamp::StaticClass(); \
	UMaterialExpressionCosine::StaticClass(); \
	UMaterialExpressionCrossProduct::StaticClass(); \
	UMaterialExpressionCustom::StaticClass(); \
	UMaterialExpressionCustomTexture::StaticClass(); \
	UMaterialExpressionDepthBiasedAlpha::StaticClass(); \
	UMaterialExpressionDepthBiasedBlend::StaticClass(); \
	UMaterialExpressionDepthOfFieldFunction::StaticClass(); \
	UMaterialExpressionDeriveNormalZ::StaticClass(); \
	UMaterialExpressionDesaturation::StaticClass(); \
	UMaterialExpressionDestColor::StaticClass(); \
	UMaterialExpressionDestDepth::StaticClass(); \
	UMaterialExpressionDistance::StaticClass(); \
	UMaterialExpressionDivide::StaticClass(); \
	UMaterialExpressionDotProduct::StaticClass(); \
	UMaterialExpressionDynamicParameter::StaticClass(); \
	UMaterialExpressionMeshEmitterDynamicParameter::StaticClass(); \
	UMaterialExpressionFloor::StaticClass(); \
	UMaterialExpressionFluidNormal::StaticClass(); \
	UMaterialExpressionFmod::StaticClass(); \
	UMaterialExpressionFoliageImpulseDirection::StaticClass(); \
	UMaterialExpressionFoliageNormalizedRotationAxisAndAngle::StaticClass(); \
	UMaterialExpressionFontSample::StaticClass(); \
	UMaterialExpressionFontSampleParameter::StaticClass(); \
	UMaterialExpressionFrac::StaticClass(); \
	UMaterialExpressionFresnel::StaticClass(); \
	UMaterialExpressionIf::StaticClass(); \
	UMaterialExpressionLensFlareIntensity::StaticClass(); \
	UMaterialExpressionLensFlareOcclusion::StaticClass(); \
	UMaterialExpressionLensFlareRadialDistance::StaticClass(); \
	UMaterialExpressionLensFlareRayDistance::StaticClass(); \
	UMaterialExpressionLensFlareSourceDistance::StaticClass(); \
	UMaterialExpressionLightmapUVs::StaticClass(); \
	UMaterialExpressionLightmassReplace::StaticClass(); \
	UMaterialExpressionLightVector::StaticClass(); \
	UMaterialExpressionLinearInterpolate::StaticClass(); \
	UMaterialExpressionMeshEmitterVertexColor::StaticClass(); \
	UMaterialExpressionMultiply::StaticClass(); \
	UMaterialExpressionNormalize::StaticClass(); \
	UMaterialExpressionObjectOrientation::StaticClass(); \
	UMaterialExpressionObjectRadius::StaticClass(); \
	UMaterialExpressionObjectWorldPosition::StaticClass(); \
	UMaterialExpressionOcclusionPercentage::StaticClass(); \
	UMaterialExpressionOneMinus::StaticClass(); \
	UMaterialExpressionPanner::StaticClass(); \
	UMaterialExpressionParameter::StaticClass(); \
	UMaterialExpressionScalarParameter::StaticClass(); \
	UMaterialExpressionStaticComponentMaskParameter::StaticClass(); \
	UMaterialExpressionStaticSwitchParameter::StaticClass(); \
	UMaterialExpressionVectorParameter::StaticClass(); \
	UMaterialExpressionParticleMacroUV::StaticClass(); \
	UMaterialExpressionPerInstanceRandom::StaticClass(); \
	UMaterialExpressionPixelDepth::StaticClass(); \
	UMaterialExpressionPower::StaticClass(); \
	UMaterialExpressionReflectionVector::StaticClass(); \
	UMaterialExpressionRotateAboutAxis::StaticClass(); \
	UMaterialExpressionRotator::StaticClass(); \
	UMaterialExpressionSceneDepth::StaticClass(); \
	UMaterialExpressionSceneTexture::StaticClass(); \
	UMaterialExpressionScreenPosition::StaticClass(); \
	UMaterialExpressionSine::StaticClass(); \
	UMaterialExpressionSphereMask::StaticClass(); \
	UMaterialExpressionSquareRoot::StaticClass(); \
	UMaterialExpressionSubtract::StaticClass(); \
	UMaterialExpressionTerrainLayerCoords::StaticClass(); \
	UMaterialExpressionTerrainLayerWeight::StaticClass(); \
	UMaterialExpressionTextureCoordinate::StaticClass(); \
	UMaterialExpressionTextureSample::StaticClass(); \
	UMaterialExpressionDepthBiasBlend::StaticClass(); \
	UMaterialExpressionFlipBookSample::StaticClass(); \
	UMaterialExpressionMeshSubUV::StaticClass(); \
	UMaterialExpressionMeshSubUVBlend::StaticClass(); \
	UMaterialExpressionParticleSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameter::StaticClass(); \
	UMaterialExpressionTextureSampleParameter2D::StaticClass(); \
	UMaterialExpressionAntialiasedTextureMask::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMeshSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMeshSubUVBlend::StaticClass(); \
	UMaterialExpressionTextureSampleParameterSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameterCube::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMovie::StaticClass(); \
	UMaterialExpressionTextureSampleParameterNormal::StaticClass(); \
	UMaterialExpressionTime::StaticClass(); \
	UMaterialExpressionTransform::StaticClass(); \
	UMaterialExpressionTransformPosition::StaticClass(); \
	UMaterialExpressionTwoSidedSign::StaticClass(); \
	UMaterialExpressionVertexColor::StaticClass(); \
	UMaterialExpressionWindDirectionAndSpeed::StaticClass(); \
	UMaterialExpressionWorldNormal::StaticClass(); \
	UMaterialExpressionWorldPosition::StaticClass(); \
	UMaterialInterface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInterface"), GEngineUMaterialInterfaceNatives); \
	UMaterial::StaticClass(); \
	UMaterialInstance::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstance"), GEngineUMaterialInstanceNatives); \
	UMaterialInstanceConstant::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstanceConstant"), GEngineUMaterialInstanceConstantNatives); \
	UMaterialInstanceTimeVarying::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstanceTimeVarying"), GEngineUMaterialInstanceTimeVaryingNatives); \

#endif // ENGINE_MATERIAL_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUMaterialInterfaceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInterface, execSetForceMipLevelsToBeResident)
	MAP_NATIVE(UMaterialInterface, execGetVectorCurveParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetVectorParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetTextureParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetScalarParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetFontParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetParameterDesc)
	MAP_NATIVE(UMaterialInterface, execGetPhysicalMaterial)
	MAP_NATIVE(UMaterialInterface, execGetMaterial)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstance, execIsInMapOrTransientPackage)
	MAP_NATIVE(UMaterialInstance, execClearParameterValues)
	MAP_NATIVE(UMaterialInstance, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetParent)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceConstantNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceConstant, execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceConstant, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetParent)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceTimeVaryingNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceTimeVarying, execGetMaxDurationFromAllParameters)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorStartTime)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetDuration)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarStartTime)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetParent)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAbs,MaterialExpressionAbs,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAbs)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAdd,MaterialExpressionAdd,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAdd,MaterialExpressionAdd,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAdd)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAppendVector,MaterialExpressionAppendVector,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAppendVector,MaterialExpressionAppendVector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAppendVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionBumpOffset,MaterialExpressionBumpOffset,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionBumpOffset,MaterialExpressionBumpOffset,ReferencePlane)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionBumpOffset)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCeil,MaterialExpressionCeil,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCeil)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionClamp,MaterialExpressionClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionClamp,MaterialExpressionClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionClamp)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComment,MaterialExpressionComment,PosX)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComment,MaterialExpressionComment,Text)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComment)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComponentMask,MaterialExpressionComponentMask,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComponentMask)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCompound,MaterialExpressionCompound,MaterialExpressions)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCompound,MaterialExpressionCompound,Caption)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCompound)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant,MaterialExpressionConstant,R)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant2Vector,MaterialExpressionConstant2Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant2Vector,MaterialExpressionConstant2Vector,G)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant2Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant3Vector,MaterialExpressionConstant3Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant3Vector,MaterialExpressionConstant3Vector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant3Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant4Vector,MaterialExpressionConstant4Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant4Vector,MaterialExpressionConstant4Vector,A)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant4Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantBiasScale,MaterialExpressionConstantBiasScale,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantBiasScale,MaterialExpressionConstantBiasScale,Scale)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstantBiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantClamp,MaterialExpressionConstantClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantClamp,MaterialExpressionConstantClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstantClamp)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCosine,MaterialExpressionCosine,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCosine,MaterialExpressionCosine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCosine)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCrossProduct,MaterialExpressionCrossProduct,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCrossProduct,MaterialExpressionCrossProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCrossProduct)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustom,MaterialExpressionCustom,Code)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustom,MaterialExpressionCustom,Inputs)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCustom)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustomTexture,MaterialExpressionCustomTexture,Texture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCustomTexture)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedAlpha,MaterialExpressionDepthBiasedAlpha,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedAlpha,MaterialExpressionDepthBiasedAlpha,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedAlpha)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedBlend,MaterialExpressionDepthBiasedBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedBlend,MaterialExpressionDepthBiasedBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedBlend)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthOfFieldFunction,MaterialExpressionDepthOfFieldFunction,FunctionValue)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthOfFieldFunction,MaterialExpressionDepthOfFieldFunction,Depth)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthOfFieldFunction)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDeriveNormalZ,MaterialExpressionDeriveNormalZ,InXY)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDeriveNormalZ)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDesaturation,MaterialExpressionDesaturation,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDesaturation,MaterialExpressionDesaturation,LuminanceFactors)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDesaturation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDistance,MaterialExpressionDistance,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDistance,MaterialExpressionDistance,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDistance)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDivide,MaterialExpressionDivide,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDivide,MaterialExpressionDivide,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDivide)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDotProduct,MaterialExpressionDotProduct,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDotProduct,MaterialExpressionDotProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDotProduct)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDynamicParameter,MaterialExpressionDynamicParameter,ParamNames)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDynamicParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshEmitterDynamicParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFloor,MaterialExpressionFloor,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFloor)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFluidNormal,MaterialExpressionFluidNormal,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFluidNormal)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFmod,MaterialExpressionFmod,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFmod,MaterialExpressionFmod,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFmod)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFoliageImpulseDirection)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFoliageNormalizedRotationAxisAndAngle)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSample,MaterialExpressionFontSample,Font)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSample,MaterialExpressionFontSample,FontTexturePage)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSample)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSampleParameter,MaterialExpressionFontSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSampleParameter,MaterialExpressionFontSampleParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSampleParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFrac,MaterialExpressionFrac,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFrac)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFresnel,MaterialExpressionFresnel,Exponent)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFresnel,MaterialExpressionFresnel,Normal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFresnel)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionIf,MaterialExpressionIf,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionIf,MaterialExpressionIf,ALessThanB)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionIf)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareIntensity)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareOcclusion)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRadialDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRayDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareSourceDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightmapUVs)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLightmassReplace,MaterialExpressionLightmassReplace,Realtime)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLightmassReplace,MaterialExpressionLightmassReplace,Lightmass)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightmassReplace)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLinearInterpolate,MaterialExpressionLinearInterpolate,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLinearInterpolate,MaterialExpressionLinearInterpolate,Alpha)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLinearInterpolate)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshEmitterVertexColor)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMultiply,MaterialExpressionMultiply,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMultiply,MaterialExpressionMultiply,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMultiply)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionNormalize,MaterialExpressionNormalize,VectorInput)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionNormalize)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectOrientation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectRadius)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectWorldPosition)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionOcclusionPercentage)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionOneMinus,MaterialExpressionOneMinus,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionOneMinus)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPanner,MaterialExpressionPanner,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPanner,MaterialExpressionPanner,SpeedY)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPanner)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionParameter,MaterialExpressionParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionParameter,MaterialExpressionParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionScalarParameter,MaterialExpressionScalarParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScalarParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticComponentMaskParameter,MaterialExpressionStaticComponentMaskParameter,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticComponentMaskParameter,MaterialExpressionStaticComponentMaskParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticComponentMaskParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitchParameter,MaterialExpressionStaticSwitchParameter,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitchParameter,MaterialExpressionStaticSwitchParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticSwitchParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionVectorParameter,MaterialExpressionVectorParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVectorParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleMacroUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPerInstanceRandom)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPixelDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPower,MaterialExpressionPower,Base)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPower,MaterialExpressionPower,Exponent)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPower)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionReflectionVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotateAboutAxis,MaterialExpressionRotateAboutAxis,NormalizedRotationAxisAndAngle)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotateAboutAxis,MaterialExpressionRotateAboutAxis,Position)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotateAboutAxis)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotator,MaterialExpressionRotator,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotator,MaterialExpressionRotator,Speed)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotator)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneDepth,MaterialExpressionSceneDepth,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneTexture,MaterialExpressionSceneTexture,Coordinates)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneTexture,MaterialExpressionSceneTexture,SceneTextureType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneTexture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScreenPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSine,MaterialExpressionSine,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSine,MaterialExpressionSine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSine)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSphereMask,MaterialExpressionSphereMask,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSphereMask,MaterialExpressionSphereMask,HardnessPercent)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSphereMask)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSquareRoot,MaterialExpressionSquareRoot,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSquareRoot)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSubtract,MaterialExpressionSubtract,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSubtract,MaterialExpressionSubtract,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSubtract)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerCoords,MaterialExpressionTerrainLayerCoords,MappingType)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerCoords,MaterialExpressionTerrainLayerCoords,MappingPanV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTerrainLayerCoords)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerWeight,MaterialExpressionTerrainLayerWeight,InstanceOverride)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerWeight,MaterialExpressionTerrainLayerWeight,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTerrainLayerWeight)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureCoordinate,MaterialExpressionTextureCoordinate,CoordinateIndex)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureCoordinate,MaterialExpressionTextureCoordinate,VTiling)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureCoordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSample,MaterialExpressionTextureSample,Texture)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSample,MaterialExpressionTextureSample,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSample)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasBlend,MaterialExpressionDepthBiasBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasBlend,MaterialExpressionDepthBiasBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFlipBookSample)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshSubUVBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleSubUV)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameter,MaterialExpressionTextureSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameter,MaterialExpressionTextureSampleParameter,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter2D)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAntialiasedTextureMask,MaterialExpressionAntialiasedTextureMask,Threshold)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAntialiasedTextureMask,MaterialExpressionAntialiasedTextureMask,Channel)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAntialiasedTextureMask)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMeshSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMeshSubUVBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterCube)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMovie)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameterNormal,MaterialExpressionTextureSampleParameterNormal,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterNormal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTime)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransform,MaterialExpressionTransform,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransform,MaterialExpressionTransform,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransform)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransformPosition,MaterialExpressionTransformPosition,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransformPosition,MaterialExpressionTransformPosition,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransformPosition)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTwoSidedSign)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVertexColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWindDirectionAndSpeed)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWorldNormal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInterface,MaterialInterface,ParentRefFence)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInterface,MaterialInterface,MobileSwayMaxAngle)
VERIFY_CLASS_SIZE_NODIE(UMaterialInterface)
VERIFY_CLASS_OFFSET_NODIE(UMaterial,Material,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterial,Material,ReferencedTextureGuids)
VERIFY_CLASS_SIZE_NODIE(UMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstance,MaterialInstance,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstance,MaterialInstance,ParentLightingGuid)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstance)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceConstant,MaterialInstanceConstant,FontParameterValues)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceConstant,MaterialInstanceConstant,VectorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceTimeVarying,MaterialInstanceTimeVarying,Duration)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceTimeVarying,MaterialInstanceTimeVarying,VectorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceTimeVarying)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
