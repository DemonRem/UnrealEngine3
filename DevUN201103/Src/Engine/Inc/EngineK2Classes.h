/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_K2_ENUMS
#define INCLUDED_ENGINE_K2_ENUMS 1


#endif // !INCLUDED_ENGINE_K2_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_K2_CLASSES
#define INCLUDED_ENGINE_K2_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UK2Input_Bool : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Bool
    BITFIELD bDefaultBool:1;
    SCRIPT_ALIGN;
    //## END PROPS K2Input_Bool

    DECLARE_CLASS(UK2Input_Bool,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_Exec : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Exec
    //## END PROPS K2Input_Exec

    DECLARE_CLASS(UK2Input_Exec,UK2Input,0,Engine)
	
};

class UK2Input_Float : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Float
    FLOAT DefaultFloat;
    //## END PROPS K2Input_Float

    DECLARE_CLASS(UK2Input_Float,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_Int : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Int
    INT DefaultInt;
    //## END PROPS K2Input_Int

    DECLARE_CLASS(UK2Input_Int,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_Object : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Object
    //## END PROPS K2Input_Object

    DECLARE_CLASS(UK2Input_Object,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_Rotator : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Rotator
    FRotator DefaultRotator;
    //## END PROPS K2Input_Rotator

    DECLARE_CLASS(UK2Input_Rotator,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual FString GetValueCodeString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_String : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_String
    FStringNoInit DefaultString;
    //## END PROPS K2Input_String

    DECLARE_CLASS(UK2Input_String,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual FString GetValueCodeString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Input_Vector : public UK2Input
{
public:
    //## BEGIN PROPS K2Input_Vector
    FVector DefaultVector;
    //## END PROPS K2Input_Vector

    DECLARE_CLASS(UK2Input_Vector,UK2Input,0,Engine)
#if WITH_EDITOR
	virtual FString GetValueString();
	virtual FString GetValueCodeString();
	virtual void SetDefaultFromString(const FString& InString);
#endif
};

class UK2Output_Object : public UK2Output
{
public:
    //## BEGIN PROPS K2Output_Object
    class UClass* ObjClass;
    //## END PROPS K2Output_Object

    DECLARE_CLASS(UK2Output_Object,UK2Output,0,Engine)
#if WITH_EDITOR
	virtual FString GetTypeAsCodeString();
#endif
};

class UK2Node_Code : public UK2NodeBase
{
public:
    //## BEGIN PROPS K2Node_Code
    //## END PROPS K2Node_Code

    DECLARE_CLASS(UK2Node_Code,UK2NodeBase,0,Engine)
#if WITH_EDITOR
	virtual void GetCodeText(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);

	virtual void CreateConnectorsFromFunction(UFunction* InFunction, UClass* ReturnConClass = NULL);

	class UK2Node_Code* GetCodeNodeFromOutputName(const FString& OutputName);

	virtual FString GetCodeFromParamInput(const FString& InputName, struct FK2CodeGenContext& Context);

	/** Get the set of pure function nodes that need to be processed before this node can be */
	void GetDependentPureFunctions(struct FK2CodeGenContext& Context, TArray<class UK2Node_FuncPure*>& OutPureFuncs);

	/** Generate code to assign any output vars to local variables */
	void GetMemberVarAssignCode(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);
#endif
};

class UK2Node_Event : public UK2Node_Code
{
public:
    //## BEGIN PROPS K2Node_Event
    FStringNoInit EventName;
    class UFunction* Function;
    //## END PROPS K2Node_Event

    DECLARE_CLASS(UK2Node_Event,UK2Node_Code,0,Engine)
#if WITH_EDITOR
	virtual void CreateAutoConnectors();

	virtual FString GetDisplayName();
	virtual FColor GetBorderColor();

	void GetEventText(FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);
#endif
};

class UK2Node_ForLoop : public UK2Node_Code
{
public:
    //## BEGIN PROPS K2Node_ForLoop
    //## END PROPS K2Node_ForLoop

    DECLARE_CLASS(UK2Node_ForLoop,UK2Node_Code,0,Engine)
#if WITH_EDITOR
	virtual FString GetDisplayName();

	virtual void GetCodeText(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);	

	virtual void CreateAutoConnectors();
#endif
};

class UK2Node_FuncBase : public UK2Node_Code
{
public:
    //## BEGIN PROPS K2Node_FuncBase
    class UFunction* Function;
    //## END PROPS K2Node_FuncBase

    DECLARE_CLASS(UK2Node_FuncBase,UK2Node_Code,0,Engine)
#if WITH_EDITOR
	// K2NodeBase
	virtual FString GetDisplayName();

	// K2Node_Code
	virtual void GetCodeText(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);

	// K2Node_FuncBase

	/** Gets the name of the function currently being used by this node */
	FString GetFunctionName();
#endif
};

class UK2Node_Func : public UK2Node_FuncBase
{
public:
    //## BEGIN PROPS K2Node_Func
    //## END PROPS K2Node_Func

    DECLARE_CLASS(UK2Node_Func,UK2Node_FuncBase,0,Engine)
#if WITH_EDITOR
	virtual void GetCodeText(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);
	virtual FColor GetBorderColor();

	virtual void CreateAutoConnectors();
#endif
};

class UK2Node_Func_NewComp : public UK2Node_Func
{
public:
    //## BEGIN PROPS K2Node_Func_NewComp
    class UActorComponent* ComponentTemplate;
    //## END PROPS K2Node_Func_NewComp

    DECLARE_CLASS(UK2Node_Func_NewComp,UK2Node_Func,0,Engine)
#if WITH_EDITOR
	// K2NodeBase

	virtual FString GetDisplayName();

	virtual FString GetCodeFromParamInput(const FString& InputName, struct FK2CodeGenContext& Context);	
#endif
};

class UK2Node_FuncPure : public UK2Node_FuncBase
{
public:
    //## BEGIN PROPS K2Node_FuncPure
    //## END PROPS K2Node_FuncPure

    DECLARE_CLASS(UK2Node_FuncPure,UK2Node_FuncBase,0,Engine)
	
};

class UK2Node_IfElse : public UK2Node_Code
{
public:
    //## BEGIN PROPS K2Node_IfElse
    //## END PROPS K2Node_IfElse

    DECLARE_CLASS(UK2Node_IfElse,UK2Node_Code,0,Engine)
#if WITH_EDITOR
	virtual FString GetDisplayName();

	virtual void GetCodeText(struct FK2CodeGenContext& Context, TArray<struct FK2CodeLine>& OutCode);	

	virtual void CreateAutoConnectors();
#endif
};

class UK2Node_MemberVar : public UK2Node_Code
{
public:
    //## BEGIN PROPS K2Node_MemberVar
    BYTE VarType;
    FStringNoInit VarName;
    //## END PROPS K2Node_MemberVar

    DECLARE_CLASS(UK2Node_MemberVar,UK2Node_Code,0,Engine)
#if WITH_EDITOR
	virtual FString GetDisplayName();
	virtual UBOOL InputDefaultsAreEditable();

	virtual void CreateAutoConnectors();

	virtual void CreateConnectorsFromVariable(UProperty* InVar);
#endif
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_K2_CLASSES
#endif // !NAMES_ONLY


#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_K2_NATIVE_DEFS
#define ENGINE_K2_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_K2 \
	UK2Input_Bool::StaticClass(); \
	UK2Input_Exec::StaticClass(); \
	UK2Input_Float::StaticClass(); \
	UK2Input_Int::StaticClass(); \
	UK2Input_Object::StaticClass(); \
	UK2Input_Rotator::StaticClass(); \
	UK2Input_String::StaticClass(); \
	UK2Input_Vector::StaticClass(); \
	UK2Output_Object::StaticClass(); \
	UK2Node_Code::StaticClass(); \
	UK2Node_Event::StaticClass(); \
	UK2Node_ForLoop::StaticClass(); \
	UK2Node_FuncBase::StaticClass(); \
	UK2Node_Func::StaticClass(); \
	UK2Node_Func_NewComp::StaticClass(); \
	UK2Node_FuncPure::StaticClass(); \
	UK2Node_IfElse::StaticClass(); \
	UK2Node_MemberVar::StaticClass(); \

#endif // ENGINE_K2_NATIVE_DEFS

#ifdef NATIVES_ONLY
#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(UK2Input_Bool)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Exec)
VERIFY_CLASS_OFFSET_NODIE(UK2Input_Float,K2Input_Float,DefaultFloat)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Float)
VERIFY_CLASS_OFFSET_NODIE(UK2Input_Int,K2Input_Int,DefaultInt)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Int)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Object)
VERIFY_CLASS_OFFSET_NODIE(UK2Input_Rotator,K2Input_Rotator,DefaultRotator)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Rotator)
VERIFY_CLASS_OFFSET_NODIE(UK2Input_String,K2Input_String,DefaultString)
VERIFY_CLASS_SIZE_NODIE(UK2Input_String)
VERIFY_CLASS_OFFSET_NODIE(UK2Input_Vector,K2Input_Vector,DefaultVector)
VERIFY_CLASS_SIZE_NODIE(UK2Input_Vector)
VERIFY_CLASS_OFFSET_NODIE(UK2Output_Object,K2Output_Object,ObjClass)
VERIFY_CLASS_SIZE_NODIE(UK2Output_Object)
VERIFY_CLASS_SIZE_NODIE(UK2Node_Code)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_Event,K2Node_Event,EventName)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_Event,K2Node_Event,Function)
VERIFY_CLASS_SIZE_NODIE(UK2Node_Event)
VERIFY_CLASS_SIZE_NODIE(UK2Node_ForLoop)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_FuncBase,K2Node_FuncBase,Function)
VERIFY_CLASS_SIZE_NODIE(UK2Node_FuncBase)
VERIFY_CLASS_SIZE_NODIE(UK2Node_Func)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_Func_NewComp,K2Node_Func_NewComp,ComponentTemplate)
VERIFY_CLASS_SIZE_NODIE(UK2Node_Func_NewComp)
VERIFY_CLASS_SIZE_NODIE(UK2Node_FuncPure)
VERIFY_CLASS_SIZE_NODIE(UK2Node_IfElse)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_MemberVar,K2Node_MemberVar,VarType)
VERIFY_CLASS_OFFSET_NODIE(UK2Node_MemberVar,K2Node_MemberVar,VarName)
VERIFY_CLASS_SIZE_NODIE(UK2Node_MemberVar)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
